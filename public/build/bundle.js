
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop$2() { }
    const identity$1 = x => x;
    function assign$1(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function not_equal(a, b) {
        return a != a ? b == b : a !== b;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop$2;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign$1($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$2;
    }

    const is_client = typeof window !== 'undefined';
    let now$1 = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop$2;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append$1(target, node) {
        target.appendChild(node);
    }
    function insert$1(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty$1() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function set_svg_attributes(node, attributes) {
        for (const key in attributes) {
            attr(node, key, attributes[key]);
        }
    }
    function set_custom_element_data(node, prop, value) {
        if (prop in node) {
            node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
        }
        else {
            attr(node, prop, value);
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    // unfortunately this can't be a constant as that wouldn't be tree-shakeable
    // so we cache the result instead
    let crossorigin;
    function is_crossorigin() {
        if (crossorigin === undefined) {
            crossorigin = false;
            try {
                if (typeof window !== 'undefined' && window.parent) {
                    void window.parent.document;
                }
            }
            catch (error) {
                crossorigin = true;
            }
        }
        return crossorigin;
    }
    function add_resize_listener(node, fn) {
        const computed_style = getComputedStyle(node);
        if (computed_style.position === 'static') {
            node.style.position = 'relative';
        }
        const iframe = element('iframe');
        iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
            'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
        iframe.setAttribute('aria-hidden', 'true');
        iframe.tabIndex = -1;
        const crossorigin = is_crossorigin();
        let unsubscribe;
        if (crossorigin) {
            iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
            unsubscribe = listen(window, 'message', (event) => {
                if (event.source === iframe.contentWindow)
                    fn();
            });
        }
        else {
            iframe.src = 'about:blank';
            iframe.onload = () => {
                unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            };
        }
        append$1(node, iframe);
        return () => {
            if (crossorigin) {
                unsubscribe();
            }
            else if (unsubscribe && iframe.contentWindow) {
                unsubscribe();
            }
            detach(iframe);
        };
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }
    class HtmlTag {
        constructor(anchor = null) {
            this.a = anchor;
            this.e = this.n = null;
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.h(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert$1(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    function hasContext(key) {
        return get_current_component().$$.context.has(key);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick$1() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update$1(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update$1($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = program.b - t;
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity$1, tick = noop$2, css } = config || null_transition;
            const program = {
                start: now$1() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error('Cannot have duplicate keys in a keyed each');
            }
            keys.add(key);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind$2(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop$2,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$2;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.38.2' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append$1(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert$1(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }
    /**
     * Base class to create strongly typed Svelte components.
     * This only exists for typing purposes and should be used in `.d.ts` files.
     *
     * ### Example:
     *
     * You have component library on npm called `component-library`, from which
     * you export a component called `MyComponent`. For Svelte+TypeScript users,
     * you want to provide typings. Therefore you create a `index.d.ts`:
     * ```ts
     * import { SvelteComponentTyped } from "svelte";
     * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}
     * ```
     * Typing this makes it possible for IDEs like VS Code with the Svelte extension
     * to provide intellisense and to use the component like this in a Svelte file
     * with TypeScript:
     * ```svelte
     * <script lang="ts">
     * 	import { MyComponent } from "component-library";
     * </script>
     * <MyComponent foo={'bar'} />
     * ```
     *
     * #### Why not make this part of `SvelteComponent(Dev)`?
     * Because
     * ```ts
     * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}
     * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;
     * ```
     * will throw a type error, so we need to seperate the more strictly typed class.
     */
    class SvelteComponentTyped extends SvelteComponentDev {
        constructor(options) {
            super(options);
        }
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    /**
     * Parses an URI
     *
     * @author Steven Levithan <stevenlevithan.com> (MIT license)
     * @api private
     */
    var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

    var parts = [
        'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
    ];

    var parseuri = function parseuri(str) {
        var src = str,
            b = str.indexOf('['),
            e = str.indexOf(']');

        if (b != -1 && e != -1) {
            str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
        }

        var m = re.exec(str || ''),
            uri = {},
            i = 14;

        while (i--) {
            uri[parts[i]] = m[i] || '';
        }

        if (b != -1 && e != -1) {
            uri.source = src;
            uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
            uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
            uri.ipv6uri = true;
        }

        uri.pathNames = pathNames(uri, uri['path']);
        uri.queryKey = queryKey(uri, uri['query']);

        return uri;
    };

    function pathNames(obj, path) {
        var regx = /\/{2,9}/g,
            names = path.replace(regx, "/").split("/");

        if (path.substr(0, 1) == '/' || path.length === 0) {
            names.splice(0, 1);
        }
        if (path.substr(path.length - 1, 1) == '/') {
            names.splice(names.length - 1, 1);
        }

        return names;
    }

    function queryKey(uri, query) {
        var data = {};

        query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
            if ($1) {
                data[$1] = $2;
            }
        });

        return data;
    }

    /**
     * Helpers.
     */
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;

    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} [options]
     * @throws {Error} throw an error if val is not a non-empty string or a number
     * @return {String|Number}
     * @api public
     */

    var ms = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === 'string' && val.length > 0) {
        return parse$1(val);
      } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        'val is not a non-empty string or a valid number. val=' +
          JSON.stringify(val)
      );
    };

    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

    function parse$1(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'weeks':
        case 'week':
        case 'w':
          return n * w;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
        default:
          return undefined;
      }
    }

    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + 's';
      }
      return ms + 'ms';
    }

    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
      }
      return ms + ' ms';
    }

    /**
     * Pluralization helper.
     */

    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
    }

    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     */

    function setup(env) {
    	createDebug.debug = createDebug;
    	createDebug.default = createDebug;
    	createDebug.coerce = coerce;
    	createDebug.disable = disable;
    	createDebug.enable = enable;
    	createDebug.enabled = enabled;
    	createDebug.humanize = ms;
    	createDebug.destroy = destroy;

    	Object.keys(env).forEach(key => {
    		createDebug[key] = env[key];
    	});

    	/**
    	* The currently active debug mode names, and names to skip.
    	*/

    	createDebug.names = [];
    	createDebug.skips = [];

    	/**
    	* Map of special "%n" handling functions, for the debug "format" argument.
    	*
    	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
    	*/
    	createDebug.formatters = {};

    	/**
    	* Selects a color for a debug namespace
    	* @param {String} namespace The namespace string for the for the debug instance to be colored
    	* @return {Number|String} An ANSI color code for the given namespace
    	* @api private
    	*/
    	function selectColor(namespace) {
    		let hash = 0;

    		for (let i = 0; i < namespace.length; i++) {
    			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
    			hash |= 0; // Convert to 32bit integer
    		}

    		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    	}
    	createDebug.selectColor = selectColor;

    	/**
    	* Create a debugger with the given `namespace`.
    	*
    	* @param {String} namespace
    	* @return {Function}
    	* @api public
    	*/
    	function createDebug(namespace) {
    		let prevTime;
    		let enableOverride = null;
    		let namespacesCache;
    		let enabledCache;

    		function debug(...args) {
    			// Disabled?
    			if (!debug.enabled) {
    				return;
    			}

    			const self = debug;

    			// Set `diff` timestamp
    			const curr = Number(new Date());
    			const ms = curr - (prevTime || curr);
    			self.diff = ms;
    			self.prev = prevTime;
    			self.curr = curr;
    			prevTime = curr;

    			args[0] = createDebug.coerce(args[0]);

    			if (typeof args[0] !== 'string') {
    				// Anything else let's inspect with %O
    				args.unshift('%O');
    			}

    			// Apply any `formatters` transformations
    			let index = 0;
    			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
    				// If we encounter an escaped % then don't increase the array index
    				if (match === '%%') {
    					return '%';
    				}
    				index++;
    				const formatter = createDebug.formatters[format];
    				if (typeof formatter === 'function') {
    					const val = args[index];
    					match = formatter.call(self, val);

    					// Now we need to remove `args[index]` since it's inlined in the `format`
    					args.splice(index, 1);
    					index--;
    				}
    				return match;
    			});

    			// Apply env-specific formatting (colors, etc.)
    			createDebug.formatArgs.call(self, args);

    			const logFn = self.log || createDebug.log;
    			logFn.apply(self, args);
    		}

    		debug.namespace = namespace;
    		debug.useColors = createDebug.useColors();
    		debug.color = createDebug.selectColor(namespace);
    		debug.extend = extend;
    		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    		Object.defineProperty(debug, 'enabled', {
    			enumerable: true,
    			configurable: false,
    			get: () => {
    				if (enableOverride !== null) {
    					return enableOverride;
    				}
    				if (namespacesCache !== createDebug.namespaces) {
    					namespacesCache = createDebug.namespaces;
    					enabledCache = createDebug.enabled(namespace);
    				}

    				return enabledCache;
    			},
    			set: v => {
    				enableOverride = v;
    			}
    		});

    		// Env-specific initialization logic for debug instances
    		if (typeof createDebug.init === 'function') {
    			createDebug.init(debug);
    		}

    		return debug;
    	}

    	function extend(namespace, delimiter) {
    		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    		newDebug.log = this.log;
    		return newDebug;
    	}

    	/**
    	* Enables a debug mode by namespaces. This can include modes
    	* separated by a colon and wildcards.
    	*
    	* @param {String} namespaces
    	* @api public
    	*/
    	function enable(namespaces) {
    		createDebug.save(namespaces);
    		createDebug.namespaces = namespaces;

    		createDebug.names = [];
    		createDebug.skips = [];

    		let i;
    		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    		const len = split.length;

    		for (i = 0; i < len; i++) {
    			if (!split[i]) {
    				// ignore empty strings
    				continue;
    			}

    			namespaces = split[i].replace(/\*/g, '.*?');

    			if (namespaces[0] === '-') {
    				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    			} else {
    				createDebug.names.push(new RegExp('^' + namespaces + '$'));
    			}
    		}
    	}

    	/**
    	* Disable debug output.
    	*
    	* @return {String} namespaces
    	* @api public
    	*/
    	function disable() {
    		const namespaces = [
    			...createDebug.names.map(toNamespace),
    			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
    		].join(',');
    		createDebug.enable('');
    		return namespaces;
    	}

    	/**
    	* Returns true if the given mode name is enabled, false otherwise.
    	*
    	* @param {String} name
    	* @return {Boolean}
    	* @api public
    	*/
    	function enabled(name) {
    		if (name[name.length - 1] === '*') {
    			return true;
    		}

    		let i;
    		let len;

    		for (i = 0, len = createDebug.skips.length; i < len; i++) {
    			if (createDebug.skips[i].test(name)) {
    				return false;
    			}
    		}

    		for (i = 0, len = createDebug.names.length; i < len; i++) {
    			if (createDebug.names[i].test(name)) {
    				return true;
    			}
    		}

    		return false;
    	}

    	/**
    	* Convert regexp to namespace
    	*
    	* @param {RegExp} regxep
    	* @return {String} namespace
    	* @api private
    	*/
    	function toNamespace(regexp) {
    		return regexp.toString()
    			.substring(2, regexp.toString().length - 2)
    			.replace(/\.\*\?$/, '*');
    	}

    	/**
    	* Coerce `val`.
    	*
    	* @param {Mixed} val
    	* @return {Mixed}
    	* @api private
    	*/
    	function coerce(val) {
    		if (val instanceof Error) {
    			return val.stack || val.message;
    		}
    		return val;
    	}

    	/**
    	* XXX DO NOT USE. This is a temporary stub function.
    	* XXX It WILL be removed in the next major release.
    	*/
    	function destroy() {
    		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    	}

    	createDebug.enable(createDebug.load());

    	return createDebug;
    }

    var common = setup;

    /* eslint-env browser */

    var browser = createCommonjsModule(function (module, exports) {
    /**
     * This is the web browser implementation of `debug()`.
     */

    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
    	let warned = false;

    	return () => {
    		if (!warned) {
    			warned = true;
    			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    		}
    	};
    })();

    /**
     * Colors.
     */

    exports.colors = [
    	'#0000CC',
    	'#0000FF',
    	'#0033CC',
    	'#0033FF',
    	'#0066CC',
    	'#0066FF',
    	'#0099CC',
    	'#0099FF',
    	'#00CC00',
    	'#00CC33',
    	'#00CC66',
    	'#00CC99',
    	'#00CCCC',
    	'#00CCFF',
    	'#3300CC',
    	'#3300FF',
    	'#3333CC',
    	'#3333FF',
    	'#3366CC',
    	'#3366FF',
    	'#3399CC',
    	'#3399FF',
    	'#33CC00',
    	'#33CC33',
    	'#33CC66',
    	'#33CC99',
    	'#33CCCC',
    	'#33CCFF',
    	'#6600CC',
    	'#6600FF',
    	'#6633CC',
    	'#6633FF',
    	'#66CC00',
    	'#66CC33',
    	'#9900CC',
    	'#9900FF',
    	'#9933CC',
    	'#9933FF',
    	'#99CC00',
    	'#99CC33',
    	'#CC0000',
    	'#CC0033',
    	'#CC0066',
    	'#CC0099',
    	'#CC00CC',
    	'#CC00FF',
    	'#CC3300',
    	'#CC3333',
    	'#CC3366',
    	'#CC3399',
    	'#CC33CC',
    	'#CC33FF',
    	'#CC6600',
    	'#CC6633',
    	'#CC9900',
    	'#CC9933',
    	'#CCCC00',
    	'#CCCC33',
    	'#FF0000',
    	'#FF0033',
    	'#FF0066',
    	'#FF0099',
    	'#FF00CC',
    	'#FF00FF',
    	'#FF3300',
    	'#FF3333',
    	'#FF3366',
    	'#FF3399',
    	'#FF33CC',
    	'#FF33FF',
    	'#FF6600',
    	'#FF6633',
    	'#FF9900',
    	'#FF9933',
    	'#FFCC00',
    	'#FFCC33'
    ];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    // eslint-disable-next-line complexity
    function useColors() {
    	// NB: In an Electron preload script, document will be defined but not fully
    	// initialized. Since we know we're in Chrome, we'll just detect this case
    	// explicitly
    	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    		return true;
    	}

    	// Internet Explorer and Edge do not support colors.
    	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    		return false;
    	}

    	// Is webkit? http://stackoverflow.com/a/16459606/376773
    	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    		// Is firebug? http://stackoverflow.com/a/398120/376773
    		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    		// Is firefox >= v31?
    		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    		// Double check webkit in userAgent just in case we are in a worker
    		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
    }

    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
    	args[0] = (this.useColors ? '%c' : '') +
    		this.namespace +
    		(this.useColors ? ' %c' : ' ') +
    		args[0] +
    		(this.useColors ? '%c ' : ' ') +
    		'+' + module.exports.humanize(this.diff);

    	if (!this.useColors) {
    		return;
    	}

    	const c = 'color: ' + this.color;
    	args.splice(1, 0, c, 'color: inherit');

    	// The final "%c" is somewhat tricky, because there could be other
    	// arguments passed either before or after the %c, so we need to
    	// figure out the correct index to insert the CSS into
    	let index = 0;
    	let lastC = 0;
    	args[0].replace(/%[a-zA-Z%]/g, match => {
    		if (match === '%%') {
    			return;
    		}
    		index++;
    		if (match === '%c') {
    			// We only are interested in the *last* %c
    			// (the user may have provided their own)
    			lastC = index;
    		}
    	});

    	args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.debug()` when available.
     * No-op when `console.debug` is not a "function".
     * If `console.debug` is not available, falls back
     * to `console.log`.
     *
     * @api public
     */
    exports.log = console.debug || console.log || (() => {});

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
    	try {
    		if (namespaces) {
    			exports.storage.setItem('debug', namespaces);
    		} else {
    			exports.storage.removeItem('debug');
    		}
    	} catch (error) {
    		// Swallow
    		// XXX (@Qix-) should we be logging these?
    	}
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    function load() {
    	let r;
    	try {
    		r = exports.storage.getItem('debug');
    	} catch (error) {
    		// Swallow
    		// XXX (@Qix-) should we be logging these?
    	}

    	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    	if (!r && typeof process !== 'undefined' && 'env' in process) {
    		r = process.env.DEBUG;
    	}

    	return r;
    }

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
    	try {
    		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    		// The Browser also has localStorage in the global context.
    		return localStorage;
    	} catch (error) {
    		// Swallow
    		// XXX (@Qix-) should we be logging these?
    	}
    }

    module.exports = common(exports);

    const {formatters} = module.exports;

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    formatters.j = function (v) {
    	try {
    		return JSON.stringify(v);
    	} catch (error) {
    		return '[UnexpectedJSONParseError]: ' + error.message;
    	}
    };
    });

    var url_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.url = void 0;

    const debug = browser("socket.io-client:url");
    /**
     * URL parser.
     *
     * @param uri - url
     * @param path - the request path of the connection
     * @param loc - An object meant to mimic window.location.
     *        Defaults to window.location.
     * @public
     */
    function url(uri, path = "", loc) {
        let obj = uri;
        // default to window.location
        loc = loc || (typeof location !== "undefined" && location);
        if (null == uri)
            uri = loc.protocol + "//" + loc.host;
        // relative path support
        if (typeof uri === "string") {
            if ("/" === uri.charAt(0)) {
                if ("/" === uri.charAt(1)) {
                    uri = loc.protocol + uri;
                }
                else {
                    uri = loc.host + uri;
                }
            }
            if (!/^(https?|wss?):\/\//.test(uri)) {
                debug("protocol-less url %s", uri);
                if ("undefined" !== typeof loc) {
                    uri = loc.protocol + "//" + uri;
                }
                else {
                    uri = "https://" + uri;
                }
            }
            // parse
            debug("parse %s", uri);
            obj = parseuri(uri);
        }
        // make sure we treat `localhost:80` and `localhost` equally
        if (!obj.port) {
            if (/^(http|ws)$/.test(obj.protocol)) {
                obj.port = "80";
            }
            else if (/^(http|ws)s$/.test(obj.protocol)) {
                obj.port = "443";
            }
        }
        obj.path = obj.path || "/";
        const ipv6 = obj.host.indexOf(":") !== -1;
        const host = ipv6 ? "[" + obj.host + "]" : obj.host;
        // define unique id
        obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
        // define href
        obj.href =
            obj.protocol +
                "://" +
                host +
                (loc && loc.port === obj.port ? "" : ":" + obj.port);
        return obj;
    }
    exports.url = url;
    });

    var hasCors = createCommonjsModule(function (module) {
    /**
     * Module exports.
     *
     * Logic borrowed from Modernizr:
     *
     *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
     */

    try {
      module.exports = typeof XMLHttpRequest !== 'undefined' &&
        'withCredentials' in new XMLHttpRequest();
    } catch (err) {
      // if XMLHttp support is disabled in IE then it will throw
      // when trying to create
      module.exports = false;
    }
    });

    var globalThis_browser = (() => {
      if (typeof self !== "undefined") {
        return self;
      } else if (typeof window !== "undefined") {
        return window;
      } else {
        return Function("return this")();
      }
    })();

    // browser shim for xmlhttprequest module




    var xmlhttprequest = function(opts) {
      const xdomain = opts.xdomain;

      // scheme must be same when usign XDomainRequest
      // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
      const xscheme = opts.xscheme;

      // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
      // https://github.com/Automattic/engine.io-client/pull/217
      const enablesXDR = opts.enablesXDR;

      // XMLHttpRequest can be disabled on IE
      try {
        if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCors)) {
          return new XMLHttpRequest();
        }
      } catch (e) {}

      // Use XDomainRequest for IE8 if enablesXDR is true
      // because loading bar keeps flashing when using jsonp-polling
      // https://github.com/yujiosaka/socke.io-ie8-loading-example
      try {
        if ("undefined" !== typeof XDomainRequest && !xscheme && enablesXDR) {
          return new XDomainRequest();
        }
      } catch (e) {}

      if (!xdomain) {
        try {
          return new globalThis_browser[["Active"].concat("Object").join("X")](
            "Microsoft.XMLHTTP"
          );
        } catch (e) {}
      }
    };

    const PACKET_TYPES$1 = Object.create(null); // no Map = no polyfill
    PACKET_TYPES$1["open"] = "0";
    PACKET_TYPES$1["close"] = "1";
    PACKET_TYPES$1["ping"] = "2";
    PACKET_TYPES$1["pong"] = "3";
    PACKET_TYPES$1["message"] = "4";
    PACKET_TYPES$1["upgrade"] = "5";
    PACKET_TYPES$1["noop"] = "6";

    const PACKET_TYPES_REVERSE$1 = Object.create(null);
    Object.keys(PACKET_TYPES$1).forEach(key => {
      PACKET_TYPES_REVERSE$1[PACKET_TYPES$1[key]] = key;
    });

    const ERROR_PACKET$1 = { type: "error", data: "parser error" };

    var commons = {
      PACKET_TYPES: PACKET_TYPES$1,
      PACKET_TYPES_REVERSE: PACKET_TYPES_REVERSE$1,
      ERROR_PACKET: ERROR_PACKET$1
    };

    const { PACKET_TYPES } = commons;

    const withNativeBlob =
      typeof Blob === "function" ||
      (typeof Blob !== "undefined" &&
        Object.prototype.toString.call(Blob) === "[object BlobConstructor]");
    const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";

    // ArrayBuffer.isView method is not defined in IE10
    const isView = obj => {
      return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj && obj.buffer instanceof ArrayBuffer;
    };

    const encodePacket = ({ type, data }, supportsBinary, callback) => {
      if (withNativeBlob && data instanceof Blob) {
        if (supportsBinary) {
          return callback(data);
        } else {
          return encodeBlobAsBase64(data, callback);
        }
      } else if (
        withNativeArrayBuffer$1 &&
        (data instanceof ArrayBuffer || isView(data))
      ) {
        if (supportsBinary) {
          return callback(data instanceof ArrayBuffer ? data : data.buffer);
        } else {
          return encodeBlobAsBase64(new Blob([data]), callback);
        }
      }
      // plain string
      return callback(PACKET_TYPES[type] + (data || ""));
    };

    const encodeBlobAsBase64 = (data, callback) => {
      const fileReader = new FileReader();
      fileReader.onload = function() {
        const content = fileReader.result.split(",")[1];
        callback("b" + content);
      };
      return fileReader.readAsDataURL(data);
    };

    var encodePacket_browser = encodePacket;

    /*
     * base64-arraybuffer
     * https://github.com/niklasvh/base64-arraybuffer
     *
     * Copyright (c) 2012 Niklas von Hertzen
     * Licensed under the MIT license.
     */

    var base64Arraybuffer = createCommonjsModule(function (module, exports) {
    (function(chars){

      exports.encode = function(arraybuffer) {
        var bytes = new Uint8Array(arraybuffer),
        i, len = bytes.length, base64 = "";

        for (i = 0; i < len; i+=3) {
          base64 += chars[bytes[i] >> 2];
          base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
          base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
          base64 += chars[bytes[i + 2] & 63];
        }

        if ((len % 3) === 2) {
          base64 = base64.substring(0, base64.length - 1) + "=";
        } else if (len % 3 === 1) {
          base64 = base64.substring(0, base64.length - 2) + "==";
        }

        return base64;
      };

      exports.decode =  function(base64) {
        var bufferLength = base64.length * 0.75,
        len = base64.length, i, p = 0,
        encoded1, encoded2, encoded3, encoded4;

        if (base64[base64.length - 1] === "=") {
          bufferLength--;
          if (base64[base64.length - 2] === "=") {
            bufferLength--;
          }
        }

        var arraybuffer = new ArrayBuffer(bufferLength),
        bytes = new Uint8Array(arraybuffer);

        for (i = 0; i < len; i+=4) {
          encoded1 = chars.indexOf(base64[i]);
          encoded2 = chars.indexOf(base64[i+1]);
          encoded3 = chars.indexOf(base64[i+2]);
          encoded4 = chars.indexOf(base64[i+3]);

          bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
          bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
          bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
        }

        return arraybuffer;
      };
    })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
    });

    const { PACKET_TYPES_REVERSE, ERROR_PACKET } = commons;

    const withNativeArrayBuffer = typeof ArrayBuffer === "function";

    let base64decoder;
    if (withNativeArrayBuffer) {
      base64decoder = base64Arraybuffer;
    }

    const decodePacket = (encodedPacket, binaryType) => {
      if (typeof encodedPacket !== "string") {
        return {
          type: "message",
          data: mapBinary(encodedPacket, binaryType)
        };
      }
      const type = encodedPacket.charAt(0);
      if (type === "b") {
        return {
          type: "message",
          data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
        };
      }
      const packetType = PACKET_TYPES_REVERSE[type];
      if (!packetType) {
        return ERROR_PACKET;
      }
      return encodedPacket.length > 1
        ? {
            type: PACKET_TYPES_REVERSE[type],
            data: encodedPacket.substring(1)
          }
        : {
            type: PACKET_TYPES_REVERSE[type]
          };
    };

    const decodeBase64Packet = (data, binaryType) => {
      if (base64decoder) {
        const decoded = base64decoder.decode(data);
        return mapBinary(decoded, binaryType);
      } else {
        return { base64: true, data }; // fallback for old browsers
      }
    };

    const mapBinary = (data, binaryType) => {
      switch (binaryType) {
        case "blob":
          return data instanceof ArrayBuffer ? new Blob([data]) : data;
        case "arraybuffer":
        default:
          return data; // assuming the data is already an ArrayBuffer
      }
    };

    var decodePacket_browser = decodePacket;

    const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text

    const encodePayload = (packets, callback) => {
      // some packets may be added to the array while encoding, so the initial length must be saved
      const length = packets.length;
      const encodedPackets = new Array(length);
      let count = 0;

      packets.forEach((packet, i) => {
        // force base64 encoding for binary packets
        encodePacket_browser(packet, false, encodedPacket => {
          encodedPackets[i] = encodedPacket;
          if (++count === length) {
            callback(encodedPackets.join(SEPARATOR));
          }
        });
      });
    };

    const decodePayload = (encodedPayload, binaryType) => {
      const encodedPackets = encodedPayload.split(SEPARATOR);
      const packets = [];
      for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = decodePacket_browser(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
          break;
        }
      }
      return packets;
    };

    var lib$1 = {
      protocol: 4,
      encodePacket: encodePacket_browser,
      encodePayload,
      decodePacket: decodePacket_browser,
      decodePayload
    };

    var componentEmitter = createCommonjsModule(function (module) {
    /**
     * Expose `Emitter`.
     */

    {
      module.exports = Emitter;
    }

    /**
     * Initialize a new `Emitter`.
     *
     * @api public
     */

    function Emitter(obj) {
      if (obj) return mixin(obj);
    }
    /**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */

    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }

    /**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.on =
    Emitter.prototype.addEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};
      (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
        .push(fn);
      return this;
    };

    /**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.once = function(event, fn){
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }

      on.fn = fn;
      this.on(event, on);
      return this;
    };

    /**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.off =
    Emitter.prototype.removeListener =
    Emitter.prototype.removeAllListeners =
    Emitter.prototype.removeEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};

      // all
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }

      // specific event
      var callbacks = this._callbacks['$' + event];
      if (!callbacks) return this;

      // remove all handlers
      if (1 == arguments.length) {
        delete this._callbacks['$' + event];
        return this;
      }

      // remove specific handler
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }

      // Remove event specific arrays for event types that no
      // one is subscribed for to avoid memory leak.
      if (callbacks.length === 0) {
        delete this._callbacks['$' + event];
      }

      return this;
    };

    /**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */

    Emitter.prototype.emit = function(event){
      this._callbacks = this._callbacks || {};

      var args = new Array(arguments.length - 1)
        , callbacks = this._callbacks['$' + event];

      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }

      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }

      return this;
    };

    /**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */

    Emitter.prototype.listeners = function(event){
      this._callbacks = this._callbacks || {};
      return this._callbacks['$' + event] || [];
    };

    /**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */

    Emitter.prototype.hasListeners = function(event){
      return !! this.listeners(event).length;
    };
    });

    const debug$6 = browser("engine.io-client:transport");

    class Transport$1 extends componentEmitter {
      /**
       * Transport abstract constructor.
       *
       * @param {Object} options.
       * @api private
       */
      constructor(opts) {
        super();

        this.opts = opts;
        this.query = opts.query;
        this.readyState = "";
        this.socket = opts.socket;
      }

      /**
       * Emits an error.
       *
       * @param {String} str
       * @return {Transport} for chaining
       * @api public
       */
      onError(msg, desc) {
        const err = new Error(msg);
        err.type = "TransportError";
        err.description = desc;
        this.emit("error", err);
        return this;
      }

      /**
       * Opens the transport.
       *
       * @api public
       */
      open() {
        if ("closed" === this.readyState || "" === this.readyState) {
          this.readyState = "opening";
          this.doOpen();
        }

        return this;
      }

      /**
       * Closes the transport.
       *
       * @api private
       */
      close() {
        if ("opening" === this.readyState || "open" === this.readyState) {
          this.doClose();
          this.onClose();
        }

        return this;
      }

      /**
       * Sends multiple packets.
       *
       * @param {Array} packets
       * @api private
       */
      send(packets) {
        if ("open" === this.readyState) {
          this.write(packets);
        } else {
          // this might happen if the transport was silently closed in the beforeunload event handler
          debug$6("transport is not open, discarding packets");
        }
      }

      /**
       * Called upon open
       *
       * @api private
       */
      onOpen() {
        this.readyState = "open";
        this.writable = true;
        this.emit("open");
      }

      /**
       * Called with data.
       *
       * @param {String} data
       * @api private
       */
      onData(data) {
        const packet = lib$1.decodePacket(data, this.socket.binaryType);
        this.onPacket(packet);
      }

      /**
       * Called with a decoded packet.
       */
      onPacket(packet) {
        this.emit("packet", packet);
      }

      /**
       * Called upon close.
       *
       * @api private
       */
      onClose() {
        this.readyState = "closed";
        this.emit("close");
      }
    }

    var transport = Transport$1;

    /**
     * Compiles a querystring
     * Returns string representation of the object
     *
     * @param {Object}
     * @api private
     */
    var encode$1 = function (obj) {
      var str = '';

      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          if (str.length) str += '&';
          str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
        }
      }

      return str;
    };

    /**
     * Parses a simple querystring into an object
     *
     * @param {String} qs
     * @api private
     */

    var decode$1 = function(qs){
      var qry = {};
      var pairs = qs.split('&');
      for (var i = 0, l = pairs.length; i < l; i++) {
        var pair = pairs[i].split('=');
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
      }
      return qry;
    };

    var parseqs = {
    	encode: encode$1,
    	decode: decode$1
    };

    var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
      , length = 64
      , map$1 = {}
      , seed = 0
      , i = 0
      , prev;

    /**
     * Return a string representing the specified number.
     *
     * @param {Number} num The number to convert.
     * @returns {String} The string representation of the number.
     * @api public
     */
    function encode(num) {
      var encoded = '';

      do {
        encoded = alphabet[num % length] + encoded;
        num = Math.floor(num / length);
      } while (num > 0);

      return encoded;
    }

    /**
     * Return the integer value specified by the given string.
     *
     * @param {String} str The string to convert.
     * @returns {Number} The integer value represented by the string.
     * @api public
     */
    function decode(str) {
      var decoded = 0;

      for (i = 0; i < str.length; i++) {
        decoded = decoded * length + map$1[str.charAt(i)];
      }

      return decoded;
    }

    /**
     * Yeast: A tiny growing id generator.
     *
     * @returns {String} A unique id.
     * @api public
     */
    function yeast() {
      var now = encode(+new Date());

      if (now !== prev) return seed = 0, prev = now;
      return now +'.'+ encode(seed++);
    }

    //
    // Map each character to its index.
    //
    for (; i < length; i++) map$1[alphabet[i]] = i;

    //
    // Expose the `yeast`, `encode` and `decode` functions.
    //
    yeast.encode = encode;
    yeast.decode = decode;
    var yeast_1 = yeast;

    const debug$5 = browser("engine.io-client:polling");

    class Polling extends transport {
      /**
       * Transport name.
       */
      get name() {
        return "polling";
      }

      /**
       * Opens the socket (triggers polling). We write a PING message to determine
       * when the transport is open.
       *
       * @api private
       */
      doOpen() {
        this.poll();
      }

      /**
       * Pauses polling.
       *
       * @param {Function} callback upon buffers are flushed and transport is paused
       * @api private
       */
      pause(onPause) {
        this.readyState = "pausing";

        const pause = () => {
          debug$5("paused");
          this.readyState = "paused";
          onPause();
        };

        if (this.polling || !this.writable) {
          let total = 0;

          if (this.polling) {
            debug$5("we are currently polling - waiting to pause");
            total++;
            this.once("pollComplete", function() {
              debug$5("pre-pause polling complete");
              --total || pause();
            });
          }

          if (!this.writable) {
            debug$5("we are currently writing - waiting to pause");
            total++;
            this.once("drain", function() {
              debug$5("pre-pause writing complete");
              --total || pause();
            });
          }
        } else {
          pause();
        }
      }

      /**
       * Starts polling cycle.
       *
       * @api public
       */
      poll() {
        debug$5("polling");
        this.polling = true;
        this.doPoll();
        this.emit("poll");
      }

      /**
       * Overloads onData to detect payloads.
       *
       * @api private
       */
      onData(data) {
        debug$5("polling got data %s", data);
        const callback = packet => {
          // if its the first message we consider the transport open
          if ("opening" === this.readyState && packet.type === "open") {
            this.onOpen();
          }

          // if its a close packet, we close the ongoing requests
          if ("close" === packet.type) {
            this.onClose();
            return false;
          }

          // otherwise bypass onData and handle the message
          this.onPacket(packet);
        };

        // decode payload
        lib$1.decodePayload(data, this.socket.binaryType).forEach(callback);

        // if an event did not trigger closing
        if ("closed" !== this.readyState) {
          // if we got data we're not polling
          this.polling = false;
          this.emit("pollComplete");

          if ("open" === this.readyState) {
            this.poll();
          } else {
            debug$5('ignoring poll - transport state "%s"', this.readyState);
          }
        }
      }

      /**
       * For polling, send a close packet.
       *
       * @api private
       */
      doClose() {
        const close = () => {
          debug$5("writing close packet");
          this.write([{ type: "close" }]);
        };

        if ("open" === this.readyState) {
          debug$5("transport open - closing");
          close();
        } else {
          // in case we're trying to close while
          // handshaking is in progress (GH-164)
          debug$5("transport not open - deferring close");
          this.once("open", close);
        }
      }

      /**
       * Writes a packets payload.
       *
       * @param {Array} data packets
       * @param {Function} drain callback
       * @api private
       */
      write(packets) {
        this.writable = false;

        lib$1.encodePayload(packets, data => {
          this.doWrite(data, () => {
            this.writable = true;
            this.emit("drain");
          });
        });
      }

      /**
       * Generates uri for connection.
       *
       * @api private
       */
      uri() {
        let query = this.query || {};
        const schema = this.opts.secure ? "https" : "http";
        let port = "";

        // cache busting is forced
        if (false !== this.opts.timestampRequests) {
          query[this.opts.timestampParam] = yeast_1();
        }

        if (!this.supportsBinary && !query.sid) {
          query.b64 = 1;
        }

        query = parseqs.encode(query);

        // avoid port if default for schema
        if (
          this.opts.port &&
          (("https" === schema && Number(this.opts.port) !== 443) ||
            ("http" === schema && Number(this.opts.port) !== 80))
        ) {
          port = ":" + this.opts.port;
        }

        // prepend ? to query
        if (query.length) {
          query = "?" + query;
        }

        const ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return (
          schema +
          "://" +
          (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
          port +
          this.opts.path +
          query
        );
      }
    }

    var polling$1 = Polling;

    var pick$3 = (obj, ...attr) => {
      return attr.reduce((acc, k) => {
        if (obj.hasOwnProperty(k)) {
          acc[k] = obj[k];
        }
        return acc;
      }, {});
    };

    var util$2 = {
    	pick: pick$3
    };

    /* global attachEvent */

    const { pick: pick$2 } = util$2;


    const debug$4 = browser("engine.io-client:polling-xhr");

    /**
     * Empty function
     */

    function empty() {}

    const hasXHR2 = (function() {
      const xhr = new xmlhttprequest({ xdomain: false });
      return null != xhr.responseType;
    })();

    class XHR extends polling$1 {
      /**
       * XHR Polling constructor.
       *
       * @param {Object} opts
       * @api public
       */
      constructor(opts) {
        super(opts);

        if (typeof location !== "undefined") {
          const isSSL = "https:" === location.protocol;
          let port = location.port;

          // some user agents have empty `location.port`
          if (!port) {
            port = isSSL ? 443 : 80;
          }

          this.xd =
            (typeof location !== "undefined" &&
              opts.hostname !== location.hostname) ||
            port !== opts.port;
          this.xs = opts.secure !== isSSL;
        }
        /**
         * XHR supports binary
         */
        const forceBase64 = opts && opts.forceBase64;
        this.supportsBinary = hasXHR2 && !forceBase64;
      }

      /**
       * Creates a request.
       *
       * @param {String} method
       * @api private
       */
      request(opts = {}) {
        Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
        return new Request(this.uri(), opts);
      }

      /**
       * Sends data.
       *
       * @param {String} data to send.
       * @param {Function} called upon flush.
       * @api private
       */
      doWrite(data, fn) {
        const req = this.request({
          method: "POST",
          data: data
        });
        req.on("success", fn);
        req.on("error", err => {
          this.onError("xhr post error", err);
        });
      }

      /**
       * Starts a poll cycle.
       *
       * @api private
       */
      doPoll() {
        debug$4("xhr poll");
        const req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", err => {
          this.onError("xhr poll error", err);
        });
        this.pollXhr = req;
      }
    }

    class Request extends componentEmitter {
      /**
       * Request constructor
       *
       * @param {Object} options
       * @api public
       */
      constructor(uri, opts) {
        super();
        this.opts = opts;

        this.method = opts.method || "GET";
        this.uri = uri;
        this.async = false !== opts.async;
        this.data = undefined !== opts.data ? opts.data : null;

        this.create();
      }

      /**
       * Creates the XHR object and sends the request.
       *
       * @api private
       */
      create() {
        const opts = pick$2(
          this.opts,
          "agent",
          "enablesXDR",
          "pfx",
          "key",
          "passphrase",
          "cert",
          "ca",
          "ciphers",
          "rejectUnauthorized",
          "autoUnref"
        );
        opts.xdomain = !!this.opts.xd;
        opts.xscheme = !!this.opts.xs;

        const xhr = (this.xhr = new xmlhttprequest(opts));

        try {
          debug$4("xhr open %s: %s", this.method, this.uri);
          xhr.open(this.method, this.uri, this.async);
          try {
            if (this.opts.extraHeaders) {
              xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
              for (let i in this.opts.extraHeaders) {
                if (this.opts.extraHeaders.hasOwnProperty(i)) {
                  xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
                }
              }
            }
          } catch (e) {}

          if ("POST" === this.method) {
            try {
              xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
            } catch (e) {}
          }

          try {
            xhr.setRequestHeader("Accept", "*/*");
          } catch (e) {}

          // ie6 check
          if ("withCredentials" in xhr) {
            xhr.withCredentials = this.opts.withCredentials;
          }

          if (this.opts.requestTimeout) {
            xhr.timeout = this.opts.requestTimeout;
          }

          if (this.hasXDR()) {
            xhr.onload = () => {
              this.onLoad();
            };
            xhr.onerror = () => {
              this.onError(xhr.responseText);
            };
          } else {
            xhr.onreadystatechange = () => {
              if (4 !== xhr.readyState) return;
              if (200 === xhr.status || 1223 === xhr.status) {
                this.onLoad();
              } else {
                // make sure the `error` event handler that's user-set
                // does not throw in the same tick and gets caught here
                setTimeout(() => {
                  this.onError(typeof xhr.status === "number" ? xhr.status : 0);
                }, 0);
              }
            };
          }

          debug$4("xhr data %s", this.data);
          xhr.send(this.data);
        } catch (e) {
          // Need to defer since .create() is called directly from the constructor
          // and thus the 'error' event can only be only bound *after* this exception
          // occurs.  Therefore, also, we cannot throw here at all.
          setTimeout(() => {
            this.onError(e);
          }, 0);
          return;
        }

        if (typeof document !== "undefined") {
          this.index = Request.requestsCount++;
          Request.requests[this.index] = this;
        }
      }

      /**
       * Called upon successful response.
       *
       * @api private
       */
      onSuccess() {
        this.emit("success");
        this.cleanup();
      }

      /**
       * Called if we have data.
       *
       * @api private
       */
      onData(data) {
        this.emit("data", data);
        this.onSuccess();
      }

      /**
       * Called upon error.
       *
       * @api private
       */
      onError(err) {
        this.emit("error", err);
        this.cleanup(true);
      }

      /**
       * Cleans up house.
       *
       * @api private
       */
      cleanup(fromError) {
        if ("undefined" === typeof this.xhr || null === this.xhr) {
          return;
        }
        // xmlhttprequest
        if (this.hasXDR()) {
          this.xhr.onload = this.xhr.onerror = empty;
        } else {
          this.xhr.onreadystatechange = empty;
        }

        if (fromError) {
          try {
            this.xhr.abort();
          } catch (e) {}
        }

        if (typeof document !== "undefined") {
          delete Request.requests[this.index];
        }

        this.xhr = null;
      }

      /**
       * Called upon load.
       *
       * @api private
       */
      onLoad() {
        const data = this.xhr.responseText;
        if (data !== null) {
          this.onData(data);
        }
      }

      /**
       * Check if it has XDomainRequest.
       *
       * @api private
       */
      hasXDR() {
        return typeof XDomainRequest !== "undefined" && !this.xs && this.enablesXDR;
      }

      /**
       * Aborts the request.
       *
       * @api public
       */
      abort() {
        this.cleanup();
      }
    }

    /**
     * Aborts pending requests when unloading the window. This is needed to prevent
     * memory leaks (e.g. when using IE) and to ensure that no spurious error is
     * emitted.
     */

    Request.requestsCount = 0;
    Request.requests = {};

    if (typeof document !== "undefined") {
      if (typeof attachEvent === "function") {
        attachEvent("onunload", unloadHandler);
      } else if (typeof addEventListener === "function") {
        const terminationEvent = "onpagehide" in globalThis_browser ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
      }
    }

    function unloadHandler() {
      for (let i in Request.requests) {
        if (Request.requests.hasOwnProperty(i)) {
          Request.requests[i].abort();
        }
      }
    }

    var pollingXhr = XHR;
    var Request_1 = Request;
    pollingXhr.Request = Request_1;

    const rNewline = /\n/g;
    const rEscapedNewline = /\\n/g;

    /**
     * Global JSONP callbacks.
     */

    let callbacks;

    class JSONPPolling extends polling$1 {
      /**
       * JSONP Polling constructor.
       *
       * @param {Object} opts.
       * @api public
       */
      constructor(opts) {
        super(opts);

        this.query = this.query || {};

        // define global callbacks array if not present
        // we do this here (lazily) to avoid unneeded global pollution
        if (!callbacks) {
          // we need to consider multiple engines in the same page
          callbacks = globalThis_browser.___eio = globalThis_browser.___eio || [];
        }

        // callback identifier
        this.index = callbacks.length;

        // add callback to jsonp global
        callbacks.push(this.onData.bind(this));

        // append to query string
        this.query.j = this.index;
      }

      /**
       * JSONP only supports binary as base64 encoded strings
       */
      get supportsBinary() {
        return false;
      }

      /**
       * Closes the socket.
       *
       * @api private
       */
      doClose() {
        if (this.script) {
          // prevent spurious errors from being emitted when the window is unloaded
          this.script.onerror = () => {};
          this.script.parentNode.removeChild(this.script);
          this.script = null;
        }

        if (this.form) {
          this.form.parentNode.removeChild(this.form);
          this.form = null;
          this.iframe = null;
        }

        super.doClose();
      }

      /**
       * Starts a poll cycle.
       *
       * @api private
       */
      doPoll() {
        const script = document.createElement("script");

        if (this.script) {
          this.script.parentNode.removeChild(this.script);
          this.script = null;
        }

        script.async = true;
        script.src = this.uri();
        script.onerror = e => {
          this.onError("jsonp poll error", e);
        };

        const insertAt = document.getElementsByTagName("script")[0];
        if (insertAt) {
          insertAt.parentNode.insertBefore(script, insertAt);
        } else {
          (document.head || document.body).appendChild(script);
        }
        this.script = script;

        const isUAgecko =
          "undefined" !== typeof navigator && /gecko/i.test(navigator.userAgent);

        if (isUAgecko) {
          setTimeout(function() {
            const iframe = document.createElement("iframe");
            document.body.appendChild(iframe);
            document.body.removeChild(iframe);
          }, 100);
        }
      }

      /**
       * Writes with a hidden iframe.
       *
       * @param {String} data to send
       * @param {Function} called upon flush.
       * @api private
       */
      doWrite(data, fn) {
        let iframe;

        if (!this.form) {
          const form = document.createElement("form");
          const area = document.createElement("textarea");
          const id = (this.iframeId = "eio_iframe_" + this.index);

          form.className = "socketio";
          form.style.position = "absolute";
          form.style.top = "-1000px";
          form.style.left = "-1000px";
          form.target = id;
          form.method = "POST";
          form.setAttribute("accept-charset", "utf-8");
          area.name = "d";
          form.appendChild(area);
          document.body.appendChild(form);

          this.form = form;
          this.area = area;
        }

        this.form.action = this.uri();

        function complete() {
          initIframe();
          fn();
        }

        const initIframe = () => {
          if (this.iframe) {
            try {
              this.form.removeChild(this.iframe);
            } catch (e) {
              this.onError("jsonp polling iframe removal error", e);
            }
          }

          try {
            // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
            const html = '<iframe src="javascript:0" name="' + this.iframeId + '">';
            iframe = document.createElement(html);
          } catch (e) {
            iframe = document.createElement("iframe");
            iframe.name = this.iframeId;
            iframe.src = "javascript:0";
          }

          iframe.id = this.iframeId;

          this.form.appendChild(iframe);
          this.iframe = iframe;
        };

        initIframe();

        // escape \n to prevent it from being converted into \r\n by some UAs
        // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
        data = data.replace(rEscapedNewline, "\\\n");
        this.area.value = data.replace(rNewline, "\\n");

        try {
          this.form.submit();
        } catch (e) {}

        if (this.iframe.attachEvent) {
          this.iframe.onreadystatechange = () => {
            if (this.iframe.readyState === "complete") {
              complete();
            }
          };
        } else {
          this.iframe.onload = complete;
        }
      }
    }

    var pollingJsonp = JSONPPolling;

    var websocketConstructor_browser = {
      WebSocket: globalThis_browser.WebSocket || globalThis_browser.MozWebSocket,
      usingBrowserWebSocket: true,
      defaultBinaryType: "arraybuffer"
    };

    const { pick: pick$1 } = util$2;
    const {
      WebSocket,
      usingBrowserWebSocket,
      defaultBinaryType
    } = websocketConstructor_browser;

    const debug$3 = browser("engine.io-client:websocket");

    // detect ReactNative environment
    const isReactNative =
      typeof navigator !== "undefined" &&
      typeof navigator.product === "string" &&
      navigator.product.toLowerCase() === "reactnative";

    class WS extends transport {
      /**
       * WebSocket transport constructor.
       *
       * @api {Object} connection options
       * @api public
       */
      constructor(opts) {
        super(opts);

        this.supportsBinary = !opts.forceBase64;
      }

      /**
       * Transport name.
       *
       * @api public
       */
      get name() {
        return "websocket";
      }

      /**
       * Opens socket.
       *
       * @api private
       */
      doOpen() {
        if (!this.check()) {
          // let probe timeout
          return;
        }

        const uri = this.uri();
        const protocols = this.opts.protocols;

        // React Native only supports the 'headers' option, and will print a warning if anything else is passed
        const opts = isReactNative
          ? {}
          : pick$1(
              this.opts,
              "agent",
              "perMessageDeflate",
              "pfx",
              "key",
              "passphrase",
              "cert",
              "ca",
              "ciphers",
              "rejectUnauthorized",
              "localAddress",
              "protocolVersion",
              "origin",
              "maxPayload",
              "family",
              "checkServerIdentity"
            );

        if (this.opts.extraHeaders) {
          opts.headers = this.opts.extraHeaders;
        }

        try {
          this.ws =
            usingBrowserWebSocket && !isReactNative
              ? protocols
                ? new WebSocket(uri, protocols)
                : new WebSocket(uri)
              : new WebSocket(uri, protocols, opts);
        } catch (err) {
          return this.emit("error", err);
        }

        this.ws.binaryType = this.socket.binaryType || defaultBinaryType;

        this.addEventListeners();
      }

      /**
       * Adds event listeners to the socket
       *
       * @api private
       */
      addEventListeners() {
        this.ws.onopen = () => {
          if (this.opts.autoUnref) {
            this.ws._socket.unref();
          }
          this.onOpen();
        };
        this.ws.onclose = this.onClose.bind(this);
        this.ws.onmessage = ev => this.onData(ev.data);
        this.ws.onerror = e => this.onError("websocket error", e);
      }

      /**
       * Writes data to socket.
       *
       * @param {Array} array of packets.
       * @api private
       */
      write(packets) {
        this.writable = false;

        // encodePacket efficient as it uses WS framing
        // no need for encodePayload
        for (let i = 0; i < packets.length; i++) {
          const packet = packets[i];
          const lastPacket = i === packets.length - 1;

          lib$1.encodePacket(packet, this.supportsBinary, data => {
            // always create a new object (GH-437)
            const opts = {};
            if (!usingBrowserWebSocket) {
              if (packet.options) {
                opts.compress = packet.options.compress;
              }

              if (this.opts.perMessageDeflate) {
                const len =
                  "string" === typeof data ? Buffer.byteLength(data) : data.length;
                if (len < this.opts.perMessageDeflate.threshold) {
                  opts.compress = false;
                }
              }
            }

            // Sometimes the websocket has already been closed but the browser didn't
            // have a chance of informing us about it yet, in that case send will
            // throw an error
            try {
              if (usingBrowserWebSocket) {
                // TypeError is thrown when passing the second argument on Safari
                this.ws.send(data);
              } else {
                this.ws.send(data, opts);
              }
            } catch (e) {
              debug$3("websocket closed before onclose event");
            }

            if (lastPacket) {
              // fake drain
              // defer to next tick to allow Socket to clear writeBuffer
              setTimeout(() => {
                this.writable = true;
                this.emit("drain");
              }, 0);
            }
          });
        }
      }

      /**
       * Called upon close
       *
       * @api private
       */
      onClose() {
        transport.prototype.onClose.call(this);
      }

      /**
       * Closes socket.
       *
       * @api private
       */
      doClose() {
        if (typeof this.ws !== "undefined") {
          this.ws.close();
          this.ws = null;
        }
      }

      /**
       * Generates uri for connection.
       *
       * @api private
       */
      uri() {
        let query = this.query || {};
        const schema = this.opts.secure ? "wss" : "ws";
        let port = "";

        // avoid port if default for schema
        if (
          this.opts.port &&
          (("wss" === schema && Number(this.opts.port) !== 443) ||
            ("ws" === schema && Number(this.opts.port) !== 80))
        ) {
          port = ":" + this.opts.port;
        }

        // append timestamp to URI
        if (this.opts.timestampRequests) {
          query[this.opts.timestampParam] = yeast_1();
        }

        // communicate binary support capabilities
        if (!this.supportsBinary) {
          query.b64 = 1;
        }

        query = parseqs.encode(query);

        // prepend ? to query
        if (query.length) {
          query = "?" + query;
        }

        const ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return (
          schema +
          "://" +
          (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
          port +
          this.opts.path +
          query
        );
      }

      /**
       * Feature detection for WebSocket.
       *
       * @return {Boolean} whether this transport is available.
       * @api public
       */
      check() {
        return (
          !!WebSocket &&
          !("__initialize" in WebSocket && this.name === WS.prototype.name)
        );
      }
    }

    var websocket = WS;

    var polling_1 = polling;
    var websocket_1 = websocket;

    /**
     * Polling transport polymorphic constructor.
     * Decides on xhr vs jsonp based on feature detection.
     *
     * @api private
     */

    function polling(opts) {
      let xhr;
      let xd = false;
      let xs = false;
      const jsonp = false !== opts.jsonp;

      if (typeof location !== "undefined") {
        const isSSL = "https:" === location.protocol;
        let port = location.port;

        // some user agents have empty `location.port`
        if (!port) {
          port = isSSL ? 443 : 80;
        }

        xd = opts.hostname !== location.hostname || port !== opts.port;
        xs = opts.secure !== isSSL;
      }

      opts.xdomain = xd;
      opts.xscheme = xs;
      xhr = new xmlhttprequest(opts);

      if ("open" in xhr && !opts.forceJSONP) {
        return new pollingXhr(opts);
      } else {
        if (!jsonp) throw new Error("JSONP disabled");
        return new pollingJsonp(opts);
      }
    }

    var transports$1 = {
    	polling: polling_1,
    	websocket: websocket_1
    };

    const debug$2 = browser("engine.io-client:socket");




    class Socket extends componentEmitter {
      /**
       * Socket constructor.
       *
       * @param {String|Object} uri or options
       * @param {Object} options
       * @api public
       */
      constructor(uri, opts = {}) {
        super();

        if (uri && "object" === typeof uri) {
          opts = uri;
          uri = null;
        }

        if (uri) {
          uri = parseuri(uri);
          opts.hostname = uri.host;
          opts.secure = uri.protocol === "https" || uri.protocol === "wss";
          opts.port = uri.port;
          if (uri.query) opts.query = uri.query;
        } else if (opts.host) {
          opts.hostname = parseuri(opts.host).host;
        }

        this.secure =
          null != opts.secure
            ? opts.secure
            : typeof location !== "undefined" && "https:" === location.protocol;

        if (opts.hostname && !opts.port) {
          // if no port is specified manually, use the protocol default
          opts.port = this.secure ? "443" : "80";
        }

        this.hostname =
          opts.hostname ||
          (typeof location !== "undefined" ? location.hostname : "localhost");
        this.port =
          opts.port ||
          (typeof location !== "undefined" && location.port
            ? location.port
            : this.secure
            ? 443
            : 80);

        this.transports = opts.transports || ["polling", "websocket"];
        this.readyState = "";
        this.writeBuffer = [];
        this.prevBufferLen = 0;

        this.opts = Object.assign(
          {
            path: "/engine.io",
            agent: false,
            withCredentials: false,
            upgrade: true,
            jsonp: true,
            timestampParam: "t",
            rememberUpgrade: false,
            rejectUnauthorized: true,
            perMessageDeflate: {
              threshold: 1024
            },
            transportOptions: {},
            closeOnBeforeunload: true
          },
          opts
        );

        this.opts.path = this.opts.path.replace(/\/$/, "") + "/";

        if (typeof this.opts.query === "string") {
          this.opts.query = parseqs.decode(this.opts.query);
        }

        // set on handshake
        this.id = null;
        this.upgrades = null;
        this.pingInterval = null;
        this.pingTimeout = null;

        // set on heartbeat
        this.pingTimeoutTimer = null;

        if (typeof addEventListener === "function") {
          if (this.opts.closeOnBeforeunload) {
            // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
            // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
            // closed/reloaded)
            addEventListener(
              "beforeunload",
              () => {
                if (this.transport) {
                  // silently close the transport
                  this.transport.removeAllListeners();
                  this.transport.close();
                }
              },
              false
            );
          }
          if (this.hostname !== "localhost") {
            this.offlineEventListener = () => {
              this.onClose("transport close");
            };
            addEventListener("offline", this.offlineEventListener, false);
          }
        }

        this.open();
      }

      /**
       * Creates transport of the given type.
       *
       * @param {String} transport name
       * @return {Transport}
       * @api private
       */
      createTransport(name) {
        debug$2('creating transport "%s"', name);
        const query = clone$1(this.opts.query);

        // append engine.io protocol identifier
        query.EIO = lib$1.protocol;

        // transport name
        query.transport = name;

        // session id if we already have one
        if (this.id) query.sid = this.id;

        const opts = Object.assign(
          {},
          this.opts.transportOptions[name],
          this.opts,
          {
            query,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port
          }
        );

        debug$2("options: %j", opts);

        return new transports$1[name](opts);
      }

      /**
       * Initializes transport to use and starts probe.
       *
       * @api private
       */
      open() {
        let transport;
        if (
          this.opts.rememberUpgrade &&
          Socket.priorWebsocketSuccess &&
          this.transports.indexOf("websocket") !== -1
        ) {
          transport = "websocket";
        } else if (0 === this.transports.length) {
          // Emit error on next tick so it can be listened to
          setTimeout(() => {
            this.emit("error", "No transports available");
          }, 0);
          return;
        } else {
          transport = this.transports[0];
        }
        this.readyState = "opening";

        // Retry with the next transport if the transport is disabled (jsonp: false)
        try {
          transport = this.createTransport(transport);
        } catch (e) {
          debug$2("error while creating transport: %s", e);
          this.transports.shift();
          this.open();
          return;
        }

        transport.open();
        this.setTransport(transport);
      }

      /**
       * Sets the current transport. Disables the existing one (if any).
       *
       * @api private
       */
      setTransport(transport) {
        debug$2("setting transport %s", transport.name);

        if (this.transport) {
          debug$2("clearing existing transport %s", this.transport.name);
          this.transport.removeAllListeners();
        }

        // set up transport
        this.transport = transport;

        // set up transport listeners
        transport
          .on("drain", this.onDrain.bind(this))
          .on("packet", this.onPacket.bind(this))
          .on("error", this.onError.bind(this))
          .on("close", () => {
            this.onClose("transport close");
          });
      }

      /**
       * Probes a transport.
       *
       * @param {String} transport name
       * @api private
       */
      probe(name) {
        debug$2('probing transport "%s"', name);
        let transport = this.createTransport(name, { probe: 1 });
        let failed = false;

        Socket.priorWebsocketSuccess = false;

        const onTransportOpen = () => {
          if (failed) return;

          debug$2('probe transport "%s" opened', name);
          transport.send([{ type: "ping", data: "probe" }]);
          transport.once("packet", msg => {
            if (failed) return;
            if ("pong" === msg.type && "probe" === msg.data) {
              debug$2('probe transport "%s" pong', name);
              this.upgrading = true;
              this.emit("upgrading", transport);
              if (!transport) return;
              Socket.priorWebsocketSuccess = "websocket" === transport.name;

              debug$2('pausing current transport "%s"', this.transport.name);
              this.transport.pause(() => {
                if (failed) return;
                if ("closed" === this.readyState) return;
                debug$2("changing transport and sending upgrade packet");

                cleanup();

                this.setTransport(transport);
                transport.send([{ type: "upgrade" }]);
                this.emit("upgrade", transport);
                transport = null;
                this.upgrading = false;
                this.flush();
              });
            } else {
              debug$2('probe transport "%s" failed', name);
              const err = new Error("probe error");
              err.transport = transport.name;
              this.emit("upgradeError", err);
            }
          });
        };

        function freezeTransport() {
          if (failed) return;

          // Any callback called by transport should be ignored since now
          failed = true;

          cleanup();

          transport.close();
          transport = null;
        }

        // Handle any error that happens while probing
        const onerror = err => {
          const error = new Error("probe error: " + err);
          error.transport = transport.name;

          freezeTransport();

          debug$2('probe transport "%s" failed because of error: %s', name, err);

          this.emit("upgradeError", error);
        };

        function onTransportClose() {
          onerror("transport closed");
        }

        // When the socket is closed while we're probing
        function onclose() {
          onerror("socket closed");
        }

        // When the socket is upgraded while we're probing
        function onupgrade(to) {
          if (transport && to.name !== transport.name) {
            debug$2('"%s" works - aborting "%s"', to.name, transport.name);
            freezeTransport();
          }
        }

        // Remove all listeners on the transport and on self
        const cleanup = () => {
          transport.removeListener("open", onTransportOpen);
          transport.removeListener("error", onerror);
          transport.removeListener("close", onTransportClose);
          this.removeListener("close", onclose);
          this.removeListener("upgrading", onupgrade);
        };

        transport.once("open", onTransportOpen);
        transport.once("error", onerror);
        transport.once("close", onTransportClose);

        this.once("close", onclose);
        this.once("upgrading", onupgrade);

        transport.open();
      }

      /**
       * Called when connection is deemed open.
       *
       * @api public
       */
      onOpen() {
        debug$2("socket open");
        this.readyState = "open";
        Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
        this.emit("open");
        this.flush();

        // we check for `readyState` in case an `open`
        // listener already closed the socket
        if (
          "open" === this.readyState &&
          this.opts.upgrade &&
          this.transport.pause
        ) {
          debug$2("starting upgrade probes");
          let i = 0;
          const l = this.upgrades.length;
          for (; i < l; i++) {
            this.probe(this.upgrades[i]);
          }
        }
      }

      /**
       * Handles a packet.
       *
       * @api private
       */
      onPacket(packet) {
        if (
          "opening" === this.readyState ||
          "open" === this.readyState ||
          "closing" === this.readyState
        ) {
          debug$2('socket receive: type "%s", data "%s"', packet.type, packet.data);

          this.emit("packet", packet);

          // Socket is live - any packet counts
          this.emit("heartbeat");

          switch (packet.type) {
            case "open":
              this.onHandshake(JSON.parse(packet.data));
              break;

            case "ping":
              this.resetPingTimeout();
              this.sendPacket("pong");
              this.emit("pong");
              break;

            case "error":
              const err = new Error("server error");
              err.code = packet.data;
              this.onError(err);
              break;

            case "message":
              this.emit("data", packet.data);
              this.emit("message", packet.data);
              break;
          }
        } else {
          debug$2('packet received with socket readyState "%s"', this.readyState);
        }
      }

      /**
       * Called upon handshake completion.
       *
       * @param {Object} handshake obj
       * @api private
       */
      onHandshake(data) {
        this.emit("handshake", data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this.upgrades = this.filterUpgrades(data.upgrades);
        this.pingInterval = data.pingInterval;
        this.pingTimeout = data.pingTimeout;
        this.onOpen();
        // In case open handler closes socket
        if ("closed" === this.readyState) return;
        this.resetPingTimeout();
      }

      /**
       * Sets and resets ping timeout timer based on server pings.
       *
       * @api private
       */
      resetPingTimeout() {
        clearTimeout(this.pingTimeoutTimer);
        this.pingTimeoutTimer = setTimeout(() => {
          this.onClose("ping timeout");
        }, this.pingInterval + this.pingTimeout);
        if (this.opts.autoUnref) {
          this.pingTimeoutTimer.unref();
        }
      }

      /**
       * Called on `drain` event
       *
       * @api private
       */
      onDrain() {
        this.writeBuffer.splice(0, this.prevBufferLen);

        // setting prevBufferLen = 0 is very important
        // for example, when upgrading, upgrade packet is sent over,
        // and a nonzero prevBufferLen could cause problems on `drain`
        this.prevBufferLen = 0;

        if (0 === this.writeBuffer.length) {
          this.emit("drain");
        } else {
          this.flush();
        }
      }

      /**
       * Flush write buffers.
       *
       * @api private
       */
      flush() {
        if (
          "closed" !== this.readyState &&
          this.transport.writable &&
          !this.upgrading &&
          this.writeBuffer.length
        ) {
          debug$2("flushing %d packets in socket", this.writeBuffer.length);
          this.transport.send(this.writeBuffer);
          // keep track of current length of writeBuffer
          // splice writeBuffer and callbackBuffer on `drain`
          this.prevBufferLen = this.writeBuffer.length;
          this.emit("flush");
        }
      }

      /**
       * Sends a message.
       *
       * @param {String} message.
       * @param {Function} callback function.
       * @param {Object} options.
       * @return {Socket} for chaining.
       * @api public
       */
      write(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
      }

      send(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
      }

      /**
       * Sends a packet.
       *
       * @param {String} packet type.
       * @param {String} data.
       * @param {Object} options.
       * @param {Function} callback function.
       * @api private
       */
      sendPacket(type, data, options, fn) {
        if ("function" === typeof data) {
          fn = data;
          data = undefined;
        }

        if ("function" === typeof options) {
          fn = options;
          options = null;
        }

        if ("closing" === this.readyState || "closed" === this.readyState) {
          return;
        }

        options = options || {};
        options.compress = false !== options.compress;

        const packet = {
          type: type,
          data: data,
          options: options
        };
        this.emit("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (fn) this.once("flush", fn);
        this.flush();
      }

      /**
       * Closes the connection.
       *
       * @api private
       */
      close() {
        const close = () => {
          this.onClose("forced close");
          debug$2("socket closing - telling transport to close");
          this.transport.close();
        };

        const cleanupAndClose = () => {
          this.removeListener("upgrade", cleanupAndClose);
          this.removeListener("upgradeError", cleanupAndClose);
          close();
        };

        const waitForUpgrade = () => {
          // wait for upgrade to finish since we can't send packets while pausing a transport
          this.once("upgrade", cleanupAndClose);
          this.once("upgradeError", cleanupAndClose);
        };

        if ("opening" === this.readyState || "open" === this.readyState) {
          this.readyState = "closing";

          if (this.writeBuffer.length) {
            this.once("drain", () => {
              if (this.upgrading) {
                waitForUpgrade();
              } else {
                close();
              }
            });
          } else if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        }

        return this;
      }

      /**
       * Called upon transport error
       *
       * @api private
       */
      onError(err) {
        debug$2("socket error %j", err);
        Socket.priorWebsocketSuccess = false;
        this.emit("error", err);
        this.onClose("transport error", err);
      }

      /**
       * Called upon transport close.
       *
       * @api private
       */
      onClose(reason, desc) {
        if (
          "opening" === this.readyState ||
          "open" === this.readyState ||
          "closing" === this.readyState
        ) {
          debug$2('socket close with reason: "%s"', reason);

          // clear timers
          clearTimeout(this.pingIntervalTimer);
          clearTimeout(this.pingTimeoutTimer);

          // stop event from firing again for transport
          this.transport.removeAllListeners("close");

          // ensure transport won't stay open
          this.transport.close();

          // ignore further transport communication
          this.transport.removeAllListeners();

          if (typeof removeEventListener === "function") {
            removeEventListener("offline", this.offlineEventListener, false);
          }

          // set ready state
          this.readyState = "closed";

          // clear session id
          this.id = null;

          // emit close event
          this.emit("close", reason, desc);

          // clean buffers after, so users can still
          // grab the buffers on `close` event
          this.writeBuffer = [];
          this.prevBufferLen = 0;
        }
      }

      /**
       * Filters upgrades, returning only those matching client transports.
       *
       * @param {Array} server upgrades
       * @api private
       *
       */
      filterUpgrades(upgrades) {
        const filteredUpgrades = [];
        let i = 0;
        const j = upgrades.length;
        for (; i < j; i++) {
          if (~this.transports.indexOf(upgrades[i]))
            filteredUpgrades.push(upgrades[i]);
        }
        return filteredUpgrades;
      }
    }

    Socket.priorWebsocketSuccess = false;

    /**
     * Protocol version.
     *
     * @api public
     */

    Socket.protocol = lib$1.protocol; // this is an int

    function clone$1(obj) {
      const o = {};
      for (let i in obj) {
        if (obj.hasOwnProperty(i)) {
          o[i] = obj[i];
        }
      }
      return o;
    }

    var socket$2 = Socket;

    var lib = (uri, opts) => new socket$2(uri, opts);

    /**
     * Expose deps for legacy compatibility
     * and standalone browser access.
     */

    var Socket_1 = socket$2;
    var protocol = socket$2.protocol; // this is an int
    var Transport = transport;
    var transports = transports$1;
    var parser = lib$1;
    lib.Socket = Socket_1;
    lib.protocol = protocol;
    lib.Transport = Transport;
    lib.transports = transports;
    lib.parser = parser;

    var isBinary_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasBinary = exports.isBinary = void 0;
    const withNativeArrayBuffer = typeof ArrayBuffer === "function";
    const isView = (obj) => {
        return typeof ArrayBuffer.isView === "function"
            ? ArrayBuffer.isView(obj)
            : obj.buffer instanceof ArrayBuffer;
    };
    const toString = Object.prototype.toString;
    const withNativeBlob = typeof Blob === "function" ||
        (typeof Blob !== "undefined" &&
            toString.call(Blob) === "[object BlobConstructor]");
    const withNativeFile = typeof File === "function" ||
        (typeof File !== "undefined" &&
            toString.call(File) === "[object FileConstructor]");
    /**
     * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
     *
     * @private
     */
    function isBinary(obj) {
        return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||
            (withNativeBlob && obj instanceof Blob) ||
            (withNativeFile && obj instanceof File));
    }
    exports.isBinary = isBinary;
    function hasBinary(obj, toJSON) {
        if (!obj || typeof obj !== "object") {
            return false;
        }
        if (Array.isArray(obj)) {
            for (let i = 0, l = obj.length; i < l; i++) {
                if (hasBinary(obj[i])) {
                    return true;
                }
            }
            return false;
        }
        if (isBinary(obj)) {
            return true;
        }
        if (obj.toJSON &&
            typeof obj.toJSON === "function" &&
            arguments.length === 1) {
            return hasBinary(obj.toJSON(), true);
        }
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
                return true;
            }
        }
        return false;
    }
    exports.hasBinary = hasBinary;
    });

    var binary = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reconstructPacket = exports.deconstructPacket = void 0;

    /**
     * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
     *
     * @param {Object} packet - socket.io event packet
     * @return {Object} with deconstructed packet and list of buffers
     * @public
     */
    function deconstructPacket(packet) {
        const buffers = [];
        const packetData = packet.data;
        const pack = packet;
        pack.data = _deconstructPacket(packetData, buffers);
        pack.attachments = buffers.length; // number of binary 'attachments'
        return { packet: pack, buffers: buffers };
    }
    exports.deconstructPacket = deconstructPacket;
    function _deconstructPacket(data, buffers) {
        if (!data)
            return data;
        if (isBinary_1.isBinary(data)) {
            const placeholder = { _placeholder: true, num: buffers.length };
            buffers.push(data);
            return placeholder;
        }
        else if (Array.isArray(data)) {
            const newData = new Array(data.length);
            for (let i = 0; i < data.length; i++) {
                newData[i] = _deconstructPacket(data[i], buffers);
            }
            return newData;
        }
        else if (typeof data === "object" && !(data instanceof Date)) {
            const newData = {};
            for (const key in data) {
                if (data.hasOwnProperty(key)) {
                    newData[key] = _deconstructPacket(data[key], buffers);
                }
            }
            return newData;
        }
        return data;
    }
    /**
     * Reconstructs a binary packet from its placeholder packet and buffers
     *
     * @param {Object} packet - event packet with placeholders
     * @param {Array} buffers - binary buffers to put in placeholder positions
     * @return {Object} reconstructed packet
     * @public
     */
    function reconstructPacket(packet, buffers) {
        packet.data = _reconstructPacket(packet.data, buffers);
        packet.attachments = undefined; // no longer useful
        return packet;
    }
    exports.reconstructPacket = reconstructPacket;
    function _reconstructPacket(data, buffers) {
        if (!data)
            return data;
        if (data && data._placeholder) {
            return buffers[data.num]; // appropriate buffer (should be natural order anyway)
        }
        else if (Array.isArray(data)) {
            for (let i = 0; i < data.length; i++) {
                data[i] = _reconstructPacket(data[i], buffers);
            }
        }
        else if (typeof data === "object") {
            for (const key in data) {
                if (data.hasOwnProperty(key)) {
                    data[key] = _reconstructPacket(data[key], buffers);
                }
            }
        }
        return data;
    }
    });

    var dist = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;



    const debug = browser("socket.io-parser");
    /**
     * Protocol version.
     *
     * @public
     */
    exports.protocol = 5;
    var PacketType;
    (function (PacketType) {
        PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
        PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
        PacketType[PacketType["EVENT"] = 2] = "EVENT";
        PacketType[PacketType["ACK"] = 3] = "ACK";
        PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
        PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
        PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
    })(PacketType = exports.PacketType || (exports.PacketType = {}));
    /**
     * A socket.io Encoder instance
     */
    class Encoder {
        /**
         * Encode a packet as a single string if non-binary, or as a
         * buffer sequence, depending on packet type.
         *
         * @param {Object} obj - packet object
         */
        encode(obj) {
            debug("encoding packet %j", obj);
            if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
                if (isBinary_1.hasBinary(obj)) {
                    obj.type =
                        obj.type === PacketType.EVENT
                            ? PacketType.BINARY_EVENT
                            : PacketType.BINARY_ACK;
                    return this.encodeAsBinary(obj);
                }
            }
            return [this.encodeAsString(obj)];
        }
        /**
         * Encode packet as string.
         */
        encodeAsString(obj) {
            // first is type
            let str = "" + obj.type;
            // attachments if we have them
            if (obj.type === PacketType.BINARY_EVENT ||
                obj.type === PacketType.BINARY_ACK) {
                str += obj.attachments + "-";
            }
            // if we have a namespace other than `/`
            // we append it followed by a comma `,`
            if (obj.nsp && "/" !== obj.nsp) {
                str += obj.nsp + ",";
            }
            // immediately followed by the id
            if (null != obj.id) {
                str += obj.id;
            }
            // json data
            if (null != obj.data) {
                str += JSON.stringify(obj.data);
            }
            debug("encoded %j as %s", obj, str);
            return str;
        }
        /**
         * Encode packet as 'buffer sequence' by removing blobs, and
         * deconstructing packet into object with placeholders and
         * a list of buffers.
         */
        encodeAsBinary(obj) {
            const deconstruction = binary.deconstructPacket(obj);
            const pack = this.encodeAsString(deconstruction.packet);
            const buffers = deconstruction.buffers;
            buffers.unshift(pack); // add packet info to beginning of data list
            return buffers; // write all the buffers
        }
    }
    exports.Encoder = Encoder;
    /**
     * A socket.io Decoder instance
     *
     * @return {Object} decoder
     */
    class Decoder extends componentEmitter {
        constructor() {
            super();
        }
        /**
         * Decodes an encoded packet string into packet JSON.
         *
         * @param {String} obj - encoded packet
         */
        add(obj) {
            let packet;
            if (typeof obj === "string") {
                packet = this.decodeString(obj);
                if (packet.type === PacketType.BINARY_EVENT ||
                    packet.type === PacketType.BINARY_ACK) {
                    // binary packet's json
                    this.reconstructor = new BinaryReconstructor(packet);
                    // no attachments, labeled binary but no binary data to follow
                    if (packet.attachments === 0) {
                        super.emit("decoded", packet);
                    }
                }
                else {
                    // non-binary full packet
                    super.emit("decoded", packet);
                }
            }
            else if (isBinary_1.isBinary(obj) || obj.base64) {
                // raw binary data
                if (!this.reconstructor) {
                    throw new Error("got binary data when not reconstructing a packet");
                }
                else {
                    packet = this.reconstructor.takeBinaryData(obj);
                    if (packet) {
                        // received final buffer
                        this.reconstructor = null;
                        super.emit("decoded", packet);
                    }
                }
            }
            else {
                throw new Error("Unknown type: " + obj);
            }
        }
        /**
         * Decode a packet String (JSON data)
         *
         * @param {String} str
         * @return {Object} packet
         */
        decodeString(str) {
            let i = 0;
            // look up type
            const p = {
                type: Number(str.charAt(0)),
            };
            if (PacketType[p.type] === undefined) {
                throw new Error("unknown packet type " + p.type);
            }
            // look up attachments if type binary
            if (p.type === PacketType.BINARY_EVENT ||
                p.type === PacketType.BINARY_ACK) {
                const start = i + 1;
                while (str.charAt(++i) !== "-" && i != str.length) { }
                const buf = str.substring(start, i);
                if (buf != Number(buf) || str.charAt(i) !== "-") {
                    throw new Error("Illegal attachments");
                }
                p.attachments = Number(buf);
            }
            // look up namespace (if any)
            if ("/" === str.charAt(i + 1)) {
                const start = i + 1;
                while (++i) {
                    const c = str.charAt(i);
                    if ("," === c)
                        break;
                    if (i === str.length)
                        break;
                }
                p.nsp = str.substring(start, i);
            }
            else {
                p.nsp = "/";
            }
            // look up id
            const next = str.charAt(i + 1);
            if ("" !== next && Number(next) == next) {
                const start = i + 1;
                while (++i) {
                    const c = str.charAt(i);
                    if (null == c || Number(c) != c) {
                        --i;
                        break;
                    }
                    if (i === str.length)
                        break;
                }
                p.id = Number(str.substring(start, i + 1));
            }
            // look up json data
            if (str.charAt(++i)) {
                const payload = tryParse(str.substr(i));
                if (Decoder.isPayloadValid(p.type, payload)) {
                    p.data = payload;
                }
                else {
                    throw new Error("invalid payload");
                }
            }
            debug("decoded %s as %j", str, p);
            return p;
        }
        static isPayloadValid(type, payload) {
            switch (type) {
                case PacketType.CONNECT:
                    return typeof payload === "object";
                case PacketType.DISCONNECT:
                    return payload === undefined;
                case PacketType.CONNECT_ERROR:
                    return typeof payload === "string" || typeof payload === "object";
                case PacketType.EVENT:
                case PacketType.BINARY_EVENT:
                    return Array.isArray(payload) && payload.length > 0;
                case PacketType.ACK:
                case PacketType.BINARY_ACK:
                    return Array.isArray(payload);
            }
        }
        /**
         * Deallocates a parser's resources
         */
        destroy() {
            if (this.reconstructor) {
                this.reconstructor.finishedReconstruction();
            }
        }
    }
    exports.Decoder = Decoder;
    function tryParse(str) {
        try {
            return JSON.parse(str);
        }
        catch (e) {
            return false;
        }
    }
    /**
     * A manager of a binary event's 'buffer sequence'. Should
     * be constructed whenever a packet of type BINARY_EVENT is
     * decoded.
     *
     * @param {Object} packet
     * @return {BinaryReconstructor} initialized reconstructor
     */
    class BinaryReconstructor {
        constructor(packet) {
            this.packet = packet;
            this.buffers = [];
            this.reconPack = packet;
        }
        /**
         * Method to be called when binary data received from connection
         * after a BINARY_EVENT packet.
         *
         * @param {Buffer | ArrayBuffer} binData - the raw binary data received
         * @return {null | Object} returns null if more binary data is expected or
         *   a reconstructed packet object if all buffers have been received.
         */
        takeBinaryData(binData) {
            this.buffers.push(binData);
            if (this.buffers.length === this.reconPack.attachments) {
                // done with buffer list
                const packet = binary.reconstructPacket(this.reconPack, this.buffers);
                this.finishedReconstruction();
                return packet;
            }
            return null;
        }
        /**
         * Cleans up binary packet reconstruction variables.
         */
        finishedReconstruction() {
            this.reconPack = null;
            this.buffers = [];
        }
    }
    });

    var on_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.on = void 0;
    function on(obj, ev, fn) {
        obj.on(ev, fn);
        return function subDestroy() {
            obj.off(ev, fn);
        };
    }
    exports.on = on;
    });

    var typedEvents = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StrictEventEmitter = void 0;

    /**
     * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type
     * parameters for mappings of event names to event data types, and strictly
     * types method calls to the `EventEmitter` according to these event maps.
     *
     * @typeParam ListenEvents - `EventsMap` of user-defined events that can be
     * listened to with `on` or `once`
     * @typeParam EmitEvents - `EventsMap` of user-defined events that can be
     * emitted with `emit`
     * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be
     * emitted by socket.io with `emitReserved`, and can be listened to with
     * `listen`.
     */
    class StrictEventEmitter extends componentEmitter {
        /**
         * Adds the `listener` function as an event listener for `ev`.
         *
         * @param ev Name of the event
         * @param listener Callback function
         */
        on(ev, listener) {
            super.on(ev, listener);
            return this;
        }
        /**
         * Adds a one-time `listener` function as an event listener for `ev`.
         *
         * @param ev Name of the event
         * @param listener Callback function
         */
        once(ev, listener) {
            super.once(ev, listener);
            return this;
        }
        /**
         * Emits an event.
         *
         * @param ev Name of the event
         * @param args Values to send to listeners of this event
         */
        emit(ev, ...args) {
            super.emit(ev, ...args);
            return this;
        }
        /**
         * Emits a reserved event.
         *
         * This method is `protected`, so that only a class extending
         * `StrictEventEmitter` can emit its own reserved events.
         *
         * @param ev Reserved event name
         * @param args Arguments to emit along with the event
         */
        emitReserved(ev, ...args) {
            super.emit(ev, ...args);
            return this;
        }
        /**
         * Returns the listeners listening to an event.
         *
         * @param event Event name
         * @returns Array of listeners subscribed to `event`
         */
        listeners(event) {
            return super.listeners(event);
        }
    }
    exports.StrictEventEmitter = StrictEventEmitter;
    });

    var socket$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Socket = void 0;



    const debug = browser("socket.io-client:socket");
    /**
     * Internal events.
     * These events can't be emitted by the user.
     */
    const RESERVED_EVENTS = Object.freeze({
        connect: 1,
        connect_error: 1,
        disconnect: 1,
        disconnecting: 1,
        // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
        newListener: 1,
        removeListener: 1,
    });
    class Socket extends typedEvents.StrictEventEmitter {
        /**
         * `Socket` constructor.
         *
         * @public
         */
        constructor(io, nsp, opts) {
            super();
            this.receiveBuffer = [];
            this.sendBuffer = [];
            this.ids = 0;
            this.acks = {};
            this.flags = {};
            this.io = io;
            this.nsp = nsp;
            this.ids = 0;
            this.acks = {};
            this.receiveBuffer = [];
            this.sendBuffer = [];
            this.connected = false;
            this.disconnected = true;
            this.flags = {};
            if (opts && opts.auth) {
                this.auth = opts.auth;
            }
            if (this.io._autoConnect)
                this.open();
        }
        /**
         * Subscribe to open, close and packet events
         *
         * @private
         */
        subEvents() {
            if (this.subs)
                return;
            const io = this.io;
            this.subs = [
                on_1.on(io, "open", this.onopen.bind(this)),
                on_1.on(io, "packet", this.onpacket.bind(this)),
                on_1.on(io, "error", this.onerror.bind(this)),
                on_1.on(io, "close", this.onclose.bind(this)),
            ];
        }
        /**
         * Whether the Socket will try to reconnect when its Manager connects or reconnects
         */
        get active() {
            return !!this.subs;
        }
        /**
         * "Opens" the socket.
         *
         * @public
         */
        connect() {
            if (this.connected)
                return this;
            this.subEvents();
            if (!this.io["_reconnecting"])
                this.io.open(); // ensure open
            if ("open" === this.io._readyState)
                this.onopen();
            return this;
        }
        /**
         * Alias for connect()
         */
        open() {
            return this.connect();
        }
        /**
         * Sends a `message` event.
         *
         * @return self
         * @public
         */
        send(...args) {
            args.unshift("message");
            this.emit.apply(this, args);
            return this;
        }
        /**
         * Override `emit`.
         * If the event is in `events`, it's emitted normally.
         *
         * @return self
         * @public
         */
        emit(ev, ...args) {
            if (RESERVED_EVENTS.hasOwnProperty(ev)) {
                throw new Error('"' + ev + '" is a reserved event name');
            }
            args.unshift(ev);
            const packet = {
                type: dist.PacketType.EVENT,
                data: args,
            };
            packet.options = {};
            packet.options.compress = this.flags.compress !== false;
            // event ack callback
            if ("function" === typeof args[args.length - 1]) {
                debug("emitting packet with ack id %d", this.ids);
                this.acks[this.ids] = args.pop();
                packet.id = this.ids++;
            }
            const isTransportWritable = this.io.engine &&
                this.io.engine.transport &&
                this.io.engine.transport.writable;
            const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
            if (discardPacket) {
                debug("discard packet as the transport is not currently writable");
            }
            else if (this.connected) {
                this.packet(packet);
            }
            else {
                this.sendBuffer.push(packet);
            }
            this.flags = {};
            return this;
        }
        /**
         * Sends a packet.
         *
         * @param packet
         * @private
         */
        packet(packet) {
            packet.nsp = this.nsp;
            this.io._packet(packet);
        }
        /**
         * Called upon engine `open`.
         *
         * @private
         */
        onopen() {
            debug("transport is open - connecting");
            if (typeof this.auth == "function") {
                this.auth((data) => {
                    this.packet({ type: dist.PacketType.CONNECT, data });
                });
            }
            else {
                this.packet({ type: dist.PacketType.CONNECT, data: this.auth });
            }
        }
        /**
         * Called upon engine or manager `error`.
         *
         * @param err
         * @private
         */
        onerror(err) {
            if (!this.connected) {
                this.emitReserved("connect_error", err);
            }
        }
        /**
         * Called upon engine `close`.
         *
         * @param reason
         * @private
         */
        onclose(reason) {
            debug("close (%s)", reason);
            this.connected = false;
            this.disconnected = true;
            delete this.id;
            this.emitReserved("disconnect", reason);
        }
        /**
         * Called with socket packet.
         *
         * @param packet
         * @private
         */
        onpacket(packet) {
            const sameNamespace = packet.nsp === this.nsp;
            if (!sameNamespace)
                return;
            switch (packet.type) {
                case dist.PacketType.CONNECT:
                    if (packet.data && packet.data.sid) {
                        const id = packet.data.sid;
                        this.onconnect(id);
                    }
                    else {
                        this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                    }
                    break;
                case dist.PacketType.EVENT:
                    this.onevent(packet);
                    break;
                case dist.PacketType.BINARY_EVENT:
                    this.onevent(packet);
                    break;
                case dist.PacketType.ACK:
                    this.onack(packet);
                    break;
                case dist.PacketType.BINARY_ACK:
                    this.onack(packet);
                    break;
                case dist.PacketType.DISCONNECT:
                    this.ondisconnect();
                    break;
                case dist.PacketType.CONNECT_ERROR:
                    const err = new Error(packet.data.message);
                    // @ts-ignore
                    err.data = packet.data.data;
                    this.emitReserved("connect_error", err);
                    break;
            }
        }
        /**
         * Called upon a server event.
         *
         * @param packet
         * @private
         */
        onevent(packet) {
            const args = packet.data || [];
            debug("emitting event %j", args);
            if (null != packet.id) {
                debug("attaching ack callback to event");
                args.push(this.ack(packet.id));
            }
            if (this.connected) {
                this.emitEvent(args);
            }
            else {
                this.receiveBuffer.push(Object.freeze(args));
            }
        }
        emitEvent(args) {
            if (this._anyListeners && this._anyListeners.length) {
                const listeners = this._anyListeners.slice();
                for (const listener of listeners) {
                    listener.apply(this, args);
                }
            }
            super.emit.apply(this, args);
        }
        /**
         * Produces an ack callback to emit with an event.
         *
         * @private
         */
        ack(id) {
            const self = this;
            let sent = false;
            return function (...args) {
                // prevent double callbacks
                if (sent)
                    return;
                sent = true;
                debug("sending ack %j", args);
                self.packet({
                    type: dist.PacketType.ACK,
                    id: id,
                    data: args,
                });
            };
        }
        /**
         * Called upon a server acknowlegement.
         *
         * @param packet
         * @private
         */
        onack(packet) {
            const ack = this.acks[packet.id];
            if ("function" === typeof ack) {
                debug("calling ack %s with %j", packet.id, packet.data);
                ack.apply(this, packet.data);
                delete this.acks[packet.id];
            }
            else {
                debug("bad ack %s", packet.id);
            }
        }
        /**
         * Called upon server connect.
         *
         * @private
         */
        onconnect(id) {
            debug("socket connected with id %s", id);
            this.id = id;
            this.connected = true;
            this.disconnected = false;
            this.emitBuffered();
            this.emitReserved("connect");
        }
        /**
         * Emit buffered events (received and emitted).
         *
         * @private
         */
        emitBuffered() {
            this.receiveBuffer.forEach((args) => this.emitEvent(args));
            this.receiveBuffer = [];
            this.sendBuffer.forEach((packet) => this.packet(packet));
            this.sendBuffer = [];
        }
        /**
         * Called upon server disconnect.
         *
         * @private
         */
        ondisconnect() {
            debug("server disconnect (%s)", this.nsp);
            this.destroy();
            this.onclose("io server disconnect");
        }
        /**
         * Called upon forced client/server side disconnections,
         * this method ensures the manager stops tracking us and
         * that reconnections don't get triggered for this.
         *
         * @private
         */
        destroy() {
            if (this.subs) {
                // clean subscriptions to avoid reconnections
                this.subs.forEach((subDestroy) => subDestroy());
                this.subs = undefined;
            }
            this.io["_destroy"](this);
        }
        /**
         * Disconnects the socket manually.
         *
         * @return self
         * @public
         */
        disconnect() {
            if (this.connected) {
                debug("performing disconnect (%s)", this.nsp);
                this.packet({ type: dist.PacketType.DISCONNECT });
            }
            // remove socket from pool
            this.destroy();
            if (this.connected) {
                // fire events
                this.onclose("io client disconnect");
            }
            return this;
        }
        /**
         * Alias for disconnect()
         *
         * @return self
         * @public
         */
        close() {
            return this.disconnect();
        }
        /**
         * Sets the compress flag.
         *
         * @param compress - if `true`, compresses the sending data
         * @return self
         * @public
         */
        compress(compress) {
            this.flags.compress = compress;
            return this;
        }
        /**
         * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
         * ready to send messages.
         *
         * @returns self
         * @public
         */
        get volatile() {
            this.flags.volatile = true;
            return this;
        }
        /**
         * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
         * callback.
         *
         * @param listener
         * @public
         */
        onAny(listener) {
            this._anyListeners = this._anyListeners || [];
            this._anyListeners.push(listener);
            return this;
        }
        /**
         * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
         * callback. The listener is added to the beginning of the listeners array.
         *
         * @param listener
         * @public
         */
        prependAny(listener) {
            this._anyListeners = this._anyListeners || [];
            this._anyListeners.unshift(listener);
            return this;
        }
        /**
         * Removes the listener that will be fired when any event is emitted.
         *
         * @param listener
         * @public
         */
        offAny(listener) {
            if (!this._anyListeners) {
                return this;
            }
            if (listener) {
                const listeners = this._anyListeners;
                for (let i = 0; i < listeners.length; i++) {
                    if (listener === listeners[i]) {
                        listeners.splice(i, 1);
                        return this;
                    }
                }
            }
            else {
                this._anyListeners = [];
            }
            return this;
        }
        /**
         * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
         * e.g. to remove listeners.
         *
         * @public
         */
        listenersAny() {
            return this._anyListeners || [];
        }
    }
    exports.Socket = Socket;
    });

    /**
     * Expose `Backoff`.
     */

    var backo2 = Backoff;

    /**
     * Initialize backoff timer with `opts`.
     *
     * - `min` initial timeout in milliseconds [100]
     * - `max` max timeout [10000]
     * - `jitter` [0]
     * - `factor` [2]
     *
     * @param {Object} opts
     * @api public
     */

    function Backoff(opts) {
      opts = opts || {};
      this.ms = opts.min || 100;
      this.max = opts.max || 10000;
      this.factor = opts.factor || 2;
      this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
      this.attempts = 0;
    }

    /**
     * Return the backoff duration.
     *
     * @return {Number}
     * @api public
     */

    Backoff.prototype.duration = function(){
      var ms = this.ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var rand =  Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
      }
      return Math.min(ms, this.max) | 0;
    };

    /**
     * Reset the number of attempts.
     *
     * @api public
     */

    Backoff.prototype.reset = function(){
      this.attempts = 0;
    };

    /**
     * Set the minimum duration
     *
     * @api public
     */

    Backoff.prototype.setMin = function(min){
      this.ms = min;
    };

    /**
     * Set the maximum duration
     *
     * @api public
     */

    Backoff.prototype.setMax = function(max){
      this.max = max;
    };

    /**
     * Set the jitter
     *
     * @api public
     */

    Backoff.prototype.setJitter = function(jitter){
      this.jitter = jitter;
    };

    var manager = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Manager = void 0;






    const debug = browser("socket.io-client:manager");
    class Manager extends typedEvents.StrictEventEmitter {
        constructor(uri, opts) {
            super();
            this.nsps = {};
            this.subs = [];
            if (uri && "object" === typeof uri) {
                opts = uri;
                uri = undefined;
            }
            opts = opts || {};
            opts.path = opts.path || "/socket.io";
            this.opts = opts;
            this.reconnection(opts.reconnection !== false);
            this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
            this.reconnectionDelay(opts.reconnectionDelay || 1000);
            this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
            this.randomizationFactor(opts.randomizationFactor || 0.5);
            this.backoff = new backo2({
                min: this.reconnectionDelay(),
                max: this.reconnectionDelayMax(),
                jitter: this.randomizationFactor(),
            });
            this.timeout(null == opts.timeout ? 20000 : opts.timeout);
            this._readyState = "closed";
            this.uri = uri;
            const _parser = opts.parser || dist;
            this.encoder = new _parser.Encoder();
            this.decoder = new _parser.Decoder();
            this._autoConnect = opts.autoConnect !== false;
            if (this._autoConnect)
                this.open();
        }
        reconnection(v) {
            if (!arguments.length)
                return this._reconnection;
            this._reconnection = !!v;
            return this;
        }
        reconnectionAttempts(v) {
            if (v === undefined)
                return this._reconnectionAttempts;
            this._reconnectionAttempts = v;
            return this;
        }
        reconnectionDelay(v) {
            var _a;
            if (v === undefined)
                return this._reconnectionDelay;
            this._reconnectionDelay = v;
            (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
            return this;
        }
        randomizationFactor(v) {
            var _a;
            if (v === undefined)
                return this._randomizationFactor;
            this._randomizationFactor = v;
            (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
            return this;
        }
        reconnectionDelayMax(v) {
            var _a;
            if (v === undefined)
                return this._reconnectionDelayMax;
            this._reconnectionDelayMax = v;
            (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
            return this;
        }
        timeout(v) {
            if (!arguments.length)
                return this._timeout;
            this._timeout = v;
            return this;
        }
        /**
         * Starts trying to reconnect if reconnection is enabled and we have not
         * started reconnecting yet
         *
         * @private
         */
        maybeReconnectOnOpen() {
            // Only try to reconnect if it's the first time we're connecting
            if (!this._reconnecting &&
                this._reconnection &&
                this.backoff.attempts === 0) {
                // keeps reconnection from firing twice for the same reconnection loop
                this.reconnect();
            }
        }
        /**
         * Sets the current transport `socket`.
         *
         * @param {Function} fn - optional, callback
         * @return self
         * @public
         */
        open(fn) {
            debug("readyState %s", this._readyState);
            if (~this._readyState.indexOf("open"))
                return this;
            debug("opening %s", this.uri);
            this.engine = lib(this.uri, this.opts);
            const socket = this.engine;
            const self = this;
            this._readyState = "opening";
            this.skipReconnect = false;
            // emit `open`
            const openSubDestroy = on_1.on(socket, "open", function () {
                self.onopen();
                fn && fn();
            });
            // emit `error`
            const errorSub = on_1.on(socket, "error", (err) => {
                debug("error");
                self.cleanup();
                self._readyState = "closed";
                this.emitReserved("error", err);
                if (fn) {
                    fn(err);
                }
                else {
                    // Only do this if there is no fn to handle the error
                    self.maybeReconnectOnOpen();
                }
            });
            if (false !== this._timeout) {
                const timeout = this._timeout;
                debug("connect attempt will timeout after %d", timeout);
                if (timeout === 0) {
                    openSubDestroy(); // prevents a race condition with the 'open' event
                }
                // set timer
                const timer = setTimeout(() => {
                    debug("connect attempt timed out after %d", timeout);
                    openSubDestroy();
                    socket.close();
                    socket.emit("error", new Error("timeout"));
                }, timeout);
                if (this.opts.autoUnref) {
                    timer.unref();
                }
                this.subs.push(function subDestroy() {
                    clearTimeout(timer);
                });
            }
            this.subs.push(openSubDestroy);
            this.subs.push(errorSub);
            return this;
        }
        /**
         * Alias for open()
         *
         * @return self
         * @public
         */
        connect(fn) {
            return this.open(fn);
        }
        /**
         * Called upon transport open.
         *
         * @private
         */
        onopen() {
            debug("open");
            // clear old subs
            this.cleanup();
            // mark as open
            this._readyState = "open";
            this.emitReserved("open");
            // add new subs
            const socket = this.engine;
            this.subs.push(on_1.on(socket, "ping", this.onping.bind(this)), on_1.on(socket, "data", this.ondata.bind(this)), on_1.on(socket, "error", this.onerror.bind(this)), on_1.on(socket, "close", this.onclose.bind(this)), on_1.on(this.decoder, "decoded", this.ondecoded.bind(this)));
        }
        /**
         * Called upon a ping.
         *
         * @private
         */
        onping() {
            this.emitReserved("ping");
        }
        /**
         * Called with data.
         *
         * @private
         */
        ondata(data) {
            this.decoder.add(data);
        }
        /**
         * Called when parser fully decodes a packet.
         *
         * @private
         */
        ondecoded(packet) {
            this.emitReserved("packet", packet);
        }
        /**
         * Called upon socket error.
         *
         * @private
         */
        onerror(err) {
            debug("error", err);
            this.emitReserved("error", err);
        }
        /**
         * Creates a new socket for the given `nsp`.
         *
         * @return {Socket}
         * @public
         */
        socket(nsp, opts) {
            let socket = this.nsps[nsp];
            if (!socket) {
                socket = new socket$1.Socket(this, nsp, opts);
                this.nsps[nsp] = socket;
            }
            return socket;
        }
        /**
         * Called upon a socket close.
         *
         * @param socket
         * @private
         */
        _destroy(socket) {
            const nsps = Object.keys(this.nsps);
            for (const nsp of nsps) {
                const socket = this.nsps[nsp];
                if (socket.active) {
                    debug("socket %s is still active, skipping close", nsp);
                    return;
                }
            }
            this._close();
        }
        /**
         * Writes a packet.
         *
         * @param packet
         * @private
         */
        _packet(packet) {
            debug("writing packet %j", packet);
            const encodedPackets = this.encoder.encode(packet);
            for (let i = 0; i < encodedPackets.length; i++) {
                this.engine.write(encodedPackets[i], packet.options);
            }
        }
        /**
         * Clean up transport subscriptions and packet buffer.
         *
         * @private
         */
        cleanup() {
            debug("cleanup");
            this.subs.forEach((subDestroy) => subDestroy());
            this.subs.length = 0;
            this.decoder.destroy();
        }
        /**
         * Close the current socket.
         *
         * @private
         */
        _close() {
            debug("disconnect");
            this.skipReconnect = true;
            this._reconnecting = false;
            if ("opening" === this._readyState) {
                // `onclose` will not fire because
                // an open event never happened
                this.cleanup();
            }
            this.backoff.reset();
            this._readyState = "closed";
            if (this.engine)
                this.engine.close();
        }
        /**
         * Alias for close()
         *
         * @private
         */
        disconnect() {
            return this._close();
        }
        /**
         * Called upon engine close.
         *
         * @private
         */
        onclose(reason) {
            debug("onclose");
            this.cleanup();
            this.backoff.reset();
            this._readyState = "closed";
            this.emitReserved("close", reason);
            if (this._reconnection && !this.skipReconnect) {
                this.reconnect();
            }
        }
        /**
         * Attempt a reconnection.
         *
         * @private
         */
        reconnect() {
            if (this._reconnecting || this.skipReconnect)
                return this;
            const self = this;
            if (this.backoff.attempts >= this._reconnectionAttempts) {
                debug("reconnect failed");
                this.backoff.reset();
                this.emitReserved("reconnect_failed");
                this._reconnecting = false;
            }
            else {
                const delay = this.backoff.duration();
                debug("will wait %dms before reconnect attempt", delay);
                this._reconnecting = true;
                const timer = setTimeout(() => {
                    if (self.skipReconnect)
                        return;
                    debug("attempting reconnect");
                    this.emitReserved("reconnect_attempt", self.backoff.attempts);
                    // check again for the case socket closed in above events
                    if (self.skipReconnect)
                        return;
                    self.open((err) => {
                        if (err) {
                            debug("reconnect attempt error");
                            self._reconnecting = false;
                            self.reconnect();
                            this.emitReserved("reconnect_error", err);
                        }
                        else {
                            debug("reconnect success");
                            self.onreconnect();
                        }
                    });
                }, delay);
                if (this.opts.autoUnref) {
                    timer.unref();
                }
                this.subs.push(function subDestroy() {
                    clearTimeout(timer);
                });
            }
        }
        /**
         * Called upon successful reconnect.
         *
         * @private
         */
        onreconnect() {
            const attempt = this.backoff.attempts;
            this._reconnecting = false;
            this.backoff.reset();
            this.emitReserved("reconnect", attempt);
        }
    }
    exports.Manager = Manager;
    });

    var build$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.io = exports.Socket = exports.Manager = exports.protocol = void 0;


    const debug = browser("socket.io-client");
    /**
     * Module exports.
     */
    module.exports = exports = lookup;
    /**
     * Managers cache.
     */
    const cache = (exports.managers = {});
    function lookup(uri, opts) {
        if (typeof uri === "object") {
            opts = uri;
            uri = undefined;
        }
        opts = opts || {};
        const parsed = url_1.url(uri, opts.path || "/socket.io");
        const source = parsed.source;
        const id = parsed.id;
        const path = parsed.path;
        const sameNamespace = cache[id] && path in cache[id]["nsps"];
        const newConnection = opts.forceNew ||
            opts["force new connection"] ||
            false === opts.multiplex ||
            sameNamespace;
        let io;
        if (newConnection) {
            debug("ignoring socket cache for %s", source);
            io = new manager.Manager(source, opts);
        }
        else {
            if (!cache[id]) {
                debug("new io instance for %s", source);
                cache[id] = new manager.Manager(source, opts);
            }
            io = cache[id];
        }
        if (parsed.query && !opts.query) {
            opts.query = parsed.queryKey;
        }
        return io.socket(parsed.path, opts);
    }
    exports.io = lookup;
    /**
     * Protocol version.
     *
     * @public
     */

    Object.defineProperty(exports, "protocol", { enumerable: true, get: function () { return dist.protocol; } });
    /**
     * `connect`.
     *
     * @param {String} uri
     * @public
     */
    exports.connect = lookup;
    /**
     * Expose constructors for standalone build.
     *
     * @public
     */
    var manager_2 = manager;
    Object.defineProperty(exports, "Manager", { enumerable: true, get: function () { return manager_2.Manager; } });

    Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket$1.Socket; } });
    exports.default = lookup;
    });

    var io = /*@__PURE__*/getDefaultExportFromCjs(build$1);

    io.Manager;
    io.Socket;

    var svelte = /*#__PURE__*/Object.freeze({
        __proto__: null,
        SvelteComponent: SvelteComponentDev,
        SvelteComponentTyped: SvelteComponentTyped,
        afterUpdate: afterUpdate,
        beforeUpdate: beforeUpdate,
        createEventDispatcher: createEventDispatcher,
        getContext: getContext,
        hasContext: hasContext,
        onDestroy: onDestroy,
        onMount: onMount,
        setContext: setContext,
        tick: tick$1
    });

    const fs = require('fs');
    const DefaultPath = __dirname + "/settings.json";

    class NeuDB {
        constructor(data = {}, autoSave = true, path = DefaultPath) {
            this.path = path;
            this.autoSave = autoSave;
            if (!fs.existsSync(this.path)) {
                this.saveData = data;
                this.save();
            } else {
                this.load();
                //fix potential missing fields
                this.saveData = MakeValid(this.saveData, data);
                this.save();
            }
            console.log(this.path);
        }
        //get data() { return this.saveData }
        set data(data) {
            this.saveData = data;

            if (this.autoSave)
                this.save();
        }
        set filename(filename) {
            this.path = __dirname + "/" + filename;
        }
        set(path, value) {
            if (path.trim() == "") return new Error("Invalid path");
            this.saveData[path] = value;

            if (this.autoSave)
                this.save();
        }
        get(path) {
            if (path == undefined || path == "")
                return this.saveData;
            else if (this.saveData[path])
                return this.saveData[path]
            else
                return new Error("Invalid path")
        }
        push(path, value, force = false) {
            if (Array.isArray(this.saveData[path])) {
                if (!this.saveData[path].includes(value) || force) {
                    this.saveData[path].push(value);

                    if (this.autoSave)
                        this.save();
                }
            }
            else {
                console.log("push", path, this.saveData[path]);
                throw new Error("not an array")
            }
        }
        save() {
            SaveJson(this.saveData, this.path);
        }
        load() {
            this.saveData = LoadJson(this.path);
        }
    }

    function MakeValid(ob, compare) {
        let newob = {};
        for (let prop in compare) newob[prop] = (!(ob[prop] == null || ob[prop] == undefined)) ? ob[prop] : compare[prop];
        return newob;
    }

    function SaveJson(json, location) {
        let data = JSON.stringify(json, null, 4);
        fs.writeFileSync(location, data);
    }

    function LoadJson(location) {
        let raw = fs.readFileSync(location);
        return JSON.parse(raw);
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop$2) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop$2) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop$2;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    const messages = writable([]);
    const history = writable([]);
    const connected = writable(false);
    const receivedCounter = writable(0);
    let isVolatile = writable(false);

    let connecting = writable(false);
    let socket;

    let data = writable({});


    function changeConnected(val = false) {
        connected.update(o => {
            return val;
        });
    }

    function SocketErrors(cb) {
        const errorFunction = (evt) => {
            if (typeof cb === 'function')
                cb(evt);
        };

        //socket.on("error", errorFunction);
        socket.on("connect_failed", errorFunction);
        socket.on("connect_error", errorFunction);
    }

    function ChangeCounter(mod) {
        receivedCounter.update(o => {
            return o + mod;
        });
    }
    const setSocket = (soc) => { socket = soc; };

    /* src\components\Nav.svelte generated by Svelte v3.38.2 */

    const file$F = "src\\components\\Nav.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	return child_ctx;
    }

    // (62:16) {#each $history as item}
    function create_each_block$b(ctx) {
    	let option;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			option.__value = option_value_value = /*item*/ ctx[15];
    			option.value = option.__value;
    			add_location(option, file$F, 62, 20, 1864);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$history*/ 16 && option_value_value !== (option_value_value = /*item*/ ctx[15])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(62:16) {#each $history as item}",
    		ctx
    	});

    	return block;
    }

    // (79:12) {:else}
    function create_else_block$c(ctx) {
    	let button;
    	let img;
    	let img_src_value;
    	let t0_value = (/*$connecting*/ ctx[3] ? "Cancel" : "Connect") + "";
    	let t0;
    	let t1;
    	let div;
    	let div_class_value;
    	let button_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			img = element("img");
    			t0 = text(t0_value);
    			t1 = space();
    			div = element("div");

    			if (img.src !== (img_src_value = /*$connecting*/ ctx[3]
    			? "icons/unlink.png"
    			: "icons/link.png")) attr_dev(img, "src", img_src_value);

    			attr_dev(img, "alt", "connect");
    			add_location(img, file$F, 83, 21, 2573);
    			attr_dev(div, "class", div_class_value = "ring " + (/*$connecting*/ ctx[3] ? "loading-ring" : ""));
    			add_location(div, file$F, 89, 20, 2839);
    			attr_dev(button, "class", button_class_value = "button " + (/*$connecting*/ ctx[3] ? "is-warning" : "is-primary"));
    			attr_dev(button, "title", "connect");
    			add_location(button, file$F, 79, 16, 2386);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, img);
    			append_dev(button, t0);
    			append_dev(button, t1);
    			append_dev(button, div);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*connect*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$connecting*/ 8 && img.src !== (img_src_value = /*$connecting*/ ctx[3]
    			? "icons/unlink.png"
    			: "icons/link.png")) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*$connecting*/ 8 && t0_value !== (t0_value = (/*$connecting*/ ctx[3] ? "Cancel" : "Connect") + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*$connecting*/ 8 && div_class_value !== (div_class_value = "ring " + (/*$connecting*/ ctx[3] ? "loading-ring" : ""))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*$connecting*/ 8 && button_class_value !== (button_class_value = "button " + (/*$connecting*/ ctx[3] ? "is-warning" : "is-primary"))) {
    				attr_dev(button, "class", button_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$c.name,
    		type: "else",
    		source: "(79:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (69:12) {#if $connected}
    function create_if_block_1$d(ctx) {
    	let button;
    	let img;
    	let img_src_value;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			img = element("img");
    			t = text("Disconnect");
    			if (img.src !== (img_src_value = "icons/unlink.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "disconnect");
    			add_location(img, file$F, 73, 21, 2192);
    			attr_dev(button, "class", "button is-danger");
    			attr_dev(button, "title", "disconnect");
    			add_location(button, file$F, 69, 16, 2033);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, img);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*disconnect*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(69:12) {#if $connected}",
    		ctx
    	});

    	return block;
    }

    // (95:12) {#if $connected}
    function create_if_block$k(ctx) {
    	let button;
    	let img;
    	let img_src_value;
    	let t0;
    	let br;
    	let t1;
    	let label;
    	let t3;
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			img = element("img");
    			t0 = text("Send");
    			br = element("br");
    			t1 = space();
    			label = element("label");
    			label.textContent = "Volatile";
    			t3 = space();
    			input = element("input");
    			if (img.src !== (img_src_value = "icons/Save32.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "send");
    			add_location(img, file$F, 100, 21, 3217);
    			attr_dev(button, "class", "button is-primary");
    			attr_dev(button, "id", "SendBtn");
    			attr_dev(button, "title", "send");
    			add_location(button, file$F, 95, 16, 3035);
    			add_location(br, file$F, 101, 17, 3289);
    			attr_dev(label, "for", "volatileCheck");
    			add_location(label, file$F, 102, 16, 3313);
    			attr_dev(input, "id", "volatileCheck");
    			attr_dev(input, "type", "checkbox");
    			add_location(input, file$F, 103, 16, 3374);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, img);
    			append_dev(button, t0);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, label, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, input, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*send*/ ctx[7], false, false, false),
    					listen_dev(input, "click", /*toggleVolatile*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(label);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(95:12) {#if $connected}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let div5;
    	let div4;
    	let div0;
    	let label0;
    	let t1;
    	let input0;
    	let input0_disabled_value;
    	let input0_class_value;
    	let t2;
    	let div1;
    	let label1;
    	let t4;
    	let input1;
    	let t5;
    	let datalist;
    	let t6;
    	let div2;
    	let t7;
    	let div3;
    	let mounted;
    	let dispose;
    	let each_value = /*$history*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	function select_block_type(ctx, dirty) {
    		if (/*$connected*/ ctx[2]) return create_if_block_1$d;
    		return create_else_block$c;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*$connected*/ ctx[2] && create_if_block$k(ctx);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			div0 = element("div");
    			label0 = element("label");
    			label0.textContent = "Connect URI";
    			t1 = space();
    			input0 = element("input");
    			t2 = space();
    			div1 = element("div");
    			label1 = element("label");
    			label1.textContent = "Event";
    			t4 = space();
    			input1 = element("input");
    			t5 = space();
    			datalist = element("datalist");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t6 = space();
    			div2 = element("div");
    			if_block0.c();
    			t7 = space();
    			div3 = element("div");
    			if (if_block1) if_block1.c();
    			attr_dev(label0, "for", "connect_URI");
    			add_location(label0, file$F, 42, 12, 1118);
    			input0.disabled = input0_disabled_value = /*$connected*/ ctx[2] || /*$connecting*/ ctx[3];
    			attr_dev(input0, "id", "connect_URI");
    			attr_dev(input0, "type", "text");

    			attr_dev(input0, "class", input0_class_value = "input " + (/*$connected*/ ctx[2] === true
    			? "is-success"
    			: "is-link"));

    			attr_dev(input0, "placeholder", "url");
    			add_location(input0, file$F, 43, 12, 1176);
    			attr_dev(div0, "class", "column");
    			add_location(div0, file$F, 41, 8, 1084);
    			attr_dev(label1, "for", "eventName");
    			add_location(label1, file$F, 53, 12, 1528);
    			attr_dev(input1, "id", "eventName");
    			attr_dev(input1, "class", "input is-info");
    			attr_dev(input1, "list", "events");
    			add_location(input1, file$F, 54, 12, 1578);
    			attr_dev(datalist, "id", "events");
    			add_location(datalist, file$F, 60, 12, 1757);
    			attr_dev(div1, "class", "column");
    			add_location(div1, file$F, 52, 8, 1494);
    			attr_dev(div2, "class", "column");
    			add_location(div2, file$F, 67, 8, 1965);
    			attr_dev(div3, "class", "column");
    			add_location(div3, file$F, 93, 8, 2967);
    			attr_dev(div4, "class", "columns");
    			add_location(div4, file$F, 40, 4, 1053);
    			attr_dev(div5, "class", "topMenu");
    			add_location(div5, file$F, 39, 0, 1026);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div0);
    			append_dev(div0, label0);
    			append_dev(div0, t1);
    			append_dev(div0, input0);
    			set_input_value(input0, /*connUri*/ ctx[0]);
    			append_dev(div4, t2);
    			append_dev(div4, div1);
    			append_dev(div1, label1);
    			append_dev(div1, t4);
    			append_dev(div1, input1);
    			set_input_value(input1, /*eventValue*/ ctx[1]);
    			append_dev(div1, t5);
    			append_dev(div1, datalist);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(datalist, null);
    			}

    			append_dev(div4, t6);
    			append_dev(div4, div2);
    			if_block0.m(div2, null);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			if (if_block1) if_block1.m(div3, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[10]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[11]),
    					listen_dev(datalist, "blur", /*addHistory*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$connected, $connecting*/ 12 && input0_disabled_value !== (input0_disabled_value = /*$connected*/ ctx[2] || /*$connecting*/ ctx[3])) {
    				prop_dev(input0, "disabled", input0_disabled_value);
    			}

    			if (dirty & /*$connected*/ 4 && input0_class_value !== (input0_class_value = "input " + (/*$connected*/ ctx[2] === true
    			? "is-success"
    			: "is-link"))) {
    				attr_dev(input0, "class", input0_class_value);
    			}

    			if (dirty & /*connUri*/ 1 && input0.value !== /*connUri*/ ctx[0]) {
    				set_input_value(input0, /*connUri*/ ctx[0]);
    			}

    			if (dirty & /*eventValue*/ 2 && input1.value !== /*eventValue*/ ctx[1]) {
    				set_input_value(input1, /*eventValue*/ ctx[1]);
    			}

    			if (dirty & /*$history*/ 16) {
    				each_value = /*$history*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(datalist, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div2, null);
    				}
    			}

    			if (/*$connected*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$k(ctx);
    					if_block1.c();
    					if_block1.m(div3, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_each(each_blocks, detaching);
    			if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let $data;
    	let $isVolatile;
    	let $connected;
    	let $connecting;
    	let $history;
    	validate_store(data, "data");
    	component_subscribe($$self, data, $$value => $$invalidate(12, $data = $$value));
    	validate_store(isVolatile, "isVolatile");
    	component_subscribe($$self, isVolatile, $$value => $$invalidate(13, $isVolatile = $$value));
    	validate_store(connected, "connected");
    	component_subscribe($$self, connected, $$value => $$invalidate(2, $connected = $$value));
    	validate_store(connecting, "connecting");
    	component_subscribe($$self, connecting, $$value => $$invalidate(3, $connecting = $$value));
    	validate_store(history, "history");
    	component_subscribe($$self, history, $$value => $$invalidate(4, $history = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Nav", slots, []);
    	const dispatch = createEventDispatcher();
    	let connUri = $data.currentConnection || "http://localhost:3000";
    	let eventValue = $data.selectedEvent || "message";

    	const connect = () => {
    		dispatch("connect", { uri: connUri });
    	};

    	const disconnect = () => {
    		dispatch("disconnect", { uri: connUri });
    	};

    	const send = () => {
    		addHistory();
    		dispatch("send", { event: eventValue });
    	};

    	const addHistory = () => {
    		history.update(items => {
    			if (!items.includes(eventValue)) {
    				return [eventValue, ...items];
    			} else return [...items];
    		});
    	};

    	const toggleVolatile = () => {
    		set_store_value(isVolatile, $isVolatile = !$isVolatile, $isVolatile);
    	};

    	addHistory();
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Nav> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		connUri = this.value;
    		$$invalidate(0, connUri);
    	}

    	function input1_input_handler() {
    		eventValue = this.value;
    		$$invalidate(1, eventValue);
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		connected,
    		connecting,
    		changeConnected,
    		history,
    		isVolatile,
    		data,
    		dispatch,
    		connUri,
    		eventValue,
    		connect,
    		disconnect,
    		send,
    		addHistory,
    		toggleVolatile,
    		$data,
    		$isVolatile,
    		$connected,
    		$connecting,
    		$history
    	});

    	$$self.$inject_state = $$props => {
    		if ("connUri" in $$props) $$invalidate(0, connUri = $$props.connUri);
    		if ("eventValue" in $$props) $$invalidate(1, eventValue = $$props.eventValue);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		connUri,
    		eventValue,
    		$connected,
    		$connecting,
    		$history,
    		connect,
    		disconnect,
    		send,
    		addHistory,
    		toggleVolatile,
    		input0_input_handler,
    		input1_input_handler
    	];
    }

    class Nav extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$I, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Nav",
    			options,
    			id: create_fragment$I.name
    		});
    	}
    }

    /*!
     * Font Awesome Free 5.15.3 by @fontawesome - https://fontawesome.com
     * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
     */
    var faAngleDown = {
      prefix: 'fas',
      iconName: 'angle-down',
      icon: [320, 512, [], "f107", "M143 352.3L7 216.3c-9.4-9.4-9.4-24.6 0-33.9l22.6-22.6c9.4-9.4 24.6-9.4 33.9 0l96.4 96.4 96.4-96.4c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9l-136 136c-9.2 9.4-24.4 9.4-33.8 0z"]
    };
    var faAngleRight = {
      prefix: 'fas',
      iconName: 'angle-right',
      icon: [256, 512, [], "f105", "M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34z"]
    };
    var faArrowDown = {
      prefix: 'fas',
      iconName: 'arrow-down',
      icon: [448, 512, [], "f063", "M413.1 222.5l22.2 22.2c9.4 9.4 9.4 24.6 0 33.9L241 473c-9.4 9.4-24.6 9.4-33.9 0L12.7 278.6c-9.4-9.4-9.4-24.6 0-33.9l22.2-22.2c9.5-9.5 25-9.3 34.3.4L184 343.4V56c0-13.3 10.7-24 24-24h32c13.3 0 24 10.7 24 24v287.4l114.8-120.5c9.3-9.8 24.8-10 34.3-.4z"]
    };
    var faCaretDown = {
      prefix: 'fas',
      iconName: 'caret-down',
      icon: [320, 512, [], "f0d7", "M31.3 192h257.3c17.8 0 26.7 21.5 14.1 34.1L174.1 354.8c-7.8 7.8-20.5 7.8-28.3 0L17.2 226.1C4.6 213.5 13.5 192 31.3 192z"]
    };
    var faCaretRight = {
      prefix: 'fas',
      iconName: 'caret-right',
      icon: [192, 512, [], "f0da", "M0 384.662V127.338c0-17.818 21.543-26.741 34.142-14.142l128.662 128.662c7.81 7.81 7.81 20.474 0 28.284L34.142 398.804C21.543 411.404 0 402.48 0 384.662z"]
    };
    var faCaretSquareDown = {
      prefix: 'fas',
      iconName: 'caret-square-down',
      icon: [448, 512, [], "f150", "M448 80v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V80c0-26.5 21.5-48 48-48h352c26.5 0 48 21.5 48 48zM92.5 220.5l123 123c4.7 4.7 12.3 4.7 17 0l123-123c7.6-7.6 2.2-20.5-8.5-20.5H101c-10.7 0-16.1 12.9-8.5 20.5z"]
    };
    var faCaretSquareUp = {
      prefix: 'fas',
      iconName: 'caret-square-up',
      icon: [448, 512, [], "f151", "M0 432V80c0-26.51 21.49-48 48-48h352c26.51 0 48 21.49 48 48v352c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48zm355.515-140.485l-123.03-123.03c-4.686-4.686-12.284-4.686-16.971 0L92.485 291.515c-7.56 7.56-2.206 20.485 8.485 20.485h246.059c10.691 0 16.045-12.926 8.486-20.485z"]
    };
    var faCheck = {
      prefix: 'fas',
      iconName: 'check',
      icon: [512, 512, [], "f00c", "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"]
    };
    var faChevronDown = {
      prefix: 'fas',
      iconName: 'chevron-down',
      icon: [448, 512, [], "f078", "M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"]
    };
    var faChevronUp = {
      prefix: 'fas',
      iconName: 'chevron-up',
      icon: [448, 512, [], "f077", "M240.971 130.524l194.343 194.343c9.373 9.373 9.373 24.569 0 33.941l-22.667 22.667c-9.357 9.357-24.522 9.375-33.901.04L224 227.495 69.255 381.516c-9.379 9.335-24.544 9.317-33.901-.04l-22.667-22.667c-9.373-9.373-9.373-24.569 0-33.941L207.03 130.525c9.372-9.373 24.568-9.373 33.941-.001z"]
    };
    var faCircleNotch = {
      prefix: 'fas',
      iconName: 'circle-notch',
      icon: [512, 512, [], "f1ce", "M288 39.056v16.659c0 10.804 7.281 20.159 17.686 23.066C383.204 100.434 440 171.518 440 256c0 101.689-82.295 184-184 184-101.689 0-184-82.295-184-184 0-84.47 56.786-155.564 134.312-177.219C216.719 75.874 224 66.517 224 55.712V39.064c0-15.709-14.834-27.153-30.046-23.234C86.603 43.482 7.394 141.206 8.003 257.332c.72 137.052 111.477 246.956 248.531 246.667C393.255 503.711 504 392.788 504 256c0-115.633-79.14-212.779-186.211-240.236C302.678 11.889 288 23.456 288 39.056z"]
    };
    var faClone = {
      prefix: 'fas',
      iconName: 'clone',
      icon: [512, 512, [], "f24d", "M464 0c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48H176c-26.51 0-48-21.49-48-48V48c0-26.51 21.49-48 48-48h288M176 416c-44.112 0-80-35.888-80-80V128H48c-26.51 0-48 21.49-48 48v288c0 26.51 21.49 48 48 48h288c26.51 0 48-21.49 48-48v-48H176z"]
    };
    var faCode = {
      prefix: 'fas',
      iconName: 'code',
      icon: [640, 512, [], "f121", "M278.9 511.5l-61-17.7c-6.4-1.8-10-8.5-8.2-14.9L346.2 8.7c1.8-6.4 8.5-10 14.9-8.2l61 17.7c6.4 1.8 10 8.5 8.2 14.9L293.8 503.3c-1.9 6.4-8.5 10.1-14.9 8.2zm-114-112.2l43.5-46.4c4.6-4.9 4.3-12.7-.8-17.2L117 256l90.6-79.7c5.1-4.5 5.5-12.3.8-17.2l-43.5-46.4c-4.5-4.8-12.1-5.1-17-.5L3.8 247.2c-5.1 4.7-5.1 12.8 0 17.5l144.1 135.1c4.9 4.6 12.5 4.4 17-.5zm327.2.6l144.1-135.1c5.1-4.7 5.1-12.8 0-17.5L492.1 112.1c-4.8-4.5-12.4-4.3-17 .5L431.6 159c-4.6 4.9-4.3 12.7.8 17.2L523 256l-90.6 79.7c-5.1 4.5-5.5 12.3-.8 17.2l43.5 46.4c4.5 4.9 12.1 5.1 17 .6z"]
    };
    var faCopy = {
      prefix: 'fas',
      iconName: 'copy',
      icon: [448, 512, [], "f0c5", "M320 448v40c0 13.255-10.745 24-24 24H24c-13.255 0-24-10.745-24-24V120c0-13.255 10.745-24 24-24h72v296c0 30.879 25.121 56 56 56h168zm0-344V0H152c-13.255 0-24 10.745-24 24v368c0 13.255 10.745 24 24 24h272c13.255 0 24-10.745 24-24V128H344c-13.2 0-24-10.8-24-24zm120.971-31.029L375.029 7.029A24 24 0 0 0 358.059 0H352v96h96v-6.059a24 24 0 0 0-7.029-16.97z"]
    };
    var faCropAlt = {
      prefix: 'fas',
      iconName: 'crop-alt',
      icon: [512, 512, [], "f565", "M488 352h-40V96c0-17.67-14.33-32-32-32H192v96h160v328c0 13.25 10.75 24 24 24h48c13.25 0 24-10.75 24-24v-40h40c13.25 0 24-10.75 24-24v-48c0-13.26-10.75-24-24-24zM160 24c0-13.26-10.75-24-24-24H88C74.75 0 64 10.74 64 24v40H24C10.75 64 0 74.74 0 88v48c0 13.25 10.75 24 24 24h40v256c0 17.67 14.33 32 32 32h224v-96H160V24z"]
    };
    var faCut = {
      prefix: 'fas',
      iconName: 'cut',
      icon: [448, 512, [], "f0c4", "M278.06 256L444.48 89.57c4.69-4.69 4.69-12.29 0-16.97-32.8-32.8-85.99-32.8-118.79 0L210.18 188.12l-24.86-24.86c4.31-10.92 6.68-22.81 6.68-35.26 0-53.02-42.98-96-96-96S0 74.98 0 128s42.98 96 96 96c4.54 0 8.99-.32 13.36-.93L142.29 256l-32.93 32.93c-4.37-.61-8.83-.93-13.36-.93-53.02 0-96 42.98-96 96s42.98 96 96 96 96-42.98 96-96c0-12.45-2.37-24.34-6.68-35.26l24.86-24.86L325.69 439.4c32.8 32.8 85.99 32.8 118.79 0 4.69-4.68 4.69-12.28 0-16.97L278.06 256zM96 160c-17.64 0-32-14.36-32-32s14.36-32 32-32 32 14.36 32 32-14.36 32-32 32zm0 256c-17.64 0-32-14.36-32-32s14.36-32 32-32 32 14.36 32 32-14.36 32-32 32z"]
    };
    var faEllipsisV = {
      prefix: 'fas',
      iconName: 'ellipsis-v',
      icon: [192, 512, [], "f142", "M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z"]
    };
    var faExclamationTriangle = {
      prefix: 'fas',
      iconName: 'exclamation-triangle',
      icon: [576, 512, [], "f071", "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"]
    };
    var faFilter = {
      prefix: 'fas',
      iconName: 'filter',
      icon: [512, 512, [], "f0b0", "M487.976 0H24.028C2.71 0-8.047 25.866 7.058 40.971L192 225.941V432c0 7.831 3.821 15.17 10.237 19.662l80 55.98C298.02 518.69 320 507.493 320 487.98V225.941l184.947-184.97C520.021 25.896 509.338 0 487.976 0z"]
    };
    var faPaste = {
      prefix: 'fas',
      iconName: 'paste',
      icon: [448, 512, [], "f0ea", "M128 184c0-30.879 25.122-56 56-56h136V56c0-13.255-10.745-24-24-24h-80.61C204.306 12.89 183.637 0 160 0s-44.306 12.89-55.39 32H24C10.745 32 0 42.745 0 56v336c0 13.255 10.745 24 24 24h104V184zm32-144c13.255 0 24 10.745 24 24s-10.745 24-24 24-24-10.745-24-24 10.745-24 24-24zm184 248h104v200c0 13.255-10.745 24-24 24H184c-13.255 0-24-10.745-24-24V184c0-13.255 10.745-24 24-24h136v104c0 13.2 10.8 24 24 24zm104-38.059V256h-96v-96h6.059a24 24 0 0 1 16.97 7.029l65.941 65.941a24.002 24.002 0 0 1 7.03 16.971z"]
    };
    var faPen = {
      prefix: 'fas',
      iconName: 'pen',
      icon: [512, 512, [], "f304", "M290.74 93.24l128.02 128.02-277.99 277.99-114.14 12.6C11.35 513.54-1.56 500.62.14 485.34l12.7-114.22 277.9-277.88zm207.2-19.06l-60.11-60.11c-18.75-18.75-49.16-18.75-67.91 0l-56.55 56.55 128.02 128.02 56.55-56.55c18.75-18.76 18.75-49.16 0-67.91z"]
    };
    var faPlus = {
      prefix: 'fas',
      iconName: 'plus',
      icon: [448, 512, [], "f067", "M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z"]
    };
    var faRedo = {
      prefix: 'fas',
      iconName: 'redo',
      icon: [512, 512, [], "f01e", "M500.33 0h-47.41a12 12 0 0 0-12 12.57l4 82.76A247.42 247.42 0 0 0 256 8C119.34 8 7.9 119.53 8 256.19 8.1 393.07 119.1 504 256 504a247.1 247.1 0 0 0 166.18-63.91 12 12 0 0 0 .48-17.43l-34-34a12 12 0 0 0-16.38-.55A176 176 0 1 1 402.1 157.8l-101.53-4.87a12 12 0 0 0-12.57 12v47.41a12 12 0 0 0 12 12h200.33a12 12 0 0 0 12-12V12a12 12 0 0 0-12-12z"]
    };
    var faSearch = {
      prefix: 'fas',
      iconName: 'search',
      icon: [512, 512, [], "f002", "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"]
    };
    var faSortAmountDownAlt = {
      prefix: 'fas',
      iconName: 'sort-amount-down-alt',
      icon: [512, 512, [], "f884", "M240 96h64a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16h-64a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16zm0 128h128a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16H240a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16zm256 192H240a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h256a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm-256-64h192a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16H240a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16zm-64 0h-48V48a16 16 0 0 0-16-16H80a16 16 0 0 0-16 16v304H16c-14.19 0-21.37 17.24-11.29 27.31l80 96a16 16 0 0 0 22.62 0l80-96C197.35 369.26 190.22 352 176 352z"]
    };
    var faTimes = {
      prefix: 'fas',
      iconName: 'times',
      icon: [352, 512, [], "f00d", "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"]
    };
    var faUndo = {
      prefix: 'fas',
      iconName: 'undo',
      icon: [512, 512, [], "f0e2", "M212.333 224.333H12c-6.627 0-12-5.373-12-12V12C0 5.373 5.373 0 12 0h48c6.627 0 12 5.373 12 12v78.112C117.773 39.279 184.26 7.47 258.175 8.007c136.906.994 246.448 111.623 246.157 248.532C504.041 393.258 393.12 504 256.333 504c-64.089 0-122.496-24.313-166.51-64.215-5.099-4.622-5.334-12.554-.467-17.42l33.967-33.967c4.474-4.474 11.662-4.717 16.401-.525C170.76 415.336 211.58 432 256.333 432c97.268 0 176-78.716 176-176 0-97.267-78.716-176-176-176-58.496 0-110.28 28.476-142.274 72.333h98.274c6.627 0 12 5.373 12 12v48c0 6.627-5.373 12-12 12z"]
    };
    var faWrench = {
      prefix: 'fas',
      iconName: 'wrench',
      icon: [512, 512, [], "f0ad", "M507.73 109.1c-2.24-9.03-13.54-12.09-20.12-5.51l-74.36 74.36-67.88-11.31-11.31-67.88 74.36-74.36c6.62-6.62 3.43-17.9-5.66-20.16-47.38-11.74-99.55.91-136.58 37.93-39.64 39.64-50.55 97.1-34.05 147.2L18.74 402.76c-24.99 24.99-24.99 65.51 0 90.5 24.99 24.99 65.51 24.99 90.5 0l213.21-213.21c50.12 16.71 107.47 5.68 147.37-34.22 37.07-37.07 49.7-89.32 37.91-136.73zM64 472c-13.25 0-24-10.75-24-24 0-13.26 10.75-24 24-24s24 10.74 24 24c0 13.25-10.75 24-24 24z"]
    };

    var immutableJSONPatch = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
      factory(exports) ;
    }(commonjsGlobal, (function (exports) {
      function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

      /**
       * Test deep equality of two JSON values, objects, or arrays
       * @param {JSONData} a
       * @param {JSONData} b
       * @returns {boolean}
       */
      // TODO: write unit tests
      function isEqual(a, b) {
        // FIXME: this function will return false for two objects with the same keys
        //  but different order of keys
        return JSON.stringify(a) === JSON.stringify(b);
      }
      /**
       * Test whether two values are strictly equal
       * @param {*} a
       * @param {*} b
       * @returns {boolean}
       */

      function strictEqual(a, b) {
        return a === b;
      }
      /**
       * Get all but the last items from an array
       * @param {Array} array
       * @return {Array}
       */
      // TODO: write unit tests

      function initial(array) {
        return array.slice(0, array.length - 1);
      }
      /**
       * Get the last item from an array
       * @param {Array} array
       * @returns {*}
       */
      // TODO: write unit tests

      function last(array) {
        return array[array.length - 1];
      }
      /**
       * Test whether array1 starts with array2
       * @param {Array} array1
       * @param {Array} array2
       * @param {function} [isEqual=strictEqual] Optional function to check equality
       */

      function startsWith(array1, array2) {
        var isEqual = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : strictEqual;

        if (array1.length < array2.length) {
          return false;
        }

        for (var i = 0; i < array2.length; i++) {
          if (!isEqual(array1[i], array2[i])) {
            return false;
          }
        }

        return true;
      }
      /**
       * Test whether a value is an Object or an Array (and not a primitive JSON value)
       * @param {*} value
       * @return {boolean}
       */
      // TODO: write unit tests

      function isObjectOrArray(value) {
        return _typeof(value) === 'object' && value !== null;
      }

      function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

      function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

      function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

      function _typeof$1(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }
      /**
       * Shallow clone of an Object, Array, or value
       * Symbols are cloned too.
       * @param {*} value
       * @return {*}
       */

      function shallowClone(value) {
        if (Array.isArray(value)) {
          // copy array items
          var copy = value.slice(); // copy all symbols

          Object.getOwnPropertySymbols(value).forEach(function (symbol) {
            copy[symbol] = value[symbol];
          });
          return copy;
        } else if (_typeof$1(value) === 'object') {
          // copy object properties
          var _copy = _objectSpread({}, value); // copy all symbols


          Object.getOwnPropertySymbols(value).forEach(function (symbol) {
            _copy[symbol] = value[symbol];
          });
          return _copy;
        } else {
          return value;
        }
      }
      /**
       * Update a value in an object in an immutable way.
       * If the value is unchanged, the original object will be returned
       * @param {Object | Array} object
       * @param {string | index} key
       * @param {*} value
       * @returns {Object | Array}
       */

      function applyProp(object, key, value) {
        if (object[key] === value) {
          // return original object unchanged when the new value is identical to the old one
          return object;
        } else {
          var updatedObject = shallowClone(object);
          updatedObject[key] = value;
          return updatedObject;
        }
      }
      /**
       * helper function to get a nested property in an object or array
       *
       * @param {Object | Array} object
       * @param {JSONPath} path
       * @return {* | undefined} Returns the field when found, or undefined when the
       *                         path doesn't exist
       */

      function getIn(object, path) {
        var value = object;
        var i = 0;

        while (i < path.length) {
          if (isObjectOrArray(value)) {
            value = value[path[i]];
          } else {
            value = undefined;
          }

          i++;
        }

        return value;
      }
      /**
       * helper function to replace a nested property in an object with a new value
       * without mutating the object itself.
       *
       * @param {Object | Array} object
       * @param {JSONPath} path
       * @param {*} value
       * @param {boolean} [createPath=false]
       *                    If true, `path` will be created when (partly) missing in
       *                    the object. For correctly creating nested Arrays or
       *                    Objects, the function relies on `path` containing a number
       *                    in case of array indexes.
       *                    If false (default), an error will be thrown when the
       *                    path doesn't exist.
       * @return {Object | Array} Returns a new, updated object or array
       */

      function setIn(object, path, value) {
        var createPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        if (path.length === 0) {
          return value;
        }

        var key = path[0];
        var updatedValue = setIn(object ? object[key] : undefined, path.slice(1), value, createPath);

        if (!isObjectOrArray(object)) {
          if (createPath) {
            var newObject = typeof key === 'number' ? [] : {};
            newObject[key] = updatedValue;
            return newObject;
          } else {
            throw new Error('Path does not exist');
          }
        }

        return applyProp(object, key, updatedValue);
      }
      /**
       * helper function to replace a nested property in an object with a new value
       * without mutating the object itself.
       *
       * @param {Object | Array} object
       * @param {JSONPath} path
       * @param {function} callback
       * @return {Object | Array} Returns a new, updated object or array
       */

      function updateIn(object, path, callback) {
        if (path.length === 0) {
          return callback(object);
        }

        if (!isObjectOrArray(object)) {
          throw new Error('Path doesn\'t exist');
        }

        var key = path[0];
        var updatedValue = updateIn(object[key], path.slice(1), callback);
        return applyProp(object, key, updatedValue);
      }
      /**
       * helper function to delete a nested property in an object
       * without mutating the object itself.
       *
       * @param {Object | Array} object
       * @param {JSONPath} path
       * @return {Object | Array} Returns a new, updated object or array
       */

      function deleteIn(object, path) {
        if (path.length === 0) {
          return object;
        }

        if (!isObjectOrArray(object)) {
          throw new Error('Path does not exist');
        }

        if (path.length === 1) {
          var _key = path[0];

          if (!(_key in object)) {
            // key doesn't exist. return object unchanged
            return object;
          } else {
            var updatedObject = shallowClone(object);

            if (Array.isArray(updatedObject)) {
              updatedObject.splice(_key, 1);
            } else {
              delete updatedObject[_key];
            }

            return updatedObject;
          }
        }

        var key = path[0];
        var updatedValue = deleteIn(object[key], path.slice(1));
        return applyProp(object, key, updatedValue);
      }
      /**
       * Insert a new item in an array at a specific index.
       * Example usage:
       *
       *     insertAt({arr: [1,2,3]}, ['arr', '2'], 'inserted')  // [1,2,'inserted',3]
       *
       * @param {Object | Array} object
       * @param {JSONPath} path
       * @param {*} value
       * @return {Array}
       */

      function insertAt(object, path, value) {
        var parentPath = path.slice(0, path.length - 1);
        var index = path[path.length - 1];
        return updateIn(object, parentPath, function (items) {
          if (!Array.isArray(items)) {
            throw new TypeError('Array expected at path ' + JSON.stringify(parentPath));
          }

          var updatedItems = shallowClone(items);
          updatedItems.splice(index, 0, value);
          return updatedItems;
        });
      }
      /**
       * Test whether a path exists in a JSON object
       * @param {JSONData} json
       * @param {JSONPath} path
       * @return {boolean} Returns true if the path exists, else returns false
       * @private
       */

      function existsIn(json, path) {
        if (json === undefined) {
          return false;
        }

        if (path.length === 0) {
          return true;
        }

        return existsIn(json[path[0]], path.slice(1));
      }

      /**
       * Parse a JSON Pointer
       * @param {string} pointer
       * @return {JSONPath}
       */
      function parseJSONPointer(pointer) {
        var path = pointer.split('/');
        path.shift(); // remove the first empty entry

        return path.map(function (p) {
          return p.replace(/~1/g, '/').replace(/~0/g, '~');
        });
      }
      /**
       * Compile a JSON Pointer
       * @param {JSONPath} path
       * @return {string}
       */

      function compileJSONPointer(path) {
        return path.map(function (p) {
          return '/' + String(p).replace(/~/g, '~0').replace(/\//g, '~1');
        }).join('');
      }

      /**
       * Apply a patch to a JSON object
       * The original JSON object will not be changed,
       * instead, the patch is applied in an immutable way
       * @param {JSONData} json
       * @param {JSONPatchDocument} operations    Array with JSON patch actions
       * @param {JSONPatchOptions} [options]
       * @return {JSONData} Returns the updated json
       */

      function immutableJSONPatch(json, operations, options) {
        var updatedJson = json;

        for (var i = 0; i < operations.length; i++) {
          validateJSONPatchOperation(operations[i]);
          var operation = preprocessJSONPatchOperation(updatedJson, operations[i]); // TODO: test before

          if (options && options.before) {
            var result = options.before(updatedJson, operation);

            if (result !== undefined) {
              if (result.json !== undefined) {
                updatedJson = result.json;
              }

              if (result.operation !== undefined) {
                operation = result.operation;
              }
            }
          }

          var previousJson = updatedJson;
          var patchOp = PATCH_OPS[operation.op];

          if (patchOp) {
            updatedJson = patchOp(updatedJson, operation);
          } else if (operation.op === 'test') {
            test(updatedJson, operation);
          } else {
            throw new Error('Unknown JSONPatch operation ' + JSON.stringify(operation.op));
          } // TODO: test after


          if (options && options.after) {
            var _result = options.after(updatedJson, operation, previousJson);

            if (_result !== undefined) {
              updatedJson = _result;
            }
          }
        }

        return updatedJson;
      }
      var PATCH_OPS = {
        add: add,
        remove: remove,
        replace: replace,
        copy: copy,
        move: move
      };
      /**
       * Replace an existing item
       * @param {JSONData} json
       * @param {{ path: JSONPath, value: JSONData }} operation
       * @return {JSONData}
       */

      function replace(json, _ref) {
        var path = _ref.path,
            value = _ref.value;
        return setIn(json, path, value);
      }
      /**
       * Remove an item or property
       * @param {JSONData} json
       * @param {{ path: JSONPath }} operation
       * @return {JSONData}
       */

      function remove(json, _ref2) {
        var path = _ref2.path;
        return deleteIn(json, path);
      }
      /**
       * @param {JSONData} json
       * @param {{ path: JSONPath, value: JSONData }} operation
       * @return {JSONData}
       */

      function add(json, _ref3) {
        var path = _ref3.path,
            value = _ref3.value;

        if (isArrayItem(json, path)) {
          return insertAt(json, path, value);
        } else {
          return setIn(json, path, value);
        }
      }
      /**
       * Copy a value
       * @param {JSONData} json
       * @param {{ path: JSONPath, from: JSONPath }} operation
       * @return {JSONData}
       */

      function copy(json, _ref4) {
        var path = _ref4.path,
            from = _ref4.from;
        var value = getIn(json, from);

        if (isArrayItem(json, path)) {
          return insertAt(json, path, value);
        } else {
          var _value = getIn(json, from);

          return setIn(json, path, _value);
        }
      }
      /**
       * Move a value
       * @param {JSONData} json
       * @param {{ path: JSONPath, from: JSONPath }} operation
       * @return {JSONData}
       */

      function move(json, _ref5) {
        var path = _ref5.path,
            from = _ref5.from;
        var value = getIn(json, from);
        var removedJson = deleteIn(json, from);
        return isArrayItem(removedJson, path) ? insertAt(removedJson, path, value) : setIn(removedJson, path, value);
      }
      /**
       * Test whether the data contains the provided value at the specified path.
       * Throws an error when the test fails
       * @param {JSONData} json
       * @param {{ path: JSONPath, value: JSONData }} operation
       */

      function test(json, _ref6) {
        var path = _ref6.path,
            value = _ref6.value;

        if (value === undefined) {
          throw new Error("Test failed: no value provided (path: \"".concat(compileJSONPointer(path), "\")"));
        }

        if (!existsIn(json, path)) {
          throw new Error("Test failed: path not found (path: \"".concat(compileJSONPointer(path), "\")"));
        }

        var actualValue = getIn(json, path);

        if (!isEqual(actualValue, value)) {
          throw new Error("Test failed, value differs (path: \"".concat(compileJSONPointer(path), "\")"));
        }
      }
      /**
       * @param {JSONData} json
       * @param {JSONPath} path
       * @returns {boolean}
       */
      // TODO: write unit tests

      function isArrayItem(json, path) {
        var parent = getIn(json, initial(path));
        return Array.isArray(parent);
      }
      /**
       * Resolve the path index of an array, resolves indexes '-'
       * @param {JSONData} json
       * @param {JSONPath} path
       * @returns {JSONPath} Returns the resolved path
       */

      function resolvePathIndex(json, path) {
        if (last(path) !== '-') {
          return path;
        }

        var parentPath = initial(path);
        var parent = getIn(json, parentPath);
        return parentPath.concat(parent.length);
      }
      /**
       * Validate a JSONPatch operation.
       * Throws an error when there is an issue
       * @param {JSONPatchOperation} operation
       */

      function validateJSONPatchOperation(operation) {
        // TODO: write unit tests
        var ops = ['add', 'remove', 'replace', 'copy', 'move', 'test'];

        if (!ops.includes(operation.op)) {
          throw new Error('Unknown JSONPatch op ' + JSON.stringify(operation.op));
        }

        if (typeof operation.path !== 'string') {
          throw new Error('Required property "path" missing or not a string in operation ' + JSON.stringify(operation));
        }

        if (operation.op === 'copy' || operation.op === 'move') {
          if (typeof operation.from !== 'string') {
            throw new Error('Required property "from" missing or not a string in operation ' + JSON.stringify(operation));
          }
        }
      }
      /**
       * @param {JSONData} json
       * @param {JSONPatchOperation} operation
       * @return {PreprocessedJSONPatchOperation}
       */
      // TODO: write unit tests

      function preprocessJSONPatchOperation(json, operation) {
        return {
          op: operation.op,
          path: resolvePathIndex(json, parseJSONPointer(operation.path)),
          from: operation.from !== undefined ? parseJSONPointer(operation.from) : null,
          value: operation.value
        };
      }

      /**
       * Create the inverse of a set of json patch operations
       * @param {JSONData} json
       * @param {JSONPatchDocument} operations    Array with JSON patch actions
       * @return {JSONPatchDocument} Returns the operations to revert the changes
       */

      function revertJSONPatch(json, operations) {
        var revertOperations = [];
        immutableJSONPatch(json, operations, {
          before: function before(json, operation) {
            var revertOp = REVERT_OPS[operation.op];

            if (revertOp) {
              revertOperations = revertOp(json, operation).concat(revertOperations);
            }
          }
        });
        return revertOperations;
      }
      var REVERT_OPS = {
        add: revertAdd,
        remove: revertRemove,
        replace: revertReplace,
        copy: revertCopy,
        move: revertMove
      };
      /**
       * @param {JSONData} json
       * @param {{ path: JSONPath }} operation
       * @return {JSONPatchDocument}
       */

      function revertReplace(json, _ref) {
        var path = _ref.path;
        return [{
          op: 'replace',
          path: compileJSONPointer(path),
          value: getIn(json, path)
        }];
      }
      /**
       * @param {JSONData} json
       * @param {{ path: JSONPath }} operation
       * @return {JSONPatchDocument}
       */


      function revertRemove(json, _ref2) {
        var path = _ref2.path;
        return [{
          op: 'add',
          path: compileJSONPointer(path),
          value: getIn(json, path)
        }];
      }
      /**
       * @param {JSONData} json
       * @param {{ path: JSONPath, value: JSONData }} operation
       * @return {JSONPatchDocument}
       */


      function revertAdd(json, _ref3) {
        var path = _ref3.path,
            value = _ref3.value;

        if (isArrayItem(json, path) || !existsIn(json, path)) {
          return [{
            op: 'remove',
            path: compileJSONPointer(path)
          }];
        } else {
          return revertReplace(json, {
            path: path,
            value: value
          });
        }
      }
      /**
       * @param {JSONData} json
       * @param {{ path: JSONPath, value: JSONData }} operation
       * @return {JSONPatchDocument}
       */


      function revertCopy(json, _ref4) {
        var path = _ref4.path,
            value = _ref4.value;
        return revertAdd(json, {
          path: path,
          value: value
        });
      }
      /**
       * @param {JSONData} json
       * @param {{ path: JSONPath, from: JSONPath }} operation
       * @return {JSONPatchDocument}
       */


      function revertMove(json, _ref5) {
        var path = _ref5.path,
            from = _ref5.from;

        if (path.length < from.length && startsWith(from, path)) {
          // replacing the parent with the child
          return [{
            op: 'replace',
            path: compileJSONPointer(path),
            value: json
          }];
        }

        var revert = [{
          op: 'move',
          from: compileJSONPointer(path),
          path: compileJSONPointer(from)
        }];

        if (!isArrayItem(json, path) && existsIn(json, path)) {
          // the move replaces an existing value in an object
          revert = revert.concat(revertRemove(json, {
            path: path
          }));
        }

        return revert;
      }

      exports.compileJSONPointer = compileJSONPointer;
      exports.deleteIn = deleteIn;
      exports.existsIn = existsIn;
      exports.getIn = getIn;
      exports.immutableJSONPatch = immutableJSONPatch;
      exports.insertAt = insertAt;
      exports.parseJSONPointer = parseJSONPointer;
      exports.revertJSONPatch = revertJSONPatch;
      exports.setIn = setIn;
      exports.updateIn = updateIn;

      Object.defineProperty(exports, '__esModule', { value: true });

    })));

    });

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = freeGlobal || freeSelf || Function('return this')();

    /** Built-in value references. */
    var Symbol$1 = root.Symbol;

    /** Used for built-in method references. */
    var objectProto$s = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$o = objectProto$s.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$3 = objectProto$s.toString;

    /** Built-in value references. */
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty$o.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$3.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$r = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$2 = objectProto$r.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString$2.call(value);
    }

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /** `Object#toString` result references. */
    var symbolTag$3 = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag$3);
    }

    /** Used as references for various `Number` constants. */
    var NAN$2 = 0 / 0;

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN$2;
      }
      return +value;
    }

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /** Used as references for various `Number` constants. */
    var INFINITY$5 = 1 / 0;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : undefined,
        symbolToString = symbolProto$2 ? symbolProto$2.toString : undefined;

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY$5) ? '-0' : result;
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /** Used to match a single whitespace character. */
    var reWhitespace = /\s/;

    /**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
     * character of `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the index of the last non-whitespace character.
     */
    function trimmedEndIndex(string) {
      var index = string.length;

      while (index-- && reWhitespace.test(string.charAt(index))) {}
      return index;
    }

    /** Used to match leading whitespace. */
    var reTrimStart$2 = /^\s+/;

    /**
     * The base implementation of `_.trim`.
     *
     * @private
     * @param {string} string The string to trim.
     * @returns {string} Returns the trimmed string.
     */
    function baseTrim(string) {
      return string
        ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart$2, '')
        : string;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject$1(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /** Used as references for various `Number` constants. */
    var NAN$1 = 0 / 0;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN$1;
      }
      if (isObject$1(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject$1(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN$1 : +value);
    }

    /** Used as references for various `Number` constants. */
    var INFINITY$4 = 1 / 0,
        MAX_INTEGER = 1.7976931348623157e+308;

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY$4 || value === -INFINITY$4) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT$b = 'Expected a function';

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$b);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag$2 = '[object Function]',
        genTag$1 = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject$1(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
    }

    /** Used to detect overreaching core-js shims. */
    var coreJsData = root['__core-js_shared__'];

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /** Used for built-in method references. */
    var funcProto$2 = Function.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$2 = funcProto$2.toString;

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Used for built-in method references. */
    var funcProto$1 = Function.prototype,
        objectProto$q = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$1 = funcProto$1.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$n = objectProto$q.hasOwnProperty;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString$1.call(hasOwnProperty$n).replace(reRegExpChar$1, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject$1(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /* Built-in method references that are verified to be native. */
    var WeakMap = getNative(root, 'WeakMap');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /** Built-in value references. */
    var objectCreate = Object.create;

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject$1(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject$1(result) ? result : thisBinding;
      };
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$8 = 1;

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG$8,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * A faster alternative to `Function#apply`, this function invokes `func`
     * with the `this` binding of `thisArg` and the arguments of `args`.
     *
     * @private
     * @param {Function} func The function to invoke.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} args The arguments to invoke `func` with.
     * @returns {*} Returns the result of `func`.
     */
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0: return func.call(thisArg);
        case 1: return func.call(thisArg, args[0]);
        case 2: return func.call(thisArg, args[0], args[1]);
        case 3: return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$g = Math.max;

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax$g(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$f = Math.max;

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax$f(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Gets the number of `placeholder` occurrences in `array`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} placeholder The placeholder to search for.
     * @returns {number} Returns the placeholder count.
     */
    function countHolders(array, placeholder) {
      var length = array.length,
          result = 0;

      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH$6 = 4294967295;

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH$6;
      this.__views__ = [];
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop$1() {
      // No operation performed.
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop$1 : function(func) {
      return metaMap.get(func);
    };

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used for built-in method references. */
    var objectProto$p = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$m = objectProto$p.hasOwnProperty;

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty$m.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$o = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$l = objectProto$o.hasOwnProperty;

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty$l.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /** Used to detect hot functions by number of calls within a span of milliseconds. */
    var HOT_COUNT = 800,
        HOT_SPAN = 16;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeNow = Date.now;

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /** Used to match wrap detail comments. */
    var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
        reSplitDetails = /,? & /;

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /** Used to match wrap detail comments. */
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);

      while ((fromRight ? index-- : ++index < length)) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.isNaN` without support for number objects.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     */
    function baseIsNaN(value) {
      return value !== value;
    }

    /**
     * A specialized version of `_.indexOf` which performs strict equality
     * comparisons of values, i.e. `===`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseIndexOf(array, value, fromIndex) {
      return value === value
        ? strictIndexOf(array, value, fromIndex)
        : baseFindIndex(array, baseIsNaN, fromIndex);
    }

    /**
     * A specialized version of `_.includes` for arrays without support for
     * specifying an index to search from.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$7 = 1,
        WRAP_BIND_KEY_FLAG$6 = 2,
        WRAP_CURRY_FLAG$6 = 8,
        WRAP_CURRY_RIGHT_FLAG$3 = 16,
        WRAP_PARTIAL_FLAG$6 = 32,
        WRAP_PARTIAL_RIGHT_FLAG$3 = 64,
        WRAP_ARY_FLAG$4 = 128,
        WRAP_REARG_FLAG$3 = 256,
        WRAP_FLIP_FLAG$2 = 512;

    /** Used to associate wrap methods with their bit flags. */
    var wrapFlags = [
      ['ary', WRAP_ARY_FLAG$4],
      ['bind', WRAP_BIND_FLAG$7],
      ['bindKey', WRAP_BIND_KEY_FLAG$6],
      ['curry', WRAP_CURRY_FLAG$6],
      ['curryRight', WRAP_CURRY_RIGHT_FLAG$3],
      ['flip', WRAP_FLIP_FLAG$2],
      ['partial', WRAP_PARTIAL_FLAG$6],
      ['partialRight', WRAP_PARTIAL_RIGHT_FLAG$3],
      ['rearg', WRAP_REARG_FLAG$3]
    ];

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$6 = 1,
        WRAP_BIND_KEY_FLAG$5 = 2,
        WRAP_CURRY_BOUND_FLAG$1 = 4,
        WRAP_CURRY_FLAG$5 = 8,
        WRAP_PARTIAL_FLAG$5 = 32,
        WRAP_PARTIAL_RIGHT_FLAG$2 = 64;

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG$5,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG$5 : WRAP_PARTIAL_RIGHT_FLAG$2);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG$2 : WRAP_PARTIAL_FLAG$5);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG$1)) {
        bitmask &= ~(WRAP_BIND_FLAG$6 | WRAP_BIND_KEY_FLAG$5);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = func;
      return object.placeholder;
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$5 = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$5 : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMin$e = Math.min;

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin$e(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /** Used as the internal argument placeholder. */
    var PLACEHOLDER$1 = '__lodash_placeholder__';

    /**
     * Replaces all `placeholder` elements in `array` with an internal placeholder
     * and returns an array of their indexes.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {*} placeholder The placeholder to replace.
     * @returns {Array} Returns the new array of placeholder indexes.
     */
    function replaceHolders(array, placeholder) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER$1) {
          array[index] = PLACEHOLDER$1;
          result[resIndex++] = index;
        }
      }
      return result;
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$5 = 1,
        WRAP_BIND_KEY_FLAG$4 = 2,
        WRAP_CURRY_FLAG$4 = 8,
        WRAP_CURRY_RIGHT_FLAG$2 = 16,
        WRAP_ARY_FLAG$3 = 128,
        WRAP_FLIP_FLAG$1 = 512;

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG$3,
          isBind = bitmask & WRAP_BIND_FLAG$5,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG$4,
          isCurried = bitmask & (WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$2),
          isFlip = bitmask & WRAP_FLIP_FLAG$1,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$4 = 1;

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG$4,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /** Used as the internal argument placeholder. */
    var PLACEHOLDER = '__lodash_placeholder__';

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$3 = 1,
        WRAP_BIND_KEY_FLAG$3 = 2,
        WRAP_CURRY_BOUND_FLAG = 4,
        WRAP_CURRY_FLAG$3 = 8,
        WRAP_ARY_FLAG$2 = 128,
        WRAP_REARG_FLAG$2 = 256;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMin$d = Math.min;

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG$3 | WRAP_BIND_KEY_FLAG$3 | WRAP_ARY_FLAG$2);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG$2) && (bitmask == WRAP_CURRY_FLAG$3)) ||
        ((srcBitmask == WRAP_ARY_FLAG$2) && (bitmask == WRAP_REARG_FLAG$2) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG$2 | WRAP_REARG_FLAG$2)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG$3));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG$3) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG$3 ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG$2) {
        data[8] = data[8] == null ? source[8] : nativeMin$d(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT$a = 'Expected a function';

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$2 = 1,
        WRAP_BIND_KEY_FLAG$2 = 2,
        WRAP_CURRY_FLAG$2 = 8,
        WRAP_CURRY_RIGHT_FLAG$1 = 16,
        WRAP_PARTIAL_FLAG$4 = 32,
        WRAP_PARTIAL_RIGHT_FLAG$1 = 64;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$e = Math.max;

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG$2;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$a);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG$4 | WRAP_PARTIAL_RIGHT_FLAG$1);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax$e(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG$1) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax$e(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1)) {
        bitmask &= ~(WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG$2) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG$2 || bitmask == WRAP_CURRY_RIGHT_FLAG$1) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG$4 || bitmask == (WRAP_BIND_FLAG$2 | WRAP_PARTIAL_FLAG$4)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_ARY_FLAG$1 = 128;

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG$1, undefined, undefined, undefined, undefined, n);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /** Used for built-in method references. */
    var objectProto$n = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$k = objectProto$n.hasOwnProperty;

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$k.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$d = Math.max;

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax$d(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax$d(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$4 = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$4;
    }

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject$1(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /** Used for built-in method references. */
    var objectProto$m = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$m;

      return value === proto;
    }

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    /** `Object#toString` result references. */
    var argsTag$3 = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$3;
    }

    /** Used for built-in method references. */
    var objectProto$l = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$j = objectProto$l.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable$1 = objectProto$l.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$j.call(value, 'callee') &&
        !propertyIsEnumerable$1.call(value, 'callee');
    };

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /** Detect free variable `exports`. */
    var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

    /** Built-in value references. */
    var Buffer$2 = moduleExports$2 ? root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /** `Object#toString` result references. */
    var argsTag$2 = '[object Arguments]',
        arrayTag$2 = '[object Array]',
        boolTag$4 = '[object Boolean]',
        dateTag$4 = '[object Date]',
        errorTag$3 = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag$9 = '[object Map]',
        numberTag$4 = '[object Number]',
        objectTag$4 = '[object Object]',
        regexpTag$4 = '[object RegExp]',
        setTag$9 = '[object Set]',
        stringTag$4 = '[object String]',
        weakMapTag$3 = '[object WeakMap]';

    var arrayBufferTag$4 = '[object ArrayBuffer]',
        dataViewTag$4 = '[object DataView]',
        float32Tag$2 = '[object Float32Array]',
        float64Tag$2 = '[object Float64Array]',
        int8Tag$2 = '[object Int8Array]',
        int16Tag$2 = '[object Int16Array]',
        int32Tag$2 = '[object Int32Array]',
        uint8Tag$2 = '[object Uint8Array]',
        uint8ClampedTag$2 = '[object Uint8ClampedArray]',
        uint16Tag$2 = '[object Uint16Array]',
        uint32Tag$2 = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
    typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
    typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
    typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
    typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] =
    typedArrayTags[arrayBufferTag$4] = typedArrayTags[boolTag$4] =
    typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$4] =
    typedArrayTags[errorTag$3] = typedArrayTags[funcTag$1] =
    typedArrayTags[mapTag$9] = typedArrayTags[numberTag$4] =
    typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$4] =
    typedArrayTags[setTag$9] = typedArrayTags[stringTag$4] =
    typedArrayTags[weakMapTag$3] = false;

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }

    /** Detect free variable `exports`. */
    var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports$1 && freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function() {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

        if (types) {
          return types;
        }

        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }());

    /* Node.js helper references. */
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /** Used for built-in method references. */
    var objectProto$k = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$i = objectProto$k.hasOwnProperty;

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$i.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = overArg(Object.keys, Object);

    /** Used for built-in method references. */
    var objectProto$j = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$h = objectProto$j.hasOwnProperty;

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$h.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /** Used for built-in method references. */
    var objectProto$i = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$g = objectProto$i.hasOwnProperty;

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty$g.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$h = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$f = objectProto$h.hasOwnProperty;

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject$1(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty$f.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /** Used to match property names within property paths. */
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/;

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /* Built-in method references that are verified to be native. */
    var nativeCreate = getNative(Object, 'create');

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

    /** Used for built-in method references. */
    var objectProto$g = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$e = objectProto$g.hasOwnProperty;

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? undefined : result;
      }
      return hasOwnProperty$e.call(data, key) ? data[key] : undefined;
    }

    /** Used for built-in method references. */
    var objectProto$f = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$d = objectProto$f.hasOwnProperty;

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$d.call(data, key);
    }

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
      return this;
    }

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /** Used for built-in method references. */
    var arrayProto$5 = Array.prototype;

    /** Built-in value references. */
    var splice$2 = arrayProto$5.splice;

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice$2.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /* Built-in method references that are verified to be native. */
    var Map$1 = getNative(root, 'Map');

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map$1 || ListCache),
        'string': new Hash
      };
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /** Error message constants. */
    var FUNC_ERROR_TEXT$9 = 'Expected a function';

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT$9);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /** Used as the maximum memoize cache size. */
    var MAX_MEMOIZE_SIZE = 500;

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /** Used to match property names within property paths. */
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /** Used as references for various `Number` constants. */
    var INFINITY$3 = 1 / 0;

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY$3) ? '-0' : result;
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    /** Built-in value references. */
    var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : undefined;

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /** Built-in value references. */
    var getPrototype = overArg(Object.getPrototypeOf, Object);

    /** `Object#toString` result references. */
    var objectTag$3 = '[object Object]';

    /** Used for built-in method references. */
    var funcProto = Function.prototype,
        objectProto$e = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$c = objectProto$e.hasOwnProperty;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$c.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /** `Object#toString` result references. */
    var domExcTag = '[object DOMException]',
        errorTag$2 = '[object Error]';

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag$2 || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /** Error message constants. */
    var FUNC_ERROR_TEXT$8 = 'Expected a function';

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$8);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$1 = 1,
        WRAP_PARTIAL_FLAG$3 = 32;

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind$1 = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG$1;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind$1));
        bitmask |= WRAP_PARTIAL_FLAG$3;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    // Assign default placeholders.
    bind$1.placeholder = {};

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind$1(object[key], object));
      });
      return object;
    });

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG = 1,
        WRAP_BIND_KEY_FLAG$1 = 2,
        WRAP_PARTIAL_FLAG$2 = 32;

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG$1;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG$2;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    // Assign default placeholders.
    bindKey.placeholder = {};

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /** Used to compose unicode character classes. */
    var rsAstralRange$3 = '\\ud800-\\udfff',
        rsComboMarksRange$4 = '\\u0300-\\u036f',
        reComboHalfMarksRange$4 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$4 = '\\u20d0-\\u20ff',
        rsComboRange$4 = rsComboMarksRange$4 + reComboHalfMarksRange$4 + rsComboSymbolsRange$4,
        rsVarRange$3 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsZWJ$3 = '\\u200d';

    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
    var reHasUnicode = RegExp('[' + rsZWJ$3 + rsAstralRange$3  + rsComboRange$4 + rsVarRange$3 + ']');

    /**
     * Checks if `string` contains Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
     */
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }

    /**
     * Converts an ASCII `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function asciiToArray(string) {
      return string.split('');
    }

    /** Used to compose unicode character classes. */
    var rsAstralRange$2 = '\\ud800-\\udfff',
        rsComboMarksRange$3 = '\\u0300-\\u036f',
        reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$3 = '\\u20d0-\\u20ff',
        rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
        rsVarRange$2 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsAstral$1 = '[' + rsAstralRange$2 + ']',
        rsCombo$3 = '[' + rsComboRange$3 + ']',
        rsFitz$2 = '\\ud83c[\\udffb-\\udfff]',
        rsModifier$2 = '(?:' + rsCombo$3 + '|' + rsFitz$2 + ')',
        rsNonAstral$2 = '[^' + rsAstralRange$2 + ']',
        rsRegional$2 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair$2 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ$2 = '\\u200d';

    /** Used to compose unicode regexes. */
    var reOptMod$2 = rsModifier$2 + '?',
        rsOptVar$2 = '[' + rsVarRange$2 + ']?',
        rsOptJoin$2 = '(?:' + rsZWJ$2 + '(?:' + [rsNonAstral$2, rsRegional$2, rsSurrPair$2].join('|') + ')' + rsOptVar$2 + reOptMod$2 + ')*',
        rsSeq$2 = rsOptVar$2 + reOptMod$2 + rsOptJoin$2,
        rsSymbol$1 = '(?:' + [rsNonAstral$2 + rsCombo$3 + '?', rsCombo$3, rsRegional$2, rsSurrPair$2, rsAstral$1].join('|') + ')';

    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode$1 = RegExp(rsFitz$2 + '(?=' + rsFitz$2 + ')|' + rsSymbol$1 + rsSeq$2, 'g');

    /**
     * Converts a Unicode `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function unicodeToArray(string) {
      return string.match(reUnicode$1) || [];
    }

    /**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function stringToArray(string) {
      return hasUnicode(string)
        ? unicodeToArray(string)
        : asciiToArray(string);
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array == null ? 0 : array.length;

      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * The base implementation of `_.propertyOf` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined : object[key];
      };
    }

    /** Used to map Latin Unicode letters to basic Latin letters. */
    var deburredLetters = {
      // Latin-1 Supplement block.
      '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
      '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
      '\xc7': 'C',  '\xe7': 'c',
      '\xd0': 'D',  '\xf0': 'd',
      '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
      '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
      '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
      '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
      '\xd1': 'N',  '\xf1': 'n',
      '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
      '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
      '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
      '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
      '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
      '\xc6': 'Ae', '\xe6': 'ae',
      '\xde': 'Th', '\xfe': 'th',
      '\xdf': 'ss',
      // Latin Extended-A block.
      '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
      '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
      '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
      '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
      '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
      '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
      '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
      '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
      '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
      '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
      '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
      '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
      '\u0134': 'J',  '\u0135': 'j',
      '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
      '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
      '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
      '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
      '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
      '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
      '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
      '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
      '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
      '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
      '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
      '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
      '\u0163': 't',  '\u0165': 't', '\u0167': 't',
      '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
      '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
      '\u0174': 'W',  '\u0175': 'w',
      '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
      '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
      '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
      '\u0132': 'IJ', '\u0133': 'ij',
      '\u0152': 'Oe', '\u0153': 'oe',
      '\u0149': "'n", '\u017f': 's'
    };

    /**
     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
     * letters to basic Latin letters.
     *
     * @private
     * @param {string} letter The matched letter to deburr.
     * @returns {string} Returns the deburred letter.
     */
    var deburrLetter = basePropertyOf(deburredLetters);

    /** Used to match Latin Unicode letters (excluding mathematical operators). */
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

    /** Used to compose unicode character classes. */
    var rsComboMarksRange$2 = '\\u0300-\\u036f',
        reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$2 = '\\u20d0-\\u20ff',
        rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;

    /** Used to compose unicode capture groups. */
    var rsCombo$2 = '[' + rsComboRange$2 + ']';

    /**
     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
     */
    var reComboMark = RegExp(rsCombo$2, 'g');

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /** Used to match words composed of alphanumeric characters. */
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

    /**
     * Splits an ASCII `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }

    /** Used to detect strings that need a more robust regexp to match words. */
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

    /**
     * Checks if `string` contains a word composed of Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a word is found, else `false`.
     */
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }

    /** Used to compose unicode character classes. */
    var rsAstralRange$1 = '\\ud800-\\udfff',
        rsComboMarksRange$1 = '\\u0300-\\u036f',
        reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
        rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
        rsDingbatRange = '\\u2700-\\u27bf',
        rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
        rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
        rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
        rsPunctuationRange = '\\u2000-\\u206f',
        rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
        rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
        rsVarRange$1 = '\\ufe0e\\ufe0f',
        rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

    /** Used to compose unicode capture groups. */
    var rsApos$1 = "['\u2019]",
        rsBreak = '[' + rsBreakRange + ']',
        rsCombo$1 = '[' + rsComboRange$1 + ']',
        rsDigits = '\\d+',
        rsDingbat = '[' + rsDingbatRange + ']',
        rsLower = '[' + rsLowerRange + ']',
        rsMisc = '[^' + rsAstralRange$1 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
        rsFitz$1 = '\\ud83c[\\udffb-\\udfff]',
        rsModifier$1 = '(?:' + rsCombo$1 + '|' + rsFitz$1 + ')',
        rsNonAstral$1 = '[^' + rsAstralRange$1 + ']',
        rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsUpper = '[' + rsUpperRange + ']',
        rsZWJ$1 = '\\u200d';

    /** Used to compose unicode regexes. */
    var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
        rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
        rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?',
        rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?',
        reOptMod$1 = rsModifier$1 + '?',
        rsOptVar$1 = '[' + rsVarRange$1 + ']?',
        rsOptJoin$1 = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
        rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
        rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
        rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
        rsEmoji = '(?:' + [rsDingbat, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsSeq$1;

    /** Used to match complex or compound words. */
    var reUnicodeWord = RegExp([
      rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
      rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
      rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
      rsUpper + '+' + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join('|'), 'g');

    /**
     * Splits a Unicode `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /** Used to compose unicode capture groups. */
    var rsApos = "['\u2019]";

    /** Used to match apostrophes. */
    var reApos = RegExp(rsApos, 'g');

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsFinite$1 = root.isFinite,
        nativeMin$c = Math.min;

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin$c(toInteger(precision), 292);
        if (precision && nativeIsFinite$1(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil$3 = Math.ceil,
        nativeMax$c = Math.max;

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax$c(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil$3(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE$2 = 200;

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || (pairs.length < LARGE_ARRAY_SIZE$2 - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /** Detect free variable `exports`. */
    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer$1 = moduleExports ? root.Buffer : undefined,
        allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /** Used for built-in method references. */
    var objectProto$d = Object.prototype;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$d.propertyIsEnumerable;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(root, 'DataView');

    /* Built-in method references that are verified to be native. */
    var Promise$1 = getNative(root, 'Promise');

    /* Built-in method references that are verified to be native. */
    var Set$1 = getNative(root, 'Set');

    /** `Object#toString` result references. */
    var mapTag$8 = '[object Map]',
        objectTag$2 = '[object Object]',
        promiseTag = '[object Promise]',
        setTag$8 = '[object Set]',
        weakMapTag$2 = '[object WeakMap]';

    var dataViewTag$3 = '[object DataView]';

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map$1),
        promiseCtorString = toSource(Promise$1),
        setCtorString = toSource(Set$1),
        weakMapCtorString = toSource(WeakMap);

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3) ||
        (Map$1 && getTag(new Map$1) != mapTag$8) ||
        (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
        (Set$1 && getTag(new Set$1) != setTag$8) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag$2)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag$2 ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag$3;
            case mapCtorString: return mapTag$8;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag$8;
            case weakMapCtorString: return weakMapTag$2;
          }
        }
        return result;
      };
    }

    var getTag$1 = getTag;

    /** Used for built-in method references. */
    var objectProto$c = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$b = objectProto$c.hasOwnProperty;

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty$b.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /** Built-in value references. */
    var Uint8Array$1 = root.Uint8Array;

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /** Used to match `RegExp` flags from their coerced string values. */
    var reFlags$1 = /\w*$/;

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags$1.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /** Used to convert symbols to primitives and strings. */
    var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
        symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /** `Object#toString` result references. */
    var boolTag$3 = '[object Boolean]',
        dateTag$3 = '[object Date]',
        mapTag$7 = '[object Map]',
        numberTag$3 = '[object Number]',
        regexpTag$3 = '[object RegExp]',
        setTag$7 = '[object Set]',
        stringTag$3 = '[object String]',
        symbolTag$2 = '[object Symbol]';

    var arrayBufferTag$3 = '[object ArrayBuffer]',
        dataViewTag$2 = '[object DataView]',
        float32Tag$1 = '[object Float32Array]',
        float64Tag$1 = '[object Float64Array]',
        int8Tag$1 = '[object Int8Array]',
        int16Tag$1 = '[object Int16Array]',
        int32Tag$1 = '[object Int32Array]',
        uint8Tag$1 = '[object Uint8Array]',
        uint8ClampedTag$1 = '[object Uint8ClampedArray]',
        uint16Tag$1 = '[object Uint16Array]',
        uint32Tag$1 = '[object Uint32Array]';

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag$3:
          return cloneArrayBuffer(object);

        case boolTag$3:
        case dateTag$3:
          return new Ctor(+object);

        case dataViewTag$2:
          return cloneDataView(object, isDeep);

        case float32Tag$1: case float64Tag$1:
        case int8Tag$1: case int16Tag$1: case int32Tag$1:
        case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
          return cloneTypedArray(object, isDeep);

        case mapTag$7:
          return new Ctor;

        case numberTag$3:
        case stringTag$3:
          return new Ctor(object);

        case regexpTag$3:
          return cloneRegExp(object);

        case setTag$7:
          return new Ctor;

        case symbolTag$2:
          return cloneSymbol(object);
      }
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /** `Object#toString` result references. */
    var mapTag$6 = '[object Map]';

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag$1(value) == mapTag$6;
    }

    /* Node.js helper references. */
    var nodeIsMap = nodeUtil && nodeUtil.isMap;

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /** `Object#toString` result references. */
    var setTag$6 = '[object Set]';

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag$1(value) == setTag$6;
    }

    /* Node.js helper references. */
    var nodeIsSet = nodeUtil && nodeUtil.isSet;

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG$7 = 1,
        CLONE_FLAT_FLAG$1 = 2,
        CLONE_SYMBOLS_FLAG$5 = 4;

    /** `Object#toString` result references. */
    var argsTag$1 = '[object Arguments]',
        arrayTag$1 = '[object Array]',
        boolTag$2 = '[object Boolean]',
        dateTag$2 = '[object Date]',
        errorTag$1 = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag$5 = '[object Map]',
        numberTag$2 = '[object Number]',
        objectTag$1 = '[object Object]',
        regexpTag$2 = '[object RegExp]',
        setTag$5 = '[object Set]',
        stringTag$2 = '[object String]',
        symbolTag$1 = '[object Symbol]',
        weakMapTag$1 = '[object WeakMap]';

    var arrayBufferTag$2 = '[object ArrayBuffer]',
        dataViewTag$1 = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values supported by `_.clone`. */
    var cloneableTags = {};
    cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] =
    cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$1] =
    cloneableTags[boolTag$2] = cloneableTags[dateTag$2] =
    cloneableTags[float32Tag] = cloneableTags[float64Tag] =
    cloneableTags[int8Tag] = cloneableTags[int16Tag] =
    cloneableTags[int32Tag] = cloneableTags[mapTag$5] =
    cloneableTags[numberTag$2] = cloneableTags[objectTag$1] =
    cloneableTags[regexpTag$2] = cloneableTags[setTag$5] =
    cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] =
    cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
    cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag$1] = cloneableTags[funcTag] =
    cloneableTags[weakMapTag$1] = false;

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG$7,
          isFlat = bitmask & CLONE_FLAT_FLAG$1,
          isFull = bitmask & CLONE_SYMBOLS_FLAG$5;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject$1(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag$1(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag$1 || tag == argsTag$1 || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /** Used to compose bitmasks for cloning. */
    var CLONE_SYMBOLS_FLAG$4 = 4;

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG$4);
    }

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG$6 = 1,
        CLONE_SYMBOLS_FLAG$3 = 4;

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG$6 | CLONE_SYMBOLS_FLAG$3);
    }

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG$5 = 1,
        CLONE_SYMBOLS_FLAG$2 = 4;

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG$5 | CLONE_SYMBOLS_FLAG$2, customizer);
    }

    /** Used to compose bitmasks for cloning. */
    var CLONE_SYMBOLS_FLAG$1 = 4;

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG$1, customizer);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function cacheHas(cache, key) {
      return cache.has(key);
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$5 = 1,
        COMPARE_UNORDERED_FLAG$3 = 2;

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */
    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);

      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }

    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */
    function setToArray(set) {
      var index = -1,
          result = Array(set.size);

      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$4 = 1,
        COMPARE_UNORDERED_FLAG$2 = 2;

    /** `Object#toString` result references. */
    var boolTag$1 = '[object Boolean]',
        dateTag$1 = '[object Date]',
        errorTag = '[object Error]',
        mapTag$4 = '[object Map]',
        numberTag$1 = '[object Number]',
        regexpTag$1 = '[object RegExp]',
        setTag$4 = '[object Set]',
        stringTag$1 = '[object String]',
        symbolTag = '[object Symbol]';

    var arrayBufferTag$1 = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]';

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag$1:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
            return false;
          }
          return true;

        case boolTag$1:
        case dateTag$1:
        case numberTag$1:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag$1:
        case stringTag$1:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag$4:
          var convert = mapToArray;

        case setTag$4:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$2;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$3 = 1;

    /** Used for built-in method references. */
    var objectProto$b = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$a = objectProto$b.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty$a.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$2 = 1;

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        objectTag = '[object Object]';

    /** Used for built-in method references. */
    var objectProto$a = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$9 = objectProto$a.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag$1(object),
          othTag = othIsArr ? arrayTag : getTag$1(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
        var objIsWrapped = objIsObj && hasOwnProperty$9.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty$9.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$1 = 1,
        COMPARE_UNORDERED_FLAG$1 = 2;

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject$1(value);
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT$7 = 'Expected a function';

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = baseIteratee;

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT$7);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG$4 = 1;

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG$4));
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * A specialized version of `baseAggregator` for arrays.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, baseIteratee(iteratee), accumulator);
      };
    }

    /** Used for built-in method references. */
    var objectProto$9 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$8 = objectProto$9.hasOwnProperty;

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty$8.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_CURRY_FLAG$1 = 8;

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG$1, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    // Assign default placeholders.
    curry.placeholder = {};

    /** Used to compose bitmasks for function metadata. */
    var WRAP_CURRY_RIGHT_FLAG = 16;

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    // Assign default placeholders.
    curryRight.placeholder = {};

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = function() {
      return root.Date.now();
    };

    /** Error message constants. */
    var FUNC_ERROR_TEXT$6 = 'Expected a function';

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$b = Math.max,
        nativeMin$b = Math.min;

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce$1(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$6);
      }
      wait = toNumber(wait) || 0;
      if (isObject$1(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax$b(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin$b(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /** Used for built-in method references. */
    var objectProto$8 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults$1 = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto$8[key]) && !hasOwnProperty$7.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject$1(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject$1(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject$1(objValue) && isObject$1(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /** Error message constants. */
    var FUNC_ERROR_TEXT$5 = 'Expected a function';

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$5);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * This function is like `arrayIncludes` except that it accepts a comparator.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @param {Function} comparator The comparator invoked per element.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */
    function arrayIncludesWith(array, value, comparator) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE$1 = 200;

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE$1) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), baseIteratee(iteratee))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, baseIteratee(predicate), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, baseIteratee(predicate), true)
        : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, castFunction(iteratee));
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
     * of key-value pairs for `object` corresponding to the property names of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the key-value pairs.
     */
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }

    /**
     * Converts `set` to its value-value pairs.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the value-value pairs.
     */
    function setToPairs(set) {
      var index = -1,
          result = Array(set.size);

      set.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }

    /** `Object#toString` result references. */
    var mapTag$3 = '[object Map]',
        setTag$3 = '[object Set]';

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag$1(object);
        if (tag == mapTag$3) {
          return mapToArray(object);
        }
        if (tag == setTag$3) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /** Used to map characters to HTML entities. */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /**
     * Used by `_.escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} chr The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    var escapeHtmlChar = basePropertyOf(htmlEscapes);

    /** Used to match HTML entities and HTML characters. */
    var reUnescapedHtml = /[&<>"']/g,
        reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
        reHasRegExpChar = RegExp(reRegExpChar.source);

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * A specialized version of `_.every` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, baseIteratee(predicate));
    }

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH$5 = 4294967295;

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH$5) : 0;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate));
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = baseIteratee(predicate);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$a = Math.max;

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax$a(length + index, 0);
      }
      return baseFindIndex(array, baseIteratee(predicate), index);
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * The base implementation of methods like `_.findKey` and `_.findLastKey`,
     * without support for iteratee shorthands, which iterates over `collection`
     * using `eachFunc`.
     *
     * @private
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, baseIteratee(predicate), baseForOwn);
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$9 = Math.max,
        nativeMin$a = Math.min;

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax$9(length + index, 0)
          : nativeMin$a(index, length - 1);
      }
      return baseFindIndex(array, baseIteratee(predicate), index, true);
    }

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, baseIteratee(predicate), baseForOwnRight);
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee));
    }

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /** Used as references for various `Number` constants. */
    var INFINITY$2 = 1 / 0;

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY$2);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /** Used as references for various `Number` constants. */
    var INFINITY$1 = 1 / 0;

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY$1) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_FLIP_FLAG = 512;

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /** Error message constants. */
    var FUNC_ERROR_TEXT$4 = 'Expected a function';

    /** Used to compose bitmasks for function metadata. */
    var WRAP_CURRY_FLAG = 8,
        WRAP_PARTIAL_FLAG$1 = 32,
        WRAP_ARY_FLAG = 128,
        WRAP_REARG_FLAG$1 = 256;

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT$4);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG$1 | WRAP_REARG_FLAG$1) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, castFunction(iteratee), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, castFunction(iteratee), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, castFunction(iteratee));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, castFunction(iteratee));
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /** Used for built-in method references. */
    var objectProto$7 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty$6.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /** Used for built-in method references. */
    var objectProto$6 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty$5.call(object, key);
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$8 = Math.max,
        nativeMin$9 = Math.min;

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin$9(start, end) && number < nativeMax$8(start, end);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /** `Object#toString` result references. */
    var stringTag = '[object String]';

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$7 = Math.max;

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax$7(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$6 = Math.max;

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax$6(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMin$8 = Math.min;

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin$8(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, baseIteratee(iteratee))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$5.toString;

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString$1.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto$4.toString;

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty$4.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, baseIteratee);

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    var arrayBufferTag = '[object ArrayBuffer]';

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /* Node.js helper references. */
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /** `Object#toString` result references. */
    var boolTag = '[object Boolean]';

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /** `Object#toString` result references. */
    var dateTag = '[object Date]';

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /* Node.js helper references. */
    var nodeIsDate = nodeUtil && nodeUtil.isDate;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /** `Object#toString` result references. */
    var mapTag$2 = '[object Map]',
        setTag$2 = '[object Set]';

    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag$1(value);
      if (tag == mapTag$2 || tag == setTag$2) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty$3.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsFinite = root.isFinite;

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite$1(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /** `Object#toString` result references. */
    var numberTag = '[object Number]';

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN$1(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /** Error message constants. */
    var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.';

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /** `Object#toString` result references. */
    var regexpTag = '[object RegExp]';

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /* Node.js helper references. */
    var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$3 = 9007199254740991;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER$3 && value <= MAX_SAFE_INTEGER$3;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /** `Object#toString` result references. */
    var weakMapTag = '[object WeakMap]';

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag$1(value) == weakMapTag;
    }

    /** `Object#toString` result references. */
    var weakSetTag = '[object WeakSet]';

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG$3 = 1;

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG$3));
    }

    /** Used for built-in method references. */
    var arrayProto$4 = Array.prototype;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeJoin = arrayProto$4.join;

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * A specialized version of `_.lastIndexOf` which performs strict equality
     * comparisons of values, i.e. `===`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$5 = Math.max,
        nativeMin$7 = Math.min;

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax$5(length + index, 0) : nativeMin$7(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = baseIteratee(iteratee);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = baseIteratee(iteratee);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG$2 = 1;

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG$2));
    }

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG$1 = 1;

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG$1));
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, baseIteratee(iteratee), baseGt)
        : undefined;
    }

    /**
     * The base implementation of `_.sum` and `_.sumBy` without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function baseSum(array, iteratee) {
      var result,
          index = -1,
          length = array.length;

      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined) {
          result = result === undefined ? current : (result + current);
        }
      }
      return result;
    }

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /**
     * The base implementation of `_.mean` and `_.meanBy` without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the mean.
     */
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? (baseSum(array, iteratee) / length) : NAN;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, baseIteratee(iteratee));
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, baseIteratee(iteratee), baseLt)
        : undefined;
    }

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin$1(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      var chain = !(isObject$1(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /** Error message constants. */
    var FUNC_ERROR_TEXT$3 = 'Expected a function';

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$3);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Converts `iterator` to an array.
     *
     * @private
     * @param {Object} iterator The iterator to convert.
     * @returns {Array} Returns the converted array.
     */
    function iteratorToArray(iterator) {
      var data,
          result = [];

      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }

    /** `Object#toString` result references. */
    var mapTag$1 = '[object Map]',
        setTag$1 = '[object Set]';

    /** Built-in value references. */
    var symIterator$1 = Symbol$1 ? Symbol$1.iterator : undefined;

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator$1 && value[symIterator$1]) {
        return iteratorToArray(value[symIterator$1]());
      }
      var tag = getTag$1(value),
          func = tag == mapTag$1 ? mapToArray : (tag == setTag$1 ? setToArray : values);

      return func(value);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG = 1,
        CLONE_FLAT_FLAG = 2,
        CLONE_SYMBOLS_FLAG = 4;

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject$1(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          return object;
        }

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject$1(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = baseIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(baseIteratee(predicate)));
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * The base implementation of `_.sortBy` which uses `comparer` to define the
     * sort order of `array` and replaces criteria objects with their corresponding
     * values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */
    function baseSortBy(array, comparer) {
      var length = array.length;

      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            }
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }

      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMin$6 = Math.min;

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(baseIteratee))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(baseIteratee));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin$6(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */
    var overSome = createOver(arraySome);

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$2 = 9007199254740991;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeFloor$3 = Math.floor;

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER$2) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor$3(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * Gets the size of an ASCII `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */
    var asciiSize = baseProperty('length');

    /** Used to compose unicode character classes. */
    var rsAstralRange = '\\ud800-\\udfff',
        rsComboMarksRange = '\\u0300-\\u036f',
        reComboHalfMarksRange = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange = '\\u20d0-\\u20ff',
        rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
        rsVarRange = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsAstral = '[' + rsAstralRange + ']',
        rsCombo = '[' + rsComboRange + ']',
        rsFitz = '\\ud83c[\\udffb-\\udfff]',
        rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
        rsNonAstral = '[^' + rsAstralRange + ']',
        rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ = '\\u200d';

    /** Used to compose unicode regexes. */
    var reOptMod = rsModifier + '?',
        rsOptVar = '[' + rsVarRange + ']?',
        rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

    /**
     * Gets the size of a Unicode `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }

    /**
     * Gets the number of symbols in `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the string size.
     */
    function stringSize(string) {
      return hasUnicode(string)
        ? unicodeSize(string)
        : asciiSize(string);
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil$2 = Math.ceil;

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil$2(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil$1 = Math.ceil,
        nativeFloor$2 = Math.floor;

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor$2(mid), chars) +
        string +
        createPadding(nativeCeil$1(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /** Used to match leading whitespace. */
    var reTrimStart$1 = /^\s+/;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeParseInt = root.parseInt;

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt$1(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart$1, ''), radix || 0);
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_PARTIAL_FLAG = 32;

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    // Assign default placeholders.
    partial.placeholder = {};

    /** Used to compose bitmasks for function metadata. */
    var WRAP_PARTIAL_RIGHT_FLAG = 64;

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    // Assign default placeholders.
    partialRight.placeholder = {};

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * This function is like `baseIndexOf` except that it accepts a comparator.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @param {Function} comparator The comparator invoked per element.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /** Used for built-in method references. */
    var arrayProto$3 = Array.prototype;

    /** Built-in value references. */
    var splice$1 = arrayProto$3.splice;

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice$1.call(seen, fromIndex, 1);
          }
          splice$1.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, baseIteratee(iteratee))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /** Used for built-in method references. */
    var arrayProto$2 = Array.prototype;

    /** Built-in value references. */
    var splice = arrayProto$2.splice;

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeFloor$1 = Math.floor,
        nativeRandom$1 = Math.random;

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor$1(nativeRandom$1() * (upper - lower + 1));
    }

    /** Built-in method references without a dependency on `root`. */
    var freeParseFloat = parseFloat;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMin$5 = Math.min,
        nativeRandom = Math.random;

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin$5(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeMax$4 = Math.max;

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax$4(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /** Used to compose bitmasks for function metadata. */
    var WRAP_REARG_FLAG = 256;

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * The base implementation of `_.reduce` and `_.reduceRight`, without support
     * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initAccum Specify using the first or last element of
     *  `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initAccum
          ? (initAccum = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, baseIteratee(iteratee), accumulator, initAccum, baseEach);
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the last element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, baseIteratee(iteratee), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(baseIteratee(predicate)));
    }

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = baseIteratee(predicate);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace$1() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT$2 = 'Expected a function';

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$2);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /** Used for built-in method references. */
    var arrayProto$1 = Array.prototype;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeReverse = arrayProto$1.reverse;

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /** `Object#toString` result references. */
    var mapTag = '[object Map]',
        setTag = '[object Set]';

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag$1(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, baseIteratee(predicate));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH$4 = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH$4 - 1;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeFloor = Math.floor,
        nativeMin$4 = Math.min;

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      var low = 0,
          high = array == null ? 0 : array.length;
      if (high === 0) {
        return 0;
      }

      value = iteratee(value);
      var valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin$4(high, MAX_ARRAY_INDEX);
    }

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH$3 = 4294967295,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH$3 >>> 1;

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, baseIteratee(iteratee));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, baseIteratee(iteratee), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, baseIteratee(iteratee))
        : [];
    }

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH$2 = 4294967295;

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH$2 : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT$1 = 'Expected a function';

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$3 = Math.max;

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      start = start == null ? 0 : nativeMax$3(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, baseIteratee(iteratee))
        : 0;
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, baseIteratee(predicate), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, baseIteratee(predicate))
        : [];
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /** Used for built-in method references. */
    var objectProto$2 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto$2[key]) && !hasOwnProperty$2.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /** Used to escape characters for inclusion in compiled string literals. */
    var stringEscapes = {
      '\\': '\\',
      "'": "'",
      '\n': 'n',
      '\r': 'r',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    /**
     * Used by `_.template` to escape characters for inclusion in compiled string literals.
     *
     * @private
     * @param {string} chr The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeStringChar(chr) {
      return '\\' + stringEscapes[chr];
    }

    /** Used to match template delimiters. */
    var reInterpolate = /<%=([\s\S]+?)%>/g;

    /** Used to match template delimiters. */
    var reEscape = /<%-([\s\S]+?)%>/g;

    /** Used to match template delimiters. */
    var reEvaluate = /<%([\s\S]+?)%>/g;

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    var templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': { 'escape': escape }
      }
    };

    /** Error message constants. */
    var INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

    /** Used to match empty string literals in compiled template source. */
    var reEmptyStringLeading = /\b__p \+= '';/g,
        reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
        reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

    /**
     * Used to validate the `validate` option in `_.template` variable.
     *
     * Forbids characters which could potentially change the meaning of the function argument definition:
     * - "()," (modification of function parameters)
     * - "=" (default value)
     * - "[]{}" (destructuring of function parameters)
     * - "/" (beginning of a comment)
     * - whitespace
     */
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

    /**
     * Used to match
     * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
     */
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

    /** Used to ensure capturing order of template delimiters. */
    var reNoMatch = /($^)/;

    /** Used to match unescaped characters in compiled string literals. */
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = templateSettings.imports._.templateSettings || templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
      // and escape the comment, thus injecting code that gets evaled.
      var sourceURL = hasOwnProperty$1.call(options, 'sourceURL')
        ? ('//# sourceURL=' +
           (options.sourceURL + '').replace(/\s/g, ' ') +
           '\n')
        : '';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = hasOwnProperty$1.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Throw an error if a forbidden character was found in `variable`, to prevent
      // potential command injection attacks.
      else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
      }

      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject$1(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce$1(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH$1 = 4294967295;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMin$3 = Math.min;

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER$1) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH$1,
          length = nativeMin$3(n, MAX_ARRAY_LENGTH$1);

      iteratee = castFunction(iteratee);
      n -= MAX_ARRAY_LENGTH$1;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = baseIteratee(iteratee);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject$1(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
     * that is not found in the character symbols.
     *
     * @private
     * @param {Array} strSymbols The string symbols to inspect.
     * @param {Array} chrSymbols The character symbols to find.
     * @returns {number} Returns the index of the last unmatched string symbol.
     */
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;

      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
      return index;
    }

    /**
     * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
     * that is not found in the character symbols.
     *
     * @private
     * @param {Array} strSymbols The string symbols to inspect.
     * @param {Array} chrSymbols The character symbols to find.
     * @returns {number} Returns the index of the first unmatched string symbol.
     */
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1,
          length = strSymbols.length;

      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
      return index;
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return baseTrim(string);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.slice(0, trimmedEndIndex(string) + 1);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /** Used to match leading whitespace. */
    var reTrimStart = /^\s+/;

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /** Used as default options for `_.truncate`. */
    var DEFAULT_TRUNC_LENGTH = 30,
        DEFAULT_TRUNC_OMISSION = '...';

    /** Used to match `RegExp` flags from their coerced string values. */
    var reFlags = /\w*$/;

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate$1(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject$1(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /** Used to map HTML entities to characters. */
    var htmlUnescapes = {
      '&amp;': '&',
      '&lt;': '<',
      '&gt;': '>',
      '&quot;': '"',
      '&#39;': "'"
    };

    /**
     * Used by `_.unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} chr The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

    /** Used to match HTML entities and HTML characters. */
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
        reHasEscapedHtml = RegExp(reEscapedHtml.source);

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0;

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set$1 && (1 / setToArray(new Set$1([,-0]))[1]) == INFINITY) ? noop$1 : function(values) {
      return new Set$1(values);
    };

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), baseIteratee(iteratee));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, baseIteratee(iteratee)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId$1(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$2 = Math.max;

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax$2(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), baseIteratee(iteratee));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    var array = {
      chunk, compact, concat, difference, differenceBy,
      differenceWith, drop, dropRight, dropRightWhile, dropWhile,
      fill, findIndex, findLastIndex, first: head, flatten,
      flattenDeep, flattenDepth, fromPairs, head, indexOf,
      initial, intersection, intersectionBy, intersectionWith, join,
      last, lastIndexOf, nth, pull, pullAll,
      pullAllBy, pullAllWith, pullAt, remove, reverse,
      slice, sortedIndex, sortedIndexBy, sortedIndexOf, sortedLastIndex,
      sortedLastIndexBy, sortedLastIndexOf, sortedUniq, sortedUniqBy, tail,
      take, takeRight, takeRightWhile, takeWhile, union,
      unionBy, unionWith, uniq, uniqBy, uniqWith,
      unzip, unzipWith, without, xor, xorBy,
      xorWith, zip, zipObject, zipObjectDeep, zipWith
    };

    var collection = {
      countBy, each: forEach, eachRight: forEachRight, every, filter,
      find, findLast, flatMap, flatMapDeep, flatMapDepth,
      forEach, forEachRight, groupBy, includes, invokeMap,
      keyBy, map, orderBy, partition, reduce,
      reduceRight, reject, sample, sampleSize, shuffle,
      size, some, sortBy
    };

    var date = {
      now
    };

    var func = {
      after, ary, before, bind: bind$1, bindKey,
      curry, curryRight, debounce: debounce$1, defer, delay,
      flip, memoize, negate, once, overArgs,
      partial, partialRight, rearg, rest, spread,
      throttle, unary, wrap
    };

    var lang = {
      castArray, clone, cloneDeep, cloneDeepWith, cloneWith,
      conformsTo, eq, gt, gte, isArguments,
      isArray, isArrayBuffer, isArrayLike, isArrayLikeObject, isBoolean,
      isBuffer, isDate, isElement, isEmpty, isEqual,
      isEqualWith, isError, isFinite: isFinite$1, isFunction, isInteger,
      isLength, isMap, isMatch, isMatchWith, isNaN: isNaN$1,
      isNative, isNil, isNull, isNumber, isObject: isObject$1,
      isObjectLike, isPlainObject, isRegExp, isSafeInteger, isSet,
      isString, isSymbol, isTypedArray, isUndefined, isWeakMap,
      isWeakSet, lt, lte, toArray, toFinite,
      toInteger, toLength, toNumber, toPlainObject, toSafeInteger,
      toString
    };

    var math = {
      add, ceil, divide, floor, max,
      maxBy, mean, meanBy, min, minBy,
      multiply, round, subtract, sum, sumBy
    };

    var number = {
      clamp, inRange, random
    };

    var object = {
      assign, assignIn, assignInWith, assignWith, at,
      create, defaults: defaults$1, defaultsDeep, entries: toPairs, entriesIn: toPairsIn,
      extend: assignIn, extendWith: assignInWith, findKey, findLastKey, forIn,
      forInRight, forOwn, forOwnRight, functions, functionsIn,
      get, has, hasIn, invert, invertBy,
      invoke, keys, keysIn, mapKeys, mapValues,
      merge, mergeWith, omit, omitBy, pick,
      pickBy, result, set, setWith, toPairs,
      toPairsIn, transform, unset, update, updateWith,
      values, valuesIn
    };

    var seq = {
      at: wrapperAt, chain, commit: wrapperCommit, lodash, next: wrapperNext,
      plant: wrapperPlant, reverse: wrapperReverse, tap, thru, toIterator: wrapperToIterator,
      toJSON: wrapperValue, value: wrapperValue, valueOf: wrapperValue, wrapperChain
    };

    var string = {
      camelCase, capitalize, deburr, endsWith, escape,
      escapeRegExp, kebabCase, lowerCase, lowerFirst, pad,
      padEnd, padStart, parseInt: parseInt$1, repeat, replace: replace$1,
      snakeCase, split, startCase, startsWith, template,
      templateSettings, toLower, toUpper, trim, trimEnd,
      trimStart, truncate: truncate$1, unescape, upperCase, upperFirst,
      words
    };

    var util$1 = {
      attempt, bindAll, cond, conforms, constant,
      defaultTo, flow, flowRight, identity, iteratee,
      matches, matchesProperty, method, methodOf, mixin: mixin$1,
      noop: noop$1, nthArg, over, overEvery, overSome,
      property, propertyOf, range, rangeRight, stubArray,
      stubFalse, stubObject, stubString, stubTrue, times,
      toPath, uniqueId: uniqueId$1
    };

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$1 = Math.max,
        nativeMin$2 = Math.min;

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin$2(end, start + size); break;
          case 'takeRight': start = nativeMax$1(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /** Used to indicate the type of lazy iteratees. */
    var LAZY_FILTER_FLAG$1 = 1,
        LAZY_MAP_FLAG = 2;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMin$1 = Math.min;

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin$1(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG$1) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    /**
     * @license
     * Lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="es" -o ./`
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */

    /** Used as the semantic version number. */
    var VERSION = '4.17.21';

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_KEY_FLAG = 2;

    /** Used to indicate the type of lazy iteratees. */
    var LAZY_FILTER_FLAG = 1,
        LAZY_WHILE_FLAG = 3;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = 4294967295;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Built-in value references. */
    var symIterator = Symbol$1 ? Symbol$1.iterator : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max,
        nativeMin = Math.min;

    // wrap `_.mixin` so it works when provided only one argument
    var mixin = (function(func) {
      return function(object, source, options) {
        if (options == null) {
          var isObj = isObject$1(source),
              props = isObj && keys(source),
              methodNames = props && props.length && baseFunctions(source, props);

          if (!(methodNames ? methodNames.length : isObj)) {
            options = source;
            source = object;
            object = this;
          }
        }
        return func(object, source, options);
      };
    }(mixin$1));

    // Add methods that return wrapped values in chain sequences.
    lodash.after = func.after;
    lodash.ary = func.ary;
    lodash.assign = object.assign;
    lodash.assignIn = object.assignIn;
    lodash.assignInWith = object.assignInWith;
    lodash.assignWith = object.assignWith;
    lodash.at = object.at;
    lodash.before = func.before;
    lodash.bind = func.bind;
    lodash.bindAll = util$1.bindAll;
    lodash.bindKey = func.bindKey;
    lodash.castArray = lang.castArray;
    lodash.chain = seq.chain;
    lodash.chunk = array.chunk;
    lodash.compact = array.compact;
    lodash.concat = array.concat;
    lodash.cond = util$1.cond;
    lodash.conforms = util$1.conforms;
    lodash.constant = util$1.constant;
    lodash.countBy = collection.countBy;
    lodash.create = object.create;
    lodash.curry = func.curry;
    lodash.curryRight = func.curryRight;
    lodash.debounce = func.debounce;
    lodash.defaults = object.defaults;
    lodash.defaultsDeep = object.defaultsDeep;
    lodash.defer = func.defer;
    lodash.delay = func.delay;
    lodash.difference = array.difference;
    lodash.differenceBy = array.differenceBy;
    lodash.differenceWith = array.differenceWith;
    lodash.drop = array.drop;
    lodash.dropRight = array.dropRight;
    lodash.dropRightWhile = array.dropRightWhile;
    lodash.dropWhile = array.dropWhile;
    lodash.fill = array.fill;
    lodash.filter = collection.filter;
    lodash.flatMap = collection.flatMap;
    lodash.flatMapDeep = collection.flatMapDeep;
    lodash.flatMapDepth = collection.flatMapDepth;
    lodash.flatten = array.flatten;
    lodash.flattenDeep = array.flattenDeep;
    lodash.flattenDepth = array.flattenDepth;
    lodash.flip = func.flip;
    lodash.flow = util$1.flow;
    lodash.flowRight = util$1.flowRight;
    lodash.fromPairs = array.fromPairs;
    lodash.functions = object.functions;
    lodash.functionsIn = object.functionsIn;
    lodash.groupBy = collection.groupBy;
    lodash.initial = array.initial;
    lodash.intersection = array.intersection;
    lodash.intersectionBy = array.intersectionBy;
    lodash.intersectionWith = array.intersectionWith;
    lodash.invert = object.invert;
    lodash.invertBy = object.invertBy;
    lodash.invokeMap = collection.invokeMap;
    lodash.iteratee = util$1.iteratee;
    lodash.keyBy = collection.keyBy;
    lodash.keys = keys;
    lodash.keysIn = object.keysIn;
    lodash.map = collection.map;
    lodash.mapKeys = object.mapKeys;
    lodash.mapValues = object.mapValues;
    lodash.matches = util$1.matches;
    lodash.matchesProperty = util$1.matchesProperty;
    lodash.memoize = func.memoize;
    lodash.merge = object.merge;
    lodash.mergeWith = object.mergeWith;
    lodash.method = util$1.method;
    lodash.methodOf = util$1.methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = util$1.nthArg;
    lodash.omit = object.omit;
    lodash.omitBy = object.omitBy;
    lodash.once = func.once;
    lodash.orderBy = collection.orderBy;
    lodash.over = util$1.over;
    lodash.overArgs = func.overArgs;
    lodash.overEvery = util$1.overEvery;
    lodash.overSome = util$1.overSome;
    lodash.partial = func.partial;
    lodash.partialRight = func.partialRight;
    lodash.partition = collection.partition;
    lodash.pick = object.pick;
    lodash.pickBy = object.pickBy;
    lodash.property = util$1.property;
    lodash.propertyOf = util$1.propertyOf;
    lodash.pull = array.pull;
    lodash.pullAll = array.pullAll;
    lodash.pullAllBy = array.pullAllBy;
    lodash.pullAllWith = array.pullAllWith;
    lodash.pullAt = array.pullAt;
    lodash.range = util$1.range;
    lodash.rangeRight = util$1.rangeRight;
    lodash.rearg = func.rearg;
    lodash.reject = collection.reject;
    lodash.remove = array.remove;
    lodash.rest = func.rest;
    lodash.reverse = array.reverse;
    lodash.sampleSize = collection.sampleSize;
    lodash.set = object.set;
    lodash.setWith = object.setWith;
    lodash.shuffle = collection.shuffle;
    lodash.slice = array.slice;
    lodash.sortBy = collection.sortBy;
    lodash.sortedUniq = array.sortedUniq;
    lodash.sortedUniqBy = array.sortedUniqBy;
    lodash.split = string.split;
    lodash.spread = func.spread;
    lodash.tail = array.tail;
    lodash.take = array.take;
    lodash.takeRight = array.takeRight;
    lodash.takeRightWhile = array.takeRightWhile;
    lodash.takeWhile = array.takeWhile;
    lodash.tap = seq.tap;
    lodash.throttle = func.throttle;
    lodash.thru = thru;
    lodash.toArray = lang.toArray;
    lodash.toPairs = object.toPairs;
    lodash.toPairsIn = object.toPairsIn;
    lodash.toPath = util$1.toPath;
    lodash.toPlainObject = lang.toPlainObject;
    lodash.transform = object.transform;
    lodash.unary = func.unary;
    lodash.union = array.union;
    lodash.unionBy = array.unionBy;
    lodash.unionWith = array.unionWith;
    lodash.uniq = array.uniq;
    lodash.uniqBy = array.uniqBy;
    lodash.uniqWith = array.uniqWith;
    lodash.unset = object.unset;
    lodash.unzip = array.unzip;
    lodash.unzipWith = array.unzipWith;
    lodash.update = object.update;
    lodash.updateWith = object.updateWith;
    lodash.values = object.values;
    lodash.valuesIn = object.valuesIn;
    lodash.without = array.without;
    lodash.words = string.words;
    lodash.wrap = func.wrap;
    lodash.xor = array.xor;
    lodash.xorBy = array.xorBy;
    lodash.xorWith = array.xorWith;
    lodash.zip = array.zip;
    lodash.zipObject = array.zipObject;
    lodash.zipObjectDeep = array.zipObjectDeep;
    lodash.zipWith = array.zipWith;

    // Add aliases.
    lodash.entries = object.toPairs;
    lodash.entriesIn = object.toPairsIn;
    lodash.extend = object.assignIn;
    lodash.extendWith = object.assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = math.add;
    lodash.attempt = util$1.attempt;
    lodash.camelCase = string.camelCase;
    lodash.capitalize = string.capitalize;
    lodash.ceil = math.ceil;
    lodash.clamp = number.clamp;
    lodash.clone = lang.clone;
    lodash.cloneDeep = lang.cloneDeep;
    lodash.cloneDeepWith = lang.cloneDeepWith;
    lodash.cloneWith = lang.cloneWith;
    lodash.conformsTo = lang.conformsTo;
    lodash.deburr = string.deburr;
    lodash.defaultTo = util$1.defaultTo;
    lodash.divide = math.divide;
    lodash.endsWith = string.endsWith;
    lodash.eq = lang.eq;
    lodash.escape = string.escape;
    lodash.escapeRegExp = string.escapeRegExp;
    lodash.every = collection.every;
    lodash.find = collection.find;
    lodash.findIndex = array.findIndex;
    lodash.findKey = object.findKey;
    lodash.findLast = collection.findLast;
    lodash.findLastIndex = array.findLastIndex;
    lodash.findLastKey = object.findLastKey;
    lodash.floor = math.floor;
    lodash.forEach = collection.forEach;
    lodash.forEachRight = collection.forEachRight;
    lodash.forIn = object.forIn;
    lodash.forInRight = object.forInRight;
    lodash.forOwn = object.forOwn;
    lodash.forOwnRight = object.forOwnRight;
    lodash.get = object.get;
    lodash.gt = lang.gt;
    lodash.gte = lang.gte;
    lodash.has = object.has;
    lodash.hasIn = object.hasIn;
    lodash.head = array.head;
    lodash.identity = identity;
    lodash.includes = collection.includes;
    lodash.indexOf = array.indexOf;
    lodash.inRange = number.inRange;
    lodash.invoke = object.invoke;
    lodash.isArguments = lang.isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = lang.isArrayBuffer;
    lodash.isArrayLike = lang.isArrayLike;
    lodash.isArrayLikeObject = lang.isArrayLikeObject;
    lodash.isBoolean = lang.isBoolean;
    lodash.isBuffer = lang.isBuffer;
    lodash.isDate = lang.isDate;
    lodash.isElement = lang.isElement;
    lodash.isEmpty = lang.isEmpty;
    lodash.isEqual = lang.isEqual;
    lodash.isEqualWith = lang.isEqualWith;
    lodash.isError = lang.isError;
    lodash.isFinite = lang.isFinite;
    lodash.isFunction = lang.isFunction;
    lodash.isInteger = lang.isInteger;
    lodash.isLength = lang.isLength;
    lodash.isMap = lang.isMap;
    lodash.isMatch = lang.isMatch;
    lodash.isMatchWith = lang.isMatchWith;
    lodash.isNaN = lang.isNaN;
    lodash.isNative = lang.isNative;
    lodash.isNil = lang.isNil;
    lodash.isNull = lang.isNull;
    lodash.isNumber = lang.isNumber;
    lodash.isObject = isObject$1;
    lodash.isObjectLike = lang.isObjectLike;
    lodash.isPlainObject = lang.isPlainObject;
    lodash.isRegExp = lang.isRegExp;
    lodash.isSafeInteger = lang.isSafeInteger;
    lodash.isSet = lang.isSet;
    lodash.isString = lang.isString;
    lodash.isSymbol = lang.isSymbol;
    lodash.isTypedArray = lang.isTypedArray;
    lodash.isUndefined = lang.isUndefined;
    lodash.isWeakMap = lang.isWeakMap;
    lodash.isWeakSet = lang.isWeakSet;
    lodash.join = array.join;
    lodash.kebabCase = string.kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = array.lastIndexOf;
    lodash.lowerCase = string.lowerCase;
    lodash.lowerFirst = string.lowerFirst;
    lodash.lt = lang.lt;
    lodash.lte = lang.lte;
    lodash.max = math.max;
    lodash.maxBy = math.maxBy;
    lodash.mean = math.mean;
    lodash.meanBy = math.meanBy;
    lodash.min = math.min;
    lodash.minBy = math.minBy;
    lodash.stubArray = util$1.stubArray;
    lodash.stubFalse = util$1.stubFalse;
    lodash.stubObject = util$1.stubObject;
    lodash.stubString = util$1.stubString;
    lodash.stubTrue = util$1.stubTrue;
    lodash.multiply = math.multiply;
    lodash.nth = array.nth;
    lodash.noop = util$1.noop;
    lodash.now = date.now;
    lodash.pad = string.pad;
    lodash.padEnd = string.padEnd;
    lodash.padStart = string.padStart;
    lodash.parseInt = string.parseInt;
    lodash.random = number.random;
    lodash.reduce = collection.reduce;
    lodash.reduceRight = collection.reduceRight;
    lodash.repeat = string.repeat;
    lodash.replace = string.replace;
    lodash.result = object.result;
    lodash.round = math.round;
    lodash.sample = collection.sample;
    lodash.size = collection.size;
    lodash.snakeCase = string.snakeCase;
    lodash.some = collection.some;
    lodash.sortedIndex = array.sortedIndex;
    lodash.sortedIndexBy = array.sortedIndexBy;
    lodash.sortedIndexOf = array.sortedIndexOf;
    lodash.sortedLastIndex = array.sortedLastIndex;
    lodash.sortedLastIndexBy = array.sortedLastIndexBy;
    lodash.sortedLastIndexOf = array.sortedLastIndexOf;
    lodash.startCase = string.startCase;
    lodash.startsWith = string.startsWith;
    lodash.subtract = math.subtract;
    lodash.sum = math.sum;
    lodash.sumBy = math.sumBy;
    lodash.template = string.template;
    lodash.times = util$1.times;
    lodash.toFinite = lang.toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = lang.toLength;
    lodash.toLower = string.toLower;
    lodash.toNumber = lang.toNumber;
    lodash.toSafeInteger = lang.toSafeInteger;
    lodash.toString = lang.toString;
    lodash.toUpper = string.toUpper;
    lodash.trim = string.trim;
    lodash.trimEnd = string.trimEnd;
    lodash.trimStart = string.trimStart;
    lodash.truncate = string.truncate;
    lodash.unescape = string.unescape;
    lodash.uniqueId = util$1.uniqueId;
    lodash.upperCase = string.upperCase;
    lodash.upperFirst = string.upperFirst;

    // Add aliases.
    lodash.each = collection.forEach;
    lodash.eachRight = collection.forEachRight;
    lodash.first = array.head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;
    (lodash.templateSettings = string.templateSettings).imports._ = lodash;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': baseIteratee(iteratee),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(baseIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = seq.at;
    lodash.prototype.chain = seq.wrapperChain;
    lodash.prototype.commit = seq.commit;
    lodash.prototype.next = seq.next;
    lodash.prototype.plant = seq.plant;
    lodash.prototype.reverse = seq.reverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = seq.value;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = seq.toIterator;
    }

    /**
     * @license
     * Lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="es" -o ./`
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */

    var _ = /*#__PURE__*/Object.freeze({
        __proto__: null,
        add: add,
        after: after,
        ary: ary,
        assign: assign,
        assignIn: assignIn,
        assignInWith: assignInWith,
        assignWith: assignWith,
        at: at,
        attempt: attempt,
        before: before,
        bind: bind$1,
        bindAll: bindAll,
        bindKey: bindKey,
        camelCase: camelCase,
        capitalize: capitalize,
        castArray: castArray,
        ceil: ceil,
        chain: chain,
        chunk: chunk,
        clamp: clamp,
        clone: clone,
        cloneDeep: cloneDeep,
        cloneDeepWith: cloneDeepWith,
        cloneWith: cloneWith,
        commit: wrapperCommit,
        compact: compact,
        concat: concat,
        cond: cond,
        conforms: conforms,
        conformsTo: conformsTo,
        constant: constant,
        countBy: countBy,
        create: create,
        curry: curry,
        curryRight: curryRight,
        debounce: debounce$1,
        deburr: deburr,
        defaultTo: defaultTo,
        defaults: defaults$1,
        defaultsDeep: defaultsDeep,
        defer: defer,
        delay: delay,
        difference: difference,
        differenceBy: differenceBy,
        differenceWith: differenceWith,
        divide: divide,
        drop: drop,
        dropRight: dropRight,
        dropRightWhile: dropRightWhile,
        dropWhile: dropWhile,
        each: forEach,
        eachRight: forEachRight,
        endsWith: endsWith,
        entries: toPairs,
        entriesIn: toPairsIn,
        eq: eq,
        escape: escape,
        escapeRegExp: escapeRegExp,
        every: every,
        extend: assignIn,
        extendWith: assignInWith,
        fill: fill,
        filter: filter,
        find: find,
        findIndex: findIndex,
        findKey: findKey,
        findLast: findLast,
        findLastIndex: findLastIndex,
        findLastKey: findLastKey,
        first: head,
        flatMap: flatMap,
        flatMapDeep: flatMapDeep,
        flatMapDepth: flatMapDepth,
        flatten: flatten,
        flattenDeep: flattenDeep,
        flattenDepth: flattenDepth,
        flip: flip,
        floor: floor,
        flow: flow,
        flowRight: flowRight,
        forEach: forEach,
        forEachRight: forEachRight,
        forIn: forIn,
        forInRight: forInRight,
        forOwn: forOwn,
        forOwnRight: forOwnRight,
        fromPairs: fromPairs,
        functions: functions,
        functionsIn: functionsIn,
        get: get,
        groupBy: groupBy,
        gt: gt,
        gte: gte,
        has: has,
        hasIn: hasIn,
        head: head,
        identity: identity,
        inRange: inRange,
        includes: includes,
        indexOf: indexOf,
        initial: initial,
        intersection: intersection,
        intersectionBy: intersectionBy,
        intersectionWith: intersectionWith,
        invert: invert,
        invertBy: invertBy,
        invoke: invoke,
        invokeMap: invokeMap,
        isArguments: isArguments,
        isArray: isArray,
        isArrayBuffer: isArrayBuffer,
        isArrayLike: isArrayLike,
        isArrayLikeObject: isArrayLikeObject,
        isBoolean: isBoolean,
        isBuffer: isBuffer,
        isDate: isDate,
        isElement: isElement,
        isEmpty: isEmpty,
        isEqual: isEqual,
        isEqualWith: isEqualWith,
        isError: isError,
        isFinite: isFinite$1,
        isFunction: isFunction,
        isInteger: isInteger,
        isLength: isLength,
        isMap: isMap,
        isMatch: isMatch,
        isMatchWith: isMatchWith,
        isNaN: isNaN$1,
        isNative: isNative,
        isNil: isNil,
        isNull: isNull,
        isNumber: isNumber,
        isObject: isObject$1,
        isObjectLike: isObjectLike,
        isPlainObject: isPlainObject,
        isRegExp: isRegExp,
        isSafeInteger: isSafeInteger,
        isSet: isSet,
        isString: isString,
        isSymbol: isSymbol,
        isTypedArray: isTypedArray,
        isUndefined: isUndefined,
        isWeakMap: isWeakMap,
        isWeakSet: isWeakSet,
        iteratee: iteratee,
        join: join,
        kebabCase: kebabCase,
        keyBy: keyBy,
        keys: keys,
        keysIn: keysIn,
        last: last,
        lastIndexOf: lastIndexOf,
        lodash: lodash,
        lowerCase: lowerCase,
        lowerFirst: lowerFirst,
        lt: lt,
        lte: lte,
        map: map,
        mapKeys: mapKeys,
        mapValues: mapValues,
        matches: matches,
        matchesProperty: matchesProperty,
        max: max,
        maxBy: maxBy,
        mean: mean,
        meanBy: meanBy,
        memoize: memoize,
        merge: merge,
        mergeWith: mergeWith,
        method: method,
        methodOf: methodOf,
        min: min,
        minBy: minBy,
        mixin: mixin$1,
        multiply: multiply,
        negate: negate,
        next: wrapperNext,
        noop: noop$1,
        now: now,
        nth: nth,
        nthArg: nthArg,
        omit: omit,
        omitBy: omitBy,
        once: once,
        orderBy: orderBy,
        over: over,
        overArgs: overArgs,
        overEvery: overEvery,
        overSome: overSome,
        pad: pad,
        padEnd: padEnd,
        padStart: padStart,
        parseInt: parseInt$1,
        partial: partial,
        partialRight: partialRight,
        partition: partition,
        pick: pick,
        pickBy: pickBy,
        plant: wrapperPlant,
        property: property,
        propertyOf: propertyOf,
        pull: pull,
        pullAll: pullAll,
        pullAllBy: pullAllBy,
        pullAllWith: pullAllWith,
        pullAt: pullAt,
        random: random,
        range: range,
        rangeRight: rangeRight,
        rearg: rearg,
        reduce: reduce,
        reduceRight: reduceRight,
        reject: reject,
        remove: remove,
        repeat: repeat,
        replace: replace$1,
        rest: rest,
        result: result,
        reverse: reverse,
        round: round,
        sample: sample,
        sampleSize: sampleSize,
        set: set,
        setWith: setWith,
        shuffle: shuffle,
        size: size,
        slice: slice,
        snakeCase: snakeCase,
        some: some,
        sortBy: sortBy,
        sortedIndex: sortedIndex,
        sortedIndexBy: sortedIndexBy,
        sortedIndexOf: sortedIndexOf,
        sortedLastIndex: sortedLastIndex,
        sortedLastIndexBy: sortedLastIndexBy,
        sortedLastIndexOf: sortedLastIndexOf,
        sortedUniq: sortedUniq,
        sortedUniqBy: sortedUniqBy,
        split: split,
        spread: spread,
        startCase: startCase,
        startsWith: startsWith,
        stubArray: stubArray,
        stubFalse: stubFalse,
        stubObject: stubObject,
        stubString: stubString,
        stubTrue: stubTrue,
        subtract: subtract,
        sum: sum,
        sumBy: sumBy,
        tail: tail,
        take: take,
        takeRight: takeRight,
        takeRightWhile: takeRightWhile,
        takeWhile: takeWhile,
        tap: tap,
        template: template,
        templateSettings: templateSettings,
        throttle: throttle,
        thru: thru,
        times: times,
        toArray: toArray,
        toFinite: toFinite,
        toInteger: toInteger,
        toIterator: wrapperToIterator,
        toJSON: wrapperValue,
        toLength: toLength,
        toLower: toLower,
        toNumber: toNumber,
        toPairs: toPairs,
        toPairsIn: toPairsIn,
        toPath: toPath,
        toPlainObject: toPlainObject,
        toSafeInteger: toSafeInteger,
        toString: toString,
        toUpper: toUpper,
        transform: transform,
        trim: trim,
        trimEnd: trimEnd,
        trimStart: trimStart,
        truncate: truncate$1,
        unary: unary,
        unescape: unescape,
        union: union,
        unionBy: unionBy,
        unionWith: unionWith,
        uniq: uniq,
        uniqBy: uniqBy,
        uniqWith: uniqWith,
        uniqueId: uniqueId$1,
        unset: unset,
        unzip: unzip,
        unzipWith: unzipWith,
        update: update,
        updateWith: updateWith,
        upperCase: upperCase,
        upperFirst: upperFirst,
        value: wrapperValue,
        valueOf: wrapperValue,
        values: values,
        valuesIn: valuesIn,
        without: without,
        words: words,
        wrap: wrap,
        wrapperAt: wrapperAt,
        wrapperChain: wrapperChain,
        wrapperCommit: wrapperCommit,
        wrapperLodash: lodash,
        wrapperNext: wrapperNext,
        wrapperPlant: wrapperPlant,
        wrapperReverse: wrapperReverse,
        wrapperToIterator: wrapperToIterator,
        wrapperValue: wrapperValue,
        xor: xor,
        xorBy: xorBy,
        xorWith: xorWith,
        zip: zip,
        zipObject: zipObject,
        zipObjectDeep: zipObjectDeep,
        zipWith: zipWith,
        'default': lodash
    });

    const MODE = {
      TREE: 'tree',
      CODE: 'code'
    };

    const STATE_ID = Symbol('id');
    const STATE_EXPANDED = Symbol('expanded');
    const STATE_VISIBLE_SECTIONS = Symbol('visible sections');
    const STATE_KEYS = Symbol('keys');
    const STATE_SEARCH_PROPERTY = Symbol('search:property');
    const STATE_SEARCH_VALUE = Symbol('search:value');
    const SEARCH_RESULT = Symbol('search:result');
    const ACTIVE_SEARCH_RESULT = Symbol('search:active-result');
    const VALIDATION_ERROR = Symbol('validation:error');

    const SCROLL_DURATION = 300; // ms
    const DEBOUNCE_DELAY = 300;
    const SEARCH_PROGRESS_THROTTLE = 300; // ms
    const CHECK_VALID_JSON_DELAY = 300; // ms
    const MAX_SEARCH_RESULTS = 1000;
    const ARRAY_SECTION_SIZE = 100;
    const DEFAULT_VISIBLE_SECTIONS = [{ start: 0, end: ARRAY_SECTION_SIZE }];
    const MAX_PREVIEW_CHARACTERS = 20e3; // characters
    const MAX_AUTO_REPAIRABLE_SIZE = 1024 * 1024; // 1 MB
    const MAX_DOCUMENT_SIZE_CODE_MODE = 10 * 1024 * 1024; // 10 MB

    const INDENTATION_WIDTH = 18; // pixels IMPORTANT: keep in sync with sass constant $indentation-width

    const SIMPLE_MODAL_OPTIONS = {
      closeButton: false,
      styleBg: {
        top: 0,
        left: 0,
        background: 'rgba(0, 0, 0, 0.3)',
        justifyContent: 'normal'
      },
      styleWindow: {
        borderRadius: '2px'
      },
      styleContent: {
        padding: '0px',
        overflow: 'visible' // needed for select box dropdowns which are larger than the modal
      }
    };

    const SORT_MODAL_OPTIONS = {
      ...SIMPLE_MODAL_OPTIONS,
      styleWindow: {
        ...SIMPLE_MODAL_OPTIONS.styleWindow,
        width: '400px'
      }
    };

    const TRANSFORM_MODAL_OPTIONS = {
      ...SIMPLE_MODAL_OPTIONS,
      styleWindow: {
        ...SIMPLE_MODAL_OPTIONS.styleWindow,
        width: '600px'
      },
      styleContent: {
        overflow: 'auto', // TODO: would be more neat if the header is fixed instead of scrolls along
        padding: 0
      }
    };

    const INSERT_EXPLANATION = 'Insert or paste contents, ' +
      'enter [ insert a new array, ' +
      'enter { to insert a new object, ' +
      'or start typing to insert a new value';

    const CONTEXT_MENU_EXPLANATION = 'Open context menu ' +
      '(Click here, ' +
      'right click on the selection, ' +
      'or use the context menu button or Ctrl+Q)';

    const HOVER_INSERT_INSIDE = 'hover-insert-inside';
    const HOVER_INSERT_AFTER = 'hover-insert-after';
    const HOVER_COLLECTION = 'hover-collection';

    const JSON_STATUS_VALID = 'valid';
    const JSON_STATUS_REPAIRABLE = 'repairable';
    const JSON_STATUS_INVALID = 'invalid';

    // TODO: can we dynamically calculate the size?
    const CONTEXT_MENU_HEIGHT = (40 + 2) * 8; // px
    const CONTEXT_MENU_WIDTH = 260; // px

    /**
     * Parse a JSONPointer, and turn array indices into numeric values.
     * For example, '/array/2/name' returns ['array', 2, 'name'] when array turns
     * out to be an actual Array
     *
     * @param {JSON} json
     * @param {string} path
     */
    // TODO: unit test
    function parseJSONPointerWithArrayIndices (json, path) {
      const parsedPath = immutableJSONPatch.parseJSONPointer(path);

      // parse Array indexes into a number
      for (let i = 0; i < parsedPath.length; i++) {
        const section = parsedPath[i];

        if (ARRAY_INDEX_REGEX.exec(section)) {
          // this path part contains a number.
          // See if the document actually contains an array
          const parentPath = parsedPath.slice(0, i);
          const parent = immutableJSONPatch.getIn(json, parentPath);

          if (Array.isArray(parent)) {
            parsedPath[i] = parseInt(section);
          }
        }
      }

      return parsedPath
    }

    // test whether a string only contains one or digits, like "1" or "204"
    const ARRAY_INDEX_REGEX = /^\d+$/;

    // TODO: unit test typeUtils.js

    /**
     * Test whether a value is an Object (and not an Array!)
     *
     * @param {*} value
     * @return {boolean}
     */
    function isObject (value) {
      return typeof value === 'object' &&
          value !== null &&
          !Array.isArray(value)
    }

    /**
     * Test whether a value is an Object or an Array
     *
     * @param {*} value
     * @return {boolean}
     */
    function isObjectOrArray (value) {
      return typeof value === 'object' && value !== null
    }

    /**
     * Get the type of a value
     * @param {*} value
     * @return {String} type
     */
    function valueType (value) {
      if (value === null) {
        return 'null'
      }
      if (value === undefined) {
        return 'undefined'
      }
      if (typeof value === 'number') {
        return 'number'
      }
      if (typeof value === 'string') {
        return 'string'
      }
      if (typeof value === 'boolean') {
        return 'boolean'
      }
      if (value instanceof RegExp) {
        return 'regexp'
      }
      if (Array.isArray(value)) {
        return 'array'
      }

      return 'object'
    }

    /**
     * Test whether a text contains a url (matches when a string starts
     * with 'http://*' or 'https://*' and has no whitespace characters)
     * @param {String} text
     */
    const isUrlRegex = /^https?:\/\/\S+$/;
    function isUrl (text) {
      return (typeof text === 'string') && isUrlRegex.test(text)
    }

    /**
     * Convert contents of a string to the correct JSON type. This can be a string,
     * a number, a boolean, etc
     * @param {String} str
     * @return {*} castedStr
     * @private
     */
    function stringConvert (str) {
      const num = Number(str); // will nicely fail with '123ab'
      const numFloat = parseFloat(str); // will nicely fail with '  '

      if (str === '') {
        return ''
      } else if (str === 'null') {
        return null
      } else if (str === 'true') {
        return true
      } else if (str === 'false') {
        return false
      } else if (!isNaN(num) && !isNaN(numFloat)) {
        return num
      } else {
        return str
      }
    }

    const MAX_ITEM_PATHS_COLLECTION = 10000;
    const EMPTY_ARRAY = [];

    /**
     * Get the paths of all nested properties in the items of an array
     * @param {JSON} array
     * @param {boolean} [includeObjects=false] If true, object and array paths are returned as well
     * @return {Path[]}
     */
    function getNestedPaths (array, includeObjects = false) {
      const pathsMap = {};

      if (!Array.isArray(array)) {
        throw new TypeError('Array expected')
      }

      function recurseNestedPaths (obj, path) {
        const isValue = !Array.isArray(obj) && !isObject(obj);

        if (isValue || includeObjects) {
          pathsMap[immutableJSONPatch.compileJSONPointer(path)] = true;
        }

        if (isObject(obj)) {
          Object.keys(obj).forEach(key => {
            recurseNestedPaths(obj[key], path.concat(key));
          });
        }
      }

      const max = Math.min(array.length, MAX_ITEM_PATHS_COLLECTION);
      for (let i = 0; i < max; i++) {
        const item = array[i];
        recurseNestedPaths(item, EMPTY_ARRAY);
      }

      const pathsArray = Object.keys(pathsMap).sort();

      return pathsArray.map(immutableJSONPatch.parseJSONPointer)
    }

    /**
     * Invoke the callback with
     * @param {number} start   Included start index
     * @param {number} end       Excluded end index. End must be larger or equal to start
     * @param {function (index: number) : void} iteratee
     */
    // TODO: write tests
    function forEachIndex (start, end, iteratee) {
      if (end <= start) {
        return
      }

      for (let index = start; index < end; index++) {
        iteratee(index);
      }
    }

    /**
     * Create sections that can be expanded.
     * Used to display a button like "Show items 100-200"
     *
     * @param {number} startIndex
     * @param {number} endIndex
     * @return {Section[]}
     */
    function getExpandItemsSections (startIndex, endIndex) {
      // expand the start of the section
      const section1 = {
        start: startIndex,
        end: Math.min(nextRoundNumber(startIndex), endIndex)
      };

      // expand the middle of the section
      const start2 = Math.max(currentRoundNumber((startIndex + endIndex) / 2), startIndex);
      const section2 = {
        start: start2,
        end: Math.min(nextRoundNumber(start2), endIndex)
      };

      // expand the end of the section
      const currentIndex = currentRoundNumber(endIndex);
      const previousIndex = currentIndex === endIndex
        ? (currentIndex - ARRAY_SECTION_SIZE)
        : currentIndex;
      const section3 = {
        start: Math.max(previousIndex, startIndex),
        end: endIndex
      };

      const sections = [
        section1
      ];

      const showSection2 = section2.start >= section1.end && section2.end <= section3.start;
      if (showSection2) {
        sections.push(section2);
      }

      const showSection3 = section3.start >= (showSection2 ? section2.end : section1.end);
      if (showSection3) {
        sections.push(section3);
      }

      return sections
    }

    /**
     * Sort and merge a list with sections
     * @param {Section[]} sections
     * @return {Section[]}
     */
    function mergeSections (sections) {
      const sortedSections = sortBy(sections, section => section.start);

      const mergedSections = [
        sortedSections[0]
      ];

      for (let sortedIndex = 0; sortedIndex < sortedSections.length; sortedIndex++) {
        const mergedIndex = mergedSections.length - 1;
        const previous = mergedSections[mergedIndex];
        const current = sortedSections[sortedIndex];

        if (current.start <= previous.end) {
          // there is overlap -> replace the previous item
          mergedSections[mergedIndex] = {
            start: Math.min(previous.start, current.start),
            end: Math.max(previous.end, current.end)
          };
        } else {
          // no overlap, just add the item
          mergedSections.push(current);
        }
      }

      return mergedSections
    }

    // TODO: write unit test
    function inVisibleSection (sections, index) {
      return sections.some(section => {
        return index >= section.start && index < section.end
      })
    }

    function nextRoundNumber (index) {
      return currentRoundNumber(index) + ARRAY_SECTION_SIZE
    }

    function currentRoundNumber (index) {
      return Math.floor(index / ARRAY_SECTION_SIZE) * ARRAY_SECTION_SIZE
    }

    const debug$1 = browser('jsoneditor:documentState');

    /**
     * Sync a state object with the json it belongs to: update keys, limit, and expanded state
     *
     * @param {JSON} json
     * @param {JSON | undefined} state
     * @param {Path} path
     * @param {function (path: Path) : boolean} expand
     * @param {boolean} [forceRefresh=false] if true, force refreshing the expanded state
     * @returns {JSON | undefined}
     */
    // TODO: refactor syncState so we don't have to pass path=[] all the time, this is only used internally for recursiveness
    function syncState (json, state, path, expand, forceRefresh = false) {
      // TODO: this function can be made way more efficient if we pass prevState:
      //  when immutable, we can simply be done already when the state === prevState

      const updatedState = Array.isArray(json) ? [] : {};

      updatedState[STATE_ID] = (state && state[STATE_ID])
        ? state[STATE_ID]
        : uniqueId$1();

      if (isObject(json)) {
        updatedState[STATE_KEYS] = syncKeys(json, state && state[STATE_KEYS]);

        updatedState[STATE_EXPANDED] = (state && !forceRefresh)
          ? state[STATE_EXPANDED]
          : expand(path);

        if (updatedState[STATE_EXPANDED]) {
          Object.keys(json).forEach(key => {
            const childJson = json[key];
            const childState = state && state[key];
            updatedState[key] = syncState(childJson, childState, path.concat(key), expand, forceRefresh);
          });
        }

        // FIXME: must create new id's in case of duplicate id's
      } else if (Array.isArray(json)) {
        updatedState[STATE_EXPANDED] = (state && !forceRefresh)
          ? state[STATE_EXPANDED]
          : expand(path);

        // note that we reset the visible items when the state is not expanded
        updatedState[STATE_VISIBLE_SECTIONS] = (state && updatedState[STATE_EXPANDED])
          ? (state[STATE_VISIBLE_SECTIONS] || DEFAULT_VISIBLE_SECTIONS)
          : DEFAULT_VISIBLE_SECTIONS;

        if (updatedState[STATE_EXPANDED]) {
          updatedState[STATE_VISIBLE_SECTIONS].forEach(({ start, end }) => {
            forEachIndex(start, Math.min(json.length, end), index => {
              const childJson = json[index];
              const childState = state && state[index];
              updatedState[index] = syncState(childJson, childState, path.concat(index), expand, forceRefresh);
            });
          });
        }
      } else ;

      return updatedState
    }

    function createState (json) {
      if (Array.isArray(json)) {
        const state = [];

        state[STATE_ID] = uniqueId$1();
        state[STATE_EXPANDED] = false;
        state[STATE_VISIBLE_SECTIONS] = DEFAULT_VISIBLE_SECTIONS;

        return state
      }

      if (isObject(json)) {
        const state = {};

        state[STATE_ID] = uniqueId$1();
        state[STATE_EXPANDED] = false;
        state[STATE_KEYS] = Object.keys(json);

        return state
      }

      // primitive value
      return {
        [STATE_ID]: uniqueId$1()
      }
    }

    /**
     * Invoke a callback function for every visible item in the array
     * @param {JSON} json
     * @param {JSON} state
     * @param {function (index: number)} callback
     */
    function forEachVisibleIndex (json, state, callback) {
      state[STATE_VISIBLE_SECTIONS].forEach(({ start, end }) => {
        forEachIndex(start, Math.min(json.length, end), callback);
      });
    }

    // TODO: write unit tests
    function forEachKey (state, callback) {
      state[STATE_KEYS].forEach(key => callback(key));
    }

    /**
     * Expand all nodes on given path
     * @param {JSON} json
     * @param {JSON} state
     * @param {Path} path
     * @return {JSON} returns the updated state
     */
    // TODO: write unit tests for expandPath
    function expandPath (json, state, path) {
      let updatedState = state;

      for (let i = 0; i < path.length; i++) {
        const partialPath = path.slice(0, i);
        const expandedPath = partialPath.concat(STATE_EXPANDED);
        updatedState = immutableJSONPatch.setIn(updatedState, expandedPath, true, true);

        // if needed, enlarge the expanded sections such that the search result becomes visible in the array
        if (Array.isArray(immutableJSONPatch.getIn(updatedState, partialPath))) {
          const key = path[i];
          const sectionsPath = partialPath.concat(STATE_VISIBLE_SECTIONS);
          const sections = immutableJSONPatch.getIn(updatedState, sectionsPath) || DEFAULT_VISIBLE_SECTIONS;
          if (!inVisibleSection(sections, key)) {
            const start = currentRoundNumber(key);
            const end = nextRoundNumber(start);
            const newSection = { start, end };
            const updatedSections = mergeSections(sections.concat(newSection));
            updatedState = immutableJSONPatch.setIn(updatedState, sectionsPath, updatedSections);
          }
        }

        // FIXME: the way to sync the state of this nested, just expanded object/array is complicated. Refactor this
        const partialJson = immutableJSONPatch.getIn(json, partialPath);
        updatedState = immutableJSONPatch.updateIn(updatedState, partialPath, partialState => {
          return syncState(partialJson, partialState, [], () => false)
        });
      }

      return updatedState
    }

    /**
     * Expand a section of items in an array
     * @param {JSON} json
     * @param {JSON} state
     * @param {Path} path
     * @param {Section} section
     * @return {JSON} returns the updated state
     */
    // TODO: write unit test
    function expandSection (json, state, path, section) {
      const updatedState = immutableJSONPatch.updateIn(state, path.concat(STATE_VISIBLE_SECTIONS), (sections) => {
        return mergeSections(sections.concat(section))
      });

      // instantiate all new expanded items
      return syncState(json, updatedState, path, () => false)
    }

    /**
     * @param {Object} object
     * @param {string[]} [prevKeys=undefined]
     * @returns {string[]}
     */
    function syncKeys (object, prevKeys) {
      if (!prevKeys) {
        return Object.keys(object)
      }

      // copy the keys that still exist
      const keys = prevKeys.filter(key => object[key] !== undefined);

      // add new keys
      const keysSet = new Set(keys);
      Object.keys(object)
        .filter(key => !keysSet.has(key))
        .forEach(key => keys.push(key));

      return keys
    }

    /**
     * Apply patch operations to both json and state
     * @param {JSON} json
     * @param {JSON} state
     * @param {JSONPatchDocument} operations
     * @returns {{json: JSON, state: JSON}}
     */
    function documentStatePatch (json, state, operations) {
      // TODO: split this function in smaller functions, it's too large

      function before (state, operation) {
        const { op, path, from } = operation;
        const parentPath = initial(path);

        let updatedState = state;
        let updatedOperation = operation;

        // correctly create state value
        if (operation.value !== undefined) {
          updatedOperation = {
            ...updatedOperation,
            value: createState(operation.value)
          };
        }

        // TODO: when path or from is not existing in updatedState, expand that now so we can handle it

        if (op === 'add' || op === 'copy') {
          const keys = getKeys(state, parentPath);
          if (keys) {
            // this is a property inside an object
            // add the key to STATE_KEYS if needed
            const key = last(path);
            if (!keys.includes(key)) {
              updatedState = appendToKeys(updatedState, parentPath, key);
            }
          }

          // shift the visible sections one down
          updatedState = shiftVisibleSections(updatedState, path, 1);
        }

        if (op === 'move') {
          const parentPath = initial(path);
          const keys = getKeys(updatedState, parentPath);
          const oldKey = last(from);
          const newKey = last(path);

          if (isEqual(initial(from), initial(path))) {
            // move inside the same object
            if (keys) {
              if (oldKey !== newKey) {
                // A key is renamed

                // in case the new key is different but will replace an existing key, remove the existing key
                updatedState = removeFromKeys(updatedState, parentPath, newKey);

                // Replace the key in the object's STATE_KEYS so it maintains its index
                updatedState = replaceInKeys(updatedState, parentPath, oldKey, newKey);
              } else {
                // key is not renamed but moved -> move it to the end of the keys
                updatedState = removeFromKeys(updatedState, parentPath, newKey);
                updatedState = appendToKeys(updatedState, parentPath, newKey);
              }
            }
          } else {
            // move from one object/array to an other -> remove old key, add new key
            const fromParentPath = initial(from);
            const fromKeys = getKeys(updatedState, fromParentPath);
            if (fromKeys) {
              updatedState = removeFromKeys(updatedState, fromParentPath, oldKey);
            }
            if (keys) {
              updatedState = appendToKeys(updatedState, parentPath, newKey);
            }
          }

          // shift the visible sections one up from where removed, and one down from where inserted
          updatedState = shiftVisibleSections(updatedState, from, -1);
          updatedState = shiftVisibleSections(updatedState, path, 1);

          // we must keep the existing state for example when renaming an object property
          const existingState = immutableJSONPatch.getIn(state, from);
          updatedOperation = { ...updatedOperation, value: existingState };
        }

        if (op === 'remove') {
          const parentPath = initial(path);
          const keys = getKeys(updatedState, parentPath);
          if (keys) {
            // remove old key
            const oldKey = last(path);
            updatedState = removeFromKeys(updatedState, parentPath, oldKey);
          } else {
            // shift the visible sections one up
            updatedState = shiftVisibleSections(updatedState, path, -1);
          }
        }

        if (op === 'replace') {
          const parentPath = initial(path);
          const keys = getKeys(updatedState, parentPath);
          if (keys) {
            const key = last(path);
            if (!keys.includes(key)) {
              updatedState = appendToKeys(updatedState, parentPath, key);
            }
          }
        }

        return {
          json: updatedState,
          operation: updatedOperation
        }
      }

      function after (state, operation) {
        const { op, path } = operation;

        let updatedState = state;

        if (op === 'copy') {
          // copying state will introduce duplicate id's -> replace with a new id
          if (immutableJSONPatch.existsIn(updatedState, path.concat([STATE_ID]))) {
            updatedState = immutableJSONPatch.setIn(updatedState, path.concat([STATE_ID]), uniqueId$1());
          }
        }

        return updatedState
      }

      debug$1('documentStatePatch', json, state, operations);

      const updatedJson = immutableJSONPatch.immutableJSONPatch(json, operations);
      const initializedState = initializeState(json, state, operations);
      const updatedState = immutableJSONPatch.immutableJSONPatch(initializedState, operations, { before, after });

      return {
        json: updatedJson,
        state: updatedState
      }
    }

    /**
     * Initialize the state needed to perform the JSON patch operations.
     * For example to a change in a nested object which is not expanded and
     * hence has no state initialize, we need to create this nested state
     * @param {JSON} json
     * @param {JSON} state
     * @param {JSONPatchDocument} operations
     */
    function initializeState (json, state, operations) {
      let updatedState = state;

      function initializePath (json, state, path) {
        let updatedState = state;

        if (immutableJSONPatch.existsIn(json, path) && !immutableJSONPatch.existsIn(updatedState, path)) {
          // first make sure the parent is initialized
          if (path.length > 0) {
            updatedState = initializePath(json, updatedState, initial(path));
          }

          // then initialize the state itself
          updatedState = immutableJSONPatch.setIn(updatedState, path, createState(immutableJSONPatch.getIn(json, path)));
        }

        return updatedState
      }

      operations.forEach(operation => {
        const from = typeof operation.from === 'string'
          ? parseJSONPointerWithArrayIndices(json, operation.from)
          : null;
        const path = typeof operation.path === 'string'
          ? parseJSONPointerWithArrayIndices(json, operation.path)
          : null;

        if (operation.op === 'add') {
          updatedState = initializePath(json, updatedState, initial(path)); // initialize parent only
        }

        if (operation.op === 'copy' || operation.op === 'move') {
          updatedState = initializePath(json, updatedState, from);
          updatedState = initializePath(json, updatedState, initial(path)); // initialize parent only
        }

        if (operation.op === 'remove' || operation.op === 'replace' || operation.op === 'test') {
          updatedState = initializePath(json, updatedState, path);
        }
      });

      return updatedState
    }

    /**
     * Shift visible sections in an Array with a specified offset
     * @param {JSON} state
     * @param {Path} path
     * @param {number} offset
     * @returns {JSON} Returns the updated state
     */
    function shiftVisibleSections (state, path, offset) {
      const parentPath = initial(path);
      const sectionsPath = parentPath.concat([STATE_VISIBLE_SECTIONS]);
      const visibleSections = immutableJSONPatch.getIn(state, sectionsPath);
      if (!visibleSections) {
        // nothing to do, this is no object but an array apparently :)
        return state
      }

      const index = parseInt(last(path), 10);
      const shiftedVisibleSections = visibleSections.map(section => {
        return {
          start: section.start > index
            ? section.start + offset
            : section.start,

          end: section.end >= index
            ? section.end + offset
            : section.end
        }
      });

      return immutableJSONPatch.setIn(state, sectionsPath, shiftedVisibleSections)
    }

    /**
     * @param {JSON} state
     * @param {Path} path
     * @return {string[]}
     */
    function getKeys (state, path) {
      return immutableJSONPatch.getIn(state, path.concat([STATE_KEYS]))
    }

    /**
     * @param {JSON} state
     * @param {Path} path
     * @param {string} key
     * @return {JSON} Returns the updated state
     */
    function removeFromKeys (state, path, key) {
      return immutableJSONPatch.updateIn(state, path.concat([STATE_KEYS]), keys => {
        const index = keys.indexOf(key);
        if (index === -1) {
          return keys
        }

        const updatedKeys = keys.slice(0);
        updatedKeys.splice(index, 1);

        return updatedKeys
      })
    }

    /**
     * @param {JSON} state
     * @param {Path} path
     * @param {string} oldKey
     * @param {string} newKey
     * @return {JSON} Returns the updated state
     */
    function replaceInKeys (state, path, oldKey, newKey) {
      return immutableJSONPatch.updateIn(state, path.concat([STATE_KEYS]), keys => {
        const index = keys.indexOf(oldKey);
        if (index === -1) {
          return keys
        }

        const updatedKeys = keys.slice(0);
        updatedKeys.splice(index, 1, newKey);

        return updatedKeys
      })
    }

    /**
     * @param {JSON} state
     * @param {Path} path
     * @param {string} key
     * @return {JSON} Returns the updated state
     */
    function appendToKeys (state, path, key) {
      return immutableJSONPatch.updateIn(state, path.concat([STATE_KEYS]), keys => keys.concat(key))
    }

    function getNextKeys (keys, key, includeKey = false) {
      const index = keys.indexOf(key);
      if (index !== -1) {
        return includeKey
          ? keys.slice(index)
          : keys.slice(index + 1)
      } else {
        // a new key, that doesn't have next keys
        return []
      }
    }

    /**
     * Get all paths which are visible and rendered
     * @param {JSON} json
     * @param {JSON} state
     * @returns {Path[]}
     */
    // TODO: create memoized version of getVisiblePaths which remembers just the previous result if json and state are the same
    function getVisiblePaths (json, state) {
      const paths = [];

      function _recurse (json, state, path) {
        paths.push(path);

        if (json && state && state[STATE_EXPANDED] === true) {
          if (Array.isArray(json)) {
            forEachVisibleIndex(json, state, index => {
              _recurse(json[index], state[index], path.concat(index));
            });
          } else { // Object
            forEachKey(state, key => {
              _recurse(json[key], state[key], path.concat(key));
            });
          }
        }
      }

      _recurse(json, state, []);

      return paths
    }

    const CARET_POSITION = {
      INSIDE: 'inside',
      AFTER: 'after',
      KEY: 'key',
      VALUE: 'value'
    };

    /**
     * Get all caret position which are visible and rendered:
     * before a node, at a key, at a value, appending an object/arrayc
     * @param {JSON} json
     * @param {JSON} state
     * @returns {CaretPosition[]}
     */
    // TODO: create memoized version of getVisibleCaretPositions which remembers just the previous result if json and state are the same
    function getVisibleCaretPositions (json, state) {
      const paths = [];

      function _recurse (json, state, path) {
        paths.push({ path, type: CARET_POSITION.VALUE });

        if (json && state && state[STATE_EXPANDED] === true) {
          paths.push({ path, type: CARET_POSITION.INSIDE });

          if (Array.isArray(json)) {
            forEachVisibleIndex(json, state, index => {
              const itemPath = path.concat(index);

              _recurse(json[index], state[index], itemPath);
              paths.push({ path: itemPath, type: CARET_POSITION.AFTER });
            });
          } else { // Object
            forEachKey(state, key => {
              const propertyPath = path.concat(key);

              paths.push({ path: propertyPath, type: CARET_POSITION.KEY });
              _recurse(json[key], state[key], propertyPath);
              paths.push({ path: propertyPath, type: CARET_POSITION.AFTER });
            });
          }
        }
      }

      _recurse(json, state, []);

      return paths
    }

    /**
     * Find the previous visible path.
     * This can be the last child of the previous object or array, or the parent of a first entry.
     * @param {JSON} json
     * @param {JSON} state
     * @param {Path} path
     * @return {Path | null}
     */
    // TODO: write tests for getPreviousVisiblePath
    function getPreviousVisiblePath (json, state, path) {
      const visiblePaths = getVisiblePaths(json, state);
      const visiblePathPointers = visiblePaths.map(immutableJSONPatch.compileJSONPointer);
      const pathPointer = immutableJSONPatch.compileJSONPointer(path);
      const index = visiblePathPointers.indexOf(pathPointer);

      if (index !== -1 && index > 0) {
        return visiblePaths[index - 1]
      }

      return null
    }

    /**
     * Find the next visible path.
     * This can be the next parent entry.
     * @param {JSON} json
     * @param {JSON} state
     * @param {Path} path
     * @return {Path | null} path
     */
    // TODO: write tests for getNextVisiblePath
    function getNextVisiblePath (json, state, path) {
      const visiblePaths = getVisiblePaths(json, state);
      const visiblePathPointers = visiblePaths.map(immutableJSONPatch.compileJSONPointer);
      const index = visiblePathPointers.indexOf(immutableJSONPatch.compileJSONPointer(path));

      if (index !== -1 && index < visiblePaths.length - 1) {
        return visiblePaths[index + 1]
      }

      return null
    }

    const SELECTION_TYPE = {
      AFTER: 'after',
      INSIDE: 'inside',
      KEY: 'key',
      VALUE: 'value',
      MULTI: 'multi'
    };

    /**
     * Expand a selection start and end into an array containing all paths
     * between (and including) start and end
     *
     * @param {JSON} json
     * @param {JSON} state
     * @param {Path} anchorPath
     * @param {Path} focusPath
     * @return {Path[]} paths
     */
    function expandSelection (json, state, anchorPath, focusPath) {
      if (isEqual(anchorPath, focusPath)) {
        // just a single node
        return [anchorPath]
      } else {
        // multiple nodes
        const sharedPath = findSharedPath(anchorPath, focusPath);

        if (anchorPath.length === sharedPath.length || focusPath.length === sharedPath.length) {
          // a parent and a child, like ['arr', 1] and ['arr']
          return [sharedPath]
        }

        const anchorKey = anchorPath[sharedPath.length];
        const focusKey = focusPath[sharedPath.length];
        const value = immutableJSONPatch.getIn(json, sharedPath);

        if (isObject(value)) {
          const keys = immutableJSONPatch.getIn(state, sharedPath.concat(STATE_KEYS));
          const anchorIndex = keys.indexOf(anchorKey);
          const focusIndex = keys.indexOf(focusKey);

          if (anchorIndex !== -1 && focusIndex !== -1) {
            const startIndex = Math.min(anchorIndex, focusIndex);
            const endIndex = Math.max(anchorIndex, focusIndex);
            const paths = [];

            for (let i = startIndex; i <= endIndex; i++) {
              paths.push(sharedPath.concat(keys[i]));
            }

            return paths
          }
        }

        if (Array.isArray(value)) {
          const startIndex = Math.min(anchorKey, focusKey);
          const endIndex = Math.max(anchorKey, focusKey);
          const paths = [];

          for (let i = startIndex; i <= endIndex; i++) {
            paths.push(sharedPath.concat(i));
          }

          return paths
        }
      }

      throw new Error('Failed to create selection')
    }

    /**
     * @param {Selection} selection
     * @return {Path} Returns parent path
     */
    function getParentPath (selection) {
      if (selection.type === SELECTION_TYPE.INSIDE) {
        return selection.focusPath
      } else {
        return initial(selection.focusPath)
      }
    }

    /**
     * @param {Selection} selection
     * @param {Path} path
     * @return boolean
     */
    // TODO: write unit test
    function isSelectionInsidePath (selection, path) {
      return (
        pathStartsWith(selection.focusPath, path) &&
        ((selection.focusPath.length > path.length) || selection.type === SELECTION_TYPE.INSIDE)
      )
    }

    /**
     * @param {Selection} selection
     * @param {Path} path
     * @param {string} anchorType
     * @return boolean
     */
    // TODO: write unit test
    function isPathInsideSelection (selection, path, anchorType) {
      const p = path.slice(0);

      if (selection.type === SELECTION_TYPE.MULTI) {
        while (p.length > 0) {
          if (selection.pathsMap[immutableJSONPatch.compileJSONPointer(p)] === true) {
            return true
          }

          p.pop();
        }
      }

      if (selection.type === SELECTION_TYPE.KEY) {
        return anchorType === SELECTION_TYPE.KEY && isEqual(selection.focusPath, path)
      }

      if (selection.type === SELECTION_TYPE.VALUE) {
        if (anchorType === SELECTION_TYPE.VALUE && isEqual(selection.focusPath, path)) {
          return true
        }

        if (
          pathStartsWith(path, selection.focusPath) &&
          path.length > selection.focusPath.length &&
          (
            anchorType === SELECTION_TYPE.KEY ||
            anchorType === SELECTION_TYPE.VALUE ||
            anchorType === SELECTION_TYPE.MULTI
          )
        ) {
          return true
        }
      }

      return false
    }

    /**
     * @param {JSON} json
     * @param {JSON} state
     * @param {Selection} selection
     * @param {boolean} [keepAnchorPath=false]
     * @returns {Selection | null}
     */
    function getSelectionUp (json, state, selection, keepAnchorPath = false) {
      const previousPath = getPreviousVisiblePath(json, state, selection.focusPath);
      const anchorPath = previousPath;
      const focusPath = previousPath;

      if (previousPath === null) {
        return null
      }

      if (keepAnchorPath) {
        // multi selection
        if (selection.type === SELECTION_TYPE.AFTER || selection.type === SELECTION_TYPE.INSIDE) {
          return createSelection(json, state, {
            type: SELECTION_TYPE.MULTI,
            anchorPath: selection.anchorPath,
            focusPath: selection.anchorPath
          })
        }

        return createSelection(json, state, {
          type: SELECTION_TYPE.MULTI,
          anchorPath: selection.anchorPath,
          focusPath
        })
      }

      if (selection.type === SELECTION_TYPE.KEY) {
        const parentPath = initial(previousPath);
        const parent = immutableJSONPatch.getIn(json, parentPath);
        if (Array.isArray(parent) || isEmpty(previousPath)) {
          // switch to value selection: array has no keys, and root object also not
          return { type: SELECTION_TYPE.VALUE, anchorPath, focusPath }
        } else {
          return { type: SELECTION_TYPE.KEY, anchorPath, focusPath }
        }
      }

      if (selection.type === SELECTION_TYPE.VALUE) {
        return { type: SELECTION_TYPE.VALUE, anchorPath, focusPath }
      }

      if (selection.type === SELECTION_TYPE.AFTER) {
        // select the node itself, not the previous node,
        // FIXME: when after an expanded object/array, should go to the last item inside the object/array
        return createSelection(json, state, {
          type: SELECTION_TYPE.MULTI,
          anchorPath: selection.focusPath,
          focusPath: selection.focusPath
        })
      }

      if (selection.type === SELECTION_TYPE.INSIDE) {
        // select the node itself, not the previous node,
        return createSelection(json, state, {
          type: SELECTION_TYPE.MULTI,
          anchorPath: selection.focusPath,
          focusPath: selection.focusPath
        })
      }

      // multi selection -> select previous node
      return createSelection(json, state, {
        type: SELECTION_TYPE.MULTI,
        anchorPath,
        focusPath
      })
    }

    /**
     * @param {JSON} json
     * @param {JSON} state
     * @param {Selection} selection
     * @param {boolean} [keepAnchorPath=false]
     * @returns {Selection | null}
     */
    function getSelectionDown (json, state, selection, keepAnchorPath = false) {
      // TODO: this function is too large, break it down in two separate functions: one for keepAnchorPath = true, and one for keepAnchorPath = false?
      const nextPath = getNextVisiblePath(json, state, selection.focusPath);
      const anchorPath = nextPath;
      const focusPath = nextPath;

      if (nextPath === null) {
        return null
      }

      if (keepAnchorPath) {
        // if the focusPath is an Array or object, we must not step into it but
        // over it, we pass state with this array/object collapsed
        const collapsedState = isObjectOrArray(immutableJSONPatch.getIn(json, selection.focusPath))
          ? immutableJSONPatch.setIn(state, selection.focusPath.concat(STATE_EXPANDED), false, true)
          : state;

        const nextPathAfter = getNextVisiblePath(json, collapsedState, selection.focusPath);

        // multi selection
        if (nextPathAfter === null) {
          return null
        }

        if (selection.type === SELECTION_TYPE.AFTER) {
          return createSelection(json, state, {
            type: SELECTION_TYPE.MULTI,
            anchorPath: nextPathAfter,
            focusPath: nextPathAfter
          })
        }

        if (selection.type === SELECTION_TYPE.INSIDE) {
          return createSelection(json, state, {
            type: SELECTION_TYPE.MULTI,
            anchorPath,
            focusPath
          })
        }

        return createSelection(json, state, {
          type: SELECTION_TYPE.MULTI,
          anchorPath: selection.anchorPath,
          focusPath: nextPathAfter
        })
      }

      if (selection.type === SELECTION_TYPE.KEY) {
        const parentPath = initial(nextPath);
        const parent = immutableJSONPatch.getIn(json, parentPath);
        if (Array.isArray(parent)) {
          // switch to value selection: array has no keys
          return { type: SELECTION_TYPE.VALUE, anchorPath, focusPath }
        } else {
          return { type: SELECTION_TYPE.KEY, anchorPath, focusPath }
        }
      }

      if (selection.type === SELECTION_TYPE.VALUE) {
        return { type: SELECTION_TYPE.VALUE, anchorPath, focusPath }
      }

      if (selection.type === SELECTION_TYPE.INSIDE) {
        return createSelection(json, state, {
          type: SELECTION_TYPE.MULTI,
          anchorPath,
          focusPath
        })
      }

      // selection type MULTI or AFTER
      return createSelection(json, state, {
        type: SELECTION_TYPE.MULTI,
        anchorPath: nextPath,
        focusPath: nextPath
      })
    }

    /**
     * Get the next selection for a value inside the current object/array
     * If there is no next value, select AFTER.
     * Only applicable for SELECTION_TYPE.VALUE
     * @param {JSON} json
     * @param {JSON} state
     * @param {Selection} selection
     * @returns {Selection | null}
     */
    function getSelectionNextInside (json, state, selection) {
      // TODO: write unit tests for getSelectionNextInside
      const path = selection.focusPath;
      const parentPath = initial(path);
      const childPath = [last(path)];

      const nextPathInside = getNextVisiblePath(immutableJSONPatch.getIn(json, parentPath), immutableJSONPatch.getIn(state, parentPath), childPath);

      if (nextPathInside) {
        return createSelection(json, state, {
          type: SELECTION_TYPE.VALUE,
          path: parentPath.concat(nextPathInside)
        })
      } else {
        return createSelection(json, state, {
          type: SELECTION_TYPE.AFTER,
          path
        })
      }
    }

    /**
     * Find the caret position and its siblings for a given selection
     * @param {JSON} json
     * @param {JSON} state
     * @param {Selection} selection
     * @returns {{next: (CaretPosition|null), caret: (CaretPosition|null), previous: (CaretPosition|null)}}
     */
    // TODO: unit test
    function findCaretAndSiblings (json, state, selection) {
      const visibleCaretPositions = getVisibleCaretPositions(json, state);

      const index = visibleCaretPositions.findIndex(caret => {
        return isEqual(caret.path, selection.focusPath) && caret.type === selection.type
      });

      return {
        caret: (index !== -1)
          ? visibleCaretPositions[index]
          : null,

        previous: (index !== -1 && index > 0)
          ? visibleCaretPositions[index - 1]
          : null,

        next: (index !== -1 && index < visibleCaretPositions.length - 1)
          ? visibleCaretPositions[index + 1]
          : null
      }
    }

    /**
     * @param {JSON} json
     * @param {JSON} state
     * @param {Selection} selection
     * @param {boolean} [keepAnchorPath=false]
     * @returns {Selection | null}
     */
    function getSelectionLeft (json, state, selection, keepAnchorPath = false) {
      const { caret, previous } = findCaretAndSiblings(json, state, selection);

      if (keepAnchorPath) {
        if (selection.type !== SELECTION_TYPE.MULTI) {
          return createSelection(json, state, {
            type: SELECTION_TYPE.MULTI,
            anchorPath: selection.anchorPath,
            focusPath: selection.focusPath
          })
        }

        return null
      }

      if (caret && previous) {
        return createSelection(json, state, {
          type: previous.type,
          path: previous.path
        })
      }

      const parentPath = initial(selection.focusPath);
      const parent = immutableJSONPatch.getIn(json, parentPath);

      if (selection.type === SELECTION_TYPE.VALUE && Array.isArray(parent)) {
        return createSelection(json, state, {
          type: SELECTION_TYPE.MULTI,
          anchorPath: selection.focusPath,
          focusPath: selection.focusPath
        })
      }

      if (selection.type === SELECTION_TYPE.MULTI && !Array.isArray(parent)) {
        return createSelection(json, state, {
          type: SELECTION_TYPE.KEY,
          path: selection.focusPath
        })
      }

      return null
    }

    /**
     * @param {JSON} json
     * @param {JSON} state
     * @param {Selection} selection
     * @param {boolean} [keepAnchorPath=false]
     * @returns {Selection | null}
     */
    function getSelectionRight (json, state, selection, keepAnchorPath = false) {
      const { caret, next } = findCaretAndSiblings(json, state, selection);

      if (keepAnchorPath) {
        if (selection.type !== SELECTION_TYPE.MULTI) {
          return createSelection(json, state, {
            type: SELECTION_TYPE.MULTI,
            anchorPath: selection.anchorPath,
            focusPath: selection.focusPath
          })
        }

        return null
      }

      if (caret && next) {
        return createSelection(json, state, {
          type: next.type,
          path: next.path
        })
      }

      if (selection.type === SELECTION_TYPE.MULTI) {
        return createSelection(json, state, {
          type: SELECTION_TYPE.VALUE,
          path: selection.focusPath
        })
      }

      return null
    }

    /**
     * Get a proper initial selection based on what is visible
     * @param {JSON} json
     * @param {JSON} state
     * @returns {Selection}
     */
    function getInitialSelection (json, state) {
      const visiblePaths = getVisiblePaths(json, state);

      // find the first, deepest nested entry (normally a value, not an Object/Array)
      let index = 0;
      while (index < visiblePaths.length - 1 && visiblePaths[index + 1].length > visiblePaths[index].length) {
        index++;
      }

      const path = visiblePaths[index];
      return (path.length === 0 || Array.isArray(immutableJSONPatch.getIn(json, initial(path))))
        ? { type: SELECTION_TYPE.VALUE, anchorPath: path, focusPath: path } // Array items and root object/array do not have a key, so select value in that case
        : { type: SELECTION_TYPE.KEY, anchorPath: path, focusPath: path }
    }

    /**
     * @param {JSON} json
     * @param {JSONPatchDocument} operations
     * @returns {MultiSelection}
     */
    function createSelectionFromOperations (json, operations) {
      if (operations.length === 1) {
        const operation = head(operations);
        if (operation.op === 'replace' || operation.op === 'move') {
          // replaced value
          const path = parseJSONPointerWithArrayIndices(json, operation.path);

          return {
            type: SELECTION_TYPE.VALUE,
            anchorPath: path,
            focusPath: path,
            edit: false
          }
        }
      }

      if (!isEmpty(operations) && operations.every(operation => operation.op === 'move')) {
        const firstOp = head(operations);
        const otherOps = operations.slice(1);

        if (firstOp.from !== firstOp.path && otherOps.every(operation => operation.from === operation.path)) {
          // a renamed key
          const path = parseJSONPointerWithArrayIndices(json, firstOp.path);

          return {
            type: SELECTION_TYPE.KEY,
            anchorPath: path,
            focusPath: path,
            edit: false
          }
        }
      }

      const paths = operations
        .filter(operation => {
          return (
            (operation.op !== 'test') &&
            (operation.op !== 'remove') &&
            (operation.op !== 'move' || operation.from !== operation.path) &&
            (typeof operation.path === 'string')
          )
        })
        .map(operation => parseJSONPointerWithArrayIndices(json, operation.path));

      if (isEmpty(paths)) {
        return null
      }

      // TODO: make this function robust against operations which do not have consecutive paths

      return {
        type: SELECTION_TYPE.MULTI,
        paths,
        anchorPath: head(paths),
        focusPath: last(paths),
        pathsMap: createPathsMap(paths)
      }
    }

    /**
     * @param {Path[]} paths
     * @returns {Object}
     */
    // TODO: write unit tests
    function createPathsMap (paths) {
      const pathsMap = {};

      paths.forEach(path => {
        pathsMap[immutableJSONPatch.compileJSONPointer(path)] = true;
      });

      return pathsMap
    }

    /**
     * Find the common path of two paths.
     * For example findCommonRoot(['arr', '1', 'name'], ['arr', '1', 'address', 'contact']) returns ['arr', '1']
     * @param {Path} path1
     * @param {Path} path2
     * @return {Path}
     */
    // TODO: write unit tests for findSharedPath
    function findSharedPath (path1, path2) {
      let i = 0;
      while (i < path1.length && path1[i] === path2[i]) {
        i++;
      }

      return path1.slice(0, i)
    }

    /**
     * @param {JSON} json
     * @param {Selection} selection
     * @return {Path}
     */
    function findRootPath (json, selection) {
      return (selection.type === SELECTION_TYPE.VALUE && isObjectOrArray(immutableJSONPatch.getIn(json, selection.focusPath)))
        ? selection.focusPath
        : initial(selection.focusPath) // the parent path of the paths
    }

    /**
     * @param {Path} path
     * @param {Path} parentPath
     * @return boolean
     */
    // TODO: unit test
    function pathStartsWith (path, parentPath) {
      if (path.length < parentPath.length) {
        return false
      }

      for (let i = 0; i < parentPath.length; i++) {
        if (path[i] !== parentPath[i]) {
          return false
        }
      }

      return true
    }

    /**
     * @param {Selection} selection
     * @return {Selection}
     */
    // TODO: write unit tests
    function removeEditModeFromSelection (selection) {
      if (selection && selection.edit) {
        return {
          ...selection,
          edit: false
        }
      } else {
        return selection
      }
    }

    /**
     * @param {JSON} json
     * @param {JSON} state
     * @param {SelectionSchema} selectionSchema
     * @return {Selection}
     */
    // TODO: write unit tests
    function createSelection (json, state, selectionSchema) {
      // TODO: remove next from SelectionSchema, pass it as a separate argument
      const { type, anchorPath, focusPath, path, edit = false, next = false, nextInside = false } = selectionSchema;

      if (type === SELECTION_TYPE.KEY) {
        let selection = {
          type,
          anchorPath: path,
          focusPath: path,
          edit
        };
        if (next) {
          selection = {
            ...selection,
            type: SELECTION_TYPE.VALUE
          };
        }
        return selection
      } else if (type === SELECTION_TYPE.VALUE) {
        let selection = {
          type: SELECTION_TYPE.VALUE,
          anchorPath: path,
          focusPath: path,
          edit
        };
        if (next) {
          selection = getSelectionDown(json, state, selection) || selection;
        }
        if (nextInside) {
          selection = getSelectionNextInside(json, state, selection) || selection;
        }
        return selection
      } else if (type === SELECTION_TYPE.AFTER) {
        return {
          type,
          anchorPath: path,
          focusPath: path
        }
      } else if (type === SELECTION_TYPE.INSIDE) {
        return {
          type,
          anchorPath: path,
          focusPath: path
        }
      } else if (anchorPath && focusPath) {
        const paths = expandSelection(json, state, anchorPath, focusPath);

        // the original anchorPath or focusPath may be somewhere inside the
        // returned paths: when one of the two paths is inside an object and the
        // other is outside. Then the selection is enlarged to span the whole object.
        const focusPathLast = isEqual(focusPath, last(paths)) || isEqual(anchorPath, head(paths));

        return {
          type: SELECTION_TYPE.MULTI,
          anchorPath: focusPathLast ? head(paths) : last(paths),
          focusPath: focusPathLast ? last(paths) : head(paths),
          paths,
          pathsMap: createPathsMap(paths)
        }
      } else {
        throw new TypeError(`Unknown type of selection ${JSON.stringify(selectionSchema)}`)
      }
    }

    /**
     * Turn selected contents into plain text partial JSON, usable for copying to
     * clipboard for example.
     * @param {JSON} json
     * @param {Selection} selection
     * @param {number} [indentation=2]
     * @returns {string | null}
     */
    function selectionToPartialJson (json, selection, indentation = 2) {
      if (selection.type === SELECTION_TYPE.KEY) {
        return last(selection.focusPath)
      }

      if (selection.type === SELECTION_TYPE.VALUE) {
        const value = immutableJSONPatch.getIn(json, selection.focusPath);
        return (typeof value === 'string')
          ? value
          : JSON.stringify(value, null, indentation) // TODO: customizable indentation?
      }

      if (selection.type === SELECTION_TYPE.MULTI) {
        if (isEmpty(selection.focusPath)) {
          // root object -> does not have a parent key/index
          return JSON.stringify(json, null, indentation)
        }

        const parentPath = getParentPath(selection);
        const parent = immutableJSONPatch.getIn(json, parentPath);
        if (Array.isArray(parent)) {
          if (selection.paths.length === 1) {
            // do not suffix a single selected array item with a comma
            const item = immutableJSONPatch.getIn(json, head(selection.paths));
            return JSON.stringify(item, null, indentation)
          } else {
            return selection.paths.map(path => {
              const item = immutableJSONPatch.getIn(json, path);
              return `${JSON.stringify(item, null, indentation)},`
            }).join('\n')
          }
        } else {
          // parent is Object
          return selection.paths.map(path => {
            const key = last(path);
            const value = immutableJSONPatch.getIn(json, path);
            return `${JSON.stringify(key)}: ${JSON.stringify(value, null, indentation)},`
          }).join('\n')
        }
      }

      return null
    }

    /**
     * Create a selection which selects the whole document
     * @returns {Selection}
     */
    // TODO: write tests
    function selectAll () {
      return {
        type: SELECTION_TYPE.VALUE,
        anchorPath: [],
        focusPath: []
      }
    }

    // TODO: write unit tests for getPlainText and setPlainText

    /**
     * Get the plain text from an HTML element
     * @param {Element} element  An HTML DOM element like a DIV
     * @return {string}
     */
    function getPlainText (element) {
      return unescapeHTML(traverseInnerText(element))
    }

    /**
     * Set plain text in an HTML element
     * @param {Element} element  An HTML DOM element like a DIV
     * @param {string} text
     */
    function setPlainText (element, text) {
      element.innerHTML = escapeHTML(text);
    }
    /**
     * escape a text, such that it can be displayed safely in an HTML element
     * @param {string} text
     * @return {string} escapedText
     */
    function escapeHTML (text) {
      if (typeof text !== 'string') {
        return String(text)
      } else {
        const htmlEscaped = String(text)
          .replace(/&/g, '&amp;') // must be replaced first!
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/ {2}/g, ' &nbsp;') // replace double space with an nbsp and space
          .replace(/^ /, '&nbsp;') // space at start
          .replace(/ $/, '&nbsp;'); // space at end

        const json = JSON.stringify(htmlEscaped);
        return json.substring(1, json.length - 1) // remove enclosing double quotes
      }
    }

    /**
     * unescape a string.
     * @param {string} escapedText
     * @return {string} text
     */
    function unescapeHTML (escapedText) {
      const json = '"' + escapeJSON(escapedText) + '"';
      const htmlEscaped = JSON.parse(json); // TODO: replace with a JSON.parse which does do linting and give an informative error

      return htmlEscaped.replace(/&nbsp;/g, ' ') // non breaking space character
    }

    /**
     * escape a text to make it a valid JSON string. The method will:
     *   - replace unescaped double quotes with '\"'
     *   - replace unescaped backslash with '\\'
     *   - replace returns with '\n'
     * @param {string} text
     * @return {string} escapedText
     * @private
     */
    function escapeJSON (text) {
      // TODO: replace with some smart regex (only when a new solution is faster!)
      let escaped = '';
      let i = 0;
      while (i < text.length) {
        let c = text.charAt(i);
        if (c === '\n') {
          escaped += '\\n';
        } else if (c === '\\') {
          escaped += c;
          i++;

          c = text.charAt(i);
          if (c === '' || '"\\/bfnrtu'.indexOf(c) === -1) {
            escaped += '\\'; // no valid escape character
          }
          escaped += c;
        } else if (c === '"') {
          escaped += '\\"';
        } else {
          escaped += c;
        }
        i++;
      }

      return escaped
    }

    /**
     * Get the inner text of an HTML element (for example a div element)
     * @param {Element} element
     * @param {Object} [buffer]
     * @return {string} innerText
     */
    function traverseInnerText (element, buffer) {
      const first = (buffer === undefined);
      if (first) {
        buffer = {
          _text: '',
          flush: function () {
            const text = this._text;
            this._text = '';
            return text
          },
          set: function (text) {
            this._text = text;
          }
        };
      }

      // text node
      if (element.nodeValue) {
        // remove return characters and the whitespace surrounding return characters
        const trimmedValue = element.nodeValue.replace(/\s*\n\s*/g, '');
        if (trimmedValue !== '') {
          return buffer.flush() + trimmedValue
        } else {
          // ignore empty text
          return ''
        }
      }

      // divs or other HTML elements
      if (element.hasChildNodes()) {
        const childNodes = element.childNodes;
        let innerText = '';

        for (let i = 0, iMax = childNodes.length; i < iMax; i++) {
          const child = childNodes[i];

          if (child.nodeName === 'DIV' || child.nodeName === 'P') {
            const prevChild = childNodes[i - 1];
            const prevName = prevChild ? prevChild.nodeName : undefined;
            if (prevName && prevName !== 'DIV' && prevName !== 'P' && prevName !== 'BR') {
              if (innerText !== '') {
                innerText += '\n';
              }
              buffer.flush();
            }
            innerText += traverseInnerText(child, buffer);
            buffer.set('\n');
          } else if (child.nodeName === 'BR') {
            innerText += buffer.flush();
            buffer.set('\n');
          } else {
            innerText += traverseInnerText(child, buffer);
          }
        }

        return innerText
      }

      // br or unknown
      return ''
    }

    function isChildOfNodeName (element, nodeName) {
      return isChildOf(element, e => e.nodeName.toUpperCase() === nodeName.toUpperCase())
    }

    function isChildOfAttribute (element, name, value) {
      return isChildOf(element, e => hasAttribute(e, name, value))
    }

    // test whether a DOM element is a content editable div
    function isContentEditableDiv (element) {
      return (element.nodeName === 'DIV' && element.contentEditable === 'true')
    }

    function hasAttribute (element, name, value) {
      return typeof element.getAttribute === 'function' && element.getAttribute(name) === value
    }

    /**
     * Test if the element or one of it's parents has a certain predicate
     * Can be use for example to check whether the element or it's parent has
     * a specific attribute or nodeName.
     * @param {HTMLElement} element
     * @param {function (element: HTMLElement) : boolean} predicate
     * @returns {*}
     */
    function isChildOf (element, predicate) {
      // TODO: can we replace isChildOf with Element.closest?
      let e = element;

      while (e && !predicate(e)) {
        e = e.parentNode;
      }

      return e && predicate(e)
    }

    /**
     * Set the cursor to the end of a content editable div
     * Source: https://stackoverflow.com/questions/13513329/set-cursor-to-the-end-of-contenteditable-div
     * @param {HTMLElement} element
     */
    function setCursorToEnd (element) {
      if (element.firstChild == null) {
        element.focus();
        return
      }

      const range = document.createRange();
      const selection = window.getSelection();
      range.setStart(element, 1);
      range.collapse(true);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    /**
     * Gets a DOM element's Window.  This is normally just the global `window`
     * variable, but if we opened a child window, it may be different.
     * @param {HTMLElement} element
     * @return {Window}
     */
    function getWindow (element) {
      return element.ownerDocument.defaultView
    }

    /**
     * @param {HTMLElement} element
     * @return {boolean}
     */
    function activeElementIsChildOf (element) {
      const window = getWindow(element);
      return isChildOf(window.document.activeElement, e => e === element)
    }

    /**
     * Traverse over the parents of the element until a node is found with the
     * searched for node name. If the element itself contains the nodeName, the
     * element itself will be returned
     * @param {HTMLElement} element
     * @param {string} nodeName
     * @return {HTMLElement | undefined}
     */
    function findParentWithNodeName (element, nodeName) {
      let e = element;

      while (e && e.nodeName !== nodeName) {
        e = e.parentNode;
      }

      return e
    }

    /**
     * @param {HTMLElement} target
     * @returns {string | null}
     */
    function getSelectionTypeFromTarget (target) {
      if (isChildOfAttribute(target, 'data-type', 'selectable-key')) {
        return SELECTION_TYPE.KEY
      }

      if (isChildOfAttribute(target, 'data-type', 'selectable-value')) {
        return SELECTION_TYPE.VALUE
      }

      if (isChildOfAttribute(target, 'data-type', 'insert-selection-area-inside')) {
        return SELECTION_TYPE.INSIDE
      }

      if (isChildOfAttribute(target, 'data-type', 'insert-selection-area-after')) {
        return SELECTION_TYPE.AFTER
      }

      return SELECTION_TYPE.MULTI
    }

    const IS_MAC = navigator.platform.toUpperCase().indexOf('MAC') >= 0;

    // inspiration: https://github.com/andrepolischuk/keycomb

    /**
     * Get a named key from a key code.
     * For example:
     *     keyFromCode(65) returns 'A'
     *     keyFromCode(13) returns 'Enter'
     * @param {string} code
     * @return {string}
     */
    function nameFromKeyCode (code) {
      return codes[code] || ''
    }

    /**
     * Get the active key combination from a keyboard event.
     * For example returns "Ctrl+Shift+Up" or "Ctrl+A"
     * @param {KeyboardEvent} event
     * @return {string}
     */
    function keyComboFromEvent (event) {
      const combi = [];

      if (event.ctrlKey) { combi.push('Ctrl'); }
      if (event.metaKey) { combi.push('Command'); }
      if (event.altKey) { combi.push(IS_MAC ? 'Option' : 'Alt'); }
      if (event.shiftKey) { combi.push('Shift'); }

      const keyName = nameFromKeyCode(event.which);
      if (!metaCodes[keyName]) { // prevent output like 'Ctrl+Ctrl'
        combi.push(keyName);
      }

      return combi.join('+')
    }

    const metaCodes = {
      Ctrl: true,
      Command: true,
      Alt: true,
      Option: true,
      Shift: true
    };

    const codes = {
      8: 'Backspace',
      9: 'Tab',
      13: 'Enter',
      16: 'Shift',
      17: 'Ctrl',
      18: 'Alt',
      19: 'Pause_Break',
      20: 'Caps_Lock',
      27: 'Escape',
      33: 'Page_Up',
      34: 'Page_Down',
      35: 'End',
      36: 'Home',
      37: 'Left',
      38: 'Up',
      39: 'Right',
      40: 'Down',
      45: 'Insert',
      46: 'Delete',
      48: '0',
      49: '1',
      50: '2',
      51: '3',
      52: '4',
      53: '5',
      54: '6',
      55: '7',
      56: '8',
      57: '9',
      65: 'A',
      66: 'B',
      67: 'C',
      68: 'D',
      69: 'E',
      70: 'F',
      71: 'G',
      72: 'H',
      73: 'I',
      74: 'J',
      75: 'K',
      76: 'L',
      77: 'M',
      78: 'N',
      79: 'O',
      80: 'P',
      81: 'Q',
      82: 'R',
      83: 'S',
      84: 'T',
      85: 'U',
      86: 'V',
      87: 'W',
      88: 'X',
      89: 'Y',
      90: 'Z',
      91: 'Left_Window_Key',
      92: 'Right_Window_Key',
      93: 'Select_Key',
      96: 'Numpad_0',
      97: 'Numpad_1',
      98: 'Numpad_2',
      99: 'Numpad_3',
      100: 'Numpad_4',
      101: 'Numpad_5',
      102: 'Numpad_6',
      103: 'Numpad_7',
      104: 'Numpad_8',
      105: 'Numpad_9',
      106: 'Numpad_*',
      107: 'Numpad_+',
      109: 'Numpad_-',
      110: 'Numpad_.',
      111: 'Numpad_/',
      112: 'F1',
      113: 'F2',
      114: 'F3',
      115: 'F4',
      116: 'F5',
      117: 'F6',
      118: 'F7',
      119: 'F8',
      120: 'F9',
      121: 'F10',
      122: 'F11',
      123: 'F12',
      144: 'Num_Lock',
      145: 'Scroll_Lock',
      186: ';',
      187: '=',
      188: ',',
      189: '-',
      190: '.',
      191: '/',
      192: '`',
      219: '[',
      220: '\\',
      221: ']',
      222: '\''
    };

    /* node_modules\svelte-jsoneditor\src\components\modals\popup\AbsolutePopup.svelte generated by Svelte v3.38.2 */

    const { Error: Error_1$1, window: window_1$1 } = globals;
    const file$E = "node_modules\\svelte-jsoneditor\\src\\components\\modals\\popup\\AbsolutePopup.svelte";

    // (140:2) {#if popupComponent && popupProps}
    function create_if_block$j(ctx) {
    	let div;
    	let input;
    	let t;
    	let switch_instance;
    	let current;
    	const switch_instance_spread_levels = [/*popupProps*/ ctx[1]];
    	var switch_value = /*popupComponent*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign$1(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			t = space();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(input, "class", "hidden-input svelte-1g8ebt0");
    			add_location(input, file$E, 144, 6, 3593);
    			attr_dev(div, "class", "absolute-popup-content svelte-1g8ebt0");
    			attr_dev(div, "style", /*calculateStyle*/ ctx[7]());
    			add_location(div, file$E, 140, 4, 3508);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			/*input_binding*/ ctx[10](input);
    			append_dev(div, t);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*popupProps*/ 2)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*popupProps*/ ctx[1])])
    			: {};

    			if (switch_value !== (switch_value = /*popupComponent*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*input_binding*/ ctx[10](null);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(140:2) {#if popupComponent && popupProps}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let div;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*popupComponent*/ ctx[0] && /*popupProps*/ ctx[1] && create_if_block$j(ctx);
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "absolute-popup svelte-1g8ebt0");
    			add_location(div, file$E, 133, 0, 3340);
    		},
    		l: function claim(nodes) {
    			throw new Error_1$1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			/*div_binding*/ ctx[11](div);
    			insert_dev(target, t, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window_1$1, "mousedown", /*handleWindowMouseDown*/ ctx[4], true, false, false),
    					listen_dev(window_1$1, "keydown", /*handleKeyDown*/ ctx[5], true, false, false),
    					listen_dev(window_1$1, "wheel", /*handleScrollWheel*/ ctx[6], true, false, false),
    					listen_dev(div, "mousedown", handleMouseDownInside, false, false, false),
    					listen_dev(div, "keydown", /*handleKeyDown*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*popupComponent*/ ctx[0] && /*popupProps*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*popupComponent, popupProps*/ 3) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$j(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			/*div_binding*/ ctx[11](null);
    			if (detaching) detach_dev(t);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function handleMouseDownInside(event) {
    	event.stopPropagation();
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AbsolutePopup", slots, ['default']);
    	const debug = browser("jsoneditor:AbsolutePopup");
    	let popupComponent = null;
    	let popupProps = null;
    	let popupOptions = {};
    	let refRootPopup;
    	let refHiddenInput;

    	function openAbsolutePopup(Component, props, options) {
    		debug("open...", options);
    		$$invalidate(0, popupComponent = Component);
    		$$invalidate(1, popupProps = props || {});
    		popupOptions = options || {};
    		tick$1().then(focus);
    	}

    	function closeAbsolutePopup() {
    		if (popupComponent) {
    			const onClose = popupOptions.onClose;
    			$$invalidate(0, popupComponent = null);
    			$$invalidate(1, popupProps = null);
    			popupOptions = {};

    			if (onClose) {
    				onClose();
    			}
    		}
    	}

    	function handleWindowMouseDown(event) {
    		if (popupOptions && popupOptions.closeOnOuterClick && !isChildOf(event.target, e => e === refRootPopup)) {
    			closeAbsolutePopup();
    		}
    	}

    	function handleKeyDown(event) {
    		const combo = keyComboFromEvent(event);

    		if (combo === "Escape") {
    			closeAbsolutePopup();
    		}
    	}

    	function handleScrollWheel() {
    		closeAbsolutePopup();
    	}

    	function calculateStyle() {
    		function calculatePosition() {
    			if (popupOptions.anchor) {
    				const { anchor, width, height } = popupOptions;
    				const { left, top, bottom, right } = anchor.getBoundingClientRect();
    				const positionAbove = top + height > window.innerHeight && top > height;
    				const positionLeft = left + width > window.innerWidth && left > width;

    				return {
    					left: positionLeft ? right : left,
    					top: positionAbove ? top - 2 : bottom + 2,
    					positionAbove,
    					positionLeft
    				};
    			} else if (typeof popupOptions.left === "number" && typeof popupOptions.top === "number") {
    				const { left, top, width, height } = popupOptions;
    				const positionAbove = top + height > window.innerHeight && top > height;
    				const positionLeft = left + width > window.innerWidth && left > width;
    				return { left, top, positionAbove, positionLeft };
    			} else {
    				throw new Error("Invalid config: pass either \"left\" and \"top\", or pass \"anchor\"");
    			}
    		}

    		const rootRect = refRootPopup.getBoundingClientRect();
    		const { left, top, positionAbove, positionLeft } = calculatePosition();

    		const verticalStyling = positionAbove
    		? `bottom: ${rootRect.top - top}px;`
    		: `top: ${top - rootRect.top}px;`;

    		const horizontalStyling = positionLeft
    		? `right: ${rootRect.left - left}px;`
    		: `left: ${left - rootRect.left}px;`;

    		return verticalStyling + horizontalStyling;
    	}

    	function focus() {
    		if (refHiddenInput) {
    			refHiddenInput.focus();
    		}
    	}

    	setContext("absolute-popup", { openAbsolutePopup, closeAbsolutePopup });
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AbsolutePopup> was created with unknown prop '${key}'`);
    	});

    	function input_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			refHiddenInput = $$value;
    			$$invalidate(3, refHiddenInput);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			refRootPopup = $$value;
    			$$invalidate(2, refRootPopup);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createDebug: browser,
    		setContext,
    		tick: tick$1,
    		isChildOf,
    		keyComboFromEvent,
    		debug,
    		popupComponent,
    		popupProps,
    		popupOptions,
    		refRootPopup,
    		refHiddenInput,
    		openAbsolutePopup,
    		closeAbsolutePopup,
    		handleWindowMouseDown,
    		handleMouseDownInside,
    		handleKeyDown,
    		handleScrollWheel,
    		calculateStyle,
    		focus
    	});

    	$$self.$inject_state = $$props => {
    		if ("popupComponent" in $$props) $$invalidate(0, popupComponent = $$props.popupComponent);
    		if ("popupProps" in $$props) $$invalidate(1, popupProps = $$props.popupProps);
    		if ("popupOptions" in $$props) popupOptions = $$props.popupOptions;
    		if ("refRootPopup" in $$props) $$invalidate(2, refRootPopup = $$props.refRootPopup);
    		if ("refHiddenInput" in $$props) $$invalidate(3, refHiddenInput = $$props.refHiddenInput);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		popupComponent,
    		popupProps,
    		refRootPopup,
    		refHiddenInput,
    		handleWindowMouseDown,
    		handleKeyDown,
    		handleScrollWheel,
    		calculateStyle,
    		$$scope,
    		slots,
    		input_binding,
    		div_binding
    	];
    }

    class AbsolutePopup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AbsolutePopup",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    function fade(node, { delay = 0, duration = 400, easing = identity$1 } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }

    /* node_modules\svelte-simple-modal\src\Modal.svelte generated by Svelte v3.38.2 */

    const { Object: Object_1$3, window: window_1 } = globals;
    const file$D = "node_modules\\svelte-simple-modal\\src\\Modal.svelte";

    // (314:0) {#if Component}
    function create_if_block$i(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let t;
    	let div0;
    	let switch_instance;
    	let div1_transition;
    	let div3_transition;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*state*/ ctx[0].closeButton && create_if_block_1$c(ctx);
    	var switch_value = /*Component*/ ctx[1];

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			div0 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div0, "class", "content svelte-2wx9ab");
    			attr_dev(div0, "style", /*cssContent*/ ctx[8]);
    			add_location(div0, file$D, 341, 8, 8219);
    			attr_dev(div1, "class", "window svelte-2wx9ab");
    			attr_dev(div1, "role", "dialog");
    			attr_dev(div1, "aria-modal", "true");
    			attr_dev(div1, "style", /*cssWindow*/ ctx[7]);
    			add_location(div1, file$D, 322, 6, 7594);
    			attr_dev(div2, "class", "window-wrap svelte-2wx9ab");
    			attr_dev(div2, "style", /*cssWindowWrap*/ ctx[6]);
    			add_location(div2, file$D, 321, 4, 7523);
    			attr_dev(div3, "class", "bg svelte-2wx9ab");
    			attr_dev(div3, "style", /*cssBg*/ ctx[5]);
    			add_location(div3, file$D, 314, 2, 7357);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t);
    			append_dev(div1, div0);

    			if (switch_instance) {
    				mount_component(switch_instance, div0, null);
    			}

    			/*div1_binding*/ ctx[37](div1);
    			/*div2_binding*/ ctx[38](div2);
    			/*div3_binding*/ ctx[39](div3);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						div1,
    						"introstart",
    						function () {
    							if (is_function(/*onOpen*/ ctx[12])) /*onOpen*/ ctx[12].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div1,
    						"outrostart",
    						function () {
    							if (is_function(/*onClose*/ ctx[13])) /*onClose*/ ctx[13].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div1,
    						"introend",
    						function () {
    							if (is_function(/*onOpened*/ ctx[14])) /*onOpened*/ ctx[14].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div1,
    						"outroend",
    						function () {
    							if (is_function(/*onClosed*/ ctx[15])) /*onClosed*/ ctx[15].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(div3, "click", /*handleOuterClick*/ ctx[19], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*state*/ ctx[0].closeButton) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*state*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (switch_value !== (switch_value = /*Component*/ ctx[1])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div0, null);
    				} else {
    					switch_instance = null;
    				}
    			}

    			if (!current || dirty[0] & /*cssContent*/ 256) {
    				attr_dev(div0, "style", /*cssContent*/ ctx[8]);
    			}

    			if (!current || dirty[0] & /*cssWindow*/ 128) {
    				attr_dev(div1, "style", /*cssWindow*/ ctx[7]);
    			}

    			if (!current || dirty[0] & /*cssWindowWrap*/ 64) {
    				attr_dev(div2, "style", /*cssWindowWrap*/ ctx[6]);
    			}

    			if (!current || dirty[0] & /*cssBg*/ 32) {
    				attr_dev(div3, "style", /*cssBg*/ ctx[5]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, /*currentTransitionWindow*/ ctx[11], /*state*/ ctx[0].transitionWindowProps, true);
    				div1_transition.run(1);
    			});

    			add_render_callback(() => {
    				if (!div3_transition) div3_transition = create_bidirectional_transition(div3, /*currentTransitionBg*/ ctx[10], /*state*/ ctx[0].transitionBgProps, true);
    				div3_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, /*currentTransitionWindow*/ ctx[11], /*state*/ ctx[0].transitionWindowProps, false);
    			div1_transition.run(0);
    			if (!div3_transition) div3_transition = create_bidirectional_transition(div3, /*currentTransitionBg*/ ctx[10], /*state*/ ctx[0].transitionBgProps, false);
    			div3_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block) if_block.d();
    			if (switch_instance) destroy_component(switch_instance);
    			/*div1_binding*/ ctx[37](null);
    			if (detaching && div1_transition) div1_transition.end();
    			/*div2_binding*/ ctx[38](null);
    			/*div3_binding*/ ctx[39](null);
    			if (detaching && div3_transition) div3_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(314:0) {#if Component}",
    		ctx
    	});

    	return block;
    }

    // (335:8) {#if state.closeButton}
    function create_if_block_1$c(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$8, create_else_block$b];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty[0] & /*state*/ 1) show_if = !!/*isFunction*/ ctx[16](/*state*/ ctx[0].closeButton);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx, [-1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(335:8) {#if state.closeButton}",
    		ctx
    	});

    	return block;
    }

    // (338:10) {:else}
    function create_else_block$b(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			attr_dev(button, "class", "close svelte-2wx9ab");
    			attr_dev(button, "style", /*cssCloseButton*/ ctx[9]);
    			add_location(button, file$D, 338, 12, 8116);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*close*/ ctx[17], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*cssCloseButton*/ 512) {
    				attr_dev(button, "style", /*cssCloseButton*/ ctx[9]);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(338:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (336:10) {#if isFunction(state.closeButton)}
    function create_if_block_2$8(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*state*/ ctx[0].closeButton;

    	function switch_props(ctx) {
    		return {
    			props: { onClose: /*close*/ ctx[17] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*state*/ ctx[0].closeButton)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(336:10) {#if isFunction(state.closeButton)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*Component*/ ctx[1] && create_if_block$i(ctx);
    	const default_slot_template = /*#slots*/ ctx[36].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[35], null);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window_1, "keydown", /*handleKeydown*/ ctx[18], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*Component*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*Component*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$i(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 16)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[35], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function bind(Component, props = {}) {
    	return function ModalComponent(options) {
    		return new Component({
    				...options,
    				props: { ...props, ...options.props }
    			});
    	};
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Modal", slots, ['default']);
    	const dispatch = createEventDispatcher();
    	const baseSetContext = setContext;
    	let { show = null } = $$props;
    	let { key = "simple-modal" } = $$props;
    	let { closeButton = true } = $$props;
    	let { closeOnEsc = true } = $$props;
    	let { closeOnOuterClick = true } = $$props;
    	let { styleBg = {} } = $$props;
    	let { styleWindowWrap = {} } = $$props;
    	let { styleWindow = {} } = $$props;
    	let { styleContent = {} } = $$props;
    	let { styleCloseButton = {} } = $$props;
    	let { setContext: setContext$1 = baseSetContext } = $$props;
    	let { transitionBg = fade } = $$props;
    	let { transitionBgProps = { duration: 250 } } = $$props;
    	let { transitionWindow = transitionBg } = $$props;
    	let { transitionWindowProps = transitionBgProps } = $$props;

    	const defaultState = {
    		closeButton,
    		closeOnEsc,
    		closeOnOuterClick,
    		styleBg,
    		styleWindowWrap,
    		styleWindow,
    		styleContent,
    		styleCloseButton,
    		transitionBg,
    		transitionBgProps,
    		transitionWindow,
    		transitionWindowProps
    	};

    	let state = { ...defaultState };
    	let Component = null;
    	let background;
    	let wrap;
    	let modalWindow;
    	let scrollY;
    	let cssBg;
    	let cssWindowWrap;
    	let cssWindow;
    	let cssContent;
    	let cssCloseButton;
    	let currentTransitionBg;
    	let currentTransitionWindow;
    	let prevBodyPosition;
    	let prevBodyOverflow;
    	const camelCaseToDash = str => str.replace(/([a-zA-Z])(?=[A-Z])/g, "$1-").toLowerCase();
    	const toCssString = props => Object.keys(props).reduce((str, key) => `${str}; ${camelCaseToDash(key)}: ${props[key]}`, "");
    	const isFunction = f => !!(f && f.constructor && f.call && f.apply);

    	const updateStyleTransition = () => {
    		$$invalidate(5, cssBg = toCssString(state.styleBg));
    		$$invalidate(6, cssWindowWrap = toCssString(state.styleWindowWrap));
    		$$invalidate(7, cssWindow = toCssString(state.styleWindow));
    		$$invalidate(8, cssContent = toCssString(state.styleContent));
    		$$invalidate(9, cssCloseButton = toCssString(state.styleCloseButton));
    		$$invalidate(10, currentTransitionBg = state.transitionBg);
    		$$invalidate(11, currentTransitionWindow = state.transitionWindow);
    	};

    	const toVoid = () => {
    		
    	};

    	let onOpen = toVoid;
    	let onClose = toVoid;
    	let onOpened = toVoid;
    	let onClosed = toVoid;

    	const open = (NewComponent, newProps = {}, options = {}, callback = {}) => {
    		$$invalidate(1, Component = bind(NewComponent, newProps));
    		$$invalidate(0, state = { ...defaultState, ...options });
    		updateStyleTransition();
    		disableScroll();

    		($$invalidate(12, onOpen = event => {
    			if (callback.onOpen) callback.onOpen(event);
    			dispatch("open");
    			dispatch("opening"); // Deprecated. Do not use!
    		}), $$invalidate(13, onClose = event => {
    			if (callback.onClose) callback.onClose(event);
    			dispatch("close");
    			dispatch("closing"); // Deprecated. Do not use!
    		}), $$invalidate(14, onOpened = event => {
    			if (callback.onOpened) callback.onOpened(event);
    			dispatch("opened");
    		}));

    		$$invalidate(15, onClosed = event => {
    			if (callback.onClosed) callback.onClosed(event);
    			dispatch("closed");
    		});
    	};

    	const close = (callback = {}) => {
    		$$invalidate(13, onClose = callback.onClose || onClose);
    		$$invalidate(15, onClosed = callback.onClosed || onClosed);
    		$$invalidate(1, Component = null);
    		enableScroll();
    	};

    	const handleKeydown = event => {
    		if (state.closeOnEsc && Component && event.key === "Escape") {
    			event.preventDefault();
    			close();
    		}

    		if (Component && event.key === "Tab") {
    			// trap focus
    			const nodes = modalWindow.querySelectorAll("*");

    			const tabbable = Array.from(nodes).filter(node => node.tabIndex >= 0);
    			let index = tabbable.indexOf(document.activeElement);
    			if (index === -1 && event.shiftKey) index = 0;
    			index += tabbable.length + (event.shiftKey ? -1 : 1);
    			index %= tabbable.length;
    			tabbable[index].focus();
    			event.preventDefault();
    		}
    	};

    	const handleOuterClick = event => {
    		if (state.closeOnOuterClick && (event.target === background || event.target === wrap)) {
    			event.preventDefault();
    			close();
    		}
    	};

    	const disableScroll = () => {
    		scrollY = window.scrollY;
    		prevBodyPosition = document.body.style.position;
    		prevBodyOverflow = document.body.style.overflow;
    		document.body.style.position = "fixed";
    		document.body.style.top = `-${scrollY}px`;
    		document.body.style.overflow = "hidden";
    	};

    	const enableScroll = () => {
    		document.body.style.position = prevBodyPosition || "";
    		document.body.style.top = "";
    		document.body.style.overflow = prevBodyOverflow || "";
    		window.scrollTo(0, scrollY);
    	};

    	setContext$1(key, { open, close });

    	onDestroy(() => {
    		close();
    	});

    	const writable_props = [
    		"show",
    		"key",
    		"closeButton",
    		"closeOnEsc",
    		"closeOnOuterClick",
    		"styleBg",
    		"styleWindowWrap",
    		"styleWindow",
    		"styleContent",
    		"styleCloseButton",
    		"setContext",
    		"transitionBg",
    		"transitionBgProps",
    		"transitionWindow",
    		"transitionWindowProps"
    	];

    	Object_1$3.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Modal> was created with unknown prop '${key}'`);
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			modalWindow = $$value;
    			$$invalidate(4, modalWindow);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			wrap = $$value;
    			$$invalidate(3, wrap);
    		});
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			background = $$value;
    			$$invalidate(2, background);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("show" in $$props) $$invalidate(20, show = $$props.show);
    		if ("key" in $$props) $$invalidate(21, key = $$props.key);
    		if ("closeButton" in $$props) $$invalidate(22, closeButton = $$props.closeButton);
    		if ("closeOnEsc" in $$props) $$invalidate(23, closeOnEsc = $$props.closeOnEsc);
    		if ("closeOnOuterClick" in $$props) $$invalidate(24, closeOnOuterClick = $$props.closeOnOuterClick);
    		if ("styleBg" in $$props) $$invalidate(25, styleBg = $$props.styleBg);
    		if ("styleWindowWrap" in $$props) $$invalidate(26, styleWindowWrap = $$props.styleWindowWrap);
    		if ("styleWindow" in $$props) $$invalidate(27, styleWindow = $$props.styleWindow);
    		if ("styleContent" in $$props) $$invalidate(28, styleContent = $$props.styleContent);
    		if ("styleCloseButton" in $$props) $$invalidate(29, styleCloseButton = $$props.styleCloseButton);
    		if ("setContext" in $$props) $$invalidate(30, setContext$1 = $$props.setContext);
    		if ("transitionBg" in $$props) $$invalidate(31, transitionBg = $$props.transitionBg);
    		if ("transitionBgProps" in $$props) $$invalidate(32, transitionBgProps = $$props.transitionBgProps);
    		if ("transitionWindow" in $$props) $$invalidate(33, transitionWindow = $$props.transitionWindow);
    		if ("transitionWindowProps" in $$props) $$invalidate(34, transitionWindowProps = $$props.transitionWindowProps);
    		if ("$$scope" in $$props) $$invalidate(35, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		bind,
    		svelte,
    		fade,
    		createEventDispatcher,
    		dispatch,
    		baseSetContext,
    		show,
    		key,
    		closeButton,
    		closeOnEsc,
    		closeOnOuterClick,
    		styleBg,
    		styleWindowWrap,
    		styleWindow,
    		styleContent,
    		styleCloseButton,
    		setContext: setContext$1,
    		transitionBg,
    		transitionBgProps,
    		transitionWindow,
    		transitionWindowProps,
    		defaultState,
    		state,
    		Component,
    		background,
    		wrap,
    		modalWindow,
    		scrollY,
    		cssBg,
    		cssWindowWrap,
    		cssWindow,
    		cssContent,
    		cssCloseButton,
    		currentTransitionBg,
    		currentTransitionWindow,
    		prevBodyPosition,
    		prevBodyOverflow,
    		camelCaseToDash,
    		toCssString,
    		isFunction,
    		updateStyleTransition,
    		toVoid,
    		onOpen,
    		onClose,
    		onOpened,
    		onClosed,
    		open,
    		close,
    		handleKeydown,
    		handleOuterClick,
    		disableScroll,
    		enableScroll
    	});

    	$$self.$inject_state = $$props => {
    		if ("show" in $$props) $$invalidate(20, show = $$props.show);
    		if ("key" in $$props) $$invalidate(21, key = $$props.key);
    		if ("closeButton" in $$props) $$invalidate(22, closeButton = $$props.closeButton);
    		if ("closeOnEsc" in $$props) $$invalidate(23, closeOnEsc = $$props.closeOnEsc);
    		if ("closeOnOuterClick" in $$props) $$invalidate(24, closeOnOuterClick = $$props.closeOnOuterClick);
    		if ("styleBg" in $$props) $$invalidate(25, styleBg = $$props.styleBg);
    		if ("styleWindowWrap" in $$props) $$invalidate(26, styleWindowWrap = $$props.styleWindowWrap);
    		if ("styleWindow" in $$props) $$invalidate(27, styleWindow = $$props.styleWindow);
    		if ("styleContent" in $$props) $$invalidate(28, styleContent = $$props.styleContent);
    		if ("styleCloseButton" in $$props) $$invalidate(29, styleCloseButton = $$props.styleCloseButton);
    		if ("setContext" in $$props) $$invalidate(30, setContext$1 = $$props.setContext);
    		if ("transitionBg" in $$props) $$invalidate(31, transitionBg = $$props.transitionBg);
    		if ("transitionBgProps" in $$props) $$invalidate(32, transitionBgProps = $$props.transitionBgProps);
    		if ("transitionWindow" in $$props) $$invalidate(33, transitionWindow = $$props.transitionWindow);
    		if ("transitionWindowProps" in $$props) $$invalidate(34, transitionWindowProps = $$props.transitionWindowProps);
    		if ("state" in $$props) $$invalidate(0, state = $$props.state);
    		if ("Component" in $$props) $$invalidate(1, Component = $$props.Component);
    		if ("background" in $$props) $$invalidate(2, background = $$props.background);
    		if ("wrap" in $$props) $$invalidate(3, wrap = $$props.wrap);
    		if ("modalWindow" in $$props) $$invalidate(4, modalWindow = $$props.modalWindow);
    		if ("scrollY" in $$props) scrollY = $$props.scrollY;
    		if ("cssBg" in $$props) $$invalidate(5, cssBg = $$props.cssBg);
    		if ("cssWindowWrap" in $$props) $$invalidate(6, cssWindowWrap = $$props.cssWindowWrap);
    		if ("cssWindow" in $$props) $$invalidate(7, cssWindow = $$props.cssWindow);
    		if ("cssContent" in $$props) $$invalidate(8, cssContent = $$props.cssContent);
    		if ("cssCloseButton" in $$props) $$invalidate(9, cssCloseButton = $$props.cssCloseButton);
    		if ("currentTransitionBg" in $$props) $$invalidate(10, currentTransitionBg = $$props.currentTransitionBg);
    		if ("currentTransitionWindow" in $$props) $$invalidate(11, currentTransitionWindow = $$props.currentTransitionWindow);
    		if ("prevBodyPosition" in $$props) prevBodyPosition = $$props.prevBodyPosition;
    		if ("prevBodyOverflow" in $$props) prevBodyOverflow = $$props.prevBodyOverflow;
    		if ("onOpen" in $$props) $$invalidate(12, onOpen = $$props.onOpen);
    		if ("onClose" in $$props) $$invalidate(13, onClose = $$props.onClose);
    		if ("onOpened" in $$props) $$invalidate(14, onOpened = $$props.onOpened);
    		if ("onClosed" in $$props) $$invalidate(15, onClosed = $$props.onClosed);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*show*/ 1048576) {
    			{
    				if (isFunction(show)) {
    					open(show);
    				} else {
    					close();
    				}
    			}
    		}
    	};

    	return [
    		state,
    		Component,
    		background,
    		wrap,
    		modalWindow,
    		cssBg,
    		cssWindowWrap,
    		cssWindow,
    		cssContent,
    		cssCloseButton,
    		currentTransitionBg,
    		currentTransitionWindow,
    		onOpen,
    		onClose,
    		onOpened,
    		onClosed,
    		isFunction,
    		close,
    		handleKeydown,
    		handleOuterClick,
    		show,
    		key,
    		closeButton,
    		closeOnEsc,
    		closeOnOuterClick,
    		styleBg,
    		styleWindowWrap,
    		styleWindow,
    		styleContent,
    		styleCloseButton,
    		setContext$1,
    		transitionBg,
    		transitionBgProps,
    		transitionWindow,
    		transitionWindowProps,
    		$$scope,
    		slots,
    		div1_binding,
    		div2_binding,
    		div3_binding
    	];
    }

    class Modal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$G,
    			create_fragment$G,
    			safe_not_equal,
    			{
    				show: 20,
    				key: 21,
    				closeButton: 22,
    				closeOnEsc: 23,
    				closeOnOuterClick: 24,
    				styleBg: 25,
    				styleWindowWrap: 26,
    				styleWindow: 27,
    				styleContent: 28,
    				styleCloseButton: 29,
    				setContext: 30,
    				transitionBg: 31,
    				transitionBgProps: 32,
    				transitionWindow: 33,
    				transitionWindowProps: 34
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modal",
    			options,
    			id: create_fragment$G.name
    		});
    	}

    	get show() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set show(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeButton() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeButton(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeOnEsc() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeOnEsc(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeOnOuterClick() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeOnOuterClick(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleBg() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleBg(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleWindowWrap() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleWindowWrap(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleWindow() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleWindow(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleContent() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleContent(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleCloseButton() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleCloseButton(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setContext() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set setContext(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionBg() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionBg(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionBgProps() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionBgProps(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionWindow() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionWindow(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionWindowProps() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionWindowProps(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const debug = browser('jsoneditor:FocusTracker');

    function createFocusTracker ({ onMount, onDestroy, getWindow, hasFocus, onFocus, onBlur }) {
      let blurTimeoutHandle;
      let focus = false;

      function handleFocusIn () {
        const newFocus = hasFocus();

        if (newFocus) {
          clearTimeout(blurTimeoutHandle);
          if (!focus) {
            debug('focus');
            onFocus();
            focus = newFocus;
          }
        }
      }

      function handleFocusOut () {
        if (focus) {
          // We set focus to false after timeout. Often, you get a blur and directly
          // another focus when moving focus from one button to another.
          // The focusIn handler will cancel any pending blur timer in those cases
          clearTimeout(blurTimeoutHandle);
          blurTimeoutHandle = setTimeout(() => {
            debug('blur');
            focus = false;
            onBlur();
          });
        }
      }

      onMount(() => {
        debug('mount FocusTracker');
        const window = getWindow();
        window.addEventListener('focusin', handleFocusIn, true);
        window.addEventListener('focusout', handleFocusOut, true);
      });

      onDestroy(() => {
        debug('destroy FocusTracker');
        const window = getWindow();
        window.removeEventListener('focusin', handleFocusIn, true);
        window.removeEventListener('focusout', handleFocusOut, true);
      });
    }

    /* node_modules\svelte-awesome\components\svg\Path.svelte generated by Svelte v3.38.2 */

    const file$C = "node_modules\\svelte-awesome\\components\\svg\\Path.svelte";

    function create_fragment$F(ctx) {
    	let path;
    	let path_key_value;

    	let path_levels = [
    		{
    			key: path_key_value = "path-" + /*id*/ ctx[0]
    		},
    		/*data*/ ctx[1]
    	];

    	let path_data = {};

    	for (let i = 0; i < path_levels.length; i += 1) {
    		path_data = assign$1(path_data, path_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			set_svg_attributes(path, path_data);
    			add_location(path, file$C, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(path, path_data = get_spread_update(path_levels, [
    				dirty & /*id*/ 1 && path_key_value !== (path_key_value = "path-" + /*id*/ ctx[0]) && { key: path_key_value },
    				dirty & /*data*/ 2 && /*data*/ ctx[1]
    			]));
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Path", slots, []);
    	let { id = "" } = $$props;
    	let { data = {} } = $$props;
    	const writable_props = ["id", "data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Path> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("data" in $$props) $$invalidate(1, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({ id, data });

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("data" in $$props) $$invalidate(1, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [id, data];
    }

    class Path extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$F, safe_not_equal, { id: 0, data: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Path",
    			options,
    			id: create_fragment$F.name
    		});
    	}

    	get id() {
    		throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get data() {
    		throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-awesome\components\svg\Polygon.svelte generated by Svelte v3.38.2 */

    const file$B = "node_modules\\svelte-awesome\\components\\svg\\Polygon.svelte";

    function create_fragment$E(ctx) {
    	let polygon;
    	let polygon_key_value;

    	let polygon_levels = [
    		{
    			key: polygon_key_value = "polygon-" + /*id*/ ctx[0]
    		},
    		/*data*/ ctx[1]
    	];

    	let polygon_data = {};

    	for (let i = 0; i < polygon_levels.length; i += 1) {
    		polygon_data = assign$1(polygon_data, polygon_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			polygon = svg_element("polygon");
    			set_svg_attributes(polygon, polygon_data);
    			add_location(polygon, file$B, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, polygon, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(polygon, polygon_data = get_spread_update(polygon_levels, [
    				dirty & /*id*/ 1 && polygon_key_value !== (polygon_key_value = "polygon-" + /*id*/ ctx[0]) && { key: polygon_key_value },
    				dirty & /*data*/ 2 && /*data*/ ctx[1]
    			]));
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(polygon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Polygon", slots, []);
    	let { id = "" } = $$props;
    	let { data = {} } = $$props;
    	const writable_props = ["id", "data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Polygon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("data" in $$props) $$invalidate(1, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({ id, data });

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("data" in $$props) $$invalidate(1, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [id, data];
    }

    class Polygon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, { id: 0, data: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Polygon",
    			options,
    			id: create_fragment$E.name
    		});
    	}

    	get id() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get data() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-awesome\components\svg\Raw.svelte generated by Svelte v3.38.2 */

    const file$A = "node_modules\\svelte-awesome\\components\\svg\\Raw.svelte";

    function create_fragment$D(ctx) {
    	let g;

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			add_location(g, file$A, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			g.innerHTML = /*raw*/ ctx[0];
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*raw*/ 1) g.innerHTML = /*raw*/ ctx[0];		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Raw", slots, []);
    	let cursor = 870711;

    	function getId() {
    		cursor += 1;
    		return `fa-${cursor.toString(16)}`;
    	}

    	let raw;
    	let { data } = $$props;

    	function getRaw(data) {
    		if (!data || !data.raw) {
    			return null;
    		}

    		let rawData = data.raw;
    		const ids = {};

    		rawData = rawData.replace(/\s(?:xml:)?id=["']?([^"')\s]+)/g, (match, id) => {
    			const uniqueId = getId();
    			ids[id] = uniqueId;
    			return ` id="${uniqueId}"`;
    		});

    		rawData = rawData.replace(/#(?:([^'")\s]+)|xpointer\(id\((['"]?)([^')]+)\2\)\))/g, (match, rawId, _, pointerId) => {
    			const id = rawId || pointerId;

    			if (!id || !ids[id]) {
    				return match;
    			}

    			return `#${ids[id]}`;
    		});

    		return rawData;
    	}

    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Raw> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("data" in $$props) $$invalidate(1, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({ cursor, getId, raw, data, getRaw });

    	$$self.$inject_state = $$props => {
    		if ("cursor" in $$props) cursor = $$props.cursor;
    		if ("raw" in $$props) $$invalidate(0, raw = $$props.raw);
    		if ("data" in $$props) $$invalidate(1, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 2) {
    			$$invalidate(0, raw = getRaw(data));
    		}
    	};

    	return [raw, data];
    }

    class Raw extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, { data: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Raw",
    			options,
    			id: create_fragment$D.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[1] === undefined && !("data" in props)) {
    			console.warn("<Raw> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<Raw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Raw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-awesome\components\svg\Svg.svelte generated by Svelte v3.38.2 */

    const file$z = "node_modules\\svelte-awesome\\components\\svg\\Svg.svelte";

    function create_fragment$C(ctx) {
    	let svg;
    	let svg_class_value;
    	let svg_role_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[13].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			if (default_slot) default_slot.c();
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "class", svg_class_value = "fa-icon " + /*className*/ ctx[0] + " svelte-1dof0an");
    			attr_dev(svg, "x", /*x*/ ctx[8]);
    			attr_dev(svg, "y", /*y*/ ctx[9]);
    			attr_dev(svg, "width", /*width*/ ctx[1]);
    			attr_dev(svg, "height", /*height*/ ctx[2]);
    			attr_dev(svg, "aria-label", /*label*/ ctx[11]);
    			attr_dev(svg, "role", svg_role_value = /*label*/ ctx[11] ? "img" : "presentation");
    			attr_dev(svg, "viewBox", /*box*/ ctx[3]);
    			attr_dev(svg, "style", /*style*/ ctx[10]);
    			toggle_class(svg, "fa-spin", /*spin*/ ctx[4]);
    			toggle_class(svg, "fa-pulse", /*pulse*/ ctx[6]);
    			toggle_class(svg, "fa-inverse", /*inverse*/ ctx[5]);
    			toggle_class(svg, "fa-flip-horizontal", /*flip*/ ctx[7] === "horizontal");
    			toggle_class(svg, "fa-flip-vertical", /*flip*/ ctx[7] === "vertical");
    			add_location(svg, file$z, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);

    			if (default_slot) {
    				default_slot.m(svg, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*className*/ 1 && svg_class_value !== (svg_class_value = "fa-icon " + /*className*/ ctx[0] + " svelte-1dof0an")) {
    				attr_dev(svg, "class", svg_class_value);
    			}

    			if (!current || dirty & /*x*/ 256) {
    				attr_dev(svg, "x", /*x*/ ctx[8]);
    			}

    			if (!current || dirty & /*y*/ 512) {
    				attr_dev(svg, "y", /*y*/ ctx[9]);
    			}

    			if (!current || dirty & /*width*/ 2) {
    				attr_dev(svg, "width", /*width*/ ctx[1]);
    			}

    			if (!current || dirty & /*height*/ 4) {
    				attr_dev(svg, "height", /*height*/ ctx[2]);
    			}

    			if (!current || dirty & /*label*/ 2048) {
    				attr_dev(svg, "aria-label", /*label*/ ctx[11]);
    			}

    			if (!current || dirty & /*label*/ 2048 && svg_role_value !== (svg_role_value = /*label*/ ctx[11] ? "img" : "presentation")) {
    				attr_dev(svg, "role", svg_role_value);
    			}

    			if (!current || dirty & /*box*/ 8) {
    				attr_dev(svg, "viewBox", /*box*/ ctx[3]);
    			}

    			if (!current || dirty & /*style*/ 1024) {
    				attr_dev(svg, "style", /*style*/ ctx[10]);
    			}

    			if (dirty & /*className, spin*/ 17) {
    				toggle_class(svg, "fa-spin", /*spin*/ ctx[4]);
    			}

    			if (dirty & /*className, pulse*/ 65) {
    				toggle_class(svg, "fa-pulse", /*pulse*/ ctx[6]);
    			}

    			if (dirty & /*className, inverse*/ 33) {
    				toggle_class(svg, "fa-inverse", /*inverse*/ ctx[5]);
    			}

    			if (dirty & /*className, flip*/ 129) {
    				toggle_class(svg, "fa-flip-horizontal", /*flip*/ ctx[7] === "horizontal");
    			}

    			if (dirty & /*className, flip*/ 129) {
    				toggle_class(svg, "fa-flip-vertical", /*flip*/ ctx[7] === "vertical");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Svg", slots, ['default']);
    	let { class: className } = $$props;
    	let { width } = $$props;
    	let { height } = $$props;
    	let { box } = $$props;
    	let { spin = false } = $$props;
    	let { inverse = false } = $$props;
    	let { pulse = false } = $$props;
    	let { flip = null } = $$props;
    	let { x = undefined } = $$props;
    	let { y = undefined } = $$props;
    	let { style = undefined } = $$props;
    	let { label = undefined } = $$props;

    	const writable_props = [
    		"class",
    		"width",
    		"height",
    		"box",
    		"spin",
    		"inverse",
    		"pulse",
    		"flip",
    		"x",
    		"y",
    		"style",
    		"label"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Svg> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("class" in $$props) $$invalidate(0, className = $$props.class);
    		if ("width" in $$props) $$invalidate(1, width = $$props.width);
    		if ("height" in $$props) $$invalidate(2, height = $$props.height);
    		if ("box" in $$props) $$invalidate(3, box = $$props.box);
    		if ("spin" in $$props) $$invalidate(4, spin = $$props.spin);
    		if ("inverse" in $$props) $$invalidate(5, inverse = $$props.inverse);
    		if ("pulse" in $$props) $$invalidate(6, pulse = $$props.pulse);
    		if ("flip" in $$props) $$invalidate(7, flip = $$props.flip);
    		if ("x" in $$props) $$invalidate(8, x = $$props.x);
    		if ("y" in $$props) $$invalidate(9, y = $$props.y);
    		if ("style" in $$props) $$invalidate(10, style = $$props.style);
    		if ("label" in $$props) $$invalidate(11, label = $$props.label);
    		if ("$$scope" in $$props) $$invalidate(12, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		width,
    		height,
    		box,
    		spin,
    		inverse,
    		pulse,
    		flip,
    		x,
    		y,
    		style,
    		label
    	});

    	$$self.$inject_state = $$props => {
    		if ("className" in $$props) $$invalidate(0, className = $$props.className);
    		if ("width" in $$props) $$invalidate(1, width = $$props.width);
    		if ("height" in $$props) $$invalidate(2, height = $$props.height);
    		if ("box" in $$props) $$invalidate(3, box = $$props.box);
    		if ("spin" in $$props) $$invalidate(4, spin = $$props.spin);
    		if ("inverse" in $$props) $$invalidate(5, inverse = $$props.inverse);
    		if ("pulse" in $$props) $$invalidate(6, pulse = $$props.pulse);
    		if ("flip" in $$props) $$invalidate(7, flip = $$props.flip);
    		if ("x" in $$props) $$invalidate(8, x = $$props.x);
    		if ("y" in $$props) $$invalidate(9, y = $$props.y);
    		if ("style" in $$props) $$invalidate(10, style = $$props.style);
    		if ("label" in $$props) $$invalidate(11, label = $$props.label);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		className,
    		width,
    		height,
    		box,
    		spin,
    		inverse,
    		pulse,
    		flip,
    		x,
    		y,
    		style,
    		label,
    		$$scope,
    		slots
    	];
    }

    class Svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$C, create_fragment$C, safe_not_equal, {
    			class: 0,
    			width: 1,
    			height: 2,
    			box: 3,
    			spin: 4,
    			inverse: 5,
    			pulse: 6,
    			flip: 7,
    			x: 8,
    			y: 9,
    			style: 10,
    			label: 11
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Svg",
    			options,
    			id: create_fragment$C.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*className*/ ctx[0] === undefined && !("class" in props)) {
    			console.warn("<Svg> was created without expected prop 'class'");
    		}

    		if (/*width*/ ctx[1] === undefined && !("width" in props)) {
    			console.warn("<Svg> was created without expected prop 'width'");
    		}

    		if (/*height*/ ctx[2] === undefined && !("height" in props)) {
    			console.warn("<Svg> was created without expected prop 'height'");
    		}

    		if (/*box*/ ctx[3] === undefined && !("box" in props)) {
    			console.warn("<Svg> was created without expected prop 'box'");
    		}
    	}

    	get class() {
    		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get box() {
    		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set box(value) {
    		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get spin() {
    		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set spin(value) {
    		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inverse() {
    		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inverse(value) {
    		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pulse() {
    		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pulse(value) {
    		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flip() {
    		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flip(value) {
    		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x() {
    		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-awesome\components\Icon.svelte generated by Svelte v3.38.2 */

    const { Object: Object_1$2, console: console_1$6 } = globals;

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[29] = list[i];
    	child_ctx[31] = i;
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[32] = list[i];
    	child_ctx[31] = i;
    	return child_ctx;
    }

    // (4:4) {#if self}
    function create_if_block$h(ctx) {
    	let t0;
    	let t1;
    	let if_block2_anchor;
    	let current;
    	let if_block0 = /*self*/ ctx[0].paths && create_if_block_3$4(ctx);
    	let if_block1 = /*self*/ ctx[0].polygons && create_if_block_2$7(ctx);
    	let if_block2 = /*self*/ ctx[0].raw && create_if_block_1$b(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*self*/ ctx[0].paths) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*self*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*self*/ ctx[0].polygons) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*self*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$7(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*self*/ ctx[0].raw) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*self*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1$b(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(4:4) {#if self}",
    		ctx
    	});

    	return block;
    }

    // (5:6) {#if self.paths}
    function create_if_block_3$4(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*self*/ ctx[0].paths;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*self*/ 1) {
    				each_value_1 = /*self*/ ctx[0].paths;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(5:6) {#if self.paths}",
    		ctx
    	});

    	return block;
    }

    // (6:8) {#each self.paths as path, i}
    function create_each_block_1$2(ctx) {
    	let path;
    	let current;

    	path = new Path({
    			props: {
    				id: /*i*/ ctx[31],
    				data: /*path*/ ctx[32]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(path.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(path, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const path_changes = {};
    			if (dirty[0] & /*self*/ 1) path_changes.data = /*path*/ ctx[32];
    			path.$set(path_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(path.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(path.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(path, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(6:8) {#each self.paths as path, i}",
    		ctx
    	});

    	return block;
    }

    // (10:6) {#if self.polygons}
    function create_if_block_2$7(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*self*/ ctx[0].polygons;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*self*/ 1) {
    				each_value = /*self*/ ctx[0].polygons;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(10:6) {#if self.polygons}",
    		ctx
    	});

    	return block;
    }

    // (11:8) {#each self.polygons as polygon, i}
    function create_each_block$a(ctx) {
    	let polygon;
    	let current;

    	polygon = new Polygon({
    			props: {
    				id: /*i*/ ctx[31],
    				data: /*polygon*/ ctx[29]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(polygon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(polygon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const polygon_changes = {};
    			if (dirty[0] & /*self*/ 1) polygon_changes.data = /*polygon*/ ctx[29];
    			polygon.$set(polygon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(polygon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(polygon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(polygon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(11:8) {#each self.polygons as polygon, i}",
    		ctx
    	});

    	return block;
    }

    // (15:6) {#if self.raw}
    function create_if_block_1$b(ctx) {
    	let raw;
    	let updating_data;
    	let current;

    	function raw_data_binding(value) {
    		/*raw_data_binding*/ ctx[15](value);
    	}

    	let raw_props = {};

    	if (/*self*/ ctx[0] !== void 0) {
    		raw_props.data = /*self*/ ctx[0];
    	}

    	raw = new Raw({ props: raw_props, $$inline: true });
    	binding_callbacks.push(() => bind$2(raw, "data", raw_data_binding));

    	const block = {
    		c: function create() {
    			create_component(raw.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(raw, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const raw_changes = {};

    			if (!updating_data && dirty[0] & /*self*/ 1) {
    				updating_data = true;
    				raw_changes.data = /*self*/ ctx[0];
    				add_flush_callback(() => updating_data = false);
    			}

    			raw.$set(raw_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(raw.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(raw.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(raw, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(15:6) {#if self.raw}",
    		ctx
    	});

    	return block;
    }

    // (3:8)      
    function fallback_block$1(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*self*/ ctx[0] && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*self*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*self*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$h(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(3:8)      ",
    		ctx
    	});

    	return block;
    }

    // (1:0) <Svg label={label} width={width} height={height} box={box} style={combinedStyle}   spin={spin} flip={flip} inverse={inverse} pulse={pulse} class={className}>
    function create_default_slot$3(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
    	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 65536)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty[0] & /*self*/ 1) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(1:0) <Svg label={label} width={width} height={height} box={box} style={combinedStyle}   spin={spin} flip={flip} inverse={inverse} pulse={pulse} class={className}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let svg;
    	let current;

    	svg = new Svg({
    			props: {
    				label: /*label*/ ctx[6],
    				width: /*width*/ ctx[7],
    				height: /*height*/ ctx[8],
    				box: /*box*/ ctx[10],
    				style: /*combinedStyle*/ ctx[9],
    				spin: /*spin*/ ctx[2],
    				flip: /*flip*/ ctx[5],
    				inverse: /*inverse*/ ctx[3],
    				pulse: /*pulse*/ ctx[4],
    				class: /*className*/ ctx[1],
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svg.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svg, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const svg_changes = {};
    			if (dirty[0] & /*label*/ 64) svg_changes.label = /*label*/ ctx[6];
    			if (dirty[0] & /*width*/ 128) svg_changes.width = /*width*/ ctx[7];
    			if (dirty[0] & /*height*/ 256) svg_changes.height = /*height*/ ctx[8];
    			if (dirty[0] & /*box*/ 1024) svg_changes.box = /*box*/ ctx[10];
    			if (dirty[0] & /*combinedStyle*/ 512) svg_changes.style = /*combinedStyle*/ ctx[9];
    			if (dirty[0] & /*spin*/ 4) svg_changes.spin = /*spin*/ ctx[2];
    			if (dirty[0] & /*flip*/ 32) svg_changes.flip = /*flip*/ ctx[5];
    			if (dirty[0] & /*inverse*/ 8) svg_changes.inverse = /*inverse*/ ctx[3];
    			if (dirty[0] & /*pulse*/ 16) svg_changes.pulse = /*pulse*/ ctx[4];
    			if (dirty[0] & /*className*/ 2) svg_changes.class = /*className*/ ctx[1];

    			if (dirty[0] & /*$$scope, self*/ 65537) {
    				svg_changes.$$scope = { dirty, ctx };
    			}

    			svg.$set(svg_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svg.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svg.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svg, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function normaliseData(data) {
    	if ("iconName" in data && "icon" in data) {
    		let normalisedData = {};
    		let faIcon = data.icon;
    		let name = data.iconName;
    		let width = faIcon[0];
    		let height = faIcon[1];
    		let paths = faIcon[4];
    		let iconData = { width, height, paths: [{ d: paths }] };
    		normalisedData[name] = iconData;
    		return normalisedData;
    	}

    	return data;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Icon", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { data } = $$props;
    	let { scale = 1 } = $$props;
    	let { spin = false } = $$props;
    	let { inverse = false } = $$props;
    	let { pulse = false } = $$props;
    	let { flip = null } = $$props;
    	let { label = null } = $$props;
    	let { self = null } = $$props;
    	let { style = null } = $$props;

    	// internal
    	let x = 0;

    	let y = 0;
    	let childrenHeight = 0;
    	let childrenWidth = 0;
    	let outerScale = 1;
    	let width;
    	let height;
    	let combinedStyle;
    	let box;

    	function init() {
    		if (typeof data === "undefined") {
    			return;
    		}

    		const normalisedData = normaliseData(data);
    		const [name] = Object.keys(normalisedData);
    		const icon = normalisedData[name];

    		if (!icon.paths) {
    			icon.paths = [];
    		}

    		if (icon.d) {
    			icon.paths.push({ d: icon.d });
    		}

    		if (!icon.polygons) {
    			icon.polygons = [];
    		}

    		if (icon.points) {
    			icon.polygons.push({ points: icon.points });
    		}

    		$$invalidate(0, self = icon);
    	}

    	function normalisedScale() {
    		let numScale = 1;

    		if (typeof scale !== "undefined") {
    			numScale = Number(scale);
    		}

    		if (isNaN(numScale) || numScale <= 0) {
    			// eslint-disable-line no-restricted-globals
    			console.warn("Invalid prop: prop \"scale\" should be a number over 0."); // eslint-disable-line no-console

    			return outerScale;
    		}

    		return numScale * outerScale;
    	}

    	function calculateBox() {
    		if (self) {
    			return `0 0 ${self.width} ${self.height}`;
    		}

    		return `0 0 ${width} ${height}`;
    	}

    	function calculateRatio() {
    		if (!self) {
    			return 1;
    		}

    		return Math.max(self.width, self.height) / 16;
    	}

    	function calculateWidth() {
    		if (childrenWidth) {
    			return childrenWidth;
    		}

    		if (self) {
    			return self.width / calculateRatio() * normalisedScale();
    		}

    		return 0;
    	}

    	function calculateHeight() {
    		if (childrenHeight) {
    			return childrenHeight;
    		}

    		if (self) {
    			return self.height / calculateRatio() * normalisedScale();
    		}

    		return 0;
    	}

    	function calculateStyle() {
    		let combined = "";

    		if (style !== null) {
    			combined += style;
    		}

    		let size = normalisedScale();

    		if (size === 1) {
    			if (combined.length === 0) {
    				return undefined;
    			}

    			return combined;
    		}

    		if (combined !== "" && !combined.endsWith(";")) {
    			combined += "; ";
    		}

    		return `${combined}font-size: ${size}em`;
    	}

    	const writable_props = [
    		"class",
    		"data",
    		"scale",
    		"spin",
    		"inverse",
    		"pulse",
    		"flip",
    		"label",
    		"self",
    		"style"
    	];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<Icon> was created with unknown prop '${key}'`);
    	});

    	function raw_data_binding(value) {
    		self = value;
    		$$invalidate(0, self);
    	}

    	$$self.$$set = $$props => {
    		if ("class" in $$props) $$invalidate(1, className = $$props.class);
    		if ("data" in $$props) $$invalidate(11, data = $$props.data);
    		if ("scale" in $$props) $$invalidate(12, scale = $$props.scale);
    		if ("spin" in $$props) $$invalidate(2, spin = $$props.spin);
    		if ("inverse" in $$props) $$invalidate(3, inverse = $$props.inverse);
    		if ("pulse" in $$props) $$invalidate(4, pulse = $$props.pulse);
    		if ("flip" in $$props) $$invalidate(5, flip = $$props.flip);
    		if ("label" in $$props) $$invalidate(6, label = $$props.label);
    		if ("self" in $$props) $$invalidate(0, self = $$props.self);
    		if ("style" in $$props) $$invalidate(13, style = $$props.style);
    		if ("$$scope" in $$props) $$invalidate(16, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Path,
    		Polygon,
    		Raw,
    		Svg,
    		className,
    		data,
    		scale,
    		spin,
    		inverse,
    		pulse,
    		flip,
    		label,
    		self,
    		style,
    		x,
    		y,
    		childrenHeight,
    		childrenWidth,
    		outerScale,
    		width,
    		height,
    		combinedStyle,
    		box,
    		init,
    		normaliseData,
    		normalisedScale,
    		calculateBox,
    		calculateRatio,
    		calculateWidth,
    		calculateHeight,
    		calculateStyle
    	});

    	$$self.$inject_state = $$props => {
    		if ("className" in $$props) $$invalidate(1, className = $$props.className);
    		if ("data" in $$props) $$invalidate(11, data = $$props.data);
    		if ("scale" in $$props) $$invalidate(12, scale = $$props.scale);
    		if ("spin" in $$props) $$invalidate(2, spin = $$props.spin);
    		if ("inverse" in $$props) $$invalidate(3, inverse = $$props.inverse);
    		if ("pulse" in $$props) $$invalidate(4, pulse = $$props.pulse);
    		if ("flip" in $$props) $$invalidate(5, flip = $$props.flip);
    		if ("label" in $$props) $$invalidate(6, label = $$props.label);
    		if ("self" in $$props) $$invalidate(0, self = $$props.self);
    		if ("style" in $$props) $$invalidate(13, style = $$props.style);
    		if ("x" in $$props) x = $$props.x;
    		if ("y" in $$props) y = $$props.y;
    		if ("childrenHeight" in $$props) childrenHeight = $$props.childrenHeight;
    		if ("childrenWidth" in $$props) childrenWidth = $$props.childrenWidth;
    		if ("outerScale" in $$props) outerScale = $$props.outerScale;
    		if ("width" in $$props) $$invalidate(7, width = $$props.width);
    		if ("height" in $$props) $$invalidate(8, height = $$props.height);
    		if ("combinedStyle" in $$props) $$invalidate(9, combinedStyle = $$props.combinedStyle);
    		if ("box" in $$props) $$invalidate(10, box = $$props.box);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*data, style, scale*/ 14336) {
    			{
    				init();
    				$$invalidate(7, width = calculateWidth());
    				$$invalidate(8, height = calculateHeight());
    				$$invalidate(9, combinedStyle = calculateStyle());
    				$$invalidate(10, box = calculateBox());
    			}
    		}
    	};

    	return [
    		self,
    		className,
    		spin,
    		inverse,
    		pulse,
    		flip,
    		label,
    		width,
    		height,
    		combinedStyle,
    		box,
    		data,
    		scale,
    		style,
    		slots,
    		raw_data_binding,
    		$$scope
    	];
    }

    class Icon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$B,
    			create_fragment$B,
    			safe_not_equal,
    			{
    				class: 1,
    				data: 11,
    				scale: 12,
    				spin: 2,
    				inverse: 3,
    				pulse: 4,
    				flip: 5,
    				label: 6,
    				self: 0,
    				style: 13
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon",
    			options,
    			id: create_fragment$B.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[11] === undefined && !("data" in props)) {
    			console_1$6.warn("<Icon> was created without expected prop 'data'");
    		}
    	}

    	get class() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get data() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scale() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scale(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get spin() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set spin(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inverse() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inverse(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pulse() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pulse(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flip() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flip(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get self() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set self(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\controls\DropdownMenu.svelte generated by Svelte v3.38.2 */
    const file$y = "node_modules\\svelte-jsoneditor\\src\\components\\controls\\DropdownMenu.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    const get_defaultItem_slot_changes = dirty => ({});
    const get_defaultItem_slot_context = ctx => ({});

    // (53:6) {#each items as item}
    function create_each_block$9(ctx) {
    	let li;
    	let button;
    	let t0_value = /*item*/ ctx[10].text + "";
    	let t0;
    	let button_title_value;
    	let button_disabled_value;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[8](/*item*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(button, "title", button_title_value = /*item*/ ctx[10].title);
    			button.disabled = button_disabled_value = /*item*/ ctx[10].disabled;
    			attr_dev(button, "class", "svelte-1el16cg");
    			add_location(button, file$y, 54, 10, 1320);
    			attr_dev(li, "class", "svelte-1el16cg");
    			add_location(li, file$y, 53, 8, 1305);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			append_dev(button, t0);
    			append_dev(li, t1);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*items*/ 2 && t0_value !== (t0_value = /*item*/ ctx[10].text + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*items*/ 2 && button_title_value !== (button_title_value = /*item*/ ctx[10].title)) {
    				attr_dev(button, "title", button_title_value);
    			}

    			if (dirty & /*items*/ 2 && button_disabled_value !== (button_disabled_value = /*item*/ ctx[10].disabled)) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(53:6) {#each items as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let div1;
    	let t0;
    	let button;
    	let icon;
    	let t1;
    	let div0;
    	let ul;
    	let current;
    	let mounted;
    	let dispose;
    	const defaultItem_slot_template = /*#slots*/ ctx[7].defaultItem;
    	const defaultItem_slot = create_slot(defaultItem_slot_template, ctx, /*$$scope*/ ctx[6], get_defaultItem_slot_context);

    	icon = new Icon({
    			props: { data: faCaretDown },
    			$$inline: true
    		});

    	let each_value = /*items*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (defaultItem_slot) defaultItem_slot.c();
    			t0 = space();
    			button = element("button");
    			create_component(icon.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(button, "class", "open-dropdown svelte-1el16cg");
    			add_location(button, file$y, 46, 2, 1102);
    			attr_dev(ul, "class", "svelte-1el16cg");
    			add_location(ul, file$y, 51, 4, 1264);
    			attr_dev(div0, "class", "items svelte-1el16cg");
    			set_style(div0, "width", /*width*/ ctx[3]);
    			toggle_class(div0, "visible", /*visible*/ ctx[0]);
    			add_location(div0, file$y, 50, 2, 1202);
    			attr_dev(div1, "class", "menu-dropdown svelte-1el16cg");
    			attr_dev(div1, "title", /*title*/ ctx[2]);
    			add_location(div1, file$y, 43, 0, 999);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);

    			if (defaultItem_slot) {
    				defaultItem_slot.m(div1, null);
    			}

    			append_dev(div1, t0);
    			append_dev(div1, button);
    			mount_component(icon, button, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*toggleShow*/ ctx[4], false, false, false),
    					listen_dev(div1, "click", /*handleClick*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (defaultItem_slot) {
    				if (defaultItem_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot(defaultItem_slot, defaultItem_slot_template, ctx, /*$$scope*/ ctx[6], dirty, get_defaultItem_slot_changes, get_defaultItem_slot_context);
    				}
    			}

    			if (dirty & /*items*/ 2) {
    				each_value = /*items*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty & /*width*/ 8) {
    				set_style(div0, "width", /*width*/ ctx[3]);
    			}

    			if (dirty & /*visible*/ 1) {
    				toggle_class(div0, "visible", /*visible*/ ctx[0]);
    			}

    			if (!current || dirty & /*title*/ 4) {
    				attr_dev(div1, "title", /*title*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(defaultItem_slot, local);
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(defaultItem_slot, local);
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (defaultItem_slot) defaultItem_slot.d(detaching);
    			destroy_component(icon);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DropdownMenu", slots, ['defaultItem']);
    	let { items = [] } = $$props;
    	let { title = null } = $$props;
    	let { width = "120px" } = $$props;
    	let { visible = false } = $$props;

    	function toggleShow(event) {
    		event.stopPropagation();
    		$$invalidate(0, visible = !visible);
    	}

    	function handleClick() {
    		$$invalidate(0, visible = false);
    	}

    	function handleKeyDown(event) {
    		const combo = keyComboFromEvent(event);

    		if (combo === "Escape") {
    			event.preventDefault();
    			$$invalidate(0, visible = false);
    		}
    	}

    	onMount(() => {
    		document.addEventListener("click", handleClick);
    		document.addEventListener("keydown", handleKeyDown);
    	});

    	onDestroy(() => {
    		document.removeEventListener("click", handleClick);
    		document.removeEventListener("keydown", handleKeyDown);
    	});

    	const writable_props = ["items", "title", "width", "visible"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DropdownMenu> was created with unknown prop '${key}'`);
    	});

    	const click_handler = item => item.onClick();

    	$$self.$$set = $$props => {
    		if ("items" in $$props) $$invalidate(1, items = $$props.items);
    		if ("title" in $$props) $$invalidate(2, title = $$props.title);
    		if ("width" in $$props) $$invalidate(3, width = $$props.width);
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Icon,
    		faCaretDown,
    		onDestroy,
    		onMount,
    		keyComboFromEvent,
    		items,
    		title,
    		width,
    		visible,
    		toggleShow,
    		handleClick,
    		handleKeyDown
    	});

    	$$self.$inject_state = $$props => {
    		if ("items" in $$props) $$invalidate(1, items = $$props.items);
    		if ("title" in $$props) $$invalidate(2, title = $$props.title);
    		if ("width" in $$props) $$invalidate(3, width = $$props.width);
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		visible,
    		items,
    		title,
    		width,
    		toggleShow,
    		handleClick,
    		$$scope,
    		slots,
    		click_handler
    	];
    }

    class DropdownMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, not_equal, { items: 1, title: 2, width: 3, visible: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DropdownMenu",
    			options,
    			id: create_fragment$A.name
    		});
    	}

    	get items() {
    		throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get visible() {
    		throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set visible(value) {
    		throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\controls\Menu.svelte generated by Svelte v3.38.2 */
    const file$x = "node_modules\\svelte-jsoneditor\\src\\components\\controls\\Menu.svelte";
    const get_right_slot_changes = dirty => ({});
    const get_right_slot_context = ctx => ({});

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    const get_left_slot_changes = dirty => ({});
    const get_left_slot_context = ctx => ({});

    // (30:4) {:else}
    function create_else_block$a(ctx) {
    	let button;
    	let t;
    	let button_class_value;
    	let button_title_value;
    	let button_disabled_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*item*/ ctx[3].icon && create_if_block_4$2(ctx);
    	let if_block1 = /*item*/ ctx[3].text && create_if_block_3$3(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(button, "class", button_class_value = "button " + /*item*/ ctx[3].className + " svelte-1qkgmuk");
    			attr_dev(button, "title", button_title_value = /*item*/ ctx[3].title);
    			button.disabled = button_disabled_value = /*item*/ ctx[3].disabled || false;
    			add_location(button, file$x, 30, 6, 704);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			if (if_block0) if_block0.m(button, null);
    			append_dev(button, t);
    			if (if_block1) if_block1.m(button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*item*/ ctx[3].onClick)) /*item*/ ctx[3].onClick.apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*item*/ ctx[3].icon) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*items*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(button, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*item*/ ctx[3].text) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$3(ctx);
    					if_block1.c();
    					if_block1.m(button, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (!current || dirty & /*items*/ 1 && button_class_value !== (button_class_value = "button " + /*item*/ ctx[3].className + " svelte-1qkgmuk")) {
    				attr_dev(button, "class", button_class_value);
    			}

    			if (!current || dirty & /*items*/ 1 && button_title_value !== (button_title_value = /*item*/ ctx[3].title)) {
    				attr_dev(button, "title", button_title_value);
    			}

    			if (!current || dirty & /*items*/ 1 && button_disabled_value !== (button_disabled_value = /*item*/ ctx[3].disabled || false)) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(30:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (16:25) 
    function create_if_block_2$6(ctx) {
    	let dropdownmenu;
    	let current;

    	dropdownmenu = new DropdownMenu({
    			props: {
    				items: /*item*/ ctx[3].items,
    				title: /*item*/ ctx[3].title,
    				$$slots: { defaultItem: [create_defaultItem_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownmenu_changes = {};
    			if (dirty & /*items*/ 1) dropdownmenu_changes.items = /*item*/ ctx[3].items;
    			if (dirty & /*items*/ 1) dropdownmenu_changes.title = /*item*/ ctx[3].title;

    			if (dirty & /*$$scope, items*/ 5) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(16:25) ",
    		ctx
    	});

    	return block;
    }

    // (14:34) 
    function create_if_block_1$a(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "space svelte-1qkgmuk");
    			add_location(div, file$x, 14, 6, 310);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop$2,
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(14:34) ",
    		ctx
    	});

    	return block;
    }

    // (12:4) {#if item.separator === true}
    function create_if_block$g(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "separator svelte-1qkgmuk");
    			add_location(div, file$x, 12, 6, 239);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop$2,
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(12:4) {#if item.separator === true}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {#if item.icon}
    function create_if_block_4$2(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: { data: /*item*/ ctx[3].icon },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};
    			if (dirty & /*items*/ 1) icon_changes.data = /*item*/ ctx[3].icon;
    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(37:8) {#if item.icon}",
    		ctx
    	});

    	return block;
    }

    // (40:8) {#if item.text}
    function create_if_block_3$3(ctx) {
    	let t_value = /*item*/ ctx[3].text + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items*/ 1 && t_value !== (t_value = /*item*/ ctx[3].text + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(40:8) {#if item.text}",
    		ctx
    	});

    	return block;
    }

    // (21:8) 
    function create_defaultItem_slot(ctx) {
    	let button;
    	let icon;
    	let button_class_value;
    	let button_disabled_value;
    	let current;
    	let mounted;
    	let dispose;

    	icon = new Icon({
    			props: { data: /*item*/ ctx[3].icon },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(icon.$$.fragment);
    			attr_dev(button, "class", button_class_value = "button " + /*item*/ ctx[3].className + " svelte-1qkgmuk");
    			attr_dev(button, "slot", "defaultItem");
    			button.disabled = button_disabled_value = /*item*/ ctx[3].disabled;
    			add_location(button, file$x, 20, 8, 452);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			mount_component(icon, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*item*/ ctx[3].onClick)) /*item*/ ctx[3].onClick.apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const icon_changes = {};
    			if (dirty & /*items*/ 1) icon_changes.data = /*item*/ ctx[3].icon;
    			icon.$set(icon_changes);

    			if (!current || dirty & /*items*/ 1 && button_class_value !== (button_class_value = "button " + /*item*/ ctx[3].className + " svelte-1qkgmuk")) {
    				attr_dev(button, "class", button_class_value);
    			}

    			if (!current || dirty & /*items*/ 1 && button_disabled_value !== (button_disabled_value = /*item*/ ctx[3].disabled)) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(icon);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_defaultItem_slot.name,
    		type: "slot",
    		source: "(21:8) ",
    		ctx
    	});

    	return block;
    }

    // (11:2) {#each items as item}
    function create_each_block$8(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$g, create_if_block_1$a, create_if_block_2$6, create_else_block$a];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*item*/ ctx[3].separator === true) return 0;
    		if (/*item*/ ctx[3].space === true) return 1;
    		if (/*item*/ ctx[3].items) return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(11:2) {#each items as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let current;
    	const left_slot_template = /*#slots*/ ctx[1].left;
    	const left_slot = create_slot(left_slot_template, ctx, /*$$scope*/ ctx[2], get_left_slot_context);
    	let each_value = /*items*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const right_slot_template = /*#slots*/ ctx[1].right;
    	const right_slot = create_slot(right_slot_template, ctx, /*$$scope*/ ctx[2], get_right_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (left_slot) left_slot.c();
    			t0 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			if (right_slot) right_slot.c();
    			attr_dev(div, "class", "menu svelte-1qkgmuk");
    			add_location(div, file$x, 7, 0, 132);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (left_slot) {
    				left_slot.m(div, null);
    			}

    			append_dev(div, t0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append_dev(div, t1);

    			if (right_slot) {
    				right_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (left_slot) {
    				if (left_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot(left_slot, left_slot_template, ctx, /*$$scope*/ ctx[2], dirty, get_left_slot_changes, get_left_slot_context);
    				}
    			}

    			if (dirty & /*items*/ 1) {
    				each_value = /*items*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, t1);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (right_slot) {
    				if (right_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot(right_slot, right_slot_template, ctx, /*$$scope*/ ctx[2], dirty, get_right_slot_changes, get_right_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(left_slot, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(right_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(left_slot, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(right_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (left_slot) left_slot.d(detaching);
    			destroy_each(each_blocks, detaching);
    			if (right_slot) right_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Menu", slots, ['left','right']);
    	let { items = [] } = $$props;
    	const writable_props = ["items"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Menu> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("items" in $$props) $$invalidate(0, items = $$props.items);
    		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ DropdownMenu, Icon, items });

    	$$self.$inject_state = $$props => {
    		if ("items" in $$props) $$invalidate(0, items = $$props.items);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [items, slots, $$scope];
    }

    class Menu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, { items: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Menu",
    			options,
    			id: create_fragment$z.name
    		});
    	}

    	get items() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\modals\Header.svelte generated by Svelte v3.38.2 */
    const file$w = "node_modules\\svelte-jsoneditor\\src\\components\\modals\\Header.svelte";

    function create_fragment$y(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let button;
    	let icon;
    	let current;
    	let mounted;
    	let dispose;
    	icon = new Icon({ props: { data: faTimes }, $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(/*title*/ ctx[0]);
    			t1 = space();
    			button = element("button");
    			create_component(icon.$$.fragment);
    			attr_dev(div0, "class", "title svelte-1l2fnw9");
    			add_location(div0, file$w, 13, 2, 296);
    			attr_dev(button, "class", "close svelte-1l2fnw9");
    			add_location(button, file$w, 16, 2, 339);
    			attr_dev(div1, "class", "header svelte-1l2fnw9");
    			add_location(div1, file$w, 12, 0, 273);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div1, t1);
    			append_dev(div1, button);
    			mount_component(icon, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*close*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*title*/ 1) set_data_dev(t0, /*title*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(icon);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Header", slots, []);
    	let { title = "Modal" } = $$props;
    	const { close } = getContext("simple-modal");
    	const writable_props = ["title"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Header> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    	};

    	$$self.$capture_state = () => ({ getContext, Icon, faTimes, title, close });

    	$$self.$inject_state = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [title, close];
    }

    class Header extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, not_equal, { title: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Header",
    			options,
    			id: create_fragment$y.name
    		});
    	}

    	get title() {
    		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\modals\CopyPasteModal.svelte generated by Svelte v3.38.2 */
    const file$v = "node_modules\\svelte-jsoneditor\\src\\components\\modals\\CopyPasteModal.svelte";

    function create_fragment$x(ctx) {
    	let div10;
    	let header;
    	let t0;
    	let div9;
    	let div0;
    	let t2;
    	let div7;
    	let div2;
    	let div1;
    	let t5;
    	let t6;
    	let div4;
    	let div3;
    	let t9;
    	let t10;
    	let div6;
    	let div5;
    	let t13;
    	let t14;
    	let div8;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	header = new Header({
    			props: { title: "Copying and pasting" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div10 = element("div");
    			create_component(header.$$.fragment);
    			t0 = space();
    			div9 = element("div");
    			div0 = element("div");
    			div0.textContent = "These actions are unavailable via the menu. Please use:";
    			t2 = space();
    			div7 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div1.textContent = `${/*ctrl*/ ctx[1]}+C`;
    			t5 = text("\n        for copy");
    			t6 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div3.textContent = `${/*ctrl*/ ctx[1]}+X`;
    			t9 = text("\n        for cut");
    			t10 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div5.textContent = `${/*ctrl*/ ctx[1]}+V`;
    			t13 = text("\n        for paste");
    			t14 = space();
    			div8 = element("div");
    			button = element("button");
    			button.textContent = "Close";
    			add_location(div0, file$v, 16, 4, 390);
    			attr_dev(div1, "class", "key svelte-1wohto6");
    			add_location(div1, file$v, 22, 8, 535);
    			attr_dev(div2, "class", "shortcut");
    			add_location(div2, file$v, 21, 6, 504);
    			attr_dev(div3, "class", "key svelte-1wohto6");
    			add_location(div3, file$v, 28, 8, 654);
    			attr_dev(div4, "class", "shortcut");
    			add_location(div4, file$v, 27, 6, 623);
    			attr_dev(div5, "class", "key svelte-1wohto6");
    			add_location(div5, file$v, 34, 8, 772);
    			attr_dev(div6, "class", "shortcut");
    			add_location(div6, file$v, 33, 6, 741);
    			attr_dev(div7, "class", "shortcuts svelte-1wohto6");
    			add_location(div7, file$v, 20, 4, 474);
    			attr_dev(button, "class", "primary svelte-1wohto6");
    			add_location(button, file$v, 42, 6, 899);
    			attr_dev(div8, "class", "actions svelte-1wohto6");
    			add_location(div8, file$v, 41, 4, 871);
    			attr_dev(div9, "class", "contents svelte-1wohto6");
    			add_location(div9, file$v, 15, 2, 363);
    			attr_dev(div10, "class", "jsoneditor-modal copy-paste svelte-1wohto6");
    			add_location(div10, file$v, 12, 0, 277);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div10, anchor);
    			mount_component(header, div10, null);
    			append_dev(div10, t0);
    			append_dev(div10, div9);
    			append_dev(div9, div0);
    			append_dev(div9, t2);
    			append_dev(div9, div7);
    			append_dev(div7, div2);
    			append_dev(div2, div1);
    			append_dev(div2, t5);
    			append_dev(div7, t6);
    			append_dev(div7, div4);
    			append_dev(div4, div3);
    			append_dev(div4, t9);
    			append_dev(div7, t10);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div6, t13);
    			append_dev(div9, t14);
    			append_dev(div9, div8);
    			append_dev(div8, button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*close*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$2,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div10);
    			destroy_component(header);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CopyPasteModal", slots, []);
    	const { close } = getContext("simple-modal");
    	const ctrl = IS_MAC ? "⌘" : "Ctrl";
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CopyPasteModal> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ getContext, IS_MAC, Header, close, ctrl });
    	return [close, ctrl];
    }

    class CopyPasteModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CopyPasteModal",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\modes\welcomemode\WelcomeMode.svelte generated by Svelte v3.38.2 */
    const file$u = "node_modules\\svelte-jsoneditor\\src\\components\\modes\\welcomemode\\WelcomeMode.svelte";

    function create_fragment$w(ctx) {
    	let div4;
    	let menu;
    	let t0;
    	let label;
    	let input;
    	let t1;
    	let div3;
    	let div0;
    	let t2;
    	let div1;
    	let t3;
    	let ul;
    	let li0;
    	let t5;
    	let li1;
    	let t6;
    	let span0;
    	let t8;
    	let li2;
    	let t9;
    	let span1;
    	let t11;
    	let li3;
    	let t12;
    	let span2;
    	let t14;
    	let div2;
    	let current;
    	let mounted;
    	let dispose;

    	menu = new Menu({
    			props: { items: /*items*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			create_component(menu.$$.fragment);
    			t0 = space();
    			label = element("label");
    			input = element("input");
    			t1 = space();
    			div3 = element("div");
    			div0 = element("div");
    			t2 = space();
    			div1 = element("div");
    			t3 = text("New document\n      ");
    			ul = element("ul");
    			li0 = element("li");
    			li0.textContent = "Click inside the editor";
    			t5 = space();
    			li1 = element("li");
    			t6 = text("Paste clipboard data using ");
    			span0 = element("span");
    			span0.textContent = "Ctrl+V";
    			t8 = space();
    			li2 = element("li");
    			t9 = text("Create a new object by typing ");
    			span1 = element("span");
    			span1.textContent = "{";
    			t11 = space();
    			li3 = element("li");
    			t12 = text("Create a new array by typing ");
    			span2 = element("span");
    			span2.textContent = "[";
    			t14 = space();
    			div2 = element("div");
    			attr_dev(input, "class", "hidden-input svelte-1ienj8w");
    			attr_dev(input, "tabindex", "-1");
    			add_location(input, file$u, 160, 4, 4025);
    			attr_dev(label, "class", "hidden-input-label svelte-1ienj8w");
    			add_location(label, file$u, 159, 2, 3986);
    			attr_dev(div0, "class", "space before svelte-1ienj8w");
    			add_location(div0, file$u, 168, 4, 4187);
    			attr_dev(li0, "class", "svelte-1ienj8w");
    			add_location(li0, file$u, 172, 8, 4285);
    			attr_dev(span0, "class", "bold svelte-1ienj8w");
    			add_location(span0, file$u, 173, 39, 4357);
    			attr_dev(li1, "class", "svelte-1ienj8w");
    			add_location(li1, file$u, 173, 8, 4326);
    			attr_dev(span1, "class", "bold svelte-1ienj8w");
    			add_location(span1, file$u, 174, 42, 4437);
    			attr_dev(li2, "class", "svelte-1ienj8w");
    			add_location(li2, file$u, 174, 8, 4403);
    			attr_dev(span2, "class", "bold svelte-1ienj8w");
    			add_location(span2, file$u, 175, 41, 4518);
    			attr_dev(li3, "class", "svelte-1ienj8w");
    			add_location(li3, file$u, 175, 8, 4485);
    			attr_dev(ul, "class", "svelte-1ienj8w");
    			add_location(ul, file$u, 171, 6, 4272);
    			attr_dev(div1, "class", "contents svelte-1ienj8w");
    			add_location(div1, file$u, 169, 4, 4224);
    			attr_dev(div2, "class", "space after svelte-1ienj8w");
    			add_location(div2, file$u, 178, 4, 4578);
    			attr_dev(div3, "class", "welcome svelte-1ienj8w");
    			add_location(div3, file$u, 167, 2, 4161);
    			attr_dev(div4, "class", "welcome-mode svelte-1ienj8w");
    			add_location(div4, file$u, 152, 0, 3838);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			mount_component(menu, div4, null);
    			append_dev(div4, t0);
    			append_dev(div4, label);
    			append_dev(label, input);
    			/*input_binding*/ ctx[12](input);
    			append_dev(div4, t1);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			append_dev(div3, t2);
    			append_dev(div3, div1);
    			append_dev(div1, t3);
    			append_dev(div1, ul);
    			append_dev(ul, li0);
    			append_dev(ul, t5);
    			append_dev(ul, li1);
    			append_dev(li1, t6);
    			append_dev(li1, span0);
    			append_dev(ul, t8);
    			append_dev(ul, li2);
    			append_dev(li2, t9);
    			append_dev(li2, span1);
    			append_dev(ul, t11);
    			append_dev(ul, li3);
    			append_dev(li3, t12);
    			append_dev(li3, span2);
    			append_dev(div3, t14);
    			append_dev(div3, div2);
    			/*div4_binding*/ ctx[13](div4);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "paste", /*handlePaste*/ ctx[5], false, false, false),
    					listen_dev(div4, "keydown", /*handleKeyDown*/ ctx[3], false, false, false),
    					listen_dev(div4, "mousedown", /*handleMouseDown*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const menu_changes = {};
    			if (dirty & /*items*/ 4) menu_changes.items = /*items*/ ctx[2];
    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(menu);
    			/*input_binding*/ ctx[12](null);
    			/*div4_binding*/ ctx[13](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let items;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("WelcomeMode", slots, []);
    	const { open } = getContext("simple-modal");
    	let { onChange } = $$props;
    	let { onFocus } = $$props;
    	let { onBlur } = $$props;

    	let { onRenderMenu = () => {
    		
    	} } = $$props;

    	let { readOnly = false } = $$props;
    	let domWelcomeMode;
    	let domHiddenInput;
    	let hasFocus = false;

    	createFocusTracker({
    		onMount,
    		onDestroy,
    		getWindow: () => getWindow(domWelcomeMode),
    		hasFocus: () => activeElementIsChildOf(domWelcomeMode),
    		onFocus: () => {
    			hasFocus = true;

    			if (onFocus) {
    				onFocus();
    			}
    		},
    		onBlur: () => {
    			hasFocus = false;

    			if (onBlur) {
    				onBlur();
    			}
    		}
    	});

    	function handlePasteFromMenu() {
    		open(
    			CopyPasteModal,
    			{},
    			{
    				...SIMPLE_MODAL_OPTIONS,
    				styleWindow: {
    					...SIMPLE_MODAL_OPTIONS.styleWindow,
    					width: "450px"
    				}
    			},
    			{ onClose: () => setTimeout(onFocus) }
    		);
    	}

    	function handleInsertObject() {
    		onChange("{}");
    	}

    	function handleInsertArray() {
    		onChange("[]");
    	}

    	function handleInsertValue() {
    		onChange("\"\"");
    	}

    	function handleKeyDown(event) {
    		// get key combo, and normalize key combo from Mac: replace "Command+X" with "Ctrl+X" etc
    		const combo = keyComboFromEvent(event).replace(/^Command\+/, "Ctrl+");

    		if (combo === "{") {
    			handleInsertObject();
    		} else if (combo === "[") {
    			handleInsertArray();
    		}
    	}

    	function handleMouseDown(event) {
    		// TODO: ugly to have to have two setTimeout here. Without it, hiddenInput will blur
    		setTimeout(() => {
    			setTimeout(() => {
    				if (!hasFocus && !isChildOfNodeName(event.target, "BUTTON")) {
    					// for example when clicking on the empty area in the main menu
    					focus();
    				}
    			});
    		});
    	}

    	function handlePaste(event) {
    		onChange(event.clipboardData.getData("text/plain"));
    	}

    	function focus() {
    		// with just .focus(), sometimes the input doesn't react on onpaste events
    		// in Chrome when having a large document open and then doing cut/paste.
    		// Calling both .focus() and .select() did solve this issue.
    		domHiddenInput.focus();

    		domHiddenInput.select();
    	}

    	const defaultItems = [
    		{
    			icon: faPaste,
    			title: "Paste (Ctrl+V)",
    			className: "paste",
    			onClick: handlePasteFromMenu,
    			disabled: readOnly
    		},
    		{ separator: true },
    		{
    			icon: faPlus,
    			title: "Insert new structure (Insert)",
    			className: "insert",
    			onClick: handleInsertObject,
    			disabled: readOnly,
    			items: [
    				// type: MenuDropdownItem[]
    				{
    					text: "Insert value",
    					title: "Insert a new value",
    					onClick: handleInsertValue,
    					disabled: readOnly,
    					default: true
    				},
    				{
    					text: "Insert object",
    					title: "Insert a new object",
    					onClick: handleInsertObject,
    					disabled: readOnly
    				},
    				{
    					text: "Insert array",
    					title: "Insert a new array",
    					onClick: handleInsertArray,
    					disabled: readOnly
    				}
    			]
    		}
    	];

    	const writable_props = ["onChange", "onFocus", "onBlur", "onRenderMenu", "readOnly"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WelcomeMode> was created with unknown prop '${key}'`);
    	});

    	function input_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			domHiddenInput = $$value;
    			$$invalidate(1, domHiddenInput);
    		});
    	}

    	function div4_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			domWelcomeMode = $$value;
    			$$invalidate(0, domWelcomeMode);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("onChange" in $$props) $$invalidate(6, onChange = $$props.onChange);
    		if ("onFocus" in $$props) $$invalidate(7, onFocus = $$props.onFocus);
    		if ("onBlur" in $$props) $$invalidate(8, onBlur = $$props.onBlur);
    		if ("onRenderMenu" in $$props) $$invalidate(9, onRenderMenu = $$props.onRenderMenu);
    		if ("readOnly" in $$props) $$invalidate(10, readOnly = $$props.readOnly);
    	};

    	$$self.$capture_state = () => ({
    		faPaste,
    		faPlus,
    		getContext,
    		onDestroy,
    		onMount,
    		SIMPLE_MODAL_OPTIONS,
    		activeElementIsChildOf,
    		getWindow,
    		isChildOfNodeName,
    		keyComboFromEvent,
    		createFocusTracker,
    		Menu,
    		CopyPasteModal,
    		open,
    		onChange,
    		onFocus,
    		onBlur,
    		onRenderMenu,
    		readOnly,
    		domWelcomeMode,
    		domHiddenInput,
    		hasFocus,
    		handlePasteFromMenu,
    		handleInsertObject,
    		handleInsertArray,
    		handleInsertValue,
    		handleKeyDown,
    		handleMouseDown,
    		handlePaste,
    		focus,
    		defaultItems,
    		items
    	});

    	$$self.$inject_state = $$props => {
    		if ("onChange" in $$props) $$invalidate(6, onChange = $$props.onChange);
    		if ("onFocus" in $$props) $$invalidate(7, onFocus = $$props.onFocus);
    		if ("onBlur" in $$props) $$invalidate(8, onBlur = $$props.onBlur);
    		if ("onRenderMenu" in $$props) $$invalidate(9, onRenderMenu = $$props.onRenderMenu);
    		if ("readOnly" in $$props) $$invalidate(10, readOnly = $$props.readOnly);
    		if ("domWelcomeMode" in $$props) $$invalidate(0, domWelcomeMode = $$props.domWelcomeMode);
    		if ("domHiddenInput" in $$props) $$invalidate(1, domHiddenInput = $$props.domHiddenInput);
    		if ("hasFocus" in $$props) hasFocus = $$props.hasFocus;
    		if ("items" in $$props) $$invalidate(2, items = $$props.items);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*onRenderMenu*/ 512) {
    			$$invalidate(2, items = onRenderMenu("tree", defaultItems) || defaultItems);
    		}
    	};

    	return [
    		domWelcomeMode,
    		domHiddenInput,
    		items,
    		handleKeyDown,
    		handleMouseDown,
    		handlePaste,
    		onChange,
    		onFocus,
    		onBlur,
    		onRenderMenu,
    		readOnly,
    		focus,
    		input_binding,
    		div4_binding
    	];
    }

    class WelcomeMode extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$w, create_fragment$w, safe_not_equal, {
    			onChange: 6,
    			onFocus: 7,
    			onBlur: 8,
    			onRenderMenu: 9,
    			readOnly: 10,
    			focus: 11
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WelcomeMode",
    			options,
    			id: create_fragment$w.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*onChange*/ ctx[6] === undefined && !("onChange" in props)) {
    			console.warn("<WelcomeMode> was created without expected prop 'onChange'");
    		}

    		if (/*onFocus*/ ctx[7] === undefined && !("onFocus" in props)) {
    			console.warn("<WelcomeMode> was created without expected prop 'onFocus'");
    		}

    		if (/*onBlur*/ ctx[8] === undefined && !("onBlur" in props)) {
    			console.warn("<WelcomeMode> was created without expected prop 'onBlur'");
    		}
    	}

    	get onChange() {
    		throw new Error("<WelcomeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onChange(value) {
    		throw new Error("<WelcomeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onFocus() {
    		throw new Error("<WelcomeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onFocus(value) {
    		throw new Error("<WelcomeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onBlur() {
    		throw new Error("<WelcomeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onBlur(value) {
    		throw new Error("<WelcomeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onRenderMenu() {
    		throw new Error("<WelcomeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onRenderMenu(value) {
    		throw new Error("<WelcomeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get readOnly() {
    		throw new Error("<WelcomeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readOnly(value) {
    		throw new Error("<WelcomeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focus() {
    		return this.$$.ctx[11];
    	}

    	set focus(value) {
    		throw new Error("<WelcomeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    let id$1 = 0;

    function uniqueId () {
      id$1++;
      return id$1
    }

    var jsonrepair_min = createCommonjsModule(function (module, exports) {
    !function(e,n){module.exports=n();}(commonjsGlobal,function(){function f(e,n){if(!(this instanceof f))throw new SyntaxError("Constructor must be called with the new operator");this.message=e+" (char "+n+")",this.char=n,this.stack=(new Error).stack;}(f.prototype=new Error).constructor=Error;var o={"'":!0,"‘":!0,"’":!0,"`":!0,"´":!0},u={'"':!0,"“":!0,"”":!0};function c(e){return n.test(e)}var n=/^[a-zA-Z_]$/;var s=/^[0-9a-fA-F]$/;function a(e){return t.test(e)}var t=/^[0-9]$/;function l(e){return " "===e||"\t"===e||"\n"===e||"\r"===e}function h(e){return " "===e||" "<=e&&e<=" "||" "===e||" "===e||"　"===e}function d(e){return !0===o[e]}function w(e){return !0===u[e]}function g(e){return !0===o[e]?"'":!0===u[e]?'"':e}function e(e,n){n=e.lastIndexOf(n);return -1!==n?e.substring(0,n)+e.substring(n+1):e}function r(e,n){var t=e.length;if(!l(e[t-1]))return e+n;for(;l(e[t-1]);)t--;return e.substring(0,t)+n+e.substring(t)}var i=0,b=1,p=2,v=3,x=4,m=5,y=6,k={"":!0,"{":!0,"}":!0,"[":!0,"]":!0,":":!0,",":!0,"(":!0,")":!0,";":!0,"+":!0},I={'"':'"',"\\":"\\","/":"/",b:"\b",f:"\f",n:"\n",r:"\r",t:"\t"},E={"\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t"},A={null:"null",true:"true",false:"false"},j={None:"null",True:"true",False:"false"},$="",O="",T=0,C="",F="",S=y;function U(){T++,C=$.charAt(T);}function z(){U(),"\\"===C&&U();}function N(){return S===i&&("["===F||"{"===F)||S===p||S===b||S===v}function V(){O+=F,S=y,F="",k[C]?(S=i,F=C,U()):function(){if(a(C)||"-"===C){if(S=b,"-"===C){if(F+=C,U(),!a(C))throw new f("Invalid number, digit expected",T)}else "0"===C&&(F+=C,U());for(;a(C);)F+=C,U();if("."===C){if(F+=C,U(),!a(C))throw new f("Invalid number, digit expected",T);for(;a(C);)F+=C,U();}if("e"===C||"E"===C){if(F+=C,U(),"+"!==C&&"-"!==C||(F+=C,U()),!a(C))throw new f("Invalid number, digit expected",T);for(;a(C);)F+=C,U();}}else "\\"===C&&'"'===$.charAt(T+1)?(U(),Z(z)):Z(U);}(),S===x&&(F=function(e){for(var n="",t=0;t<e.length;t++){var r=e[t];n+=h(r)?" ":r;}return n}(F),V()),S===m&&(S=y,F="",V());}function Z(e){if(!0===o[n=C]||!0===u[n]){var n=g(C),t=d(C)?d:w;for(F+='"',S=p,e();""!==C&&!t(C);)if("\\"===C)if(e(),void 0!==I[C])F+="\\"+C,e();else if("u"===C){F+="\\u",e();for(var r=0;r<4;r++){if(i=C,!s.test(i))throw new f("Invalid unicode character",T-F.length);F+=C,e();}}else {if("'"!==C)throw new f('Invalid escape character "\\'+C+'"',T);F+="'",e();}else E[C]?F+=E[C]:F+='"'===C?'\\"':C,e();if(g(C)!==n)throw new f("End of string expected",T-F.length);return F+='"',void e()}var i,n;!function(){if(c(C))for(S=v;c(C)||a(C)||"$"===C;)F+=C,U();else !function(){if(l(C)||h(C))for(S=x;l(C)||h(C);)F+=C,U();else !function(){if("/"!==C||"*"!==$[T+1])if("/"!==C||"/"!==$[T+1])!function(){S=y;for(;""!==C;)F+=C,U();throw new f('Syntax error in part "'+F+'"',T-F.length)}();else for(S=m;""!==C&&"\n"!==C;)F+=C,U();else {for(S=m;""!==C&&("*"!==C||"*"===C&&"/"!==$[T+1]);)F+=C,U();"*"===C&&"/"===$[T+1]&&(F+=C,U(),F+=C,U());}}();}();}();}function _(){if(S!==i||"{"!==F)!function(){if(S!==i||"["!==F)!function(){if(S!==p)(S!==b?function(){if(S!==v)!function(){throw new f(""===F?"Unexpected end of json string":"Value expected",T-F.length)}();else if(A[F])V();else {if(j[F])return F=j[F],V();var e=F,n=O.length;if(F="",V(),S===i&&"("===F)return F="",V(),_(),S===i&&")"===F&&(F="",V(),S===i&&";"===F&&(F="",V()));for(O=function(e,n,t){return e.substring(0,t)+n+e.substring(t)}(O,'"'.concat(e),n);S===v||S===b;)V();O+='"';}}:V)();else for(V();S===i&&"+"===F;){var e;F="",V(),S===p&&(e=O.lastIndexOf('"'),O=O.substring(0,e)+F.substring(1),F="",V());}}();else if(V(),S!==i||"]"!==F){for(;;)if(_(),S===i&&","===F){if(V(),S===i&&"]"===F){O=e(O,",");break}}else {if(!N())break;O=r(O,",");}S===i&&"]"===F?V():O=r(O,"]");}else V();}();else if(V(),S!==i||"}"!==F){for(;;){if(S!==v&&S!==b||(S=p,F='"'.concat(F,'"')),S!==p)throw new f("Object key expected",T-F.length);if(V(),S===i&&":"===F)V();else {if(!N())throw new f("Colon expected",T-F.length);O=r(O,":");}if(_(),S===i&&","===F){if(V(),S===i&&"}"===F){O=e(O,",");break}}else {if(S!==p&&S!==b&&S!==v)break;O=r(O,",");}}S===i&&"}"===F?V():O=r(O,"}");}else V();}return function(e){if(O="",T=0,C=($=e).charAt(0),F="",S=y,V(),e=S===i&&"{"===F,_(),""===F)return O;if(e&&N()){for(var n="";N();)n+=O=r(O,","),O="",_();return "[\n".concat(n).concat(O,"\n]")}throw new f("Unexpected characters",T-F.length)}});
    });

    /**
     * Return a human readable document size
     * For example formatSize(7570718) outputs '7.6 MB'
     * @param {number} size
     * @param {number} [kilo=1000] Is 1000 by default, you can specify 1024 if you
     *                             want the output in KiB
     * @return {string} Returns a human readable size
     */
    function formatSize (size, kilo = 1000) {
      if (size < 0.9 * kilo) {
        return size.toFixed() + ' B'
      }

      const KB = size / kilo;
      if (KB < 0.9 * kilo) {
        return KB.toFixed(1) + ' KB'
      }

      const MB = KB / kilo;
      if (MB < 0.9 * kilo) {
        return MB.toFixed(1) + ' MB'
      }

      const GB = MB / kilo;
      if (GB < 0.9 * kilo) {
        return GB.toFixed(1) + ' GB'
      }

      const TB = GB / kilo;
      return TB.toFixed(1) + ' TB'
    }

    var escapedChars = {
      'b': '\b',
      'f': '\f',
      'n': '\n',
      'r': '\r',
      't': '\t',
      '"': '"',
      '/': '/',
      '\\': '\\'
    };

    var A_CODE = 'a'.charCodeAt();


    var parse = function (source, _, options) {
      var pointers = {};
      var line = 0;
      var column = 0;
      var pos = 0;
      var bigint = options && options.bigint && typeof BigInt != 'undefined';
      return {
        data: _parse('', true),
        pointers: pointers
      };

      function _parse(ptr, topLevel) {
        whitespace();
        var data;
        map(ptr, 'value');
        var char = getChar();
        switch (char) {
          case 't': read('rue'); data = true; break;
          case 'f': read('alse'); data = false; break;
          case 'n': read('ull'); data = null; break;
          case '"': data = parseString(); break;
          case '[': data = parseArray(ptr); break;
          case '{': data = parseObject(ptr); break;
          default:
            backChar();
            if ('-0123456789'.indexOf(char) >= 0)
              data = parseNumber();
            else
              unexpectedToken();
        }
        map(ptr, 'valueEnd');
        whitespace();
        if (topLevel && pos < source.length) unexpectedToken();
        return data;
      }

      function whitespace() {
        loop:
          while (pos < source.length) {
            switch (source[pos]) {
              case ' ': column++; break;
              case '\t': column += 4; break;
              case '\r': column = 0; break;
              case '\n': column = 0; line++; break;
              default: break loop;
            }
            pos++;
          }
      }

      function parseString() {
        var str = '';
        var char;
        while (true) {
          char = getChar();
          if (char == '"') {
            break;
          } else if (char == '\\') {
            char = getChar();
            if (char in escapedChars)
              str += escapedChars[char];
            else if (char == 'u')
              str += getCharCode();
            else
              wasUnexpectedToken();
          } else {
            str += char;
          }
        }
        return str;
      }

      function parseNumber() {
        var numStr = '';
        var integer = true;
        if (source[pos] == '-') numStr += getChar();

        numStr += source[pos] == '0'
                  ? getChar()
                  : getDigits();

        if (source[pos] == '.') {
          numStr += getChar() + getDigits();
          integer = false;
        }

        if (source[pos] == 'e' || source[pos] == 'E') {
          numStr += getChar();
          if (source[pos] == '+' || source[pos] == '-') numStr += getChar();
          numStr += getDigits();
          integer = false;
        }

        var result = +numStr;
        return bigint && integer && (result > Number.MAX_SAFE_INTEGER || result < Number.MIN_SAFE_INTEGER)
                ? BigInt(numStr)
                : result;
      }

      function parseArray(ptr) {
        whitespace();
        var arr = [];
        var i = 0;
        if (getChar() == ']') return arr;
        backChar();

        while (true) {
          var itemPtr = ptr + '/' + i;
          arr.push(_parse(itemPtr));
          whitespace();
          var char = getChar();
          if (char == ']') break;
          if (char != ',') wasUnexpectedToken();
          whitespace();
          i++;
        }
        return arr;
      }

      function parseObject(ptr) {
        whitespace();
        var obj = {};
        if (getChar() == '}') return obj;
        backChar();

        while (true) {
          var loc = getLoc();
          if (getChar() != '"') wasUnexpectedToken();
          var key = parseString();
          var propPtr = ptr + '/' + escapeJsonPointer(key);
          mapLoc(propPtr, 'key', loc);
          map(propPtr, 'keyEnd');
          whitespace();
          if (getChar() != ':') wasUnexpectedToken();
          whitespace();
          obj[key] = _parse(propPtr);
          whitespace();
          var char = getChar();
          if (char == '}') break;
          if (char != ',') wasUnexpectedToken();
          whitespace();
        }
        return obj;
      }

      function read(str) {
        for (var i=0; i<str.length; i++)
          if (getChar() !== str[i]) wasUnexpectedToken();
      }

      function getChar() {
        checkUnexpectedEnd();
        var char = source[pos];
        pos++;
        column++; // new line?
        return char;
      }

      function backChar() {
        pos--;
        column--;
      }

      function getCharCode() {
        var count = 4;
        var code = 0;
        while (count--) {
          code <<= 4;
          var char = getChar().toLowerCase();
          if (char >= 'a' && char <= 'f')
            code += char.charCodeAt() - A_CODE + 10;
          else if (char >= '0' && char <= '9')
            code += +char;
          else
            wasUnexpectedToken();
        }
        return String.fromCharCode(code);
      }

      function getDigits() {
        var digits = '';
        while (source[pos] >= '0' && source[pos] <= '9')
          digits += getChar();

        if (digits.length) return digits;
        checkUnexpectedEnd();
        unexpectedToken();
      }

      function map(ptr, prop) {
        mapLoc(ptr, prop, getLoc());
      }

      function mapLoc(ptr, prop, loc) {
        pointers[ptr] = pointers[ptr] || {};
        pointers[ptr][prop] = loc;
      }

      function getLoc() {
        return {
          line: line,
          column: column,
          pos: pos
        };
      }

      function unexpectedToken() {
        throw new SyntaxError('Unexpected token ' + source[pos] + ' in JSON at position ' + pos);
      }

      function wasUnexpectedToken() {
        backChar();
        unexpectedToken();
      }

      function checkUnexpectedEnd() {
        if (pos >= source.length)
          throw new SyntaxError('Unexpected end of JSON input');
      }
    };


    var stringify = function (data, _, options) {
      if (!validType(data)) return;
      var wsLine = 0;
      var wsPos, wsColumn;
      var whitespace = typeof options == 'object'
                        ? options.space
                        : options;
      switch (typeof whitespace) {
        case 'number':
          var len = whitespace > 10
                      ? 10
                      : whitespace < 0
                        ? 0
                        : Math.floor(whitespace);
          whitespace = len && repeat(len, ' ');
          wsPos = len;
          wsColumn = len;
          break;
        case 'string':
          whitespace = whitespace.slice(0, 10);
          wsPos = 0;
          wsColumn = 0;
          for (var j=0; j<whitespace.length; j++) {
            var char = whitespace[j];
            switch (char) {
              case ' ': wsColumn++; break;
              case '\t': wsColumn += 4; break;
              case '\r': wsColumn = 0; break;
              case '\n': wsColumn = 0; wsLine++; break;
              default: throw new Error('whitespace characters not allowed in JSON');
            }
            wsPos++;
          }
          break;
        default:
          whitespace = undefined;
      }

      var json = '';
      var pointers = {};
      var line = 0;
      var column = 0;
      var pos = 0;
      var es6 = options && options.es6 && typeof Map == 'function';
      _stringify(data, 0, '');
      return {
        json: json,
        pointers: pointers
      };

      function _stringify(_data, lvl, ptr) {
        map(ptr, 'value');
        switch (typeof _data) {
          case 'number':
          case 'bigint':
          case 'boolean':
            out('' + _data); break;
          case 'string':
            out(quoted(_data)); break;
          case 'object':
            if (_data === null) {
              out('null');
            } else if (typeof _data.toJSON == 'function') {
              out(quoted(_data.toJSON()));
            } else if (Array.isArray(_data)) {
              stringifyArray();
            } else if (es6) {
              if (_data.constructor.BYTES_PER_ELEMENT)
                stringifyArray();
              else if (_data instanceof Map)
                stringifyMapSet();
              else if (_data instanceof Set)
                stringifyMapSet(true);
              else
                stringifyObject();
            } else {
              stringifyObject();
            }
        }
        map(ptr, 'valueEnd');

        function stringifyArray() {
          if (_data.length) {
            out('[');
            var itemLvl = lvl + 1;
            for (var i=0; i<_data.length; i++) {
              if (i) out(',');
              indent(itemLvl);
              var item = validType(_data[i]) ? _data[i] : null;
              var itemPtr = ptr + '/' + i;
              _stringify(item, itemLvl, itemPtr);
            }
            indent(lvl);
            out(']');
          } else {
            out('[]');
          }
        }

        function stringifyObject() {
          var keys = Object.keys(_data);
          if (keys.length) {
            out('{');
            var propLvl = lvl + 1;
            for (var i=0; i<keys.length; i++) {
              var key = keys[i];
              var value = _data[key];
              if (validType(value)) {
                if (i) out(',');
                var propPtr = ptr + '/' + escapeJsonPointer(key);
                indent(propLvl);
                map(propPtr, 'key');
                out(quoted(key));
                map(propPtr, 'keyEnd');
                out(':');
                if (whitespace) out(' ');
                _stringify(value, propLvl, propPtr);
              }
            }
            indent(lvl);
            out('}');
          } else {
            out('{}');
          }
        }

        function stringifyMapSet(isSet) {
          if (_data.size) {
            out('{');
            var propLvl = lvl + 1;
            var first = true;
            var entries = _data.entries();
            var entry = entries.next();
            while (!entry.done) {
              var item = entry.value;
              var key = item[0];
              var value = isSet ? true : item[1];
              if (validType(value)) {
                if (!first) out(',');
                first = false;
                var propPtr = ptr + '/' + escapeJsonPointer(key);
                indent(propLvl);
                map(propPtr, 'key');
                out(quoted(key));
                map(propPtr, 'keyEnd');
                out(':');
                if (whitespace) out(' ');
                _stringify(value, propLvl, propPtr);
              }
              entry = entries.next();
            }
            indent(lvl);
            out('}');
          } else {
            out('{}');
          }
        }
      }

      function out(str) {
        column += str.length;
        pos += str.length;
        json += str;
      }

      function indent(lvl) {
        if (whitespace) {
          json += '\n' + repeat(lvl, whitespace);
          line++;
          column = 0;
          while (lvl--) {
            if (wsLine) {
              line += wsLine;
              column = wsColumn;
            } else {
              column += wsColumn;
            }
            pos += wsPos;
          }
          pos += 1; // \n character
        }
      }

      function map(ptr, prop) {
        pointers[ptr] = pointers[ptr] || {};
        pointers[ptr][prop] = {
          line: line,
          column: column,
          pos: pos
        };
      }

      function repeat(n, str) {
        return Array(n + 1).join(str);
      }
    };


    var VALID_TYPES = ['number', 'bigint', 'boolean', 'string', 'object'];
    function validType(data) {
      return VALID_TYPES.indexOf(typeof data) >= 0;
    }


    var ESC_QUOTE = /"|\\/g;
    var ESC_B = /[\b]/g;
    var ESC_F = /\f/g;
    var ESC_N = /\n/g;
    var ESC_R = /\r/g;
    var ESC_T = /\t/g;
    function quoted(str) {
      str = str.replace(ESC_QUOTE, '\\$&')
               .replace(ESC_F, '\\f')
               .replace(ESC_B, '\\b')
               .replace(ESC_N, '\\n')
               .replace(ESC_R, '\\r')
               .replace(ESC_T, '\\t');
      return '"' + str + '"';
    }


    var ESC_0 = /~/g;
    var ESC_1 = /\//g;
    function escapeJsonPointer(str) {
      return str.replace(ESC_0, '~0')
                .replace(ESC_1, '~1');
    }

    var jsonSourceMap = {
    	parse: parse,
    	stringify: stringify
    };

    /**
     * Parse the JSON. if this fails, try to repair and parse.
     * Throws an exception when the JSON is invalid and could not be parsed.
     * @param {string} jsonText
     * @returns {JSON}
     */
    function parseAndRepair (jsonText) {
      try {
        return JSON.parse(jsonText)
      } catch (err) {
        // this can also throw
        return JSON.parse(jsonrepair_min(jsonText))
      }
    }

    /**
     * Parse the JSON and if needed repair it.
     * When not valid, undefined is returned.
     * @param {string} partialJson
     * @returns {undefined|JSON}
     */
    function parseAndRepairOrUndefined (partialJson) {
      try {
        return parseAndRepair(partialJson)
      } catch (err) {
        return undefined
      }
    }

    /**
     * @param {string} partialJson
     * @param {function} [parse=JSON.parse]
     * @return {JSON}
     */
    // TODO: deduplicate the logic in repairPartialJson and parseAndRepairPartialJson ?
    function parsePartialJson (partialJson, parse = JSON.parse) {
      // for now: dumb brute force approach: simply try out a few things...

      // remove trailing comma
      partialJson = partialJson.replace(END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX, '');

      try {
        return parse(partialJson)
      } catch (err) {}

      try {
        return parse('[' + partialJson + ']')
      } catch (err) {}

      try {
        return parse('{' + partialJson + '}')
      } catch (err) {}

      throw new Error('Failed to parse partial JSON')
    }

    /**
     * Repair partial JSON
     * @param {string} partialJson
     * @returns {string}
     */
    // TODO: deduplicate the logic in repairPartialJson and parseAndRepairPartialJson ?
    function repairPartialJson (partialJson) {
      // for now: dumb brute force approach: simply try out a few things...

      // remove trailing comma
      partialJson = partialJson.replace(END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX, '');

      try {
        return jsonrepair_min(partialJson)
      } catch (err) {}

      try {
        const repaired = jsonrepair_min('[' + partialJson + ']');
        return repaired.substring(1, repaired.length - 1) // remove the outer [...] again
      } catch (err) {}

      try {
        const repaired = jsonrepair_min('{' + partialJson + '}');
        return repaired.substring(1, repaired.length - 1) // remove the outer {...} again
      } catch (err) {}

      throw new Error('Failed to repair partial JSON')
    }

    // test whether a string ends with a comma, followed by zero or more white space characters
    const END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX = /,\s*$/;

    /**
     * Normalize a parse error message like
     *     "Unexpected token i in JSON at position 4"
     * or
     *     "JSON.parse: expected property name or '}' at line 2 column 3 of the JSON data"
     * and return the line and column numbers in an object
     *
     * Note that the returned line and column number in the object are zero-based,
     * and in the message are one based (human readable)
     *
     * @param {string} jsonText
     * @param {string} parseErrorMessage
     * @return {{
     *   position: number | null,
     *   line: number | null,
     *   column: number | null,
     *   message: message
     * }}
     */
    function normalizeJsonParseError (jsonText, parseErrorMessage) {
      const positionMatch = POSITION_REGEX.exec(parseErrorMessage);

      if (positionMatch) {
        // a message from Chrome, like "Unexpected token i in JSON at line 2 column 3"
        const position = parseInt(positionMatch[2], 10);

        const line = countCharacterOccurrences(jsonText, '\n', 0, position);
        const lastIndex = jsonText.lastIndexOf('\n', position);
        const column = position - lastIndex - 1;

        return {
          position,
          line,
          column,
          message: parseErrorMessage.replace(POSITION_REGEX, () => {
            return `line ${line + 1} column ${column + 1}`
          })
        }
      } else {
        // a message from Firefox, like "JSON.parse: expected property name or '}' at line 2 column 3 of the JSON data"
        const lineMatch = LINE_REGEX.exec(parseErrorMessage);
        const lineOneBased = lineMatch
          ? parseInt(lineMatch[1], 10)
          : null;
        const line = lineOneBased !== null
          ? (lineOneBased - 1)
          : null;

        const columnMatch = COLUMN_REGEX.exec(parseErrorMessage);
        const columnOneBased = columnMatch
          ? parseInt(columnMatch[1], 10)
          : null;
        const column = columnOneBased !== null
          ? (columnOneBased - 1)
          : null;

        const position = (line !== null && column !== null)
          ? calculatePosition(jsonText, line, column)
          : null;

        // line and column are one based in the message
        return {
          position,
          line,
          column,
          message: parseErrorMessage.replace(/^JSON.parse: /, '')
        }
      }
    }

    /**
     * Calculate the position in the text based on a line and column number
     * @param {string} text
     * @param {number} line     Zero-based line number
     * @param {number} column   Zero-based column number
     * @returns {number | null}
     */
    function calculatePosition (text, line, column) {
      let index = text.indexOf('\n');
      let i = 1;

      while (i < line && index !== -1) {
        index = text.indexOf('\n', index + 1);
        i++;
      }

      return (index !== -1)
        ? (index + column + 1) // +1 for the return character itself
        : null
    }

    function countCharacterOccurrences (text, character, start = 0, end = text.length) {
      let count = 0;

      for (let i = start; i < end; i++) {
        if (text.charAt(i) === character) {
          count++;
        }
      }

      return count
    }

    /**
     * Find the text location of a JSON path
     * @param {string} text
     * @param {Path} path
     * @return {{path: Path, row: number, column: number} | null}
     */
    // TODO: write unit tests
    function findTextLocation (text, path) {
      try {
        const jsmap = jsonSourceMap.parse(text);

        const pointerName = immutableJSONPatch.compileJSONPointer(path);
        const pointer = jsmap.pointers[pointerName];
        if (pointer) {
          return {
            path: path,
            row: pointer.key
              ? pointer.key.line
              : (pointer.value ? pointer.value.line : 0),
            column: pointer.key
              ? pointer.key.column
              : (pointer.value ? pointer.value.column : 0)
          }
        }
      } catch (err) {
        console.error(err);
      }

      return null
    }

    const POSITION_REGEX = /(position|char) (\d+)/;
    const LINE_REGEX = /line (\d+)/;
    const COLUMN_REGEX = /column (\d+)/;

    /* node_modules\svelte-jsoneditor\src\components\controls\Message.svelte generated by Svelte v3.38.2 */
    const file$t = "node_modules\\svelte-jsoneditor\\src\\components\\controls\\Message.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (12:4) {#if icon}
    function create_if_block_1$9(ctx) {
    	let icon_1;
    	let current;

    	icon_1 = new Icon({
    			props: { data: /*icon*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_1_changes = {};
    			if (dirty & /*icon*/ 2) icon_1_changes.data = /*icon*/ ctx[1];
    			icon_1.$set(icon_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(12:4) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (25:8) {#if action.icon}
    function create_if_block$f(ctx) {
    	let icon_1;
    	let current;

    	icon_1 = new Icon({
    			props: { data: /*action*/ ctx[4].icon },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_1_changes = {};
    			if (dirty & /*actions*/ 8) icon_1_changes.data = /*action*/ ctx[4].icon;
    			icon_1.$set(icon_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(25:8) {#if action.icon}",
    		ctx
    	});

    	return block;
    }

    // (18:4) {#each actions as action}
    function create_each_block$7(ctx) {
    	let button;
    	let t0;
    	let t1_value = /*action*/ ctx[4].text + "";
    	let t1;
    	let t2;
    	let button_title_value;
    	let button_disabled_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*action*/ ctx[4].icon && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (if_block) if_block.c();
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			attr_dev(button, "class", "button action primary svelte-1gnfkfb");
    			attr_dev(button, "title", button_title_value = /*action*/ ctx[4].title);
    			button.disabled = button_disabled_value = /*action*/ ctx[4].disabled;
    			add_location(button, file$t, 18, 6, 375);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			if (if_block) if_block.m(button, null);
    			append_dev(button, t0);
    			append_dev(button, t1);
    			append_dev(button, t2);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*action*/ ctx[4].onClick)) /*action*/ ctx[4].onClick.apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*action*/ ctx[4].icon) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*actions*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(button, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty & /*actions*/ 8) && t1_value !== (t1_value = /*action*/ ctx[4].text + "")) set_data_dev(t1, t1_value);

    			if (!current || dirty & /*actions*/ 8 && button_title_value !== (button_title_value = /*action*/ ctx[4].title)) {
    				attr_dev(button, "title", button_title_value);
    			}

    			if (!current || dirty & /*actions*/ 8 && button_disabled_value !== (button_disabled_value = /*action*/ ctx[4].disabled)) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(18:4) {#each actions as action}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let t1;
    	let t2;
    	let div1;
    	let div2_class_value;
    	let current;
    	let if_block = /*icon*/ ctx[1] && create_if_block_1$9(ctx);
    	let each_value = /*actions*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			t1 = text(/*message*/ ctx[2]);
    			t2 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "text svelte-1gnfkfb");
    			add_location(div0, file$t, 10, 2, 221);
    			attr_dev(div1, "class", "actions svelte-1gnfkfb");
    			add_location(div1, file$t, 16, 2, 317);
    			attr_dev(div2, "class", div2_class_value = "message " + /*type*/ ctx[0] + " svelte-1gnfkfb");
    			add_location(div2, file$t, 9, 0, 190);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			if (if_block) if_block.m(div0, null);
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    			append_dev(div2, t2);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*icon*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*icon*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div0, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*message*/ 4) set_data_dev(t1, /*message*/ ctx[2]);

    			if (dirty & /*actions*/ 8) {
    				each_value = /*actions*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div1, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*type*/ 1 && div2_class_value !== (div2_class_value = "message " + /*type*/ ctx[0] + " svelte-1gnfkfb")) {
    				attr_dev(div2, "class", div2_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block) if_block.d();
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Message", slots, []);
    	let { type = "success" } = $$props; // 'success' or 'error'
    	let { icon = null } = $$props;
    	let { message = null } = $$props;
    	let { actions = [] } = $$props;
    	const writable_props = ["type", "icon", "message", "actions"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Message> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("type" in $$props) $$invalidate(0, type = $$props.type);
    		if ("icon" in $$props) $$invalidate(1, icon = $$props.icon);
    		if ("message" in $$props) $$invalidate(2, message = $$props.message);
    		if ("actions" in $$props) $$invalidate(3, actions = $$props.actions);
    	};

    	$$self.$capture_state = () => ({ Icon, type, icon, message, actions });

    	$$self.$inject_state = $$props => {
    		if ("type" in $$props) $$invalidate(0, type = $$props.type);
    		if ("icon" in $$props) $$invalidate(1, icon = $$props.icon);
    		if ("message" in $$props) $$invalidate(2, message = $$props.message);
    		if ("actions" in $$props) $$invalidate(3, actions = $$props.actions);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [type, icon, message, actions];
    }

    class Message extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, { type: 0, icon: 1, message: 2, actions: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Message",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get type() {
    		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get icon() {
    		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get message() {
    		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set message(value) {
    		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get actions() {
    		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set actions(value) {
    		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * Stringify a path like
     *
     *     ["data", 2, "nested", "property"]
     *
     * into a string:
     *
     *     ".data[2].nested.property"
     *
     * @param {Path}
     * @return {string}
     */
    function stringifyPath (path) {
      return path.map(prop => {
        return typeof prop === 'number'
          ? `[${prop}]`
          : `.${prop}`
      }).join('')
    }

    /* node_modules\svelte-jsoneditor\src\components\controls\ValidationErrorsOverview.svelte generated by Svelte v3.38.2 */
    const file$s = "node_modules\\svelte-jsoneditor\\src\\components\\controls\\ValidationErrorsOverview.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (36:0) {#if !isEmpty(validationErrorsList)}
    function create_if_block$e(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block_1$8, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*expanded*/ ctx[2] || /*validationErrorsList*/ ctx[0].length === 1) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "validation-errors-overview svelte-1flrdq6");
    			add_location(div, file$s, 36, 2, 722);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(36:0) {#if !isEmpty(validationErrorsList)}",
    		ctx
    	});

    	return block;
    }

    // (73:4) {:else}
    function create_else_block$9(ctx) {
    	let table;
    	let tbody;
    	let tr;
    	let td0;
    	let icon0;
    	let t0;
    	let td1;
    	let t1_value = /*validationErrorsList*/ ctx[0].length + "";
    	let t1;
    	let t2;
    	let div;
    	let icon1;
    	let current;
    	let mounted;
    	let dispose;

    	icon0 = new Icon({
    			props: { data: faExclamationTriangle },
    			$$inline: true
    		});

    	icon1 = new Icon({
    			props: { data: faAngleRight },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			table = element("table");
    			tbody = element("tbody");
    			tr = element("tr");
    			td0 = element("td");
    			create_component(icon0.$$.fragment);
    			t0 = space();
    			td1 = element("td");
    			t1 = text(t1_value);
    			t2 = text(" validation errors\n             ");
    			div = element("div");
    			create_component(icon1.$$.fragment);
    			attr_dev(td0, "class", "validation-error-icon svelte-1flrdq6");
    			add_location(td0, file$s, 76, 11, 2104);
    			attr_dev(div, "class", "validation-errors-expand svelte-1flrdq6");
    			add_location(div, file$s, 81, 13, 2296);
    			attr_dev(td1, "class", "svelte-1flrdq6");
    			add_location(td1, file$s, 79, 11, 2218);
    			attr_dev(tr, "class", "validation-error svelte-1flrdq6");
    			add_location(tr, file$s, 75, 9, 2045);
    			add_location(tbody, file$s, 74, 8, 2028);
    			attr_dev(table, "class", "svelte-1flrdq6");
    			add_location(table, file$s, 73, 6, 2012);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, tbody);
    			append_dev(tbody, tr);
    			append_dev(tr, td0);
    			mount_component(icon0, td0, null);
    			append_dev(tr, t0);
    			append_dev(tr, td1);
    			append_dev(td1, t1);
    			append_dev(td1, t2);
    			append_dev(td1, div);
    			mount_component(icon1, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(tr, "click", /*expand*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*validationErrorsList*/ 1) && t1_value !== (t1_value = /*validationErrorsList*/ ctx[0].length + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon0.$$.fragment, local);
    			transition_in(icon1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon0.$$.fragment, local);
    			transition_out(icon1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_component(icon0);
    			destroy_component(icon1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(73:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (38:4) {#if expanded || validationErrorsList.length === 1}
    function create_if_block_1$8(ctx) {
    	let table;
    	let tbody;
    	let current;
    	let each_value = /*validationErrorsList*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			table = element("table");
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(tbody, file$s, 39, 8, 841);
    			attr_dev(table, "class", "svelte-1flrdq6");
    			add_location(table, file$s, 38, 6, 825);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*setTimeout, selectError, validationErrorsList, collapse, faAngleDown, stringifyPath, faExclamationTriangle*/ 11) {
    				each_value = /*validationErrorsList*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(38:4) {#if expanded || validationErrorsList.length === 1}",
    		ctx
    	});

    	return block;
    }

    // (59:16) {#if index === 0 && validationErrorsList.length > 1}
    function create_if_block_2$5(ctx) {
    	let button;
    	let icon;
    	let current;
    	let mounted;
    	let dispose;

    	icon = new Icon({
    			props: { data: faAngleDown },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(icon.$$.fragment);
    			attr_dev(button, "class", "validation-errors-collapse svelte-1flrdq6");
    			attr_dev(button, "title", "Collapse validation errors");
    			add_location(button, file$s, 59, 18, 1614);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			mount_component(icon, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", stop_propagation(/*collapse*/ ctx[3]), false, false, true);
    				mounted = true;
    			}
    		},
    		p: noop$2,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(icon);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(59:16) {#if index === 0 && validationErrorsList.length > 1}",
    		ctx
    	});

    	return block;
    }

    // (41:10) {#each validationErrorsList as validationError, index}
    function create_each_block$6(ctx) {
    	let tr;
    	let td0;
    	let icon;
    	let t0;
    	let td1;
    	let t1_value = stringifyPath(/*validationError*/ ctx[7].path) + "";
    	let t1;
    	let t2;
    	let td2;
    	let t3_value = /*validationError*/ ctx[7].message + "";
    	let t3;
    	let t4;
    	let td3;
    	let t5;
    	let current;
    	let mounted;
    	let dispose;

    	icon = new Icon({
    			props: { data: faExclamationTriangle },
    			$$inline: true
    		});

    	let if_block = /*index*/ ctx[9] === 0 && /*validationErrorsList*/ ctx[0].length > 1 && create_if_block_2$5(ctx);

    	function click_handler() {
    		return /*click_handler*/ ctx[5](/*validationError*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			create_component(icon.$$.fragment);
    			t0 = space();
    			td1 = element("td");
    			t1 = text(t1_value);
    			t2 = space();
    			td2 = element("td");
    			t3 = text(t3_value);
    			t4 = space();
    			td3 = element("td");
    			if (if_block) if_block.c();
    			t5 = space();
    			attr_dev(td0, "class", "validation-error-icon svelte-1flrdq6");
    			add_location(td0, file$s, 48, 14, 1193);
    			attr_dev(td1, "class", "svelte-1flrdq6");
    			add_location(td1, file$s, 51, 14, 1316);
    			attr_dev(td2, "class", "svelte-1flrdq6");
    			add_location(td2, file$s, 54, 14, 1409);
    			attr_dev(td3, "class", "validation-error-action svelte-1flrdq6");
    			add_location(td3, file$s, 57, 14, 1490);
    			attr_dev(tr, "class", "validation-error svelte-1flrdq6");
    			add_location(tr, file$s, 41, 12, 926);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			mount_component(icon, td0, null);
    			append_dev(tr, t0);
    			append_dev(tr, td1);
    			append_dev(td1, t1);
    			append_dev(tr, t2);
    			append_dev(tr, td2);
    			append_dev(td2, t3);
    			append_dev(tr, t4);
    			append_dev(tr, td3);
    			if (if_block) if_block.m(td3, null);
    			append_dev(tr, t5);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(tr, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*validationErrorsList*/ 1) && t1_value !== (t1_value = stringifyPath(/*validationError*/ ctx[7].path) + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty & /*validationErrorsList*/ 1) && t3_value !== (t3_value = /*validationError*/ ctx[7].message + "")) set_data_dev(t3, t3_value);

    			if (/*index*/ ctx[9] === 0 && /*validationErrorsList*/ ctx[0].length > 1) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*validationErrorsList*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(td3, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_component(icon);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(41:10) {#each validationErrorsList as validationError, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let show_if = !isEmpty(/*validationErrorsList*/ ctx[0]);
    	let if_block_anchor;
    	let current;
    	let if_block = show_if && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*validationErrorsList*/ 1) show_if = !isEmpty(/*validationErrorsList*/ ctx[0]);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*validationErrorsList*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let filteredValidationErrors;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ValidationErrorsOverview", slots, []);
    	let { validationErrorsList } = $$props;
    	let { selectError } = $$props;
    	let expanded = true;

    	function collapse() {
    		$$invalidate(2, expanded = false);
    	}

    	function expand() {
    		$$invalidate(2, expanded = true);
    	}

    	const writable_props = ["validationErrorsList", "selectError"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ValidationErrorsOverview> was created with unknown prop '${key}'`);
    	});

    	const click_handler = validationError => {
    		// trigger on the next tick to prevent the editor not getting focus
    		setTimeout(() => selectError(validationError));
    	};

    	$$self.$$set = $$props => {
    		if ("validationErrorsList" in $$props) $$invalidate(0, validationErrorsList = $$props.validationErrorsList);
    		if ("selectError" in $$props) $$invalidate(1, selectError = $$props.selectError);
    	};

    	$$self.$capture_state = () => ({
    		faAngleDown,
    		faAngleRight,
    		faExclamationTriangle,
    		isEmpty,
    		Icon,
    		stringifyPath,
    		validationErrorsList,
    		selectError,
    		expanded,
    		collapse,
    		expand,
    		filteredValidationErrors
    	});

    	$$self.$inject_state = $$props => {
    		if ("validationErrorsList" in $$props) $$invalidate(0, validationErrorsList = $$props.validationErrorsList);
    		if ("selectError" in $$props) $$invalidate(1, selectError = $$props.selectError);
    		if ("expanded" in $$props) $$invalidate(2, expanded = $$props.expanded);
    		if ("filteredValidationErrors" in $$props) filteredValidationErrors = $$props.filteredValidationErrors;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*validationErrorsList*/ 1) {
    			filteredValidationErrors = validationErrorsList.filter(error => !error.isChildError);
    		}
    	};

    	return [validationErrorsList, selectError, expanded, collapse, expand, click_handler];
    }

    class ValidationErrorsOverview extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, not_equal, { validationErrorsList: 0, selectError: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ValidationErrorsOverview",
    			options,
    			id: create_fragment$u.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*validationErrorsList*/ ctx[0] === undefined && !("validationErrorsList" in props)) {
    			console.warn("<ValidationErrorsOverview> was created without expected prop 'validationErrorsList'");
    		}

    		if (/*selectError*/ ctx[1] === undefined && !("selectError" in props)) {
    			console.warn("<ValidationErrorsOverview> was created without expected prop 'selectError'");
    		}
    	}

    	get validationErrorsList() {
    		throw new Error("<ValidationErrorsOverview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set validationErrorsList(value) {
    		throw new Error("<ValidationErrorsOverview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectError() {
    		throw new Error("<ValidationErrorsOverview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectError(value) {
    		throw new Error("<ValidationErrorsOverview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-select\src\Item.svelte generated by Svelte v3.38.2 */

    const file$r = "node_modules\\svelte-select\\src\\Item.svelte";

    function create_fragment$t(ctx) {
    	let div;
    	let raw_value = /*getOptionLabel*/ ctx[0](/*item*/ ctx[1], /*filterText*/ ctx[2]) + "";
    	let div_class_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", div_class_value = "item " + /*itemClasses*/ ctx[3] + " svelte-bdnybl");
    			add_location(div, file$r, 61, 0, 1353);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div.innerHTML = raw_value;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*getOptionLabel, item, filterText*/ 7 && raw_value !== (raw_value = /*getOptionLabel*/ ctx[0](/*item*/ ctx[1], /*filterText*/ ctx[2]) + "")) div.innerHTML = raw_value;
    			if (dirty & /*itemClasses*/ 8 && div_class_value !== (div_class_value = "item " + /*itemClasses*/ ctx[3] + " svelte-bdnybl")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Item", slots, []);
    	let { isActive = false } = $$props;
    	let { isFirst = false } = $$props;
    	let { isHover = false } = $$props;
    	let { getOptionLabel = undefined } = $$props;
    	let { item = undefined } = $$props;
    	let { filterText = "" } = $$props;
    	let itemClasses = "";
    	const writable_props = ["isActive", "isFirst", "isHover", "getOptionLabel", "item", "filterText"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Item> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("isActive" in $$props) $$invalidate(4, isActive = $$props.isActive);
    		if ("isFirst" in $$props) $$invalidate(5, isFirst = $$props.isFirst);
    		if ("isHover" in $$props) $$invalidate(6, isHover = $$props.isHover);
    		if ("getOptionLabel" in $$props) $$invalidate(0, getOptionLabel = $$props.getOptionLabel);
    		if ("item" in $$props) $$invalidate(1, item = $$props.item);
    		if ("filterText" in $$props) $$invalidate(2, filterText = $$props.filterText);
    	};

    	$$self.$capture_state = () => ({
    		isActive,
    		isFirst,
    		isHover,
    		getOptionLabel,
    		item,
    		filterText,
    		itemClasses
    	});

    	$$self.$inject_state = $$props => {
    		if ("isActive" in $$props) $$invalidate(4, isActive = $$props.isActive);
    		if ("isFirst" in $$props) $$invalidate(5, isFirst = $$props.isFirst);
    		if ("isHover" in $$props) $$invalidate(6, isHover = $$props.isHover);
    		if ("getOptionLabel" in $$props) $$invalidate(0, getOptionLabel = $$props.getOptionLabel);
    		if ("item" in $$props) $$invalidate(1, item = $$props.item);
    		if ("filterText" in $$props) $$invalidate(2, filterText = $$props.filterText);
    		if ("itemClasses" in $$props) $$invalidate(3, itemClasses = $$props.itemClasses);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*isActive, isFirst, isHover, item*/ 114) {
    			{
    				const classes = [];

    				if (isActive) {
    					classes.push("active");
    				}

    				if (isFirst) {
    					classes.push("first");
    				}

    				if (isHover) {
    					classes.push("hover");
    				}

    				if (item.isGroupHeader) {
    					classes.push("groupHeader");
    				}

    				if (item.isGroupItem) {
    					classes.push("groupItem");
    				}

    				$$invalidate(3, itemClasses = classes.join(" "));
    			}
    		}
    	};

    	return [getOptionLabel, item, filterText, itemClasses, isActive, isFirst, isHover];
    }

    class Item extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {
    			isActive: 4,
    			isFirst: 5,
    			isHover: 6,
    			getOptionLabel: 0,
    			item: 1,
    			filterText: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Item",
    			options,
    			id: create_fragment$t.name
    		});
    	}

    	get isActive() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isActive(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isFirst() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isFirst(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isHover() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isHover(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getOptionLabel() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getOptionLabel(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get item() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterText() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterText(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-select\src\VirtualList.svelte generated by Svelte v3.38.2 */
    const file$q = "node_modules\\svelte-select\\src\\VirtualList.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	return child_ctx;
    }

    const get_default_slot_changes = dirty => ({
    	item: dirty & /*visible*/ 32,
    	i: dirty & /*visible*/ 32,
    	hoverItemIndex: dirty & /*hoverItemIndex*/ 2
    });

    const get_default_slot_context = ctx => ({
    	item: /*row*/ ctx[23].data,
    	i: /*row*/ ctx[23].index,
    	hoverItemIndex: /*hoverItemIndex*/ ctx[1]
    });

    // (160:57) Missing template
    function fallback_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Missing template");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(160:57) Missing template",
    		ctx
    	});

    	return block;
    }

    // (158:2) {#each visible as row (row.index)}
    function create_each_block$5(key_1, ctx) {
    	let svelte_virtual_list_row;
    	let t;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], get_default_slot_context);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			svelte_virtual_list_row = element("svelte-virtual-list-row");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			t = space();
    			set_custom_element_data(svelte_virtual_list_row, "class", "svelte-p6ehlv");
    			add_location(svelte_virtual_list_row, file$q, 158, 3, 3514);
    			this.first = svelte_virtual_list_row;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svelte_virtual_list_row, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svelte_virtual_list_row, null);
    			}

    			append_dev(svelte_virtual_list_row, t);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, visible, hoverItemIndex*/ 16418)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[14], dirty, get_default_slot_changes, get_default_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svelte_virtual_list_row);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(158:2) {#each visible as row (row.index)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let svelte_virtual_list_viewport;
    	let svelte_virtual_list_contents;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let svelte_virtual_list_viewport_resize_listener;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*visible*/ ctx[5];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[23].index;
    	validate_each_keys(ctx, each_value, get_each_context$5, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$5(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			svelte_virtual_list_viewport = element("svelte-virtual-list-viewport");
    			svelte_virtual_list_contents = element("svelte-virtual-list-contents");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(svelte_virtual_list_contents, "padding-top", /*top*/ ctx[6] + "px");
    			set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ ctx[7] + "px");
    			set_custom_element_data(svelte_virtual_list_contents, "class", "svelte-p6ehlv");
    			add_location(svelte_virtual_list_contents, file$q, 156, 1, 3364);
    			set_style(svelte_virtual_list_viewport, "height", /*height*/ ctx[0]);
    			set_custom_element_data(svelte_virtual_list_viewport, "class", "svelte-p6ehlv");
    			add_render_callback(() => /*svelte_virtual_list_viewport_elementresize_handler*/ ctx[18].call(svelte_virtual_list_viewport));
    			add_location(svelte_virtual_list_viewport, file$q, 154, 0, 3222);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svelte_virtual_list_viewport, anchor);
    			append_dev(svelte_virtual_list_viewport, svelte_virtual_list_contents);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(svelte_virtual_list_contents, null);
    			}

    			/*svelte_virtual_list_contents_binding*/ ctx[16](svelte_virtual_list_contents);
    			/*svelte_virtual_list_viewport_binding*/ ctx[17](svelte_virtual_list_viewport);
    			svelte_virtual_list_viewport_resize_listener = add_resize_listener(svelte_virtual_list_viewport, /*svelte_virtual_list_viewport_elementresize_handler*/ ctx[18].bind(svelte_virtual_list_viewport));
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(svelte_virtual_list_viewport, "scroll", /*handle_scroll*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$$scope, visible, hoverItemIndex*/ 16418) {
    				each_value = /*visible*/ ctx[5];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$5, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, svelte_virtual_list_contents, outro_and_destroy_block, create_each_block$5, null, get_each_context$5);
    				check_outros();
    			}

    			if (!current || dirty & /*top*/ 64) {
    				set_style(svelte_virtual_list_contents, "padding-top", /*top*/ ctx[6] + "px");
    			}

    			if (!current || dirty & /*bottom*/ 128) {
    				set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ ctx[7] + "px");
    			}

    			if (!current || dirty & /*height*/ 1) {
    				set_style(svelte_virtual_list_viewport, "height", /*height*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svelte_virtual_list_viewport);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			/*svelte_virtual_list_contents_binding*/ ctx[16](null);
    			/*svelte_virtual_list_viewport_binding*/ ctx[17](null);
    			svelte_virtual_list_viewport_resize_listener();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("VirtualList", slots, ['default']);
    	let { items = undefined } = $$props;
    	let { height = "100%" } = $$props;
    	let { itemHeight = 40 } = $$props;
    	let { hoverItemIndex = 0 } = $$props;
    	let { start = 0 } = $$props;
    	let { end = 0 } = $$props;

    	// local state
    	let height_map = [];

    	let rows;
    	let viewport;
    	let contents;
    	let viewport_height = 0;
    	let visible;
    	let mounted;
    	let top = 0;
    	let bottom = 0;
    	let average_height;

    	async function refresh(items, viewport_height, itemHeight) {
    		const { scrollTop } = viewport;
    		await tick$1(); // wait until the DOM is up to date
    		let content_height = top - scrollTop;
    		let i = start;

    		while (content_height < viewport_height && i < items.length) {
    			let row = rows[i - start];

    			if (!row) {
    				$$invalidate(10, end = i + 1);
    				await tick$1(); // render the newly visible row
    				row = rows[i - start];
    			}

    			const row_height = height_map[i] = itemHeight || row.offsetHeight;
    			content_height += row_height;
    			i += 1;
    		}

    		$$invalidate(10, end = i);
    		const remaining = items.length - end;
    		average_height = (top + content_height) / end;
    		$$invalidate(7, bottom = remaining * average_height);
    		height_map.length = items.length;
    		$$invalidate(3, viewport.scrollTop = 0, viewport);
    	}

    	async function handle_scroll() {
    		const { scrollTop } = viewport;
    		const old_start = start;

    		for (let v = 0; v < rows.length; v += 1) {
    			height_map[start + v] = itemHeight || rows[v].offsetHeight;
    		}

    		let i = 0;
    		let y = 0;

    		while (i < items.length) {
    			const row_height = height_map[i] || average_height;

    			if (y + row_height > scrollTop) {
    				$$invalidate(9, start = i);
    				$$invalidate(6, top = y);
    				break;
    			}

    			y += row_height;
    			i += 1;
    		}

    		while (i < items.length) {
    			y += height_map[i] || average_height;
    			i += 1;
    			if (y > scrollTop + viewport_height) break;
    		}

    		$$invalidate(10, end = i);
    		const remaining = items.length - end;
    		average_height = y / end;
    		while (i < items.length) height_map[i++] = average_height;
    		$$invalidate(7, bottom = remaining * average_height);

    		// prevent jumping if we scrolled up into unknown territory
    		if (start < old_start) {
    			await tick$1();
    			let expected_height = 0;
    			let actual_height = 0;

    			for (let i = start; i < old_start; i += 1) {
    				if (rows[i - start]) {
    					expected_height += height_map[i];
    					actual_height += itemHeight || rows[i - start].offsetHeight;
    				}
    			}

    			const d = actual_height - expected_height;
    			viewport.scrollTo(0, scrollTop + d);
    		}
    	} // TODO if we overestimated the space these
    	// rows would occupy we may need to add some

    	// more. maybe we can just call handle_scroll again?
    	// trigger initial refresh
    	onMount(() => {
    		rows = contents.getElementsByTagName("svelte-virtual-list-row");
    		$$invalidate(13, mounted = true);
    	});

    	const writable_props = ["items", "height", "itemHeight", "hoverItemIndex", "start", "end"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<VirtualList> was created with unknown prop '${key}'`);
    	});

    	function svelte_virtual_list_contents_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			contents = $$value;
    			$$invalidate(4, contents);
    		});
    	}

    	function svelte_virtual_list_viewport_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			viewport = $$value;
    			$$invalidate(3, viewport);
    		});
    	}

    	function svelte_virtual_list_viewport_elementresize_handler() {
    		viewport_height = this.offsetHeight;
    		$$invalidate(2, viewport_height);
    	}

    	$$self.$$set = $$props => {
    		if ("items" in $$props) $$invalidate(11, items = $$props.items);
    		if ("height" in $$props) $$invalidate(0, height = $$props.height);
    		if ("itemHeight" in $$props) $$invalidate(12, itemHeight = $$props.itemHeight);
    		if ("hoverItemIndex" in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
    		if ("start" in $$props) $$invalidate(9, start = $$props.start);
    		if ("end" in $$props) $$invalidate(10, end = $$props.end);
    		if ("$$scope" in $$props) $$invalidate(14, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		tick: tick$1,
    		items,
    		height,
    		itemHeight,
    		hoverItemIndex,
    		start,
    		end,
    		height_map,
    		rows,
    		viewport,
    		contents,
    		viewport_height,
    		visible,
    		mounted,
    		top,
    		bottom,
    		average_height,
    		refresh,
    		handle_scroll
    	});

    	$$self.$inject_state = $$props => {
    		if ("items" in $$props) $$invalidate(11, items = $$props.items);
    		if ("height" in $$props) $$invalidate(0, height = $$props.height);
    		if ("itemHeight" in $$props) $$invalidate(12, itemHeight = $$props.itemHeight);
    		if ("hoverItemIndex" in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
    		if ("start" in $$props) $$invalidate(9, start = $$props.start);
    		if ("end" in $$props) $$invalidate(10, end = $$props.end);
    		if ("height_map" in $$props) height_map = $$props.height_map;
    		if ("rows" in $$props) rows = $$props.rows;
    		if ("viewport" in $$props) $$invalidate(3, viewport = $$props.viewport);
    		if ("contents" in $$props) $$invalidate(4, contents = $$props.contents);
    		if ("viewport_height" in $$props) $$invalidate(2, viewport_height = $$props.viewport_height);
    		if ("visible" in $$props) $$invalidate(5, visible = $$props.visible);
    		if ("mounted" in $$props) $$invalidate(13, mounted = $$props.mounted);
    		if ("top" in $$props) $$invalidate(6, top = $$props.top);
    		if ("bottom" in $$props) $$invalidate(7, bottom = $$props.bottom);
    		if ("average_height" in $$props) average_height = $$props.average_height;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*items, start, end*/ 3584) {
    			$$invalidate(5, visible = items.slice(start, end).map((data, i) => {
    				return { index: i + start, data };
    			}));
    		}

    		if ($$self.$$.dirty & /*mounted, items, viewport_height, itemHeight*/ 14340) {
    			// whenever `items` changes, invalidate the current heightmap
    			if (mounted) refresh(items, viewport_height, itemHeight);
    		}
    	};

    	return [
    		height,
    		hoverItemIndex,
    		viewport_height,
    		viewport,
    		contents,
    		visible,
    		top,
    		bottom,
    		handle_scroll,
    		start,
    		end,
    		items,
    		itemHeight,
    		mounted,
    		$$scope,
    		slots,
    		svelte_virtual_list_contents_binding,
    		svelte_virtual_list_viewport_binding,
    		svelte_virtual_list_viewport_elementresize_handler
    	];
    }

    class VirtualList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {
    			items: 11,
    			height: 0,
    			itemHeight: 12,
    			hoverItemIndex: 1,
    			start: 9,
    			end: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VirtualList",
    			options,
    			id: create_fragment$s.name
    		});
    	}

    	get items() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemHeight() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemHeight(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hoverItemIndex() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hoverItemIndex(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get start() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set start(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get end() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set end(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-select\src\List.svelte generated by Svelte v3.38.2 */
    const file$p = "node_modules\\svelte-select\\src\\List.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[34] = list[i];
    	child_ctx[36] = i;
    	return child_ctx;
    }

    // (210:0) {#if isVirtualList}
    function create_if_block_3$2(ctx) {
    	let div;
    	let virtuallist;
    	let current;

    	virtuallist = new VirtualList({
    			props: {
    				items: /*items*/ ctx[4],
    				itemHeight: /*itemHeight*/ ctx[7],
    				$$slots: {
    					default: [
    						create_default_slot$2,
    						({ item, i }) => ({ 34: item, 36: i }),
    						({ item, i }) => [0, (item ? 8 : 0) | (i ? 32 : 0)]
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(virtuallist.$$.fragment);
    			attr_dev(div, "class", "listContainer virtualList svelte-ux0sbr");
    			add_location(div, file$p, 210, 0, 5850);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(virtuallist, div, null);
    			/*div_binding*/ ctx[20](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const virtuallist_changes = {};
    			if (dirty[0] & /*items*/ 16) virtuallist_changes.items = /*items*/ ctx[4];
    			if (dirty[0] & /*itemHeight*/ 128) virtuallist_changes.itemHeight = /*itemHeight*/ ctx[7];

    			if (dirty[0] & /*Item, filterText, getOptionLabel, selectedValue, optionIdentifier, hoverItemIndex, items*/ 4918 | dirty[1] & /*$$scope, item, i*/ 104) {
    				virtuallist_changes.$$scope = { dirty, ctx };
    			}

    			virtuallist.$set(virtuallist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(virtuallist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(virtuallist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(virtuallist);
    			/*div_binding*/ ctx[20](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(210:0) {#if isVirtualList}",
    		ctx
    	});

    	return block;
    }

    // (213:2) <VirtualList {items} {itemHeight} let:item let:i>
    function create_default_slot$2(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*Item*/ ctx[2];

    	function switch_props(ctx) {
    		return {
    			props: {
    				item: /*item*/ ctx[34],
    				filterText: /*filterText*/ ctx[12],
    				getOptionLabel: /*getOptionLabel*/ ctx[5],
    				isFirst: isItemFirst(/*i*/ ctx[36]),
    				isActive: isItemActive(/*item*/ ctx[34], /*selectedValue*/ ctx[8], /*optionIdentifier*/ ctx[9]),
    				isHover: isItemHover(/*hoverItemIndex*/ ctx[1], /*item*/ ctx[34], /*i*/ ctx[36], /*items*/ ctx[4])
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	function mouseover_handler() {
    		return /*mouseover_handler*/ ctx[18](/*i*/ ctx[36]);
    	}

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[19](/*item*/ ctx[34], /*i*/ ctx[36], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "listItem");
    			add_location(div, file$p, 214, 4, 5970);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "mouseover", mouseover_handler, false, false, false),
    					listen_dev(div, "click", click_handler, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const switch_instance_changes = {};
    			if (dirty[1] & /*item*/ 8) switch_instance_changes.item = /*item*/ ctx[34];
    			if (dirty[0] & /*filterText*/ 4096) switch_instance_changes.filterText = /*filterText*/ ctx[12];
    			if (dirty[0] & /*getOptionLabel*/ 32) switch_instance_changes.getOptionLabel = /*getOptionLabel*/ ctx[5];
    			if (dirty[1] & /*i*/ 32) switch_instance_changes.isFirst = isItemFirst(/*i*/ ctx[36]);
    			if (dirty[0] & /*selectedValue, optionIdentifier*/ 768 | dirty[1] & /*item*/ 8) switch_instance_changes.isActive = isItemActive(/*item*/ ctx[34], /*selectedValue*/ ctx[8], /*optionIdentifier*/ ctx[9]);
    			if (dirty[0] & /*hoverItemIndex, items*/ 18 | dirty[1] & /*item, i*/ 40) switch_instance_changes.isHover = isItemHover(/*hoverItemIndex*/ ctx[1], /*item*/ ctx[34], /*i*/ ctx[36], /*items*/ ctx[4]);

    			if (switch_value !== (switch_value = /*Item*/ ctx[2])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(213:2) <VirtualList {items} {itemHeight} let:item let:i>",
    		ctx
    	});

    	return block;
    }

    // (232:0) {#if !isVirtualList}
    function create_if_block$d(ctx) {
    	let div;
    	let current;
    	let each_value = /*items*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let each_1_else = null;

    	if (!each_value.length) {
    		each_1_else = create_else_block_1$3(ctx);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			if (each_1_else) {
    				each_1_else.c();
    			}

    			attr_dev(div, "class", "listContainer svelte-ux0sbr");
    			add_location(div, file$p, 232, 0, 6477);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			if (each_1_else) {
    				each_1_else.m(div, null);
    			}

    			/*div_binding_1*/ ctx[23](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*getGroupHeaderLabel, items, handleHover, handleClick, Item, filterText, getOptionLabel, selectedValue, optionIdentifier, hoverItemIndex, noOptionsMessage, hideEmptyState*/ 32630) {
    				each_value = /*items*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();

    				if (!each_value.length && each_1_else) {
    					each_1_else.p(ctx, dirty);
    				} else if (!each_value.length) {
    					each_1_else = create_else_block_1$3(ctx);
    					each_1_else.c();
    					each_1_else.m(div, null);
    				} else if (each_1_else) {
    					each_1_else.d(1);
    					each_1_else = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (each_1_else) each_1_else.d();
    			/*div_binding_1*/ ctx[23](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(232:0) {#if !isVirtualList}",
    		ctx
    	});

    	return block;
    }

    // (254:2) {:else}
    function create_else_block_1$3(ctx) {
    	let if_block_anchor;
    	let if_block = !/*hideEmptyState*/ ctx[10] && create_if_block_2$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*hideEmptyState*/ ctx[10]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$4(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(254:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (255:4) {#if !hideEmptyState}
    function create_if_block_2$4(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*noOptionsMessage*/ ctx[11]);
    			attr_dev(div, "class", "empty svelte-ux0sbr");
    			add_location(div, file$p, 255, 6, 7178);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*noOptionsMessage*/ 2048) set_data_dev(t, /*noOptionsMessage*/ ctx[11]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(255:4) {#if !hideEmptyState}",
    		ctx
    	});

    	return block;
    }

    // (237:4) { :else }
    function create_else_block$8(ctx) {
    	let div;
    	let switch_instance;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*Item*/ ctx[2];

    	function switch_props(ctx) {
    		return {
    			props: {
    				item: /*item*/ ctx[34],
    				filterText: /*filterText*/ ctx[12],
    				getOptionLabel: /*getOptionLabel*/ ctx[5],
    				isFirst: isItemFirst(/*i*/ ctx[36]),
    				isActive: isItemActive(/*item*/ ctx[34], /*selectedValue*/ ctx[8], /*optionIdentifier*/ ctx[9]),
    				isHover: isItemHover(/*hoverItemIndex*/ ctx[1], /*item*/ ctx[34], /*i*/ ctx[36], /*items*/ ctx[4])
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	function mouseover_handler_1() {
    		return /*mouseover_handler_1*/ ctx[21](/*i*/ ctx[36]);
    	}

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[22](/*item*/ ctx[34], /*i*/ ctx[36], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t = space();
    			attr_dev(div, "class", "listItem");
    			add_location(div, file$p, 237, 4, 6691);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			append_dev(div, t);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "mouseover", mouseover_handler_1, false, false, false),
    					listen_dev(div, "click", click_handler_1, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const switch_instance_changes = {};
    			if (dirty[0] & /*items*/ 16) switch_instance_changes.item = /*item*/ ctx[34];
    			if (dirty[0] & /*filterText*/ 4096) switch_instance_changes.filterText = /*filterText*/ ctx[12];
    			if (dirty[0] & /*getOptionLabel*/ 32) switch_instance_changes.getOptionLabel = /*getOptionLabel*/ ctx[5];
    			if (dirty[0] & /*items, selectedValue, optionIdentifier*/ 784) switch_instance_changes.isActive = isItemActive(/*item*/ ctx[34], /*selectedValue*/ ctx[8], /*optionIdentifier*/ ctx[9]);
    			if (dirty[0] & /*hoverItemIndex, items*/ 18) switch_instance_changes.isHover = isItemHover(/*hoverItemIndex*/ ctx[1], /*item*/ ctx[34], /*i*/ ctx[36], /*items*/ ctx[4]);

    			if (switch_value !== (switch_value = /*Item*/ ctx[2])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, t);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(237:4) { :else }",
    		ctx
    	});

    	return block;
    }

    // (235:4) {#if item.isGroupHeader && !item.isSelectable}
    function create_if_block_1$7(ctx) {
    	let div;
    	let t_value = /*getGroupHeaderLabel*/ ctx[6](/*item*/ ctx[34]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "listGroupTitle svelte-ux0sbr");
    			add_location(div, file$p, 235, 6, 6611);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*getGroupHeaderLabel, items*/ 80 && t_value !== (t_value = /*getGroupHeaderLabel*/ ctx[6](/*item*/ ctx[34]) + "")) set_data_dev(t, t_value);
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(235:4) {#if item.isGroupHeader && !item.isSelectable}",
    		ctx
    	});

    	return block;
    }

    // (234:2) {#each items as item, i}
    function create_each_block$4(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$7, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*item*/ ctx[34].isGroupHeader && !/*item*/ ctx[34].isSelectable) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(234:2) {#each items as item, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*isVirtualList*/ ctx[3] && create_if_block_3$2(ctx);
    	let if_block1 = !/*isVirtualList*/ ctx[3] && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window, "keydown", /*handleKeyDown*/ ctx[15], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*isVirtualList*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*isVirtualList*/ 8) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*isVirtualList*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*isVirtualList*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$d(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function itemClasses(hoverItemIndex, item, itemIndex, items, selectedValue, optionIdentifier, isMulti) {
    	return `${selectedValue && !isMulti && selectedValue[optionIdentifier] === item[optionIdentifier]
	? "active "
	: ""}${hoverItemIndex === itemIndex || items.length === 1
	? "hover"
	: ""}`;
    }

    function isItemActive(item, selectedValue, optionIdentifier) {
    	return selectedValue && selectedValue[optionIdentifier] === item[optionIdentifier];
    }

    function isItemFirst(itemIndex) {
    	return itemIndex === 0;
    }

    function isItemHover(hoverItemIndex, item, itemIndex, items) {
    	return hoverItemIndex === itemIndex || items.length === 1;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("List", slots, []);
    	const dispatch = createEventDispatcher();
    	let { container = undefined } = $$props;
    	let { Item: Item$1 = Item } = $$props;
    	let { isVirtualList = false } = $$props;
    	let { items = [] } = $$props;

    	let { getOptionLabel = (option, filterText) => {
    		if (option) return option.isCreator
    		? `Create \"${filterText}\"`
    		: option.label;
    	} } = $$props;

    	let { getGroupHeaderLabel = option => {
    		return option.label;
    	} } = $$props;

    	let { itemHeight = 40 } = $$props;
    	let { hoverItemIndex = 0 } = $$props;
    	let { selectedValue = undefined } = $$props;
    	let { optionIdentifier = "value" } = $$props;
    	let { hideEmptyState = false } = $$props;
    	let { noOptionsMessage = "No options" } = $$props;
    	let { isMulti = false } = $$props;
    	let { activeItemIndex = 0 } = $$props;
    	let { filterText = "" } = $$props;
    	let isScrollingTimer = 0;
    	let isScrolling = false;
    	let prev_items;
    	let prev_activeItemIndex;
    	let prev_selectedValue;

    	onMount(() => {
    		if (items.length > 0 && !isMulti && selectedValue) {
    			const _hoverItemIndex = items.findIndex(item => item[optionIdentifier] === selectedValue[optionIdentifier]);

    			if (_hoverItemIndex) {
    				$$invalidate(1, hoverItemIndex = _hoverItemIndex);
    			}
    		}

    		scrollToActiveItem("active");

    		container.addEventListener(
    			"scroll",
    			() => {
    				clearTimeout(isScrollingTimer);

    				isScrollingTimer = setTimeout(
    					() => {
    						isScrolling = false;
    					},
    					100
    				);
    			},
    			false
    		);
    	});

    	onDestroy(() => {
    		
    	}); // clearTimeout(isScrollingTimer);

    	beforeUpdate(() => {
    		if (items !== prev_items && items.length > 0) {
    			$$invalidate(1, hoverItemIndex = 0);
    		}

    		// if (prev_activeItemIndex && activeItemIndex > -1) {
    		//   hoverItemIndex = activeItemIndex;
    		//   scrollToActiveItem('active');
    		// }
    		// if (prev_selectedValue && selectedValue) {
    		//   scrollToActiveItem('active');
    		//   if (items && !isMulti) {
    		//     const hoverItemIndex = items.findIndex((item) => item[optionIdentifier] === selectedValue[optionIdentifier]);
    		//     if (hoverItemIndex) {
    		//       hoverItemIndex = hoverItemIndex;
    		//     }
    		//   }
    		// }
    		prev_items = items;

    		prev_activeItemIndex = activeItemIndex;
    		prev_selectedValue = selectedValue;
    	});

    	function handleSelect(item) {
    		if (item.isCreator) return;
    		dispatch("itemSelected", item);
    	}

    	function handleHover(i) {
    		if (isScrolling) return;
    		$$invalidate(1, hoverItemIndex = i);
    	}

    	function handleClick(args) {
    		const { item, i, event } = args;
    		event.stopPropagation();
    		if (selectedValue && !isMulti && selectedValue[optionIdentifier] === item[optionIdentifier]) return closeList();

    		if (item.isCreator) {
    			dispatch("itemCreated", filterText);
    		} else {
    			$$invalidate(16, activeItemIndex = i);
    			$$invalidate(1, hoverItemIndex = i);
    			handleSelect(item);
    		}
    	}

    	function closeList() {
    		dispatch("closeList");
    	}

    	async function updateHoverItem(increment) {
    		if (isVirtualList) return;
    		let isNonSelectableItem = true;

    		while (isNonSelectableItem) {
    			if (increment > 0 && hoverItemIndex === items.length - 1) {
    				$$invalidate(1, hoverItemIndex = 0);
    			} else if (increment < 0 && hoverItemIndex === 0) {
    				$$invalidate(1, hoverItemIndex = items.length - 1);
    			} else {
    				$$invalidate(1, hoverItemIndex = hoverItemIndex + increment);
    			}

    			isNonSelectableItem = items[hoverItemIndex].isGroupHeader && !items[hoverItemIndex].isSelectable;
    		}

    		await tick$1();
    		scrollToActiveItem("hover");
    	}

    	function handleKeyDown(e) {
    		switch (e.key) {
    			case "ArrowDown":
    				e.preventDefault();
    				items.length && updateHoverItem(1);
    				break;
    			case "ArrowUp":
    				e.preventDefault();
    				items.length && updateHoverItem(-1);
    				break;
    			case "Enter":
    				e.preventDefault();
    				if (items.length === 0) break;
    				const hoverItem = items[hoverItemIndex];
    				if (selectedValue && !isMulti && selectedValue[optionIdentifier] === hoverItem[optionIdentifier]) {
    					closeList();
    					break;
    				}
    				if (hoverItem.isCreator) {
    					dispatch("itemCreated", filterText);
    				} else {
    					$$invalidate(16, activeItemIndex = hoverItemIndex);
    					handleSelect(items[hoverItemIndex]);
    				}
    				break;
    			case "Tab":
    				e.preventDefault();
    				if (items.length === 0) break;
    				if (selectedValue && selectedValue[optionIdentifier] === items[hoverItemIndex][optionIdentifier]) return closeList();
    				$$invalidate(16, activeItemIndex = hoverItemIndex);
    				handleSelect(items[hoverItemIndex]);
    				break;
    		}
    	}

    	function scrollToActiveItem(className) {
    		if (isVirtualList || !container) return;
    		let offsetBounding;
    		const focusedElemBounding = container.querySelector(`.listItem .${className}`);

    		if (focusedElemBounding) {
    			offsetBounding = container.getBoundingClientRect().bottom - focusedElemBounding.getBoundingClientRect().bottom;
    		}

    		$$invalidate(0, container.scrollTop -= offsetBounding, container);
    	}

    	
    	

    	const writable_props = [
    		"container",
    		"Item",
    		"isVirtualList",
    		"items",
    		"getOptionLabel",
    		"getGroupHeaderLabel",
    		"itemHeight",
    		"hoverItemIndex",
    		"selectedValue",
    		"optionIdentifier",
    		"hideEmptyState",
    		"noOptionsMessage",
    		"isMulti",
    		"activeItemIndex",
    		"filterText"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<List> was created with unknown prop '${key}'`);
    	});

    	const mouseover_handler = i => handleHover(i);
    	const click_handler = (item, i, event) => handleClick({ item, i, event });

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			container = $$value;
    			$$invalidate(0, container);
    		});
    	}

    	const mouseover_handler_1 = i => handleHover(i);
    	const click_handler_1 = (item, i, event) => handleClick({ item, i, event });

    	function div_binding_1($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			container = $$value;
    			$$invalidate(0, container);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("container" in $$props) $$invalidate(0, container = $$props.container);
    		if ("Item" in $$props) $$invalidate(2, Item$1 = $$props.Item);
    		if ("isVirtualList" in $$props) $$invalidate(3, isVirtualList = $$props.isVirtualList);
    		if ("items" in $$props) $$invalidate(4, items = $$props.items);
    		if ("getOptionLabel" in $$props) $$invalidate(5, getOptionLabel = $$props.getOptionLabel);
    		if ("getGroupHeaderLabel" in $$props) $$invalidate(6, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ("itemHeight" in $$props) $$invalidate(7, itemHeight = $$props.itemHeight);
    		if ("hoverItemIndex" in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
    		if ("selectedValue" in $$props) $$invalidate(8, selectedValue = $$props.selectedValue);
    		if ("optionIdentifier" in $$props) $$invalidate(9, optionIdentifier = $$props.optionIdentifier);
    		if ("hideEmptyState" in $$props) $$invalidate(10, hideEmptyState = $$props.hideEmptyState);
    		if ("noOptionsMessage" in $$props) $$invalidate(11, noOptionsMessage = $$props.noOptionsMessage);
    		if ("isMulti" in $$props) $$invalidate(17, isMulti = $$props.isMulti);
    		if ("activeItemIndex" in $$props) $$invalidate(16, activeItemIndex = $$props.activeItemIndex);
    		if ("filterText" in $$props) $$invalidate(12, filterText = $$props.filterText);
    	};

    	$$self.$capture_state = () => ({
    		beforeUpdate,
    		createEventDispatcher,
    		onDestroy,
    		onMount,
    		tick: tick$1,
    		dispatch,
    		container,
    		ItemComponent: Item,
    		VirtualList,
    		Item: Item$1,
    		isVirtualList,
    		items,
    		getOptionLabel,
    		getGroupHeaderLabel,
    		itemHeight,
    		hoverItemIndex,
    		selectedValue,
    		optionIdentifier,
    		hideEmptyState,
    		noOptionsMessage,
    		isMulti,
    		activeItemIndex,
    		filterText,
    		isScrollingTimer,
    		isScrolling,
    		prev_items,
    		prev_activeItemIndex,
    		prev_selectedValue,
    		itemClasses,
    		handleSelect,
    		handleHover,
    		handleClick,
    		closeList,
    		updateHoverItem,
    		handleKeyDown,
    		scrollToActiveItem,
    		isItemActive,
    		isItemFirst,
    		isItemHover
    	});

    	$$self.$inject_state = $$props => {
    		if ("container" in $$props) $$invalidate(0, container = $$props.container);
    		if ("Item" in $$props) $$invalidate(2, Item$1 = $$props.Item);
    		if ("isVirtualList" in $$props) $$invalidate(3, isVirtualList = $$props.isVirtualList);
    		if ("items" in $$props) $$invalidate(4, items = $$props.items);
    		if ("getOptionLabel" in $$props) $$invalidate(5, getOptionLabel = $$props.getOptionLabel);
    		if ("getGroupHeaderLabel" in $$props) $$invalidate(6, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ("itemHeight" in $$props) $$invalidate(7, itemHeight = $$props.itemHeight);
    		if ("hoverItemIndex" in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
    		if ("selectedValue" in $$props) $$invalidate(8, selectedValue = $$props.selectedValue);
    		if ("optionIdentifier" in $$props) $$invalidate(9, optionIdentifier = $$props.optionIdentifier);
    		if ("hideEmptyState" in $$props) $$invalidate(10, hideEmptyState = $$props.hideEmptyState);
    		if ("noOptionsMessage" in $$props) $$invalidate(11, noOptionsMessage = $$props.noOptionsMessage);
    		if ("isMulti" in $$props) $$invalidate(17, isMulti = $$props.isMulti);
    		if ("activeItemIndex" in $$props) $$invalidate(16, activeItemIndex = $$props.activeItemIndex);
    		if ("filterText" in $$props) $$invalidate(12, filterText = $$props.filterText);
    		if ("isScrollingTimer" in $$props) isScrollingTimer = $$props.isScrollingTimer;
    		if ("isScrolling" in $$props) isScrolling = $$props.isScrolling;
    		if ("prev_items" in $$props) prev_items = $$props.prev_items;
    		if ("prev_activeItemIndex" in $$props) prev_activeItemIndex = $$props.prev_activeItemIndex;
    		if ("prev_selectedValue" in $$props) prev_selectedValue = $$props.prev_selectedValue;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		container,
    		hoverItemIndex,
    		Item$1,
    		isVirtualList,
    		items,
    		getOptionLabel,
    		getGroupHeaderLabel,
    		itemHeight,
    		selectedValue,
    		optionIdentifier,
    		hideEmptyState,
    		noOptionsMessage,
    		filterText,
    		handleHover,
    		handleClick,
    		handleKeyDown,
    		activeItemIndex,
    		isMulti,
    		mouseover_handler,
    		click_handler,
    		div_binding,
    		mouseover_handler_1,
    		click_handler_1,
    		div_binding_1
    	];
    }

    class List extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$r,
    			create_fragment$r,
    			safe_not_equal,
    			{
    				container: 0,
    				Item: 2,
    				isVirtualList: 3,
    				items: 4,
    				getOptionLabel: 5,
    				getGroupHeaderLabel: 6,
    				itemHeight: 7,
    				hoverItemIndex: 1,
    				selectedValue: 8,
    				optionIdentifier: 9,
    				hideEmptyState: 10,
    				noOptionsMessage: 11,
    				isMulti: 17,
    				activeItemIndex: 16,
    				filterText: 12
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "List",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get container() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set container(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Item() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Item(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isVirtualList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isVirtualList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get items() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getOptionLabel() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getOptionLabel(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getGroupHeaderLabel() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getGroupHeaderLabel(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemHeight() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemHeight(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hoverItemIndex() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hoverItemIndex(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedValue() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedValue(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get optionIdentifier() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set optionIdentifier(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideEmptyState() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideEmptyState(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noOptionsMessage() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noOptionsMessage(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isMulti() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isMulti(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeItemIndex() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeItemIndex(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterText() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterText(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-select\src\Selection.svelte generated by Svelte v3.38.2 */

    const file$o = "node_modules\\svelte-select\\src\\Selection.svelte";

    function create_fragment$q(ctx) {
    	let div;
    	let raw_value = /*getSelectionLabel*/ ctx[0](/*item*/ ctx[1]) + "";

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "selection svelte-ch6bh7");
    			add_location(div, file$o, 13, 0, 210);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div.innerHTML = raw_value;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*getSelectionLabel, item*/ 3 && raw_value !== (raw_value = /*getSelectionLabel*/ ctx[0](/*item*/ ctx[1]) + "")) div.innerHTML = raw_value;		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Selection", slots, []);
    	let { getSelectionLabel = undefined } = $$props;
    	let { item = undefined } = $$props;
    	const writable_props = ["getSelectionLabel", "item"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Selection> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("getSelectionLabel" in $$props) $$invalidate(0, getSelectionLabel = $$props.getSelectionLabel);
    		if ("item" in $$props) $$invalidate(1, item = $$props.item);
    	};

    	$$self.$capture_state = () => ({ getSelectionLabel, item });

    	$$self.$inject_state = $$props => {
    		if ("getSelectionLabel" in $$props) $$invalidate(0, getSelectionLabel = $$props.getSelectionLabel);
    		if ("item" in $$props) $$invalidate(1, item = $$props.item);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [getSelectionLabel, item];
    }

    class Selection extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, { getSelectionLabel: 0, item: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Selection",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get getSelectionLabel() {
    		throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getSelectionLabel(value) {
    		throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get item() {
    		throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-select\src\MultiSelection.svelte generated by Svelte v3.38.2 */
    const file$n = "node_modules\\svelte-select\\src\\MultiSelection.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[11] = i;
    	return child_ctx;
    }

    // (23:2) {#if !isDisabled && !multiFullItemClearable}
    function create_if_block$c(ctx) {
    	let div;
    	let svg;
    	let path;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[6](/*i*/ ctx[11], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124 l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
    			add_location(path, file$n, 25, 6, 950);
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", "100%");
    			attr_dev(svg, "viewBox", "-2 -2 50 50");
    			attr_dev(svg, "focusable", "false");
    			attr_dev(svg, "role", "presentation");
    			attr_dev(svg, "class", "svelte-14r1jr2");
    			add_location(svg, file$n, 24, 4, 851);
    			attr_dev(div, "class", "multiSelectItem_clear svelte-14r1jr2");
    			add_location(div, file$n, 23, 2, 767);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(23:2) {#if !isDisabled && !multiFullItemClearable}",
    		ctx
    	});

    	return block;
    }

    // (18:0) {#each selectedValue as value, i}
    function create_each_block$3(ctx) {
    	let div1;
    	let div0;
    	let raw_value = /*getSelectionLabel*/ ctx[4](/*value*/ ctx[9]) + "";
    	let t0;
    	let t1;
    	let div1_class_value;
    	let mounted;
    	let dispose;
    	let if_block = !/*isDisabled*/ ctx[2] && !/*multiFullItemClearable*/ ctx[3] && create_if_block$c(ctx);

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[7](/*i*/ ctx[11], ...args);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			attr_dev(div0, "class", "multiSelectItem_label svelte-14r1jr2");
    			add_location(div0, file$n, 19, 2, 636);

    			attr_dev(div1, "class", div1_class_value = "multiSelectItem " + (/*activeSelectedValue*/ ctx[1] === /*i*/ ctx[11]
    			? "active"
    			: "") + " " + (/*isDisabled*/ ctx[2] ? "disabled" : "") + " svelte-14r1jr2");

    			add_location(div1, file$n, 18, 0, 457);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			div0.innerHTML = raw_value;
    			append_dev(div1, t0);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t1);

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*getSelectionLabel, selectedValue*/ 17 && raw_value !== (raw_value = /*getSelectionLabel*/ ctx[4](/*value*/ ctx[9]) + "")) div0.innerHTML = raw_value;
    			if (!/*isDisabled*/ ctx[2] && !/*multiFullItemClearable*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					if_block.m(div1, t1);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*activeSelectedValue, isDisabled*/ 6 && div1_class_value !== (div1_class_value = "multiSelectItem " + (/*activeSelectedValue*/ ctx[1] === /*i*/ ctx[11]
    			? "active"
    			: "") + " " + (/*isDisabled*/ ctx[2] ? "disabled" : "") + " svelte-14r1jr2")) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(18:0) {#each selectedValue as value, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let each_1_anchor;
    	let each_value = /*selectedValue*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*activeSelectedValue, isDisabled, multiFullItemClearable, handleClear, getSelectionLabel, selectedValue*/ 63) {
    				each_value = /*selectedValue*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MultiSelection", slots, []);
    	const dispatch = createEventDispatcher();
    	let { selectedValue = [] } = $$props;
    	let { activeSelectedValue = undefined } = $$props;
    	let { isDisabled = false } = $$props;
    	let { multiFullItemClearable = false } = $$props;
    	let { getSelectionLabel = undefined } = $$props;

    	function handleClear(i, event) {
    		event.stopPropagation();
    		dispatch("multiItemClear", { i });
    	}

    	const writable_props = [
    		"selectedValue",
    		"activeSelectedValue",
    		"isDisabled",
    		"multiFullItemClearable",
    		"getSelectionLabel"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MultiSelection> was created with unknown prop '${key}'`);
    	});

    	const click_handler = (i, event) => handleClear(i, event);
    	const click_handler_1 = (i, event) => multiFullItemClearable ? handleClear(i, event) : {};

    	$$self.$$set = $$props => {
    		if ("selectedValue" in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
    		if ("activeSelectedValue" in $$props) $$invalidate(1, activeSelectedValue = $$props.activeSelectedValue);
    		if ("isDisabled" in $$props) $$invalidate(2, isDisabled = $$props.isDisabled);
    		if ("multiFullItemClearable" in $$props) $$invalidate(3, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ("getSelectionLabel" in $$props) $$invalidate(4, getSelectionLabel = $$props.getSelectionLabel);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		selectedValue,
    		activeSelectedValue,
    		isDisabled,
    		multiFullItemClearable,
    		getSelectionLabel,
    		handleClear
    	});

    	$$self.$inject_state = $$props => {
    		if ("selectedValue" in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
    		if ("activeSelectedValue" in $$props) $$invalidate(1, activeSelectedValue = $$props.activeSelectedValue);
    		if ("isDisabled" in $$props) $$invalidate(2, isDisabled = $$props.isDisabled);
    		if ("multiFullItemClearable" in $$props) $$invalidate(3, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ("getSelectionLabel" in $$props) $$invalidate(4, getSelectionLabel = $$props.getSelectionLabel);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		selectedValue,
    		activeSelectedValue,
    		isDisabled,
    		multiFullItemClearable,
    		getSelectionLabel,
    		handleClear,
    		click_handler,
    		click_handler_1
    	];
    }

    class MultiSelection extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {
    			selectedValue: 0,
    			activeSelectedValue: 1,
    			isDisabled: 2,
    			multiFullItemClearable: 3,
    			getSelectionLabel: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MultiSelection",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get selectedValue() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedValue(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeSelectedValue() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeSelectedValue(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isDisabled() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isDisabled(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiFullItemClearable() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiFullItemClearable(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getSelectionLabel() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getSelectionLabel(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function isOutOfViewport(elem) {
      const bounding = elem.getBoundingClientRect();
      const out = {};

      out.top = bounding.top < 0;
      out.left = bounding.left < 0;
      out.bottom = bounding.bottom > (window.innerHeight || document.documentElement.clientHeight);
      out.right = bounding.right > (window.innerWidth || document.documentElement.clientWidth);
      out.any = out.top || out.left || out.bottom || out.right;

      return out;
    }

    function debounce(func, wait, immediate) {
      let timeout;

      return function executedFunction() {
        let context = this;
        let args = arguments;

        let later = function() {
          timeout = null;
          if (!immediate) func.apply(context, args);
        };

        let callNow = immediate && !timeout;

        clearTimeout(timeout);

        timeout = setTimeout(later, wait);

        if (callNow) func.apply(context, args);
      };
    }

    /* node_modules\svelte-select\src\ClearIcon.svelte generated by Svelte v3.38.2 */

    const file$m = "node_modules\\svelte-select\\src\\ClearIcon.svelte";

    function create_fragment$o(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
    			add_location(path, file$m, 7, 2, 108);
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", "100%");
    			attr_dev(svg, "viewBox", "-2 -2 50 50");
    			attr_dev(svg, "focusable", "false");
    			attr_dev(svg, "role", "presentation");
    			add_location(svg, file$m, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop$2,
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ClearIcon", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ClearIcon> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class ClearIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ClearIcon",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    /* node_modules\svelte-select\src\Select.svelte generated by Svelte v3.38.2 */

    const { Object: Object_1$1, console: console_1$5 } = globals;
    const file$l = "node_modules\\svelte-select\\src\\Select.svelte";

    // (827:2) {#if Icon}
    function create_if_block_7$1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*iconProps*/ ctx[18]];
    	var switch_value = /*Icon*/ ctx[17];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign$1(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty[0] & /*iconProps*/ 262144)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*iconProps*/ ctx[18])])
    			: {};

    			if (switch_value !== (switch_value = /*Icon*/ ctx[17])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(827:2) {#if Icon}",
    		ctx
    	});

    	return block;
    }

    // (831:2) {#if isMulti && selectedValue && selectedValue.length > 0}
    function create_if_block_6$1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*MultiSelection*/ ctx[7];

    	function switch_props(ctx) {
    		return {
    			props: {
    				selectedValue: /*selectedValue*/ ctx[0],
    				getSelectionLabel: /*getSelectionLabel*/ ctx[13],
    				activeSelectedValue: /*activeSelectedValue*/ ctx[25],
    				isDisabled: /*isDisabled*/ ctx[10],
    				multiFullItemClearable: /*multiFullItemClearable*/ ctx[9]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		switch_instance.$on("multiItemClear", /*handleMultiItemClear*/ ctx[29]);
    		switch_instance.$on("focus", /*handleFocus*/ ctx[32]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*selectedValue*/ 1) switch_instance_changes.selectedValue = /*selectedValue*/ ctx[0];
    			if (dirty[0] & /*getSelectionLabel*/ 8192) switch_instance_changes.getSelectionLabel = /*getSelectionLabel*/ ctx[13];
    			if (dirty[0] & /*activeSelectedValue*/ 33554432) switch_instance_changes.activeSelectedValue = /*activeSelectedValue*/ ctx[25];
    			if (dirty[0] & /*isDisabled*/ 1024) switch_instance_changes.isDisabled = /*isDisabled*/ ctx[10];
    			if (dirty[0] & /*multiFullItemClearable*/ 512) switch_instance_changes.multiFullItemClearable = /*multiFullItemClearable*/ ctx[9];

    			if (switch_value !== (switch_value = /*MultiSelection*/ ctx[7])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					switch_instance.$on("multiItemClear", /*handleMultiItemClear*/ ctx[29]);
    					switch_instance.$on("focus", /*handleFocus*/ ctx[32]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(831:2) {#if isMulti && selectedValue && selectedValue.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (852:2) {:else}
    function create_else_block_1$2(ctx) {
    	let input_1;
    	let mounted;
    	let dispose;

    	let input_1_levels = [
    		/*_inputAttributes*/ ctx[26],
    		{ placeholder: /*placeholderText*/ ctx[28] },
    		{ style: /*inputStyles*/ ctx[15] }
    	];

    	let input_1_data = {};

    	for (let i = 0; i < input_1_levels.length; i += 1) {
    		input_1_data = assign$1(input_1_data, input_1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input_1 = element("input");
    			set_attributes(input_1, input_1_data);
    			toggle_class(input_1, "svelte-17qb5ew", true);
    			add_location(input_1, file$l, 852, 4, 21497);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input_1, anchor);
    			/*input_1_binding_1*/ ctx[63](input_1);
    			set_input_value(input_1, /*filterText*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input_1, "focus", /*handleFocus*/ ctx[32], false, false, false),
    					listen_dev(input_1, "input", /*input_1_input_handler_1*/ ctx[64])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [
    				dirty[0] & /*_inputAttributes*/ 67108864 && /*_inputAttributes*/ ctx[26],
    				dirty[0] & /*placeholderText*/ 268435456 && { placeholder: /*placeholderText*/ ctx[28] },
    				dirty[0] & /*inputStyles*/ 32768 && { style: /*inputStyles*/ ctx[15] }
    			]));

    			if (dirty[0] & /*filterText*/ 2 && input_1.value !== /*filterText*/ ctx[1]) {
    				set_input_value(input_1, /*filterText*/ ctx[1]);
    			}

    			toggle_class(input_1, "svelte-17qb5ew", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input_1);
    			/*input_1_binding_1*/ ctx[63](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(852:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (843:2) {#if isDisabled}
    function create_if_block_5$1(ctx) {
    	let input_1;
    	let mounted;
    	let dispose;

    	let input_1_levels = [
    		/*_inputAttributes*/ ctx[26],
    		{ placeholder: /*placeholderText*/ ctx[28] },
    		{ style: /*inputStyles*/ ctx[15] },
    		{ disabled: true }
    	];

    	let input_1_data = {};

    	for (let i = 0; i < input_1_levels.length; i += 1) {
    		input_1_data = assign$1(input_1_data, input_1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input_1 = element("input");
    			set_attributes(input_1, input_1_data);
    			toggle_class(input_1, "svelte-17qb5ew", true);
    			add_location(input_1, file$l, 843, 4, 21285);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input_1, anchor);
    			/*input_1_binding*/ ctx[61](input_1);
    			set_input_value(input_1, /*filterText*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input_1, "focus", /*handleFocus*/ ctx[32], false, false, false),
    					listen_dev(input_1, "input", /*input_1_input_handler*/ ctx[62])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [
    				dirty[0] & /*_inputAttributes*/ 67108864 && /*_inputAttributes*/ ctx[26],
    				dirty[0] & /*placeholderText*/ 268435456 && { placeholder: /*placeholderText*/ ctx[28] },
    				dirty[0] & /*inputStyles*/ 32768 && { style: /*inputStyles*/ ctx[15] },
    				{ disabled: true }
    			]));

    			if (dirty[0] & /*filterText*/ 2 && input_1.value !== /*filterText*/ ctx[1]) {
    				set_input_value(input_1, /*filterText*/ ctx[1]);
    			}

    			toggle_class(input_1, "svelte-17qb5ew", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input_1);
    			/*input_1_binding*/ ctx[61](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(843:2) {#if isDisabled}",
    		ctx
    	});

    	return block;
    }

    // (862:2) {#if !isMulti && showSelectedItem}
    function create_if_block_4$1(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*Selection*/ ctx[6];

    	function switch_props(ctx) {
    		return {
    			props: {
    				item: /*selectedValue*/ ctx[0],
    				getSelectionLabel: /*getSelectionLabel*/ ctx[13]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "selectedItem svelte-17qb5ew");
    			add_location(div, file$l, 862, 4, 21730);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "focus", /*handleFocus*/ ctx[32], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*selectedValue*/ 1) switch_instance_changes.item = /*selectedValue*/ ctx[0];
    			if (dirty[0] & /*getSelectionLabel*/ 8192) switch_instance_changes.getSelectionLabel = /*getSelectionLabel*/ ctx[13];

    			if (switch_value !== (switch_value = /*Selection*/ ctx[6])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(862:2) {#if !isMulti && showSelectedItem}",
    		ctx
    	});

    	return block;
    }

    // (871:2) {#if showSelectedItem && isClearable && !isDisabled && !isWaiting}
    function create_if_block_3$1(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*ClearIcon*/ ctx[23];

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "clearSelect svelte-17qb5ew");
    			add_location(div, file$l, 871, 4, 21982);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", prevent_default(/*handleClear*/ ctx[24]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*ClearIcon*/ ctx[23])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(871:2) {#if showSelectedItem && isClearable && !isDisabled && !isWaiting}",
    		ctx
    	});

    	return block;
    }

    // (877:2) {#if showIndicator || (showChevron && !selectedValue || (!isSearchable && !isDisabled && !isWaiting && ((showSelectedItem && !isClearable) || !showSelectedItem)))}
    function create_if_block_1$6(ctx) {
    	let div;

    	function select_block_type_1(ctx, dirty) {
    		if (/*indicatorSvg*/ ctx[22]) return create_if_block_2$3;
    		return create_else_block$7;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "indicator svelte-17qb5ew");
    			add_location(div, file$l, 877, 4, 22281);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(877:2) {#if showIndicator || (showChevron && !selectedValue || (!isSearchable && !isDisabled && !isWaiting && ((showSelectedItem && !isClearable) || !showSelectedItem)))}",
    		ctx
    	});

    	return block;
    }

    // (881:6) {:else}
    function create_else_block$7(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n            3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n            1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n            0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n            0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
    			add_location(path, file$l, 886, 10, 22502);
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", "100%");
    			attr_dev(svg, "viewBox", "0 0 20 20");
    			attr_dev(svg, "focusable", "false");
    			attr_dev(svg, "class", "svelte-17qb5ew");
    			add_location(svg, file$l, 881, 8, 22381);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(881:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (879:6) {#if indicatorSvg}
    function create_if_block_2$3(ctx) {
    	let html_tag;
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty$1();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(/*indicatorSvg*/ ctx[22], target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*indicatorSvg*/ 4194304) html_tag.p(/*indicatorSvg*/ ctx[22]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(879:6) {#if indicatorSvg}",
    		ctx
    	});

    	return block;
    }

    // (898:2) {#if isWaiting}
    function create_if_block$b(ctx) {
    	let div;
    	let svg;
    	let circle;

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			circle = svg_element("circle");
    			attr_dev(circle, "class", "spinner_path svelte-17qb5ew");
    			attr_dev(circle, "cx", "50");
    			attr_dev(circle, "cy", "50");
    			attr_dev(circle, "r", "20");
    			attr_dev(circle, "fill", "none");
    			attr_dev(circle, "stroke", "currentColor");
    			attr_dev(circle, "stroke-width", "5");
    			attr_dev(circle, "stroke-miterlimit", "10");
    			add_location(circle, file$l, 900, 8, 23007);
    			attr_dev(svg, "class", "spinner_icon svelte-17qb5ew");
    			attr_dev(svg, "viewBox", "25 25 50 50");
    			add_location(svg, file$l, 899, 6, 22950);
    			attr_dev(div, "class", "spinner svelte-17qb5ew");
    			add_location(div, file$l, 898, 4, 22922);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, circle);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(898:2) {#if isWaiting}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*Icon*/ ctx[17] && create_if_block_7$1(ctx);
    	let if_block1 = /*isMulti*/ ctx[8] && /*selectedValue*/ ctx[0] && /*selectedValue*/ ctx[0].length > 0 && create_if_block_6$1(ctx);

    	function select_block_type(ctx, dirty) {
    		if (/*isDisabled*/ ctx[10]) return create_if_block_5$1;
    		return create_else_block_1$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block2 = current_block_type(ctx);
    	let if_block3 = !/*isMulti*/ ctx[8] && /*showSelectedItem*/ ctx[27] && create_if_block_4$1(ctx);
    	let if_block4 = /*showSelectedItem*/ ctx[27] && /*isClearable*/ ctx[16] && !/*isDisabled*/ ctx[10] && !/*isWaiting*/ ctx[5] && create_if_block_3$1(ctx);
    	let if_block5 = (/*showIndicator*/ ctx[20] || (/*showChevron*/ ctx[19] && !/*selectedValue*/ ctx[0] || !/*isSearchable*/ ctx[14] && !/*isDisabled*/ ctx[10] && !/*isWaiting*/ ctx[5] && (/*showSelectedItem*/ ctx[27] && !/*isClearable*/ ctx[16] || !/*showSelectedItem*/ ctx[27]))) && create_if_block_1$6(ctx);
    	let if_block6 = /*isWaiting*/ ctx[5] && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			if (if_block5) if_block5.c();
    			t5 = space();
    			if (if_block6) if_block6.c();
    			attr_dev(div, "class", div_class_value = "selectContainer " + /*containerClasses*/ ctx[21] + " svelte-17qb5ew");
    			attr_dev(div, "style", /*containerStyles*/ ctx[12]);
    			toggle_class(div, "hasError", /*hasError*/ ctx[11]);
    			toggle_class(div, "multiSelect", /*isMulti*/ ctx[8]);
    			toggle_class(div, "disabled", /*isDisabled*/ ctx[10]);
    			toggle_class(div, "focused", /*isFocused*/ ctx[4]);
    			add_location(div, file$l, 816, 0, 20631);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			append_dev(div, t3);
    			if (if_block4) if_block4.m(div, null);
    			append_dev(div, t4);
    			if (if_block5) if_block5.m(div, null);
    			append_dev(div, t5);
    			if (if_block6) if_block6.m(div, null);
    			/*div_binding*/ ctx[65](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "click", /*handleWindowClick*/ ctx[33], false, false, false),
    					listen_dev(window, "keydown", /*handleKeyDown*/ ctx[31], false, false, false),
    					listen_dev(window, "resize", /*getPosition*/ ctx[30], false, false, false),
    					listen_dev(div, "click", /*handleClick*/ ctx[34], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*Icon*/ ctx[17]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*Icon*/ 131072) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_7$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*isMulti*/ ctx[8] && /*selectedValue*/ ctx[0] && /*selectedValue*/ ctx[0].length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*isMulti, selectedValue*/ 257) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_6$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(div, t2);
    				}
    			}

    			if (!/*isMulti*/ ctx[8] && /*showSelectedItem*/ ctx[27]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*isMulti, showSelectedItem*/ 134217984) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_4$1(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, t3);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*showSelectedItem*/ ctx[27] && /*isClearable*/ ctx[16] && !/*isDisabled*/ ctx[10] && !/*isWaiting*/ ctx[5]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[0] & /*showSelectedItem, isClearable, isDisabled, isWaiting*/ 134284320) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_3$1(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div, t4);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*showIndicator*/ ctx[20] || (/*showChevron*/ ctx[19] && !/*selectedValue*/ ctx[0] || !/*isSearchable*/ ctx[14] && !/*isDisabled*/ ctx[10] && !/*isWaiting*/ ctx[5] && (/*showSelectedItem*/ ctx[27] && !/*isClearable*/ ctx[16] || !/*showSelectedItem*/ ctx[27]))) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);
    				} else {
    					if_block5 = create_if_block_1$6(ctx);
    					if_block5.c();
    					if_block5.m(div, t5);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (/*isWaiting*/ ctx[5]) {
    				if (if_block6) ; else {
    					if_block6 = create_if_block$b(ctx);
    					if_block6.c();
    					if_block6.m(div, null);
    				}
    			} else if (if_block6) {
    				if_block6.d(1);
    				if_block6 = null;
    			}

    			if (!current || dirty[0] & /*containerClasses*/ 2097152 && div_class_value !== (div_class_value = "selectContainer " + /*containerClasses*/ ctx[21] + " svelte-17qb5ew")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (!current || dirty[0] & /*containerStyles*/ 4096) {
    				attr_dev(div, "style", /*containerStyles*/ ctx[12]);
    			}

    			if (dirty[0] & /*containerClasses, hasError*/ 2099200) {
    				toggle_class(div, "hasError", /*hasError*/ ctx[11]);
    			}

    			if (dirty[0] & /*containerClasses, isMulti*/ 2097408) {
    				toggle_class(div, "multiSelect", /*isMulti*/ ctx[8]);
    			}

    			if (dirty[0] & /*containerClasses, isDisabled*/ 2098176) {
    				toggle_class(div, "disabled", /*isDisabled*/ ctx[10]);
    			}

    			if (dirty[0] & /*containerClasses, isFocused*/ 2097168) {
    				toggle_class(div, "focused", /*isFocused*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			/*div_binding*/ ctx[65](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let disabled;
    	let showSelectedItem;
    	let placeholderText;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Select", slots, []);
    	const dispatch = createEventDispatcher();
    	let { container = undefined } = $$props;
    	let { input = undefined } = $$props;
    	let { Item: Item$1 = Item } = $$props;
    	let { Selection: Selection$1 = Selection } = $$props;
    	let { MultiSelection: MultiSelection$1 = MultiSelection } = $$props;
    	let { isMulti = false } = $$props;
    	let { multiFullItemClearable = false } = $$props;
    	let { isDisabled = false } = $$props;
    	let { isCreatable = false } = $$props;
    	let { isFocused = false } = $$props;
    	let { selectedValue = undefined } = $$props;
    	let { filterText = "" } = $$props;
    	let { placeholder = "Select..." } = $$props;
    	let { items = [] } = $$props;
    	let { itemFilter = (label, filterText, option) => label.toLowerCase().includes(filterText.toLowerCase()) } = $$props;
    	let { groupBy = undefined } = $$props;
    	let { groupFilter = groups => groups } = $$props;
    	let { isGroupHeaderSelectable = false } = $$props;

    	let { getGroupHeaderLabel = option => {
    		return option.label;
    	} } = $$props;

    	let { getOptionLabel = (option, filterText) => {
    		return option.isCreator
    		? `Create \"${filterText}\"`
    		: option.label;
    	} } = $$props;

    	let { optionIdentifier = "value" } = $$props;
    	let { loadOptions = undefined } = $$props;
    	let { hasError = false } = $$props;
    	let { containerStyles = "" } = $$props;

    	let { getSelectionLabel = option => {
    		if (option) return option.label;
    	} } = $$props;

    	let { createGroupHeaderItem = groupValue => {
    		return { value: groupValue, label: groupValue };
    	} } = $$props;

    	let { createItem = filterText => {
    		return { value: filterText, label: filterText };
    	} } = $$props;

    	let { isSearchable = true } = $$props;
    	let { inputStyles = "" } = $$props;
    	let { isClearable = true } = $$props;
    	let { isWaiting = false } = $$props;
    	let { listPlacement = "auto" } = $$props;
    	let { listOpen = false } = $$props;
    	let { list = undefined } = $$props;
    	let { isVirtualList = false } = $$props;
    	let { loadOptionsInterval = 300 } = $$props;
    	let { noOptionsMessage = "No options" } = $$props;
    	let { hideEmptyState = false } = $$props;
    	let { filteredItems = [] } = $$props;
    	let { inputAttributes = {} } = $$props;
    	let { listAutoWidth = true } = $$props;
    	let { itemHeight = 40 } = $$props;
    	let { Icon = undefined } = $$props;
    	let { iconProps = {} } = $$props;
    	let { showChevron = false } = $$props;
    	let { showIndicator = false } = $$props;
    	let { containerClasses = "" } = $$props;
    	let { indicatorSvg = undefined } = $$props;
    	let { ClearIcon: ClearIcon$1 = ClearIcon } = $$props;
    	let target;
    	let activeSelectedValue;
    	let _items = [];
    	let originalItemsClone;
    	let prev_selectedValue;
    	let prev_listOpen;
    	let prev_filterText;
    	let prev_isFocused;
    	let prev_filteredItems;

    	async function resetFilter() {
    		await tick$1();
    		$$invalidate(1, filterText = "");
    	}

    	let getItemsHasInvoked = false;

    	const getItems = debounce(
    		async () => {
    			getItemsHasInvoked = true;
    			$$invalidate(5, isWaiting = true);

    			let res = await loadOptions(filterText).catch(err => {
    				console.warn("svelte-select loadOptions error :>> ", err);
    				dispatch("error", { type: "loadOptions", details: err });
    			});

    			if (res && !res.cancelled) {
    				if (res) {
    					$$invalidate(35, items = [...res]);
    					dispatch("loaded", { items });
    				} else {
    					$$invalidate(35, items = []);
    				}

    				$$invalidate(5, isWaiting = false);
    				$$invalidate(4, isFocused = true);
    				$$invalidate(37, listOpen = true);
    			}
    		},
    		loadOptionsInterval
    	);

    	let _inputAttributes = {};

    	beforeUpdate(() => {
    		if (isMulti && selectedValue && selectedValue.length > 1) {
    			checkSelectedValueForDuplicates();
    		}

    		if (!isMulti && selectedValue && prev_selectedValue !== selectedValue) {
    			if (!prev_selectedValue || JSON.stringify(selectedValue[optionIdentifier]) !== JSON.stringify(prev_selectedValue[optionIdentifier])) {
    				dispatch("select", selectedValue);
    			}
    		}

    		if (isMulti && JSON.stringify(selectedValue) !== JSON.stringify(prev_selectedValue)) {
    			if (checkSelectedValueForDuplicates()) {
    				dispatch("select", selectedValue);
    			}
    		}

    		if (container && listOpen !== prev_listOpen) {
    			if (listOpen) {
    				loadList();
    			} else {
    				removeList();
    			}
    		}

    		if (filterText !== prev_filterText) {
    			if (filterText.length > 0) {
    				$$invalidate(4, isFocused = true);
    				$$invalidate(37, listOpen = true);

    				if (loadOptions) {
    					getItems();
    				} else {
    					loadList();
    					$$invalidate(37, listOpen = true);

    					if (isMulti) {
    						$$invalidate(25, activeSelectedValue = undefined);
    					}
    				}
    			} else {
    				setList([]);
    			}

    			if (list) {
    				list.$set({ filterText });
    			}
    		}

    		if (isFocused !== prev_isFocused) {
    			if (isFocused || listOpen) {
    				handleFocus();
    			} else {
    				resetFilter();
    				if (input) input.blur();
    			}
    		}

    		if (prev_filteredItems !== filteredItems) {
    			let _filteredItems = [...filteredItems];

    			if (isCreatable && filterText) {
    				const itemToCreate = createItem(filterText);
    				itemToCreate.isCreator = true;

    				const existingItemWithFilterValue = _filteredItems.find(item => {
    					return item[optionIdentifier] === itemToCreate[optionIdentifier];
    				});

    				let existingSelectionWithFilterValue;

    				if (selectedValue) {
    					if (isMulti) {
    						existingSelectionWithFilterValue = selectedValue.find(selection => {
    							return selection[optionIdentifier] === itemToCreate[optionIdentifier];
    						});
    					} else if (selectedValue[optionIdentifier] === itemToCreate[optionIdentifier]) {
    						existingSelectionWithFilterValue = selectedValue;
    					}
    				}

    				if (!existingItemWithFilterValue && !existingSelectionWithFilterValue) {
    					_filteredItems = [..._filteredItems, itemToCreate];
    				}
    			}

    			setList(_filteredItems);
    		}

    		prev_selectedValue = selectedValue;
    		prev_listOpen = listOpen;
    		prev_filterText = filterText;
    		prev_isFocused = isFocused;
    		prev_filteredItems = filteredItems;
    	});

    	function checkSelectedValueForDuplicates() {
    		let noDuplicates = true;

    		if (selectedValue) {
    			const ids = [];
    			const uniqueValues = [];

    			selectedValue.forEach(val => {
    				if (!ids.includes(val[optionIdentifier])) {
    					ids.push(val[optionIdentifier]);
    					uniqueValues.push(val);
    				} else {
    					noDuplicates = false;
    				}
    			});

    			if (!noDuplicates) $$invalidate(0, selectedValue = uniqueValues);
    		}

    		return noDuplicates;
    	}

    	function findItem(selection) {
    		let matchTo = selection
    		? selection[optionIdentifier]
    		: selectedValue[optionIdentifier];

    		return items.find(item => item[optionIdentifier] === matchTo);
    	}

    	function updateSelectedValueDisplay(items) {
    		if (!items || items.length === 0 || items.some(item => typeof item !== "object")) return;

    		if (!selectedValue || (isMulti
    		? selectedValue.some(selection => !selection || !selection[optionIdentifier])
    		: !selectedValue[optionIdentifier])) return;

    		if (Array.isArray(selectedValue)) {
    			$$invalidate(0, selectedValue = selectedValue.map(selection => findItem(selection) || selection));
    		} else {
    			$$invalidate(0, selectedValue = findItem() || selectedValue);
    		}
    	}

    	async function setList(items) {
    		await tick$1();
    		if (!listOpen) return;
    		if (list) return list.$set({ items });
    		if (loadOptions && getItemsHasInvoked && items.length > 0) loadList();
    	}

    	function handleMultiItemClear(event) {
    		const { detail } = event;
    		const itemToRemove = selectedValue[detail ? detail.i : selectedValue.length - 1];

    		if (selectedValue.length === 1) {
    			$$invalidate(0, selectedValue = undefined);
    		} else {
    			$$invalidate(0, selectedValue = selectedValue.filter(item => {
    				return item !== itemToRemove;
    			}));
    		}

    		dispatch("clear", itemToRemove);
    		getPosition();
    	}

    	async function getPosition() {
    		await tick$1();
    		if (!target || !container) return;
    		const { top, height, width } = container.getBoundingClientRect();
    		target.style["min-width"] = `${width}px`;
    		target.style.width = `${listAutoWidth ? "auto" : "100%"}`;
    		target.style.left = "0";

    		if (listPlacement === "top") {
    			target.style.bottom = `${height + 5}px`;
    		} else {
    			target.style.top = `${height + 5}px`;
    		}

    		target = target;

    		if (listPlacement === "auto" && isOutOfViewport(target).bottom) {
    			target.style.top = ``;
    			target.style.bottom = `${height + 5}px`;
    		}

    		target.style.visibility = "";
    	}

    	function handleKeyDown(e) {
    		if (!isFocused) return;

    		switch (e.key) {
    			case "ArrowDown":
    				e.preventDefault();
    				$$invalidate(37, listOpen = true);
    				$$invalidate(25, activeSelectedValue = undefined);
    				break;
    			case "ArrowUp":
    				e.preventDefault();
    				$$invalidate(37, listOpen = true);
    				$$invalidate(25, activeSelectedValue = undefined);
    				break;
    			case "Tab":
    				if (!listOpen) $$invalidate(4, isFocused = false);
    				break;
    			case "Backspace":
    				if (!isMulti || filterText.length > 0) return;
    				if (isMulti && selectedValue && selectedValue.length > 0) {
    					handleMultiItemClear(activeSelectedValue !== undefined
    					? activeSelectedValue
    					: selectedValue.length - 1);

    					if (activeSelectedValue === 0 || activeSelectedValue === undefined) break;

    					$$invalidate(25, activeSelectedValue = selectedValue.length > activeSelectedValue
    					? activeSelectedValue - 1
    					: undefined);
    				}
    				break;
    			case "ArrowLeft":
    				if (list) list.$set({ hoverItemIndex: -1 });
    				if (!isMulti || filterText.length > 0) return;
    				if (activeSelectedValue === undefined) {
    					$$invalidate(25, activeSelectedValue = selectedValue.length - 1);
    				} else if (selectedValue.length > activeSelectedValue && activeSelectedValue !== 0) {
    					$$invalidate(25, activeSelectedValue -= 1);
    				}
    				break;
    			case "ArrowRight":
    				if (list) list.$set({ hoverItemIndex: -1 });
    				if (!isMulti || filterText.length > 0 || activeSelectedValue === undefined) return;
    				if (activeSelectedValue === selectedValue.length - 1) {
    					$$invalidate(25, activeSelectedValue = undefined);
    				} else if (activeSelectedValue < selectedValue.length - 1) {
    					$$invalidate(25, activeSelectedValue += 1);
    				}
    				break;
    		}
    	}

    	function handleFocus() {
    		$$invalidate(4, isFocused = true);
    		if (input) input.focus();
    	}

    	function removeList() {
    		resetFilter();
    		$$invalidate(25, activeSelectedValue = undefined);
    		if (!list) return;
    		list.$destroy();
    		$$invalidate(36, list = undefined);
    		if (!target) return;
    		if (target.parentNode) target.parentNode.removeChild(target);
    		target = undefined;
    		$$invalidate(36, list);
    		target = target;
    	}

    	function handleWindowClick(event) {
    		if (!container) return;

    		const eventTarget = event.path && event.path.length > 0
    		? event.path[0]
    		: event.target;

    		if (container.contains(eventTarget)) return;
    		$$invalidate(4, isFocused = false);
    		$$invalidate(37, listOpen = false);
    		$$invalidate(25, activeSelectedValue = undefined);
    		if (input) input.blur();
    	}

    	function handleClick() {
    		if (isDisabled) return;
    		$$invalidate(4, isFocused = true);
    		$$invalidate(37, listOpen = !listOpen);
    	}

    	function handleClear() {
    		$$invalidate(0, selectedValue = undefined);
    		$$invalidate(37, listOpen = false);
    		dispatch("clear", selectedValue);
    		handleFocus();
    	}

    	async function loadList() {
    		await tick$1();
    		if (target && list) return;

    		const data = {
    			Item: Item$1,
    			filterText,
    			optionIdentifier,
    			noOptionsMessage,
    			hideEmptyState,
    			isVirtualList,
    			selectedValue,
    			isMulti,
    			getGroupHeaderLabel,
    			items: filteredItems,
    			itemHeight
    		};

    		if (getOptionLabel) {
    			data.getOptionLabel = getOptionLabel;
    		}

    		target = document.createElement("div");

    		Object.assign(target.style, {
    			position: "absolute",
    			"z-index": 2,
    			visibility: "hidden"
    		});

    		$$invalidate(36, list);
    		target = target;
    		if (container) container.appendChild(target);
    		$$invalidate(36, list = new List({ target, props: data }));

    		list.$on("itemSelected", event => {
    			const { detail } = event;

    			if (detail) {
    				const item = Object.assign({}, detail);

    				if (!item.isGroupHeader || item.isSelectable) {
    					if (isMulti) {
    						$$invalidate(0, selectedValue = selectedValue ? selectedValue.concat([item]) : [item]);
    					} else {
    						$$invalidate(0, selectedValue = item);
    					}

    					resetFilter();
    					(($$invalidate(0, selectedValue), $$invalidate(48, optionIdentifier)), $$invalidate(8, isMulti));

    					setTimeout(() => {
    						$$invalidate(37, listOpen = false);
    						$$invalidate(25, activeSelectedValue = undefined);
    					});
    				}
    			}
    		});

    		list.$on("itemCreated", event => {
    			const { detail } = event;

    			if (isMulti) {
    				$$invalidate(0, selectedValue = selectedValue || []);
    				$$invalidate(0, selectedValue = [...selectedValue, createItem(detail)]);
    			} else {
    				$$invalidate(0, selectedValue = createItem(detail));
    			}

    			dispatch("itemCreated", detail);
    			$$invalidate(1, filterText = "");
    			$$invalidate(37, listOpen = false);
    			$$invalidate(25, activeSelectedValue = undefined);
    			resetFilter();
    		});

    		list.$on("closeList", () => {
    			$$invalidate(37, listOpen = false);
    		});

    		($$invalidate(36, list), target = target);
    		getPosition();
    	}

    	onMount(() => {
    		if (isFocused) input.focus();
    		if (listOpen) loadList();

    		if (items && items.length > 0) {
    			$$invalidate(60, originalItemsClone = JSON.stringify(items));
    		}
    	});

    	onDestroy(() => {
    		removeList();
    	});

    	const writable_props = [
    		"container",
    		"input",
    		"Item",
    		"Selection",
    		"MultiSelection",
    		"isMulti",
    		"multiFullItemClearable",
    		"isDisabled",
    		"isCreatable",
    		"isFocused",
    		"selectedValue",
    		"filterText",
    		"placeholder",
    		"items",
    		"itemFilter",
    		"groupBy",
    		"groupFilter",
    		"isGroupHeaderSelectable",
    		"getGroupHeaderLabel",
    		"getOptionLabel",
    		"optionIdentifier",
    		"loadOptions",
    		"hasError",
    		"containerStyles",
    		"getSelectionLabel",
    		"createGroupHeaderItem",
    		"createItem",
    		"isSearchable",
    		"inputStyles",
    		"isClearable",
    		"isWaiting",
    		"listPlacement",
    		"listOpen",
    		"list",
    		"isVirtualList",
    		"loadOptionsInterval",
    		"noOptionsMessage",
    		"hideEmptyState",
    		"filteredItems",
    		"inputAttributes",
    		"listAutoWidth",
    		"itemHeight",
    		"Icon",
    		"iconProps",
    		"showChevron",
    		"showIndicator",
    		"containerClasses",
    		"indicatorSvg",
    		"ClearIcon"
    	];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<Select> was created with unknown prop '${key}'`);
    	});

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			input = $$value;
    			$$invalidate(3, input);
    		});
    	}

    	function input_1_input_handler() {
    		filterText = this.value;
    		$$invalidate(1, filterText);
    	}

    	function input_1_binding_1($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			input = $$value;
    			$$invalidate(3, input);
    		});
    	}

    	function input_1_input_handler_1() {
    		filterText = this.value;
    		$$invalidate(1, filterText);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			container = $$value;
    			$$invalidate(2, container);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("container" in $$props) $$invalidate(2, container = $$props.container);
    		if ("input" in $$props) $$invalidate(3, input = $$props.input);
    		if ("Item" in $$props) $$invalidate(39, Item$1 = $$props.Item);
    		if ("Selection" in $$props) $$invalidate(6, Selection$1 = $$props.Selection);
    		if ("MultiSelection" in $$props) $$invalidate(7, MultiSelection$1 = $$props.MultiSelection);
    		if ("isMulti" in $$props) $$invalidate(8, isMulti = $$props.isMulti);
    		if ("multiFullItemClearable" in $$props) $$invalidate(9, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ("isDisabled" in $$props) $$invalidate(10, isDisabled = $$props.isDisabled);
    		if ("isCreatable" in $$props) $$invalidate(40, isCreatable = $$props.isCreatable);
    		if ("isFocused" in $$props) $$invalidate(4, isFocused = $$props.isFocused);
    		if ("selectedValue" in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
    		if ("filterText" in $$props) $$invalidate(1, filterText = $$props.filterText);
    		if ("placeholder" in $$props) $$invalidate(41, placeholder = $$props.placeholder);
    		if ("items" in $$props) $$invalidate(35, items = $$props.items);
    		if ("itemFilter" in $$props) $$invalidate(42, itemFilter = $$props.itemFilter);
    		if ("groupBy" in $$props) $$invalidate(43, groupBy = $$props.groupBy);
    		if ("groupFilter" in $$props) $$invalidate(44, groupFilter = $$props.groupFilter);
    		if ("isGroupHeaderSelectable" in $$props) $$invalidate(45, isGroupHeaderSelectable = $$props.isGroupHeaderSelectable);
    		if ("getGroupHeaderLabel" in $$props) $$invalidate(46, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ("getOptionLabel" in $$props) $$invalidate(47, getOptionLabel = $$props.getOptionLabel);
    		if ("optionIdentifier" in $$props) $$invalidate(48, optionIdentifier = $$props.optionIdentifier);
    		if ("loadOptions" in $$props) $$invalidate(49, loadOptions = $$props.loadOptions);
    		if ("hasError" in $$props) $$invalidate(11, hasError = $$props.hasError);
    		if ("containerStyles" in $$props) $$invalidate(12, containerStyles = $$props.containerStyles);
    		if ("getSelectionLabel" in $$props) $$invalidate(13, getSelectionLabel = $$props.getSelectionLabel);
    		if ("createGroupHeaderItem" in $$props) $$invalidate(50, createGroupHeaderItem = $$props.createGroupHeaderItem);
    		if ("createItem" in $$props) $$invalidate(51, createItem = $$props.createItem);
    		if ("isSearchable" in $$props) $$invalidate(14, isSearchable = $$props.isSearchable);
    		if ("inputStyles" in $$props) $$invalidate(15, inputStyles = $$props.inputStyles);
    		if ("isClearable" in $$props) $$invalidate(16, isClearable = $$props.isClearable);
    		if ("isWaiting" in $$props) $$invalidate(5, isWaiting = $$props.isWaiting);
    		if ("listPlacement" in $$props) $$invalidate(52, listPlacement = $$props.listPlacement);
    		if ("listOpen" in $$props) $$invalidate(37, listOpen = $$props.listOpen);
    		if ("list" in $$props) $$invalidate(36, list = $$props.list);
    		if ("isVirtualList" in $$props) $$invalidate(53, isVirtualList = $$props.isVirtualList);
    		if ("loadOptionsInterval" in $$props) $$invalidate(54, loadOptionsInterval = $$props.loadOptionsInterval);
    		if ("noOptionsMessage" in $$props) $$invalidate(55, noOptionsMessage = $$props.noOptionsMessage);
    		if ("hideEmptyState" in $$props) $$invalidate(56, hideEmptyState = $$props.hideEmptyState);
    		if ("filteredItems" in $$props) $$invalidate(38, filteredItems = $$props.filteredItems);
    		if ("inputAttributes" in $$props) $$invalidate(57, inputAttributes = $$props.inputAttributes);
    		if ("listAutoWidth" in $$props) $$invalidate(58, listAutoWidth = $$props.listAutoWidth);
    		if ("itemHeight" in $$props) $$invalidate(59, itemHeight = $$props.itemHeight);
    		if ("Icon" in $$props) $$invalidate(17, Icon = $$props.Icon);
    		if ("iconProps" in $$props) $$invalidate(18, iconProps = $$props.iconProps);
    		if ("showChevron" in $$props) $$invalidate(19, showChevron = $$props.showChevron);
    		if ("showIndicator" in $$props) $$invalidate(20, showIndicator = $$props.showIndicator);
    		if ("containerClasses" in $$props) $$invalidate(21, containerClasses = $$props.containerClasses);
    		if ("indicatorSvg" in $$props) $$invalidate(22, indicatorSvg = $$props.indicatorSvg);
    		if ("ClearIcon" in $$props) $$invalidate(23, ClearIcon$1 = $$props.ClearIcon);
    	};

    	$$self.$capture_state = () => ({
    		beforeUpdate,
    		createEventDispatcher,
    		onDestroy,
    		onMount,
    		tick: tick$1,
    		List,
    		ItemComponent: Item,
    		SelectionComponent: Selection,
    		MultiSelectionComponent: MultiSelection,
    		isOutOfViewport,
    		debounce,
    		DefaultClearIcon: ClearIcon,
    		dispatch,
    		container,
    		input,
    		Item: Item$1,
    		Selection: Selection$1,
    		MultiSelection: MultiSelection$1,
    		isMulti,
    		multiFullItemClearable,
    		isDisabled,
    		isCreatable,
    		isFocused,
    		selectedValue,
    		filterText,
    		placeholder,
    		items,
    		itemFilter,
    		groupBy,
    		groupFilter,
    		isGroupHeaderSelectable,
    		getGroupHeaderLabel,
    		getOptionLabel,
    		optionIdentifier,
    		loadOptions,
    		hasError,
    		containerStyles,
    		getSelectionLabel,
    		createGroupHeaderItem,
    		createItem,
    		isSearchable,
    		inputStyles,
    		isClearable,
    		isWaiting,
    		listPlacement,
    		listOpen,
    		list,
    		isVirtualList,
    		loadOptionsInterval,
    		noOptionsMessage,
    		hideEmptyState,
    		filteredItems,
    		inputAttributes,
    		listAutoWidth,
    		itemHeight,
    		Icon,
    		iconProps,
    		showChevron,
    		showIndicator,
    		containerClasses,
    		indicatorSvg,
    		ClearIcon: ClearIcon$1,
    		target,
    		activeSelectedValue,
    		_items,
    		originalItemsClone,
    		prev_selectedValue,
    		prev_listOpen,
    		prev_filterText,
    		prev_isFocused,
    		prev_filteredItems,
    		resetFilter,
    		getItemsHasInvoked,
    		getItems,
    		_inputAttributes,
    		checkSelectedValueForDuplicates,
    		findItem,
    		updateSelectedValueDisplay,
    		setList,
    		handleMultiItemClear,
    		getPosition,
    		handleKeyDown,
    		handleFocus,
    		removeList,
    		handleWindowClick,
    		handleClick,
    		handleClear,
    		loadList,
    		disabled,
    		showSelectedItem,
    		placeholderText
    	});

    	$$self.$inject_state = $$props => {
    		if ("container" in $$props) $$invalidate(2, container = $$props.container);
    		if ("input" in $$props) $$invalidate(3, input = $$props.input);
    		if ("Item" in $$props) $$invalidate(39, Item$1 = $$props.Item);
    		if ("Selection" in $$props) $$invalidate(6, Selection$1 = $$props.Selection);
    		if ("MultiSelection" in $$props) $$invalidate(7, MultiSelection$1 = $$props.MultiSelection);
    		if ("isMulti" in $$props) $$invalidate(8, isMulti = $$props.isMulti);
    		if ("multiFullItemClearable" in $$props) $$invalidate(9, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ("isDisabled" in $$props) $$invalidate(10, isDisabled = $$props.isDisabled);
    		if ("isCreatable" in $$props) $$invalidate(40, isCreatable = $$props.isCreatable);
    		if ("isFocused" in $$props) $$invalidate(4, isFocused = $$props.isFocused);
    		if ("selectedValue" in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
    		if ("filterText" in $$props) $$invalidate(1, filterText = $$props.filterText);
    		if ("placeholder" in $$props) $$invalidate(41, placeholder = $$props.placeholder);
    		if ("items" in $$props) $$invalidate(35, items = $$props.items);
    		if ("itemFilter" in $$props) $$invalidate(42, itemFilter = $$props.itemFilter);
    		if ("groupBy" in $$props) $$invalidate(43, groupBy = $$props.groupBy);
    		if ("groupFilter" in $$props) $$invalidate(44, groupFilter = $$props.groupFilter);
    		if ("isGroupHeaderSelectable" in $$props) $$invalidate(45, isGroupHeaderSelectable = $$props.isGroupHeaderSelectable);
    		if ("getGroupHeaderLabel" in $$props) $$invalidate(46, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ("getOptionLabel" in $$props) $$invalidate(47, getOptionLabel = $$props.getOptionLabel);
    		if ("optionIdentifier" in $$props) $$invalidate(48, optionIdentifier = $$props.optionIdentifier);
    		if ("loadOptions" in $$props) $$invalidate(49, loadOptions = $$props.loadOptions);
    		if ("hasError" in $$props) $$invalidate(11, hasError = $$props.hasError);
    		if ("containerStyles" in $$props) $$invalidate(12, containerStyles = $$props.containerStyles);
    		if ("getSelectionLabel" in $$props) $$invalidate(13, getSelectionLabel = $$props.getSelectionLabel);
    		if ("createGroupHeaderItem" in $$props) $$invalidate(50, createGroupHeaderItem = $$props.createGroupHeaderItem);
    		if ("createItem" in $$props) $$invalidate(51, createItem = $$props.createItem);
    		if ("isSearchable" in $$props) $$invalidate(14, isSearchable = $$props.isSearchable);
    		if ("inputStyles" in $$props) $$invalidate(15, inputStyles = $$props.inputStyles);
    		if ("isClearable" in $$props) $$invalidate(16, isClearable = $$props.isClearable);
    		if ("isWaiting" in $$props) $$invalidate(5, isWaiting = $$props.isWaiting);
    		if ("listPlacement" in $$props) $$invalidate(52, listPlacement = $$props.listPlacement);
    		if ("listOpen" in $$props) $$invalidate(37, listOpen = $$props.listOpen);
    		if ("list" in $$props) $$invalidate(36, list = $$props.list);
    		if ("isVirtualList" in $$props) $$invalidate(53, isVirtualList = $$props.isVirtualList);
    		if ("loadOptionsInterval" in $$props) $$invalidate(54, loadOptionsInterval = $$props.loadOptionsInterval);
    		if ("noOptionsMessage" in $$props) $$invalidate(55, noOptionsMessage = $$props.noOptionsMessage);
    		if ("hideEmptyState" in $$props) $$invalidate(56, hideEmptyState = $$props.hideEmptyState);
    		if ("filteredItems" in $$props) $$invalidate(38, filteredItems = $$props.filteredItems);
    		if ("inputAttributes" in $$props) $$invalidate(57, inputAttributes = $$props.inputAttributes);
    		if ("listAutoWidth" in $$props) $$invalidate(58, listAutoWidth = $$props.listAutoWidth);
    		if ("itemHeight" in $$props) $$invalidate(59, itemHeight = $$props.itemHeight);
    		if ("Icon" in $$props) $$invalidate(17, Icon = $$props.Icon);
    		if ("iconProps" in $$props) $$invalidate(18, iconProps = $$props.iconProps);
    		if ("showChevron" in $$props) $$invalidate(19, showChevron = $$props.showChevron);
    		if ("showIndicator" in $$props) $$invalidate(20, showIndicator = $$props.showIndicator);
    		if ("containerClasses" in $$props) $$invalidate(21, containerClasses = $$props.containerClasses);
    		if ("indicatorSvg" in $$props) $$invalidate(22, indicatorSvg = $$props.indicatorSvg);
    		if ("ClearIcon" in $$props) $$invalidate(23, ClearIcon$1 = $$props.ClearIcon);
    		if ("target" in $$props) target = $$props.target;
    		if ("activeSelectedValue" in $$props) $$invalidate(25, activeSelectedValue = $$props.activeSelectedValue);
    		if ("_items" in $$props) $$invalidate(75, _items = $$props._items);
    		if ("originalItemsClone" in $$props) $$invalidate(60, originalItemsClone = $$props.originalItemsClone);
    		if ("prev_selectedValue" in $$props) prev_selectedValue = $$props.prev_selectedValue;
    		if ("prev_listOpen" in $$props) prev_listOpen = $$props.prev_listOpen;
    		if ("prev_filterText" in $$props) prev_filterText = $$props.prev_filterText;
    		if ("prev_isFocused" in $$props) prev_isFocused = $$props.prev_isFocused;
    		if ("prev_filteredItems" in $$props) prev_filteredItems = $$props.prev_filteredItems;
    		if ("getItemsHasInvoked" in $$props) getItemsHasInvoked = $$props.getItemsHasInvoked;
    		if ("_inputAttributes" in $$props) $$invalidate(26, _inputAttributes = $$props._inputAttributes);
    		if ("disabled" in $$props) disabled = $$props.disabled;
    		if ("showSelectedItem" in $$props) $$invalidate(27, showSelectedItem = $$props.showSelectedItem);
    		if ("placeholderText" in $$props) $$invalidate(28, placeholderText = $$props.placeholderText);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*isDisabled*/ 1024) {
    			disabled = isDisabled;
    		}

    		if ($$self.$$.dirty[1] & /*items*/ 16) {
    			updateSelectedValueDisplay(items);
    		}

    		if ($$self.$$.dirty[0] & /*selectedValue, isMulti*/ 257 | $$self.$$.dirty[1] & /*optionIdentifier*/ 131072) {
    			{
    				if (typeof selectedValue === "string") {
    					$$invalidate(0, selectedValue = {
    						[optionIdentifier]: selectedValue,
    						label: selectedValue
    					});
    				} else if (isMulti && Array.isArray(selectedValue) && selectedValue.length > 0) {
    					$$invalidate(0, selectedValue = selectedValue.map(item => typeof item === "string"
    					? { value: item, label: item }
    					: item));
    				}
    			}
    		}

    		if ($$self.$$.dirty[1] & /*noOptionsMessage, list*/ 16777248) {
    			{
    				if (noOptionsMessage && list) list.$set({ noOptionsMessage });
    			}
    		}

    		if ($$self.$$.dirty[0] & /*selectedValue, filterText*/ 3) {
    			$$invalidate(27, showSelectedItem = selectedValue && filterText.length === 0);
    		}

    		if ($$self.$$.dirty[0] & /*selectedValue*/ 1 | $$self.$$.dirty[1] & /*placeholder*/ 1024) {
    			$$invalidate(28, placeholderText = selectedValue ? "" : placeholder);
    		}

    		if ($$self.$$.dirty[0] & /*isSearchable*/ 16384 | $$self.$$.dirty[1] & /*inputAttributes*/ 67108864) {
    			{
    				$$invalidate(26, _inputAttributes = Object.assign(
    					{
    						autocomplete: "off",
    						autocorrect: "off",
    						spellcheck: false
    					},
    					inputAttributes
    				));

    				if (!isSearchable) {
    					$$invalidate(26, _inputAttributes.readonly = true, _inputAttributes);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*filterText, isMulti, selectedValue*/ 259 | $$self.$$.dirty[1] & /*items, loadOptions, originalItemsClone, optionIdentifier, itemFilter, getOptionLabel, groupBy, createGroupHeaderItem, isGroupHeaderSelectable, groupFilter*/ 537884688) {
    			{
    				let _filteredItems;
    				let _items = items;

    				if (items && items.length > 0 && typeof items[0] !== "object") {
    					_items = items.map((item, index) => {
    						return { index, value: item, label: item };
    					});
    				}

    				if (loadOptions && filterText.length === 0 && originalItemsClone) {
    					_filteredItems = JSON.parse(originalItemsClone);
    					_items = JSON.parse(originalItemsClone);
    				} else {
    					_filteredItems = loadOptions
    					? filterText.length === 0 ? [] : _items
    					: _items.filter(item => {
    							let keepItem = true;

    							if (isMulti && selectedValue) {
    								keepItem = !selectedValue.some(value => {
    									return value[optionIdentifier] === item[optionIdentifier];
    								});
    							}

    							if (!keepItem) return false;
    							if (filterText.length < 1) return true;
    							return itemFilter(getOptionLabel(item, filterText), filterText, item);
    						});
    				}

    				if (groupBy) {
    					const groupValues = [];
    					const groups = {};

    					_filteredItems.forEach(item => {
    						const groupValue = groupBy(item);

    						if (!groupValues.includes(groupValue)) {
    							groupValues.push(groupValue);
    							groups[groupValue] = [];

    							if (groupValue) {
    								groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
    									id: groupValue,
    									isGroupHeader: true,
    									isSelectable: isGroupHeaderSelectable
    								}));
    							}
    						}

    						groups[groupValue].push(Object.assign({ isGroupItem: !!groupValue }, item));
    					});

    					const sortedGroupedItems = [];

    					groupFilter(groupValues).forEach(groupValue => {
    						sortedGroupedItems.push(...groups[groupValue]);
    					});

    					$$invalidate(38, filteredItems = sortedGroupedItems);
    				} else {
    					$$invalidate(38, filteredItems = _filteredItems);
    				}
    			}
    		}
    	};

    	return [
    		selectedValue,
    		filterText,
    		container,
    		input,
    		isFocused,
    		isWaiting,
    		Selection$1,
    		MultiSelection$1,
    		isMulti,
    		multiFullItemClearable,
    		isDisabled,
    		hasError,
    		containerStyles,
    		getSelectionLabel,
    		isSearchable,
    		inputStyles,
    		isClearable,
    		Icon,
    		iconProps,
    		showChevron,
    		showIndicator,
    		containerClasses,
    		indicatorSvg,
    		ClearIcon$1,
    		handleClear,
    		activeSelectedValue,
    		_inputAttributes,
    		showSelectedItem,
    		placeholderText,
    		handleMultiItemClear,
    		getPosition,
    		handleKeyDown,
    		handleFocus,
    		handleWindowClick,
    		handleClick,
    		items,
    		list,
    		listOpen,
    		filteredItems,
    		Item$1,
    		isCreatable,
    		placeholder,
    		itemFilter,
    		groupBy,
    		groupFilter,
    		isGroupHeaderSelectable,
    		getGroupHeaderLabel,
    		getOptionLabel,
    		optionIdentifier,
    		loadOptions,
    		createGroupHeaderItem,
    		createItem,
    		listPlacement,
    		isVirtualList,
    		loadOptionsInterval,
    		noOptionsMessage,
    		hideEmptyState,
    		inputAttributes,
    		listAutoWidth,
    		itemHeight,
    		originalItemsClone,
    		input_1_binding,
    		input_1_input_handler,
    		input_1_binding_1,
    		input_1_input_handler_1,
    		div_binding
    	];
    }

    class Select extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$n,
    			create_fragment$n,
    			safe_not_equal,
    			{
    				container: 2,
    				input: 3,
    				Item: 39,
    				Selection: 6,
    				MultiSelection: 7,
    				isMulti: 8,
    				multiFullItemClearable: 9,
    				isDisabled: 10,
    				isCreatable: 40,
    				isFocused: 4,
    				selectedValue: 0,
    				filterText: 1,
    				placeholder: 41,
    				items: 35,
    				itemFilter: 42,
    				groupBy: 43,
    				groupFilter: 44,
    				isGroupHeaderSelectable: 45,
    				getGroupHeaderLabel: 46,
    				getOptionLabel: 47,
    				optionIdentifier: 48,
    				loadOptions: 49,
    				hasError: 11,
    				containerStyles: 12,
    				getSelectionLabel: 13,
    				createGroupHeaderItem: 50,
    				createItem: 51,
    				isSearchable: 14,
    				inputStyles: 15,
    				isClearable: 16,
    				isWaiting: 5,
    				listPlacement: 52,
    				listOpen: 37,
    				list: 36,
    				isVirtualList: 53,
    				loadOptionsInterval: 54,
    				noOptionsMessage: 55,
    				hideEmptyState: 56,
    				filteredItems: 38,
    				inputAttributes: 57,
    				listAutoWidth: 58,
    				itemHeight: 59,
    				Icon: 17,
    				iconProps: 18,
    				showChevron: 19,
    				showIndicator: 20,
    				containerClasses: 21,
    				indicatorSvg: 22,
    				ClearIcon: 23,
    				handleClear: 24
    			},
    			[-1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get container() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set container(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Item() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Item(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Selection() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Selection(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get MultiSelection() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set MultiSelection(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isMulti() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isMulti(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiFullItemClearable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiFullItemClearable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isDisabled() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isDisabled(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isCreatable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isCreatable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isFocused() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isFocused(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedValue() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedValue(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterText() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterText(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get items() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemFilter() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemFilter(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupBy() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupBy(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupFilter() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupFilter(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isGroupHeaderSelectable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isGroupHeaderSelectable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getGroupHeaderLabel() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getGroupHeaderLabel(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getOptionLabel() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getOptionLabel(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get optionIdentifier() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set optionIdentifier(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loadOptions() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loadOptions(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hasError() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hasError(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get containerStyles() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set containerStyles(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getSelectionLabel() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getSelectionLabel(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get createGroupHeaderItem() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set createGroupHeaderItem(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get createItem() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set createItem(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isSearchable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isSearchable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputStyles() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputStyles(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isClearable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isClearable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isWaiting() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isWaiting(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listPlacement() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listPlacement(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listOpen() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listOpen(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get list() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set list(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isVirtualList() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isVirtualList(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loadOptionsInterval() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loadOptionsInterval(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noOptionsMessage() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noOptionsMessage(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideEmptyState() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideEmptyState(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filteredItems() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filteredItems(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputAttributes() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputAttributes(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listAutoWidth() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listAutoWidth(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemHeight() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemHeight(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Icon() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Icon(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconProps() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconProps(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showChevron() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showChevron(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showIndicator() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showIndicator(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get containerClasses() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set containerClasses(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicatorSvg() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicatorSvg(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ClearIcon() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ClearIcon(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get handleClear() {
    		return this.$$.ctx[24];
    	}

    	set handleClear(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var build = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.default = void 0;

    /**
     * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     *
     */
    // This diff-sequences package implements the linear space variation in
    // An O(ND) Difference Algorithm and Its Variations by Eugene W. Myers
    // Relationship in notation between Myers paper and this package:
    // A is a
    // N is aLength, aEnd - aStart, and so on
    // x is aIndex, aFirst, aLast, and so on
    // B is b
    // M is bLength, bEnd - bStart, and so on
    // y is bIndex, bFirst, bLast, and so on
    // Δ = N - M is negative of baDeltaLength = bLength - aLength
    // D is d
    // k is kF
    // k + Δ is kF = kR - baDeltaLength
    // V is aIndexesF or aIndexesR (see comment below about Indexes type)
    // index intervals [1, N] and [1, M] are [0, aLength) and [0, bLength)
    // starting point in forward direction (0, 0) is (-1, -1)
    // starting point in reverse direction (N + 1, M + 1) is (aLength, bLength)
    // The “edit graph” for sequences a and b corresponds to items:
    // in a on the horizontal axis
    // in b on the vertical axis
    //
    // Given a-coordinate of a point in a diagonal, you can compute b-coordinate.
    //
    // Forward diagonals kF:
    // zero diagonal intersects top left corner
    // positive diagonals intersect top edge
    // negative diagonals insersect left edge
    //
    // Reverse diagonals kR:
    // zero diagonal intersects bottom right corner
    // positive diagonals intersect right edge
    // negative diagonals intersect bottom edge
    // The graph contains a directed acyclic graph of edges:
    // horizontal: delete an item from a
    // vertical: insert an item from b
    // diagonal: common item in a and b
    //
    // The algorithm solves dual problems in the graph analogy:
    // Find longest common subsequence: path with maximum number of diagonal edges
    // Find shortest edit script: path with minimum number of non-diagonal edges
    // Input callback function compares items at indexes in the sequences.
    // Output callback function receives the number of adjacent items
    // and starting indexes of each common subsequence.
    // Either original functions or wrapped to swap indexes if graph is transposed.
    // Indexes in sequence a of last point of forward or reverse paths in graph.
    // Myers algorithm indexes by diagonal k which for negative is bad deopt in V8.
    // This package indexes by iF and iR which are greater than or equal to zero.
    // and also updates the index arrays in place to cut memory in half.
    // kF = 2 * iF - d
    // kR = d - 2 * iR
    // Division of index intervals in sequences a and b at the middle change.
    // Invariant: intervals do not have common items at the start or end.
    const pkg = 'diff-sequences'; // for error messages

    const NOT_YET_SET = 0; // small int instead of undefined to avoid deopt in V8
    // Return the number of common items that follow in forward direction.
    // The length of what Myers paper calls a “snake” in a forward path.

    const countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon) => {
      let nCommon = 0;

      while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {
        aIndex += 1;
        bIndex += 1;
        nCommon += 1;
      }

      return nCommon;
    }; // Return the number of common items that precede in reverse direction.
    // The length of what Myers paper calls a “snake” in a reverse path.

    const countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon) => {
      let nCommon = 0;

      while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {
        aIndex -= 1;
        bIndex -= 1;
        nCommon += 1;
      }

      return nCommon;
    }; // A simple function to extend forward paths from (d - 1) to d changes
    // when forward and reverse paths cannot yet overlap.

    const extendPathsF = (d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {
      // Unroll the first iteration.
      let iF = 0;
      let kF = -d; // kF = 2 * iF - d

      let aFirst = aIndexesF[iF]; // in first iteration always insert

      let aIndexPrev1 = aFirst; // prev value of [iF - 1] in next iteration

      aIndexesF[iF] += countCommonItemsF(
        aFirst + 1,
        aEnd,
        bF + aFirst - kF + 1,
        bEnd,
        isCommon
      ); // Optimization: skip diagonals in which paths cannot ever overlap.

      const nF = d < iMaxF ? d : iMaxF; // The diagonals kF are odd when d is odd and even when d is even.

      for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {
        // To get first point of path segment, move one change in forward direction
        // from last point of previous path segment in an adjacent diagonal.
        // In last possible iteration when iF === d and kF === d always delete.
        if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {
          aFirst = aIndexesF[iF]; // vertical to insert from b
        } else {
          aFirst = aIndexPrev1 + 1; // horizontal to delete from a

          if (aEnd <= aFirst) {
            // Optimization: delete moved past right of graph.
            return iF - 1;
          }
        } // To get last point of path segment, move along diagonal of common items.

        aIndexPrev1 = aIndexesF[iF];
        aIndexesF[iF] =
          aFirst +
          countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
      }

      return iMaxF;
    }; // A simple function to extend reverse paths from (d - 1) to d changes
    // when reverse and forward paths cannot yet overlap.

    const extendPathsR = (d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {
      // Unroll the first iteration.
      let iR = 0;
      let kR = d; // kR = d - 2 * iR

      let aFirst = aIndexesR[iR]; // in first iteration always insert

      let aIndexPrev1 = aFirst; // prev value of [iR - 1] in next iteration

      aIndexesR[iR] -= countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bR + aFirst - kR - 1,
        isCommon
      ); // Optimization: skip diagonals in which paths cannot ever overlap.

      const nR = d < iMaxR ? d : iMaxR; // The diagonals kR are odd when d is odd and even when d is even.

      for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {
        // To get first point of path segment, move one change in reverse direction
        // from last point of previous path segment in an adjacent diagonal.
        // In last possible iteration when iR === d and kR === -d always delete.
        if (iR !== d && aIndexesR[iR] < aIndexPrev1) {
          aFirst = aIndexesR[iR]; // vertical to insert from b
        } else {
          aFirst = aIndexPrev1 - 1; // horizontal to delete from a

          if (aFirst < aStart) {
            // Optimization: delete moved past left of graph.
            return iR - 1;
          }
        } // To get last point of path segment, move along diagonal of common items.

        aIndexPrev1 = aIndexesR[iR];
        aIndexesR[iR] =
          aFirst -
          countCommonItemsR(
            aStart,
            aFirst - 1,
            bStart,
            bR + aFirst - kR - 1,
            isCommon
          );
      }

      return iMaxR;
    }; // A complete function to extend forward paths from (d - 1) to d changes.
    // Return true if a path overlaps reverse path of (d - 1) changes in its diagonal.

    const extendOverlappablePathsF = (
      d,
      aStart,
      aEnd,
      bStart,
      bEnd,
      isCommon,
      aIndexesF,
      iMaxF,
      aIndexesR,
      iMaxR,
      division
    ) => {
      const bF = bStart - aStart; // bIndex = bF + aIndex - kF

      const aLength = aEnd - aStart;
      const bLength = bEnd - bStart;
      const baDeltaLength = bLength - aLength; // kF = kR - baDeltaLength
      // Range of diagonals in which forward and reverse paths might overlap.

      const kMinOverlapF = -baDeltaLength - (d - 1); // -(d - 1) <= kR

      const kMaxOverlapF = -baDeltaLength + (d - 1); // kR <= (d - 1)

      let aIndexPrev1 = NOT_YET_SET; // prev value of [iF - 1] in next iteration
      // Optimization: skip diagonals in which paths cannot ever overlap.

      const nF = d < iMaxF ? d : iMaxF; // The diagonals kF = 2 * iF - d are odd when d is odd and even when d is even.

      for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {
        // To get first point of path segment, move one change in forward direction
        // from last point of previous path segment in an adjacent diagonal.
        // In first iteration when iF === 0 and kF === -d always insert.
        // In last possible iteration when iF === d and kF === d always delete.
        const insert = iF === 0 || (iF !== d && aIndexPrev1 < aIndexesF[iF]);
        const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;
        const aFirst = insert
          ? aLastPrev // vertical to insert from b
          : aLastPrev + 1; // horizontal to delete from a
        // To get last point of path segment, move along diagonal of common items.

        const bFirst = bF + aFirst - kF;
        const nCommonF = countCommonItemsF(
          aFirst + 1,
          aEnd,
          bFirst + 1,
          bEnd,
          isCommon
        );
        const aLast = aFirst + nCommonF;
        aIndexPrev1 = aIndexesF[iF];
        aIndexesF[iF] = aLast;

        if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {
          // Solve for iR of reverse path with (d - 1) changes in diagonal kF:
          // kR = kF + baDeltaLength
          // kR = (d - 1) - 2 * iR
          const iR = (d - 1 - (kF + baDeltaLength)) / 2; // If this forward path overlaps the reverse path in this diagonal,
          // then this is the middle change of the index intervals.

          if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
            // Unlike the Myers algorithm which finds only the middle “snake”
            // this package can find two common subsequences per division.
            // Last point of previous path segment is on an adjacent diagonal.
            const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1); // Because of invariant that intervals preceding the middle change
            // cannot have common items at the end,
            // move in reverse direction along a diagonal of common items.

            const nCommonR = countCommonItemsR(
              aStart,
              aLastPrev,
              bStart,
              bLastPrev,
              isCommon
            );
            const aIndexPrevFirst = aLastPrev - nCommonR;
            const bIndexPrevFirst = bLastPrev - nCommonR;
            const aEndPreceding = aIndexPrevFirst + 1;
            const bEndPreceding = bIndexPrevFirst + 1;
            division.nChangePreceding = d - 1;

            if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {
              // Optimization: number of preceding changes in forward direction
              // is equal to number of items in preceding interval,
              // therefore it cannot contain any common items.
              division.aEndPreceding = aStart;
              division.bEndPreceding = bStart;
            } else {
              division.aEndPreceding = aEndPreceding;
              division.bEndPreceding = bEndPreceding;
            }

            division.nCommonPreceding = nCommonR;

            if (nCommonR !== 0) {
              division.aCommonPreceding = aEndPreceding;
              division.bCommonPreceding = bEndPreceding;
            }

            division.nCommonFollowing = nCommonF;

            if (nCommonF !== 0) {
              division.aCommonFollowing = aFirst + 1;
              division.bCommonFollowing = bFirst + 1;
            }

            const aStartFollowing = aLast + 1;
            const bStartFollowing = bFirst + nCommonF + 1;
            division.nChangeFollowing = d - 1;

            if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
              // Optimization: number of changes in reverse direction
              // is equal to number of items in following interval,
              // therefore it cannot contain any common items.
              division.aStartFollowing = aEnd;
              division.bStartFollowing = bEnd;
            } else {
              division.aStartFollowing = aStartFollowing;
              division.bStartFollowing = bStartFollowing;
            }

            return true;
          }
        }
      }

      return false;
    }; // A complete function to extend reverse paths from (d - 1) to d changes.
    // Return true if a path overlaps forward path of d changes in its diagonal.

    const extendOverlappablePathsR = (
      d,
      aStart,
      aEnd,
      bStart,
      bEnd,
      isCommon,
      aIndexesF,
      iMaxF,
      aIndexesR,
      iMaxR,
      division
    ) => {
      const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR

      const aLength = aEnd - aStart;
      const bLength = bEnd - bStart;
      const baDeltaLength = bLength - aLength; // kR = kF + baDeltaLength
      // Range of diagonals in which forward and reverse paths might overlap.

      const kMinOverlapR = baDeltaLength - d; // -d <= kF

      const kMaxOverlapR = baDeltaLength + d; // kF <= d

      let aIndexPrev1 = NOT_YET_SET; // prev value of [iR - 1] in next iteration
      // Optimization: skip diagonals in which paths cannot ever overlap.

      const nR = d < iMaxR ? d : iMaxR; // The diagonals kR = d - 2 * iR are odd when d is odd and even when d is even.

      for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {
        // To get first point of path segment, move one change in reverse direction
        // from last point of previous path segment in an adjacent diagonal.
        // In first iteration when iR === 0 and kR === d always insert.
        // In last possible iteration when iR === d and kR === -d always delete.
        const insert = iR === 0 || (iR !== d && aIndexesR[iR] < aIndexPrev1);
        const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;
        const aFirst = insert
          ? aLastPrev // vertical to insert from b
          : aLastPrev - 1; // horizontal to delete from a
        // To get last point of path segment, move along diagonal of common items.

        const bFirst = bR + aFirst - kR;
        const nCommonR = countCommonItemsR(
          aStart,
          aFirst - 1,
          bStart,
          bFirst - 1,
          isCommon
        );
        const aLast = aFirst - nCommonR;
        aIndexPrev1 = aIndexesR[iR];
        aIndexesR[iR] = aLast;

        if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {
          // Solve for iF of forward path with d changes in diagonal kR:
          // kF = kR - baDeltaLength
          // kF = 2 * iF - d
          const iF = (d + (kR - baDeltaLength)) / 2; // If this reverse path overlaps the forward path in this diagonal,
          // then this is a middle change of the index intervals.

          if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
            const bLast = bFirst - nCommonR;
            division.nChangePreceding = d;

            if (d === aLast + bLast - aStart - bStart) {
              // Optimization: number of changes in reverse direction
              // is equal to number of items in preceding interval,
              // therefore it cannot contain any common items.
              division.aEndPreceding = aStart;
              division.bEndPreceding = bStart;
            } else {
              division.aEndPreceding = aLast;
              division.bEndPreceding = bLast;
            }

            division.nCommonPreceding = nCommonR;

            if (nCommonR !== 0) {
              // The last point of reverse path segment is start of common subsequence.
              division.aCommonPreceding = aLast;
              division.bCommonPreceding = bLast;
            }

            division.nChangeFollowing = d - 1;

            if (d === 1) {
              // There is no previous path segment.
              division.nCommonFollowing = 0;
              division.aStartFollowing = aEnd;
              division.bStartFollowing = bEnd;
            } else {
              // Unlike the Myers algorithm which finds only the middle “snake”
              // this package can find two common subsequences per division.
              // Last point of previous path segment is on an adjacent diagonal.
              const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1); // Because of invariant that intervals following the middle change
              // cannot have common items at the start,
              // move in forward direction along a diagonal of common items.

              const nCommonF = countCommonItemsF(
                aLastPrev,
                aEnd,
                bLastPrev,
                bEnd,
                isCommon
              );
              division.nCommonFollowing = nCommonF;

              if (nCommonF !== 0) {
                // The last point of reverse path segment is start of common subsequence.
                division.aCommonFollowing = aLastPrev;
                division.bCommonFollowing = bLastPrev;
              }

              const aStartFollowing = aLastPrev + nCommonF; // aFirstPrev

              const bStartFollowing = bLastPrev + nCommonF; // bFirstPrev

              if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
                // Optimization: number of changes in forward direction
                // is equal to number of items in following interval,
                // therefore it cannot contain any common items.
                division.aStartFollowing = aEnd;
                division.bStartFollowing = bEnd;
              } else {
                division.aStartFollowing = aStartFollowing;
                division.bStartFollowing = bStartFollowing;
              }
            }

            return true;
          }
        }
      }

      return false;
    }; // Given index intervals and input function to compare items at indexes,
    // divide at the middle change.
    //
    // DO NOT CALL if start === end, because interval cannot contain common items
    // and because this function will throw the “no overlap” error.

    const divide = (
      nChange,
      aStart,
      aEnd,
      bStart,
      bEnd,
      isCommon,
      aIndexesF,
      aIndexesR,
      division // output
    ) => {
      const bF = bStart - aStart; // bIndex = bF + aIndex - kF

      const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR

      const aLength = aEnd - aStart;
      const bLength = bEnd - bStart; // Because graph has square or portrait orientation,
      // length difference is minimum number of items to insert from b.
      // Corresponding forward and reverse diagonals in graph
      // depend on length difference of the sequences:
      // kF = kR - baDeltaLength
      // kR = kF + baDeltaLength

      const baDeltaLength = bLength - aLength; // Optimization: max diagonal in graph intersects corner of shorter side.

      let iMaxF = aLength;
      let iMaxR = aLength; // Initialize no changes yet in forward or reverse direction:

      aIndexesF[0] = aStart - 1; // at open start of interval, outside closed start

      aIndexesR[0] = aEnd; // at open end of interval

      if (baDeltaLength % 2 === 0) {
        // The number of changes in paths is 2 * d if length difference is even.
        const dMin = (nChange || baDeltaLength) / 2;
        const dMax = (aLength + bLength) / 2;

        for (let d = 1; d <= dMax; d += 1) {
          iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);

          if (d < dMin) {
            iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
          } else if (
            // If a reverse path overlaps a forward path in the same diagonal,
            // return a division of the index intervals at the middle change.
            extendOverlappablePathsR(
              d,
              aStart,
              aEnd,
              bStart,
              bEnd,
              isCommon,
              aIndexesF,
              iMaxF,
              aIndexesR,
              iMaxR,
              division
            )
          ) {
            return;
          }
        }
      } else {
        // The number of changes in paths is 2 * d - 1 if length difference is odd.
        const dMin = ((nChange || baDeltaLength) + 1) / 2;
        const dMax = (aLength + bLength + 1) / 2; // Unroll first half iteration so loop extends the relevant pairs of paths.
        // Because of invariant that intervals have no common items at start or end,
        // and limitation not to call divide with empty intervals,
        // therefore it cannot be called if a forward path with one change
        // would overlap a reverse path with no changes, even if dMin === 1.

        let d = 1;
        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);

        for (d += 1; d <= dMax; d += 1) {
          iMaxR = extendPathsR(
            d - 1,
            aStart,
            bStart,
            bR,
            isCommon,
            aIndexesR,
            iMaxR
          );

          if (d < dMin) {
            iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
          } else if (
            // If a forward path overlaps a reverse path in the same diagonal,
            // return a division of the index intervals at the middle change.
            extendOverlappablePathsF(
              d,
              aStart,
              aEnd,
              bStart,
              bEnd,
              isCommon,
              aIndexesF,
              iMaxF,
              aIndexesR,
              iMaxR,
              division
            )
          ) {
            return;
          }
        }
      }
      /* istanbul ignore next */

      throw new Error(
        `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`
      );
    }; // Given index intervals and input function to compare items at indexes,
    // return by output function the number of adjacent items and starting indexes
    // of each common subsequence. Divide and conquer with only linear space.
    //
    // The index intervals are half open [start, end) like array slice method.
    // DO NOT CALL if start === end, because interval cannot contain common items
    // and because divide function will throw the “no overlap” error.

    const findSubsequences = (
      nChange,
      aStart,
      aEnd,
      bStart,
      bEnd,
      transposed,
      callbacks,
      aIndexesF,
      aIndexesR,
      division // temporary memory, not input nor output
    ) => {
      if (bEnd - bStart < aEnd - aStart) {
        // Transpose graph so it has portrait instead of landscape orientation.
        // Always compare shorter to longer sequence for consistency and optimization.
        transposed = !transposed;

        if (transposed && callbacks.length === 1) {
          // Lazily wrap callback functions to swap args if graph is transposed.
          const {foundSubsequence, isCommon} = callbacks[0];
          callbacks[1] = {
            foundSubsequence: (nCommon, bCommon, aCommon) => {
              foundSubsequence(nCommon, aCommon, bCommon);
            },
            isCommon: (bIndex, aIndex) => isCommon(aIndex, bIndex)
          };
        }

        const tStart = aStart;
        const tEnd = aEnd;
        aStart = bStart;
        aEnd = bEnd;
        bStart = tStart;
        bEnd = tEnd;
      }

      const {foundSubsequence, isCommon} = callbacks[transposed ? 1 : 0]; // Divide the index intervals at the middle change.

      divide(
        nChange,
        aStart,
        aEnd,
        bStart,
        bEnd,
        isCommon,
        aIndexesF,
        aIndexesR,
        division
      );
      const {
        nChangePreceding,
        aEndPreceding,
        bEndPreceding,
        nCommonPreceding,
        aCommonPreceding,
        bCommonPreceding,
        nCommonFollowing,
        aCommonFollowing,
        bCommonFollowing,
        nChangeFollowing,
        aStartFollowing,
        bStartFollowing
      } = division; // Unless either index interval is empty, they might contain common items.

      if (aStart < aEndPreceding && bStart < bEndPreceding) {
        // Recursely find and return common subsequences preceding the division.
        findSubsequences(
          nChangePreceding,
          aStart,
          aEndPreceding,
          bStart,
          bEndPreceding,
          transposed,
          callbacks,
          aIndexesF,
          aIndexesR,
          division
        );
      } // Return common subsequences that are adjacent to the middle change.

      if (nCommonPreceding !== 0) {
        foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);
      }

      if (nCommonFollowing !== 0) {
        foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);
      } // Unless either index interval is empty, they might contain common items.

      if (aStartFollowing < aEnd && bStartFollowing < bEnd) {
        // Recursely find and return common subsequences following the division.
        findSubsequences(
          nChangeFollowing,
          aStartFollowing,
          aEnd,
          bStartFollowing,
          bEnd,
          transposed,
          callbacks,
          aIndexesF,
          aIndexesR,
          division
        );
      }
    };

    const validateLength = (name, arg) => {
      if (typeof arg !== 'number') {
        throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);
      }

      if (!Number.isSafeInteger(arg)) {
        throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);
      }

      if (arg < 0) {
        throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);
      }
    };

    const validateCallback = (name, arg) => {
      const type = typeof arg;

      if (type !== 'function') {
        throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);
      }
    }; // Compare items in two sequences to find a longest common subsequence.
    // Given lengths of sequences and input function to compare items at indexes,
    // return by output function the number of adjacent items and starting indexes
    // of each common subsequence.

    var _default = (aLength, bLength, isCommon, foundSubsequence) => {
      validateLength('aLength', aLength);
      validateLength('bLength', bLength);
      validateCallback('isCommon', isCommon);
      validateCallback('foundSubsequence', foundSubsequence); // Count common items from the start in the forward direction.

      const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);

      if (nCommonF !== 0) {
        foundSubsequence(nCommonF, 0, 0);
      } // Unless both sequences consist of common items only,
      // find common items in the half-trimmed index intervals.

      if (aLength !== nCommonF || bLength !== nCommonF) {
        // Invariant: intervals do not have common items at the start.
        // The start of an index interval is closed like array slice method.
        const aStart = nCommonF;
        const bStart = nCommonF; // Count common items from the end in the reverse direction.

        const nCommonR = countCommonItemsR(
          aStart,
          aLength - 1,
          bStart,
          bLength - 1,
          isCommon
        ); // Invariant: intervals do not have common items at the end.
        // The end of an index interval is open like array slice method.

        const aEnd = aLength - nCommonR;
        const bEnd = bLength - nCommonR; // Unless one sequence consists of common items only,
        // therefore the other trimmed index interval consists of changes only,
        // find common items in the trimmed index intervals.

        const nCommonFR = nCommonF + nCommonR;

        if (aLength !== nCommonFR && bLength !== nCommonFR) {
          const nChange = 0; // number of change items is not yet known

          const transposed = false; // call the original unwrapped functions

          const callbacks = [
            {
              foundSubsequence,
              isCommon
            }
          ]; // Indexes in sequence a of last points in furthest reaching paths
          // from outside the start at top left in the forward direction:

          const aIndexesF = [NOT_YET_SET]; // from the end at bottom right in the reverse direction:

          const aIndexesR = [NOT_YET_SET]; // Initialize one object as output of all calls to divide function.

          const division = {
            aCommonFollowing: NOT_YET_SET,
            aCommonPreceding: NOT_YET_SET,
            aEndPreceding: NOT_YET_SET,
            aStartFollowing: NOT_YET_SET,
            bCommonFollowing: NOT_YET_SET,
            bCommonPreceding: NOT_YET_SET,
            bEndPreceding: NOT_YET_SET,
            bStartFollowing: NOT_YET_SET,
            nChangeFollowing: NOT_YET_SET,
            nChangePreceding: NOT_YET_SET,
            nCommonFollowing: NOT_YET_SET,
            nCommonPreceding: NOT_YET_SET
          }; // Find and return common subsequences in the trimmed index intervals.

          findSubsequences(
            nChange,
            aStart,
            aEnd,
            bStart,
            bEnd,
            transposed,
            callbacks,
            aIndexesF,
            aIndexesR,
            division
          );
        }

        if (nCommonR !== 0) {
          foundSubsequence(nCommonR, aEnd, bEnd);
        }
      }
    };

    exports.default = _default;
    });

    var diffSequencesExport = /*@__PURE__*/getDefaultExportFromCjs(build);

    var naturalCompareLite = createCommonjsModule(function (module) {
    /*
     * @version    1.4.0
     * @date       2015-10-26
     * @stability  3 - Stable
     * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
     * @license    MIT License
     */


    var naturalCompare = function(a, b) {
    	var i, codeA
    	, codeB = 1
    	, posA = 0
    	, posB = 0
    	, alphabet = String.alphabet;

    	function getCode(str, pos, code) {
    		if (code) {
    			for (i = pos; code = getCode(str, i), code < 76 && code > 65;) ++i;
    			return +str.slice(pos - 1, i)
    		}
    		code = alphabet && alphabet.indexOf(str.charAt(pos));
    		return code > -1 ? code + 76 : ((code = str.charCodeAt(pos) || 0), code < 45 || code > 127) ? code
    			: code < 46 ? 65               // -
    			: code < 48 ? code - 1
    			: code < 58 ? code + 18        // 0-9
    			: code < 65 ? code - 11
    			: code < 91 ? code + 11        // A-Z
    			: code < 97 ? code - 37
    			: code < 123 ? code + 5        // a-z
    			: code - 63
    	}


    	if ((a+="") != (b+="")) for (;codeB;) {
    		codeA = getCode(a, posA++);
    		codeB = getCode(b, posB++);

    		if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
    			codeA = getCode(a, posA, posA);
    			codeB = getCode(b, posB, posA = i);
    			posB = i;
    		}

    		if (codeA != codeB) return (codeA < codeB) ? -1 : 1
    	}
    	return 0
    };

    try {
    	module.exports = naturalCompare;
    } catch (e) {
    	String.naturalCompare = naturalCompare;
    }
    });

    diffSequencesExport.default || diffSequencesExport;

    function caseInsensitiveNaturalCompare (a, b) {
      const aLower = typeof a === 'string' ? a.toLowerCase() : a;
      const bLower = typeof b === 'string' ? b.toLowerCase() : b;

      return naturalCompareLite(aLower, bLower)
    }

    /**
     * Sort the keys of an object
     * @param {JSON} json             The the JSON containg the (optionally nested)
     *                                object to be sorted
     * @param {Path} [rootPath=[]]    Relative path when the array was located
     * @param {1 | -1} [direction=1]  Pass 1 to sort ascending, -1 to sort descending
     * @return {JSONPatchDocument}    Returns a JSONPatch document with move operation
     *                                to get the array sorted.
     */
    function sortObjectKeys (json, rootPath = [], direction = 1) {
      const object = immutableJSONPatch.getIn(json, rootPath);
      const keys = Object.keys(object);
      const sortedKeys = keys.slice();

      sortedKeys.sort((keyA, keyB) => {
        return direction * caseInsensitiveNaturalCompare(keyA, keyB)
      });

      // TODO: can we make this more efficient? check if the first couple of keys are already in order and if so ignore them
      const operations = [];
      for (let i = 0; i < sortedKeys.length; i++) {
        const key = sortedKeys[i];
        const path = immutableJSONPatch.compileJSONPointer(rootPath.concat(key));
        operations.push({
          op: 'move',
          from: path,
          path
        });
      }

      return operations
    }

    /**
     * Sort the items of an array
     * @param {JSON} json                The document containing (optionally nested)
     *                                  the array to be sorted.
     * @param {Path} [rootPath=[]]      Relative path when the array was located
     * @param {Path} [propertyPath=[]]  Nested path to the property on which to sort the contents
     * @param {1 | -1} [direction=1]    Pass 1 to sort ascending, -1 to sort descending
     * @return {JSONPatchDocument}      Returns a JSONPatch document with move operation
     *                                  to get the array sorted.
     */
    function sortArray (json, rootPath = [], propertyPath = [], direction = 1) {
      const comparator = createObjectComparator(propertyPath, direction);

      // TODO: make the mechanism to sort configurable? Like use sortOperationsMove and sortOperationsMoveAdvanced
      const array = immutableJSONPatch.getIn(json, rootPath);
      return [
        {
          op: 'replace',
          path: immutableJSONPatch.compileJSONPointer(rootPath),
          value: array.slice(0).sort(comparator)
        }
      ]
    }

    /**
     * Create a comparator function to compare nested properties in an array
     * @param {Path} propertyPath
     * @param {1 | -1} direction
     */
    function createObjectComparator (propertyPath, direction) {
      return function comparator (a, b) {
        const valueA = immutableJSONPatch.getIn(a, propertyPath);
        const valueB = immutableJSONPatch.getIn(b, propertyPath);

        if (valueA === undefined) {
          return direction
        }
        if (valueB === undefined) {
          return -direction
        }

        if (typeof valueA !== 'string' && typeof valueB !== 'string') {
          // both values are a number, boolean, or null -> use simple, fast sorting
          return valueA > valueB
            ? direction
            : valueA < valueB
              ? -direction
              : 0
        }

        return direction * caseInsensitiveNaturalCompare(valueA, valueB)
      }
    }

    const sortModalState = {};

    /* node_modules\svelte-jsoneditor\src\components\modals\SortModal.svelte generated by Svelte v3.38.2 */

    const { console: console_1$4 } = globals;
    const file$k = "node_modules\\svelte-jsoneditor\\src\\components\\modals\\SortModal.svelte";

    // (114:8) {#if jsonIsArray && (properties.length > 1 || selectedProperty === undefined) }
    function create_if_block$a(ctx) {
    	let tr;
    	let th;
    	let t1;
    	let td;
    	let select;
    	let updating_selectedValue;
    	let current;

    	function select_selectedValue_binding(value) {
    		/*select_selectedValue_binding*/ ctx[11](value);
    	}

    	let select_props = { items: /*properties*/ ctx[3] };

    	if (/*selectedProperty*/ ctx[1] !== void 0) {
    		select_props.selectedValue = /*selectedProperty*/ ctx[1];
    	}

    	select = new Select({ props: select_props, $$inline: true });
    	binding_callbacks.push(() => bind$2(select, "selectedValue", select_selectedValue_binding));

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			th = element("th");
    			th.textContent = "Property";
    			t1 = space();
    			td = element("td");
    			create_component(select.$$.fragment);
    			attr_dev(th, "class", "svelte-w5wcb3");
    			add_location(th, file$k, 115, 12, 3274);
    			attr_dev(td, "class", "svelte-w5wcb3");
    			add_location(td, file$k, 116, 12, 3304);
    			add_location(tr, file$k, 114, 10, 3257);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, th);
    			append_dev(tr, t1);
    			append_dev(tr, td);
    			mount_component(select, td, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const select_changes = {};
    			if (dirty & /*properties*/ 8) select_changes.items = /*properties*/ ctx[3];

    			if (!updating_selectedValue && dirty & /*selectedProperty*/ 2) {
    				updating_selectedValue = true;
    				select_changes.selectedValue = /*selectedProperty*/ ctx[1];
    				add_flush_callback(() => updating_selectedValue = false);
    			}

    			select.$set(select_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(select.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(select.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_component(select);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(114:8) {#if jsonIsArray && (properties.length > 1 || selectedProperty === undefined) }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let div2;
    	let header;
    	let t0;
    	let div1;
    	let table;
    	let colgroup;
    	let col0;
    	let t1;
    	let col1;
    	let t2;
    	let tbody;
    	let tr0;
    	let th0;
    	let t4;
    	let td0;
    	let input;
    	let input_value_value;
    	let t5;
    	let t6;
    	let tr1;
    	let th1;
    	let t8;
    	let td1;
    	let select;
    	let updating_selectedValue;
    	let t9;
    	let div0;
    	let button;
    	let t10;
    	let button_disabled_value;
    	let current;
    	let mounted;
    	let dispose;

    	header = new Header({
    			props: {
    				title: /*jsonIsArray*/ ctx[2]
    				? "Sort array items"
    				: "Sort object keys"
    			},
    			$$inline: true
    		});

    	let if_block = /*jsonIsArray*/ ctx[2] && (/*properties*/ ctx[3].length > 1 || /*selectedProperty*/ ctx[1] === undefined) && create_if_block$a(ctx);

    	function select_selectedValue_binding_1(value) {
    		/*select_selectedValue_binding_1*/ ctx[12](value);
    	}

    	let select_props = {
    		items: /*directions*/ ctx[5],
    		containerClasses: "test-class",
    		isClearable: false
    	};

    	if (/*selectedDirection*/ ctx[4] !== void 0) {
    		select_props.selectedValue = /*selectedDirection*/ ctx[4];
    	}

    	select = new Select({ props: select_props, $$inline: true });
    	binding_callbacks.push(() => bind$2(select, "selectedValue", select_selectedValue_binding_1));

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			create_component(header.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			table = element("table");
    			colgroup = element("colgroup");
    			col0 = element("col");
    			t1 = space();
    			col1 = element("col");
    			t2 = space();
    			tbody = element("tbody");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Path";
    			t4 = space();
    			td0 = element("td");
    			input = element("input");
    			t5 = space();
    			if (if_block) if_block.c();
    			t6 = space();
    			tr1 = element("tr");
    			th1 = element("th");
    			th1.textContent = "Direction";
    			t8 = space();
    			td1 = element("td");
    			create_component(select.$$.fragment);
    			t9 = space();
    			div0 = element("div");
    			button = element("button");
    			t10 = text("Sort");
    			attr_dev(col0, "width", "25%");
    			add_location(col0, file$k, 97, 8, 2759);
    			attr_dev(col1, "width", "75%");
    			add_location(col1, file$k, 98, 8, 2785);
    			add_location(colgroup, file$k, 96, 6, 2740);
    			attr_dev(th0, "class", "svelte-w5wcb3");
    			add_location(th0, file$k, 102, 10, 2858);
    			attr_dev(input, "class", "path svelte-w5wcb3");
    			attr_dev(input, "type", "text");
    			input.readOnly = true;
    			attr_dev(input, "title", "Selected path");

    			input.value = input_value_value = !isEmpty(/*selectedPath*/ ctx[0])
    			? stringifyPath(/*selectedPath*/ ctx[0])
    			: "(whole document)";

    			add_location(input, file$k, 104, 12, 2899);
    			attr_dev(td0, "class", "svelte-w5wcb3");
    			add_location(td0, file$k, 103, 10, 2882);
    			add_location(tr0, file$k, 101, 8, 2843);
    			attr_dev(th1, "class", "svelte-w5wcb3");
    			add_location(th1, file$k, 125, 10, 3508);
    			attr_dev(td1, "class", "svelte-w5wcb3");
    			add_location(td1, file$k, 126, 10, 3537);
    			add_location(tr1, file$k, 124, 8, 3493);
    			add_location(tbody, file$k, 100, 6, 2827);
    			attr_dev(table, "class", "svelte-w5wcb3");
    			add_location(table, file$k, 95, 4, 2726);
    			attr_dev(button, "class", "primary svelte-w5wcb3");

    			button.disabled = button_disabled_value = /*jsonIsArray*/ ctx[2]
    			? !/*selectedProperty*/ ctx[1]
    			: false;

    			add_location(button, file$k, 139, 6, 3832);
    			attr_dev(div0, "class", "actions svelte-w5wcb3");
    			add_location(div0, file$k, 138, 4, 3804);
    			attr_dev(div1, "class", "contents svelte-w5wcb3");
    			add_location(div1, file$k, 94, 2, 2699);
    			attr_dev(div2, "class", "jsoneditor-modal sort svelte-w5wcb3");
    			add_location(div2, file$k, 91, 0, 2585);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			mount_component(header, div2, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, table);
    			append_dev(table, colgroup);
    			append_dev(colgroup, col0);
    			append_dev(colgroup, t1);
    			append_dev(colgroup, col1);
    			append_dev(table, t2);
    			append_dev(table, tbody);
    			append_dev(tbody, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t4);
    			append_dev(tr0, td0);
    			append_dev(td0, input);
    			append_dev(tbody, t5);
    			if (if_block) if_block.m(tbody, null);
    			append_dev(tbody, t6);
    			append_dev(tbody, tr1);
    			append_dev(tr1, th1);
    			append_dev(tr1, t8);
    			append_dev(tr1, td1);
    			mount_component(select, td1, null);
    			append_dev(div1, t9);
    			append_dev(div1, div0);
    			append_dev(div0, button);
    			append_dev(button, t10);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*handleSort*/ ctx[6], false, false, false),
    					action_destroyer(focus$1.call(null, button))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const header_changes = {};

    			if (dirty & /*jsonIsArray*/ 4) header_changes.title = /*jsonIsArray*/ ctx[2]
    			? "Sort array items"
    			: "Sort object keys";

    			header.$set(header_changes);

    			if (!current || dirty & /*selectedPath*/ 1 && input_value_value !== (input_value_value = !isEmpty(/*selectedPath*/ ctx[0])
    			? stringifyPath(/*selectedPath*/ ctx[0])
    			: "(whole document)") && input.value !== input_value_value) {
    				prop_dev(input, "value", input_value_value);
    			}

    			if (/*jsonIsArray*/ ctx[2] && (/*properties*/ ctx[3].length > 1 || /*selectedProperty*/ ctx[1] === undefined)) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*jsonIsArray, properties, selectedProperty*/ 14) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$a(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(tbody, t6);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const select_changes = {};

    			if (!updating_selectedValue && dirty & /*selectedDirection*/ 16) {
    				updating_selectedValue = true;
    				select_changes.selectedValue = /*selectedDirection*/ ctx[4];
    				add_flush_callback(() => updating_selectedValue = false);
    			}

    			select.$set(select_changes);

    			if (!current || dirty & /*jsonIsArray, selectedProperty*/ 6 && button_disabled_value !== (button_disabled_value = /*jsonIsArray*/ ctx[2]
    			? !/*selectedProperty*/ ctx[1]
    			: false)) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(select.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(select.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(header);
    			if (if_block) if_block.d();
    			destroy_component(select);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function focus$1(element) {
    	element.focus();
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let jsonIsArray;
    	let paths;
    	let properties;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SortModal", slots, []);
    	let { id } = $$props;
    	let { json } = $$props; // the whole document
    	let { selectedPath } = $$props;
    	let { onSort } = $$props;
    	const { close } = getContext("simple-modal");
    	const stateId = `${id}:${immutableJSONPatch.compileJSONPointer(selectedPath)}`;
    	const selectedJson = immutableJSONPatch.getIn(json, selectedPath);
    	const asc = { value: 1, label: "ascending" };
    	const desc = { value: -1, label: "descending" };
    	const directions = [asc, desc];
    	let selectedProperty = sortModalState[stateId] && sortModalState[stateId].selectedProperty || undefined;
    	let selectedDirection = sortModalState[stateId] && sortModalState[stateId].selectedDirection || asc;

    	function pathToOption(path) {
    		return {
    			value: path,
    			label: isEmpty(path) ? "(whole item)" : stringifyPath(path)
    		};
    	}

    	function handleSort() {
    		// remember the selected values for the next time we open the SortModal
    		// just in memory, not persisted
    		sortModalState[stateId] = { selectedProperty, selectedDirection };

    		if (jsonIsArray) {
    			if (!selectedProperty) {
    				return;
    			}

    			const property = selectedProperty.value;
    			const direction = selectedDirection.value;
    			const operations = sortArray(json, selectedPath, property, direction);
    			onSort(operations);
    		} else if (isObject(selectedJson)) {
    			const direction = selectedDirection.value;
    			const operations = sortObjectKeys(json, selectedPath, direction);
    			onSort(operations);
    		} else {
    			console.error("Cannot sort: no array or object");
    		}

    		close();
    	}

    	const writable_props = ["id", "json", "selectedPath", "onSort"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<SortModal> was created with unknown prop '${key}'`);
    	});

    	function select_selectedValue_binding(value) {
    		selectedProperty = value;
    		((($$invalidate(1, selectedProperty), $$invalidate(3, properties)), $$invalidate(10, paths)), $$invalidate(2, jsonIsArray));
    	}

    	function select_selectedValue_binding_1(value) {
    		selectedDirection = value;
    		$$invalidate(4, selectedDirection);
    	}

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(7, id = $$props.id);
    		if ("json" in $$props) $$invalidate(8, json = $$props.json);
    		if ("selectedPath" in $$props) $$invalidate(0, selectedPath = $$props.selectedPath);
    		if ("onSort" in $$props) $$invalidate(9, onSort = $$props.onSort);
    	};

    	$$self.$capture_state = () => ({
    		isEmpty,
    		getContext,
    		Select,
    		Header,
    		getNestedPaths,
    		isObject,
    		stringifyPath,
    		sortArray,
    		sortObjectKeys,
    		sortModalState,
    		compileJSONPointer: immutableJSONPatch.compileJSONPointer,
    		getIn: immutableJSONPatch.getIn,
    		id,
    		json,
    		selectedPath,
    		onSort,
    		close,
    		stateId,
    		selectedJson,
    		asc,
    		desc,
    		directions,
    		selectedProperty,
    		selectedDirection,
    		pathToOption,
    		handleSort,
    		focus: focus$1,
    		jsonIsArray,
    		paths,
    		properties
    	});

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(7, id = $$props.id);
    		if ("json" in $$props) $$invalidate(8, json = $$props.json);
    		if ("selectedPath" in $$props) $$invalidate(0, selectedPath = $$props.selectedPath);
    		if ("onSort" in $$props) $$invalidate(9, onSort = $$props.onSort);
    		if ("selectedProperty" in $$props) $$invalidate(1, selectedProperty = $$props.selectedProperty);
    		if ("selectedDirection" in $$props) $$invalidate(4, selectedDirection = $$props.selectedDirection);
    		if ("jsonIsArray" in $$props) $$invalidate(2, jsonIsArray = $$props.jsonIsArray);
    		if ("paths" in $$props) $$invalidate(10, paths = $$props.paths);
    		if ("properties" in $$props) $$invalidate(3, properties = $$props.properties);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*jsonIsArray*/ 4) {
    			$$invalidate(10, paths = jsonIsArray ? getNestedPaths(selectedJson) : undefined);
    		}

    		if ($$self.$$.dirty & /*paths*/ 1024) {
    			$$invalidate(3, properties = paths ? paths.map(pathToOption) : undefined);
    		}

    		if ($$self.$$.dirty & /*selectedProperty, properties*/ 10) {
    			{
    				// if there is only one option, select it and do not render the select box
    				if (selectedProperty === undefined && properties && properties.length === 1) {
    					$$invalidate(1, selectedProperty = properties[0]);
    				}
    			}
    		}
    	};

    	$$invalidate(2, jsonIsArray = Array.isArray(selectedJson));

    	return [
    		selectedPath,
    		selectedProperty,
    		jsonIsArray,
    		properties,
    		selectedDirection,
    		directions,
    		handleSort,
    		id,
    		json,
    		onSort,
    		paths,
    		select_selectedValue_binding,
    		select_selectedValue_binding_1
    	];
    }

    class SortModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$m, create_fragment$m, not_equal, {
    			id: 7,
    			json: 8,
    			selectedPath: 0,
    			onSort: 9
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SortModal",
    			options,
    			id: create_fragment$m.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*id*/ ctx[7] === undefined && !("id" in props)) {
    			console_1$4.warn("<SortModal> was created without expected prop 'id'");
    		}

    		if (/*json*/ ctx[8] === undefined && !("json" in props)) {
    			console_1$4.warn("<SortModal> was created without expected prop 'json'");
    		}

    		if (/*selectedPath*/ ctx[0] === undefined && !("selectedPath" in props)) {
    			console_1$4.warn("<SortModal> was created without expected prop 'selectedPath'");
    		}

    		if (/*onSort*/ ctx[9] === undefined && !("onSort" in props)) {
    			console_1$4.warn("<SortModal> was created without expected prop 'onSort'");
    		}
    	}

    	get id() {
    		throw new Error("<SortModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<SortModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get json() {
    		throw new Error("<SortModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set json(value) {
    		throw new Error("<SortModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedPath() {
    		throw new Error("<SortModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedPath(value) {
    		throw new Error("<SortModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSort() {
    		throw new Error("<SortModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSort(value) {
    		throw new Error("<SortModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * Find a unique name. Suffix the name with ' (copy)', '(copy 2)', etc
     * until a unique name is found
     * @param {string} name
     * @param {string[]} keys    Array with existing keys
     */
    function findUniqueName (name, keys) {
      const keysSet = new Set(keys);

      // remove any " (copy)" or " (copy 2)" suffix from the name
      const nameWithoutCopySuffix = name.replace(/ \(copy( \d+)?\)$/, '');

      let validName = name;
      let i = 1;

      while (keysSet.has(validName)) {
        const copy = 'copy' + (i > 1 ? (' ' + i) : '');
        validName = `${nameWithoutCopySuffix} (${copy})`;
        i++;
      }

      return validName
    }

    /**
     * Truncate a text to a maximum length.
     * When truncated, the text will pe appended with ellipsis '...'
     * @param {string} text Text to be truncated
     * @param {number} maxLength Maximum allowed length for the text including ellipsis
     */
    function truncate (text, maxLength) {
      const ellipsis = '...';
      const maxTextLength = maxLength - ellipsis.length;

      return text.length > maxLength
        ? (text.substr(0, maxTextLength) + ellipsis)
        : text
    }

    const transformModalState = {};

    function createQuery (json, queryOptions) {
      console.log('createQuery', queryOptions);

      const { filter, sort, projection } = queryOptions;
      const queryParts = [];

      if (filter) {
        // Note that the comparisons embrace type coercion,
        // so a filter value like '5' (text) will match numbers like 5 too.
        const getActualValue = !isEmpty(filter.field)
          ? `item => _.get(item, ${JSON.stringify(filter.field)})`
          : 'item => item';
        queryParts.push(`  data = data.filter(${getActualValue} ${filter.relation} '${filter.value}')\n`);
      }

      if (sort) {
        queryParts.push(`  data = _.orderBy(data, ${JSON.stringify(sort.field)}, '${sort.direction}')\n`);
      }

      if (projection) {
        // It is possible to make a util function "pickFlat"
        // and use that when building the query to make it more readable.
        if (projection.fields.length > 1) {
          const fields = projection.fields.map(field => {
            const name = last(field) || 'item'; // 'item' in case of having selected the whole item
            const item = !isEmpty(field)
              ? `_.get(item, ${JSON.stringify(field)})`
              : 'item';
            return `    ${JSON.stringify(name)}: ${item}`
          });
          queryParts.push(`  data = data.map(item => ({\n${fields.join(',\n')}})\n  )\n`);
        } else {
          const field = projection.fields[0];
          const item = !isEmpty(field)
            ? `_.get(item, ${JSON.stringify(field)})`
            : 'item';
          queryParts.push(`  data = data.map(item => ${item})\n`);
        }
      }

      queryParts.push('  return data\n');

      return `function query (data) {\n${queryParts.join('')}}`
    }

    /* node_modules\svelte-jsoneditor\src\components\modals\TransformWizard.svelte generated by Svelte v3.38.2 */
    const file$j = "node_modules\\svelte-jsoneditor\\src\\components\\modals\\TransformWizard.svelte";

    function create_fragment$l(ctx) {
    	let table;
    	let tr0;
    	let th0;
    	let t1;
    	let td0;
    	let div0;
    	let select0;
    	let updating_selectedValue;
    	let t2;
    	let select1;
    	let updating_selectedValue_1;
    	let t3;
    	let input;
    	let t4;
    	let tr1;
    	let th1;
    	let t6;
    	let td1;
    	let div1;
    	let select2;
    	let updating_selectedValue_2;
    	let t7;
    	let select3;
    	let updating_selectedValue_3;
    	let t8;
    	let tr2;
    	let th2;
    	let t10;
    	let td2;
    	let div2;
    	let select4;
    	let updating_selectedValue_4;
    	let current;
    	let mounted;
    	let dispose;

    	function select0_selectedValue_binding(value) {
    		/*select0_selectedValue_binding*/ ctx[16](value);
    	}

    	let select0_props = {
    		containerClasses: "filter-field",
    		items: /*fieldOptions*/ ctx[6]
    	};

    	if (/*filterField*/ ctx[0] !== void 0) {
    		select0_props.selectedValue = /*filterField*/ ctx[0];
    	}

    	select0 = new Select({ props: select0_props, $$inline: true });
    	binding_callbacks.push(() => bind$2(select0, "selectedValue", select0_selectedValue_binding));

    	function select1_selectedValue_binding(value) {
    		/*select1_selectedValue_binding*/ ctx[17](value);
    	}

    	let select1_props = {
    		containerClasses: "filter-relation",
    		items: /*filterRelationOptions*/ ctx[8]
    	};

    	if (/*filterRelation*/ ctx[1] !== void 0) {
    		select1_props.selectedValue = /*filterRelation*/ ctx[1];
    	}

    	select1 = new Select({ props: select1_props, $$inline: true });
    	binding_callbacks.push(() => bind$2(select1, "selectedValue", select1_selectedValue_binding));

    	function select2_selectedValue_binding(value) {
    		/*select2_selectedValue_binding*/ ctx[19](value);
    	}

    	let select2_props = {
    		containerClasses: "sort-field",
    		items: /*fieldOptions*/ ctx[6]
    	};

    	if (/*sortField*/ ctx[3] !== void 0) {
    		select2_props.selectedValue = /*sortField*/ ctx[3];
    	}

    	select2 = new Select({ props: select2_props, $$inline: true });
    	binding_callbacks.push(() => bind$2(select2, "selectedValue", select2_selectedValue_binding));

    	function select3_selectedValue_binding(value) {
    		/*select3_selectedValue_binding*/ ctx[20](value);
    	}

    	let select3_props = {
    		containerClasses: "sort-direction",
    		items: /*sortDirectionOptions*/ ctx[9]
    	};

    	if (/*sortDirection*/ ctx[4] !== void 0) {
    		select3_props.selectedValue = /*sortDirection*/ ctx[4];
    	}

    	select3 = new Select({ props: select3_props, $$inline: true });
    	binding_callbacks.push(() => bind$2(select3, "selectedValue", select3_selectedValue_binding));

    	function select4_selectedValue_binding(value) {
    		/*select4_selectedValue_binding*/ ctx[21](value);
    	}

    	let select4_props = {
    		containerClasses: "pick-fields",
    		items: /*pickFieldOptions*/ ctx[7],
    		isMulti: true
    	};

    	if (/*pickFields*/ ctx[5] !== void 0) {
    		select4_props.selectedValue = /*pickFields*/ ctx[5];
    	}

    	select4 = new Select({ props: select4_props, $$inline: true });
    	binding_callbacks.push(() => bind$2(select4, "selectedValue", select4_selectedValue_binding));

    	const block = {
    		c: function create() {
    			table = element("table");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Filter";
    			t1 = space();
    			td0 = element("td");
    			div0 = element("div");
    			create_component(select0.$$.fragment);
    			t2 = space();
    			create_component(select1.$$.fragment);
    			t3 = space();
    			input = element("input");
    			t4 = space();
    			tr1 = element("tr");
    			th1 = element("th");
    			th1.textContent = "Sort";
    			t6 = space();
    			td1 = element("td");
    			div1 = element("div");
    			create_component(select2.$$.fragment);
    			t7 = space();
    			create_component(select3.$$.fragment);
    			t8 = space();
    			tr2 = element("tr");
    			th2 = element("th");
    			th2.textContent = "Pick";
    			t10 = space();
    			td2 = element("td");
    			div2 = element("div");
    			create_component(select4.$$.fragment);
    			attr_dev(th0, "class", "svelte-nzxx82");
    			add_location(th0, file$j, 86, 4, 2136);
    			attr_dev(input, "class", "filter-value svelte-nzxx82");
    			add_location(input, file$j, 99, 8, 2505);
    			attr_dev(div0, "class", "horizontal svelte-nzxx82");
    			add_location(div0, file$j, 88, 6, 2167);
    			add_location(td0, file$j, 87, 4, 2156);
    			add_location(tr0, file$j, 85, 2, 2127);
    			attr_dev(th1, "class", "svelte-nzxx82");
    			add_location(th1, file$j, 107, 4, 2632);
    			attr_dev(div1, "class", "horizontal svelte-nzxx82");
    			add_location(div1, file$j, 109, 6, 2661);
    			add_location(td1, file$j, 108, 4, 2650);
    			add_location(tr1, file$j, 106, 2, 2623);
    			attr_dev(th2, "class", "svelte-nzxx82");
    			add_location(th2, file$j, 124, 4, 3026);
    			attr_dev(div2, "class", "horizontal svelte-nzxx82");
    			add_location(div2, file$j, 126, 6, 3055);
    			add_location(td2, file$j, 125, 4, 3044);
    			add_location(tr2, file$j, 123, 2, 3017);
    			attr_dev(table, "class", "transform-wizard svelte-nzxx82");
    			add_location(table, file$j, 84, 0, 2092);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t1);
    			append_dev(tr0, td0);
    			append_dev(td0, div0);
    			mount_component(select0, div0, null);
    			append_dev(div0, t2);
    			mount_component(select1, div0, null);
    			append_dev(div0, t3);
    			append_dev(div0, input);
    			set_input_value(input, /*filterValue*/ ctx[2]);
    			append_dev(table, t4);
    			append_dev(table, tr1);
    			append_dev(tr1, th1);
    			append_dev(tr1, t6);
    			append_dev(tr1, td1);
    			append_dev(td1, div1);
    			mount_component(select2, div1, null);
    			append_dev(div1, t7);
    			mount_component(select3, div1, null);
    			append_dev(table, t8);
    			append_dev(table, tr2);
    			append_dev(tr2, th2);
    			append_dev(tr2, t10);
    			append_dev(tr2, td2);
    			append_dev(td2, div2);
    			mount_component(select4, div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[18]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const select0_changes = {};
    			if (dirty & /*fieldOptions*/ 64) select0_changes.items = /*fieldOptions*/ ctx[6];

    			if (!updating_selectedValue && dirty & /*filterField*/ 1) {
    				updating_selectedValue = true;
    				select0_changes.selectedValue = /*filterField*/ ctx[0];
    				add_flush_callback(() => updating_selectedValue = false);
    			}

    			select0.$set(select0_changes);
    			const select1_changes = {};

    			if (!updating_selectedValue_1 && dirty & /*filterRelation*/ 2) {
    				updating_selectedValue_1 = true;
    				select1_changes.selectedValue = /*filterRelation*/ ctx[1];
    				add_flush_callback(() => updating_selectedValue_1 = false);
    			}

    			select1.$set(select1_changes);

    			if (dirty & /*filterValue*/ 4 && input.value !== /*filterValue*/ ctx[2]) {
    				set_input_value(input, /*filterValue*/ ctx[2]);
    			}

    			const select2_changes = {};
    			if (dirty & /*fieldOptions*/ 64) select2_changes.items = /*fieldOptions*/ ctx[6];

    			if (!updating_selectedValue_2 && dirty & /*sortField*/ 8) {
    				updating_selectedValue_2 = true;
    				select2_changes.selectedValue = /*sortField*/ ctx[3];
    				add_flush_callback(() => updating_selectedValue_2 = false);
    			}

    			select2.$set(select2_changes);
    			const select3_changes = {};

    			if (!updating_selectedValue_3 && dirty & /*sortDirection*/ 16) {
    				updating_selectedValue_3 = true;
    				select3_changes.selectedValue = /*sortDirection*/ ctx[4];
    				add_flush_callback(() => updating_selectedValue_3 = false);
    			}

    			select3.$set(select3_changes);
    			const select4_changes = {};
    			if (dirty & /*pickFieldOptions*/ 128) select4_changes.items = /*pickFieldOptions*/ ctx[7];

    			if (!updating_selectedValue_4 && dirty & /*pickFields*/ 32) {
    				updating_selectedValue_4 = true;
    				select4_changes.selectedValue = /*pickFields*/ ctx[5];
    				add_flush_callback(() => updating_selectedValue_4 = false);
    			}

    			select4.$set(select4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(select0.$$.fragment, local);
    			transition_in(select1.$$.fragment, local);
    			transition_in(select2.$$.fragment, local);
    			transition_in(select3.$$.fragment, local);
    			transition_in(select4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(select0.$$.fragment, local);
    			transition_out(select1.$$.fragment, local);
    			transition_out(select2.$$.fragment, local);
    			transition_out(select3.$$.fragment, local);
    			transition_out(select4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_component(select0);
    			destroy_component(select1);
    			destroy_component(select2);
    			destroy_component(select3);
    			destroy_component(select4);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let jsonIsArray;
    	let paths;
    	let pathsIncludingObjects;
    	let fieldOptions;
    	let pickFieldOptions;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TransformWizard", slots, []);
    	let { json } = $$props;
    	let { onQuery } = $$props;
    	let { filterField } = $$props;
    	let { filterRelation } = $$props;
    	let { filterValue } = $$props;
    	let { sortField } = $$props;
    	let { sortDirection } = $$props;
    	let { pickFields } = $$props;
    	const filterRelationOptions = ["==", "!=", "<", "<=", ">", ">="].map(relation => ({ value: relation, label: relation }));
    	const sortDirectionOptions = [{ value: "asc", label: "ascending" }, { value: "desc", label: "descending" }];

    	function pathToOption(path) {
    		return {
    			value: path,
    			label: isEmpty(path) ? "(whole item)" : stringifyPath(path)
    		};
    	}

    	let queryOptions = {};

    	const writable_props = [
    		"json",
    		"onQuery",
    		"filterField",
    		"filterRelation",
    		"filterValue",
    		"sortField",
    		"sortDirection",
    		"pickFields"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TransformWizard> was created with unknown prop '${key}'`);
    	});

    	function select0_selectedValue_binding(value) {
    		filterField = value;
    		$$invalidate(0, filterField);
    	}

    	function select1_selectedValue_binding(value) {
    		filterRelation = value;
    		$$invalidate(1, filterRelation);
    	}

    	function input_input_handler() {
    		filterValue = this.value;
    		$$invalidate(2, filterValue);
    	}

    	function select2_selectedValue_binding(value) {
    		sortField = value;
    		$$invalidate(3, sortField);
    	}

    	function select3_selectedValue_binding(value) {
    		sortDirection = value;
    		$$invalidate(4, sortDirection);
    	}

    	function select4_selectedValue_binding(value) {
    		pickFields = value;
    		$$invalidate(5, pickFields);
    	}

    	$$self.$$set = $$props => {
    		if ("json" in $$props) $$invalidate(10, json = $$props.json);
    		if ("onQuery" in $$props) $$invalidate(11, onQuery = $$props.onQuery);
    		if ("filterField" in $$props) $$invalidate(0, filterField = $$props.filterField);
    		if ("filterRelation" in $$props) $$invalidate(1, filterRelation = $$props.filterRelation);
    		if ("filterValue" in $$props) $$invalidate(2, filterValue = $$props.filterValue);
    		if ("sortField" in $$props) $$invalidate(3, sortField = $$props.sortField);
    		if ("sortDirection" in $$props) $$invalidate(4, sortDirection = $$props.sortDirection);
    		if ("pickFields" in $$props) $$invalidate(5, pickFields = $$props.pickFields);
    	};

    	$$self.$capture_state = () => ({
    		Select,
    		getNestedPaths,
    		stringifyPath,
    		createQuery,
    		isEmpty,
    		isEqual,
    		json,
    		onQuery,
    		filterField,
    		filterRelation,
    		filterValue,
    		sortField,
    		sortDirection,
    		pickFields,
    		filterRelationOptions,
    		sortDirectionOptions,
    		pathToOption,
    		queryOptions,
    		jsonIsArray,
    		paths,
    		pathsIncludingObjects,
    		fieldOptions,
    		pickFieldOptions
    	});

    	$$self.$inject_state = $$props => {
    		if ("json" in $$props) $$invalidate(10, json = $$props.json);
    		if ("onQuery" in $$props) $$invalidate(11, onQuery = $$props.onQuery);
    		if ("filterField" in $$props) $$invalidate(0, filterField = $$props.filterField);
    		if ("filterRelation" in $$props) $$invalidate(1, filterRelation = $$props.filterRelation);
    		if ("filterValue" in $$props) $$invalidate(2, filterValue = $$props.filterValue);
    		if ("sortField" in $$props) $$invalidate(3, sortField = $$props.sortField);
    		if ("sortDirection" in $$props) $$invalidate(4, sortDirection = $$props.sortDirection);
    		if ("pickFields" in $$props) $$invalidate(5, pickFields = $$props.pickFields);
    		if ("queryOptions" in $$props) $$invalidate(12, queryOptions = $$props.queryOptions);
    		if ("jsonIsArray" in $$props) $$invalidate(13, jsonIsArray = $$props.jsonIsArray);
    		if ("paths" in $$props) $$invalidate(14, paths = $$props.paths);
    		if ("pathsIncludingObjects" in $$props) $$invalidate(15, pathsIncludingObjects = $$props.pathsIncludingObjects);
    		if ("fieldOptions" in $$props) $$invalidate(6, fieldOptions = $$props.fieldOptions);
    		if ("pickFieldOptions" in $$props) $$invalidate(7, pickFieldOptions = $$props.pickFieldOptions);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*json*/ 1024) {
    			// options
    			$$invalidate(13, jsonIsArray = Array.isArray(json));
    		}

    		if ($$self.$$.dirty & /*jsonIsArray, json*/ 9216) {
    			$$invalidate(14, paths = jsonIsArray ? getNestedPaths(json) : undefined);
    		}

    		if ($$self.$$.dirty & /*jsonIsArray, json*/ 9216) {
    			$$invalidate(15, pathsIncludingObjects = jsonIsArray ? getNestedPaths(json, true) : undefined);
    		}

    		if ($$self.$$.dirty & /*paths*/ 16384) {
    			$$invalidate(6, fieldOptions = paths ? paths.map(pathToOption) : undefined);
    		}

    		if ($$self.$$.dirty & /*pathsIncludingObjects*/ 32768) {
    			$$invalidate(7, pickFieldOptions = pathsIncludingObjects
    			? pathsIncludingObjects.map(pathToOption)
    			: undefined);
    		}

    		if ($$self.$$.dirty & /*filterField, filterRelation, filterValue, sortField, sortDirection, pickFields, queryOptions, json, onQuery*/ 7231) {
    			{
    				const newQueryOptions = {};

    				if (filterField && filterRelation && filterValue) {
    					newQueryOptions.filter = {
    						field: filterField.value,
    						relation: filterRelation.value,
    						value: filterValue
    					};
    				}

    				if (sortField && sortDirection) {
    					newQueryOptions.sort = {
    						field: sortField.value,
    						direction: sortDirection.value
    					};
    				}

    				if (pickFields) {
    					newQueryOptions.projection = {
    						fields: pickFields.map(item => item.value)
    					};
    				}

    				if (!isEqual(newQueryOptions, queryOptions)) {
    					$$invalidate(12, queryOptions = newQueryOptions);
    					const query = createQuery(json, queryOptions);

    					// console.log('query updated', query, queryOptions)
    					onQuery(query);
    				}
    			}
    		}
    	};

    	return [
    		filterField,
    		filterRelation,
    		filterValue,
    		sortField,
    		sortDirection,
    		pickFields,
    		fieldOptions,
    		pickFieldOptions,
    		filterRelationOptions,
    		sortDirectionOptions,
    		json,
    		onQuery,
    		queryOptions,
    		jsonIsArray,
    		paths,
    		pathsIncludingObjects,
    		select0_selectedValue_binding,
    		select1_selectedValue_binding,
    		input_input_handler,
    		select2_selectedValue_binding,
    		select3_selectedValue_binding,
    		select4_selectedValue_binding
    	];
    }

    class TransformWizard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$l, create_fragment$l, not_equal, {
    			json: 10,
    			onQuery: 11,
    			filterField: 0,
    			filterRelation: 1,
    			filterValue: 2,
    			sortField: 3,
    			sortDirection: 4,
    			pickFields: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TransformWizard",
    			options,
    			id: create_fragment$l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*json*/ ctx[10] === undefined && !("json" in props)) {
    			console.warn("<TransformWizard> was created without expected prop 'json'");
    		}

    		if (/*onQuery*/ ctx[11] === undefined && !("onQuery" in props)) {
    			console.warn("<TransformWizard> was created without expected prop 'onQuery'");
    		}

    		if (/*filterField*/ ctx[0] === undefined && !("filterField" in props)) {
    			console.warn("<TransformWizard> was created without expected prop 'filterField'");
    		}

    		if (/*filterRelation*/ ctx[1] === undefined && !("filterRelation" in props)) {
    			console.warn("<TransformWizard> was created without expected prop 'filterRelation'");
    		}

    		if (/*filterValue*/ ctx[2] === undefined && !("filterValue" in props)) {
    			console.warn("<TransformWizard> was created without expected prop 'filterValue'");
    		}

    		if (/*sortField*/ ctx[3] === undefined && !("sortField" in props)) {
    			console.warn("<TransformWizard> was created without expected prop 'sortField'");
    		}

    		if (/*sortDirection*/ ctx[4] === undefined && !("sortDirection" in props)) {
    			console.warn("<TransformWizard> was created without expected prop 'sortDirection'");
    		}

    		if (/*pickFields*/ ctx[5] === undefined && !("pickFields" in props)) {
    			console.warn("<TransformWizard> was created without expected prop 'pickFields'");
    		}
    	}

    	get json() {
    		throw new Error("<TransformWizard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set json(value) {
    		throw new Error("<TransformWizard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onQuery() {
    		throw new Error("<TransformWizard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onQuery(value) {
    		throw new Error("<TransformWizard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterField() {
    		throw new Error("<TransformWizard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterField(value) {
    		throw new Error("<TransformWizard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterRelation() {
    		throw new Error("<TransformWizard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterRelation(value) {
    		throw new Error("<TransformWizard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterValue() {
    		throw new Error("<TransformWizard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterValue(value) {
    		throw new Error("<TransformWizard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortField() {
    		throw new Error("<TransformWizard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortField(value) {
    		throw new Error("<TransformWizard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortDirection() {
    		throw new Error("<TransformWizard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortDirection(value) {
    		throw new Error("<TransformWizard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pickFields() {
    		throw new Error("<TransformWizard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pickFields(value) {
    		throw new Error("<TransformWizard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\modals\TransformModal.svelte generated by Svelte v3.38.2 */

    const { console: console_1$3 } = globals;
    const file$i = "node_modules\\svelte-jsoneditor\\src\\components\\modals\\TransformModal.svelte";

    // (155:4) {#if showWizard}
    function create_if_block$9(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$5, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty[0] & /*selectedJson*/ 4) show_if = !!Array.isArray(/*selectedJson*/ ctx[2]);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx, [-1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(155:4) {#if showWizard}",
    		ctx
    	});

    	return block;
    }

    // (167:6) {:else}
    function create_else_block$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("(Only available for arrays, not for objects)");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$2,
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(167:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (156:6) {#if Array.isArray(selectedJson)}
    function create_if_block_1$5(ctx) {
    	let transformwizard;
    	let updating_filterField;
    	let updating_filterRelation;
    	let updating_filterValue;
    	let updating_sortField;
    	let updating_sortDirection;
    	let updating_pickFields;
    	let current;

    	function transformwizard_filterField_binding(value) {
    		/*transformwizard_filterField_binding*/ ctx[19](value);
    	}

    	function transformwizard_filterRelation_binding(value) {
    		/*transformwizard_filterRelation_binding*/ ctx[20](value);
    	}

    	function transformwizard_filterValue_binding(value) {
    		/*transformwizard_filterValue_binding*/ ctx[21](value);
    	}

    	function transformwizard_sortField_binding(value) {
    		/*transformwizard_sortField_binding*/ ctx[22](value);
    	}

    	function transformwizard_sortDirection_binding(value) {
    		/*transformwizard_sortDirection_binding*/ ctx[23](value);
    	}

    	function transformwizard_pickFields_binding(value) {
    		/*transformwizard_pickFields_binding*/ ctx[24](value);
    	}

    	let transformwizard_props = {
    		json: /*selectedJson*/ ctx[2],
    		onQuery: /*updateQuery*/ ctx[12]
    	};

    	if (/*filterField*/ ctx[6] !== void 0) {
    		transformwizard_props.filterField = /*filterField*/ ctx[6];
    	}

    	if (/*filterRelation*/ ctx[7] !== void 0) {
    		transformwizard_props.filterRelation = /*filterRelation*/ ctx[7];
    	}

    	if (/*filterValue*/ ctx[8] !== void 0) {
    		transformwizard_props.filterValue = /*filterValue*/ ctx[8];
    	}

    	if (/*sortField*/ ctx[9] !== void 0) {
    		transformwizard_props.sortField = /*sortField*/ ctx[9];
    	}

    	if (/*sortDirection*/ ctx[10] !== void 0) {
    		transformwizard_props.sortDirection = /*sortDirection*/ ctx[10];
    	}

    	if (/*pickFields*/ ctx[11] !== void 0) {
    		transformwizard_props.pickFields = /*pickFields*/ ctx[11];
    	}

    	transformwizard = new TransformWizard({
    			props: transformwizard_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind$2(transformwizard, "filterField", transformwizard_filterField_binding));
    	binding_callbacks.push(() => bind$2(transformwizard, "filterRelation", transformwizard_filterRelation_binding));
    	binding_callbacks.push(() => bind$2(transformwizard, "filterValue", transformwizard_filterValue_binding));
    	binding_callbacks.push(() => bind$2(transformwizard, "sortField", transformwizard_sortField_binding));
    	binding_callbacks.push(() => bind$2(transformwizard, "sortDirection", transformwizard_sortDirection_binding));
    	binding_callbacks.push(() => bind$2(transformwizard, "pickFields", transformwizard_pickFields_binding));

    	const block = {
    		c: function create() {
    			create_component(transformwizard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(transformwizard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const transformwizard_changes = {};
    			if (dirty[0] & /*selectedJson*/ 4) transformwizard_changes.json = /*selectedJson*/ ctx[2];

    			if (!updating_filterField && dirty[0] & /*filterField*/ 64) {
    				updating_filterField = true;
    				transformwizard_changes.filterField = /*filterField*/ ctx[6];
    				add_flush_callback(() => updating_filterField = false);
    			}

    			if (!updating_filterRelation && dirty[0] & /*filterRelation*/ 128) {
    				updating_filterRelation = true;
    				transformwizard_changes.filterRelation = /*filterRelation*/ ctx[7];
    				add_flush_callback(() => updating_filterRelation = false);
    			}

    			if (!updating_filterValue && dirty[0] & /*filterValue*/ 256) {
    				updating_filterValue = true;
    				transformwizard_changes.filterValue = /*filterValue*/ ctx[8];
    				add_flush_callback(() => updating_filterValue = false);
    			}

    			if (!updating_sortField && dirty[0] & /*sortField*/ 512) {
    				updating_sortField = true;
    				transformwizard_changes.sortField = /*sortField*/ ctx[9];
    				add_flush_callback(() => updating_sortField = false);
    			}

    			if (!updating_sortDirection && dirty[0] & /*sortDirection*/ 1024) {
    				updating_sortDirection = true;
    				transformwizard_changes.sortDirection = /*sortDirection*/ ctx[10];
    				add_flush_callback(() => updating_sortDirection = false);
    			}

    			if (!updating_pickFields && dirty[0] & /*pickFields*/ 2048) {
    				updating_pickFields = true;
    				transformwizard_changes.pickFields = /*pickFields*/ ctx[11];
    				add_flush_callback(() => updating_pickFields = false);
    			}

    			transformwizard.$set(transformwizard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(transformwizard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(transformwizard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(transformwizard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(156:6) {#if Array.isArray(selectedJson)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let div8;
    	let header;
    	let t0;
    	let div7;
    	let div0;
    	let t2;
    	let div1;
    	let t3;
    	let a;
    	let t5;
    	let code0;
    	let t7;
    	let code1;
    	let t9;
    	let code2;
    	let t11;
    	let code3;
    	let t13;
    	let code4;
    	let t15;
    	let code5;
    	let t17;
    	let code6;
    	let t19;
    	let code7;
    	let t21;
    	let t22;
    	let div2;
    	let t24;
    	let input;
    	let input_value_value;
    	let t25;
    	let div3;
    	let button0;
    	let icon;
    	let t26;
    	let t27;
    	let t28;
    	let div4;
    	let t30;
    	let textarea0;
    	let t31;
    	let div5;
    	let t33;
    	let textarea1;
    	let t34;
    	let div6;
    	let button1;
    	let t35;
    	let current;
    	let mounted;
    	let dispose;

    	header = new Header({
    			props: { title: "Transform" },
    			$$inline: true
    		});

    	icon = new Icon({
    			props: {
    				data: /*showWizard*/ ctx[5] ? faCaretDown : faCaretRight
    			},
    			$$inline: true
    		});

    	let if_block = /*showWizard*/ ctx[5] && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			create_component(header.$$.fragment);
    			t0 = space();
    			div7 = element("div");
    			div0 = element("div");
    			div0.textContent = "Enter a JavaScript function to filter, sort, or transform the data.";
    			t2 = space();
    			div1 = element("div");
    			t3 = text("You can use ");
    			a = element("a");
    			a.textContent = "Lodash";
    			t5 = text("\n      functions like ");
    			code0 = element("code");
    			code0.textContent = "_.map";
    			t7 = text(", ");
    			code1 = element("code");
    			code1.textContent = "_.filter";
    			t9 = text(",\n      ");
    			code2 = element("code");
    			code2.textContent = "_.orderBy";
    			t11 = text(", ");
    			code3 = element("code");
    			code3.textContent = "_.sortBy";
    			t13 = text(", ");
    			code4 = element("code");
    			code4.textContent = "_.groupBy";
    			t15 = text(",\n      ");
    			code5 = element("code");
    			code5.textContent = "_.pick";
    			t17 = text(", ");
    			code6 = element("code");
    			code6.textContent = "_.uniq";
    			t19 = text(", ");
    			code7 = element("code");
    			code7.textContent = "_.get";
    			t21 = text(", etcetera.");
    			t22 = space();
    			div2 = element("div");
    			div2.textContent = "Path";
    			t24 = space();
    			input = element("input");
    			t25 = space();
    			div3 = element("div");
    			button0 = element("button");
    			create_component(icon.$$.fragment);
    			t26 = text("\n        Wizard");
    			t27 = space();
    			if (if_block) if_block.c();
    			t28 = space();
    			div4 = element("div");
    			div4.textContent = "Query";
    			t30 = space();
    			textarea0 = element("textarea");
    			t31 = space();
    			div5 = element("div");
    			div5.textContent = "Preview";
    			t33 = space();
    			textarea1 = element("textarea");
    			t34 = space();
    			div6 = element("div");
    			button1 = element("button");
    			t35 = text("Transform");
    			attr_dev(div0, "class", "description svelte-u7exnm");
    			add_location(div0, file$i, 127, 4, 3750);
    			attr_dev(a, "href", "https://lodash.com");
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noopener noreferrer");
    			add_location(a, file$i, 131, 18, 3909);
    			attr_dev(code0, "class", "svelte-u7exnm");
    			add_location(code0, file$i, 132, 21, 4012);
    			attr_dev(code1, "class", "svelte-u7exnm");
    			add_location(code1, file$i, 132, 41, 4032);
    			attr_dev(code2, "class", "svelte-u7exnm");
    			add_location(code2, file$i, 133, 6, 4061);
    			attr_dev(code3, "class", "svelte-u7exnm");
    			add_location(code3, file$i, 133, 30, 4085);
    			attr_dev(code4, "class", "svelte-u7exnm");
    			add_location(code4, file$i, 133, 53, 4108);
    			attr_dev(code5, "class", "svelte-u7exnm");
    			add_location(code5, file$i, 134, 6, 4138);
    			attr_dev(code6, "class", "svelte-u7exnm");
    			add_location(code6, file$i, 134, 27, 4159);
    			attr_dev(code7, "class", "svelte-u7exnm");
    			add_location(code7, file$i, 134, 48, 4180);
    			attr_dev(div1, "class", "description svelte-u7exnm");
    			add_location(div1, file$i, 130, 4, 3865);
    			attr_dev(div2, "class", "label svelte-u7exnm");
    			add_location(div2, file$i, 137, 4, 4226);
    			attr_dev(input, "class", "path svelte-u7exnm");
    			attr_dev(input, "type", "text");
    			input.readOnly = true;
    			attr_dev(input, "title", "Selected path");

    			input.value = input_value_value = !isEmpty(/*selectedPath*/ ctx[0])
    			? stringifyPath(/*selectedPath*/ ctx[0])
    			: "(whole document)";

    			add_location(input, file$i, 140, 4, 4272);
    			attr_dev(button0, "class", "svelte-u7exnm");
    			add_location(button0, file$i, 149, 6, 4485);
    			attr_dev(div3, "class", "label svelte-u7exnm");
    			add_location(div3, file$i, 148, 4, 4459);
    			attr_dev(div4, "class", "label svelte-u7exnm");
    			add_location(div4, file$i, 171, 4, 5045);
    			attr_dev(textarea0, "class", "query svelte-u7exnm");
    			add_location(textarea0, file$i, 174, 4, 5092);
    			attr_dev(div5, "class", "label svelte-u7exnm");
    			add_location(div5, file$i, 176, 4, 5152);
    			attr_dev(textarea1, "class", "preview svelte-u7exnm");
    			textarea1.readOnly = true;
    			toggle_class(textarea1, "error", /*previewHasError*/ ctx[3]);
    			add_location(textarea1, file$i, 177, 4, 5189);
    			attr_dev(button1, "class", "primary svelte-u7exnm");
    			button1.disabled = /*previewHasError*/ ctx[3];
    			add_location(button1, file$i, 185, 6, 5349);
    			attr_dev(div6, "class", "actions svelte-u7exnm");
    			add_location(div6, file$i, 184, 4, 5321);
    			attr_dev(div7, "class", "contents svelte-u7exnm");
    			add_location(div7, file$i, 126, 2, 3723);
    			attr_dev(div8, "class", "jsoneditor-modal transform svelte-u7exnm");
    			add_location(div8, file$i, 124, 0, 3649);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			mount_component(header, div8, null);
    			append_dev(div8, t0);
    			append_dev(div8, div7);
    			append_dev(div7, div0);
    			append_dev(div7, t2);
    			append_dev(div7, div1);
    			append_dev(div1, t3);
    			append_dev(div1, a);
    			append_dev(div1, t5);
    			append_dev(div1, code0);
    			append_dev(div1, t7);
    			append_dev(div1, code1);
    			append_dev(div1, t9);
    			append_dev(div1, code2);
    			append_dev(div1, t11);
    			append_dev(div1, code3);
    			append_dev(div1, t13);
    			append_dev(div1, code4);
    			append_dev(div1, t15);
    			append_dev(div1, code5);
    			append_dev(div1, t17);
    			append_dev(div1, code6);
    			append_dev(div1, t19);
    			append_dev(div1, code7);
    			append_dev(div1, t21);
    			append_dev(div7, t22);
    			append_dev(div7, div2);
    			append_dev(div7, t24);
    			append_dev(div7, input);
    			append_dev(div7, t25);
    			append_dev(div7, div3);
    			append_dev(div3, button0);
    			mount_component(icon, button0, null);
    			append_dev(button0, t26);
    			append_dev(div7, t27);
    			if (if_block) if_block.m(div7, null);
    			append_dev(div7, t28);
    			append_dev(div7, div4);
    			append_dev(div7, t30);
    			append_dev(div7, textarea0);
    			set_input_value(textarea0, /*query*/ ctx[1]);
    			append_dev(div7, t31);
    			append_dev(div7, div5);
    			append_dev(div7, t33);
    			append_dev(div7, textarea1);
    			set_input_value(textarea1, /*preview*/ ctx[4]);
    			append_dev(div7, t34);
    			append_dev(div7, div6);
    			append_dev(div6, button1);
    			append_dev(button1, t35);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*toggleShowWizard*/ ctx[14], false, false, false),
    					listen_dev(textarea0, "input", /*textarea0_input_handler*/ ctx[25]),
    					listen_dev(textarea1, "input", /*textarea1_input_handler*/ ctx[26]),
    					listen_dev(button1, "click", /*handleTransform*/ ctx[13], false, false, false),
    					action_destroyer(focus.call(null, button1))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*selectedPath*/ 1 && input_value_value !== (input_value_value = !isEmpty(/*selectedPath*/ ctx[0])
    			? stringifyPath(/*selectedPath*/ ctx[0])
    			: "(whole document)") && input.value !== input_value_value) {
    				prop_dev(input, "value", input_value_value);
    			}

    			const icon_changes = {};
    			if (dirty[0] & /*showWizard*/ 32) icon_changes.data = /*showWizard*/ ctx[5] ? faCaretDown : faCaretRight;
    			icon.$set(icon_changes);

    			if (/*showWizard*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*showWizard*/ 32) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div7, t28);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*query*/ 2) {
    				set_input_value(textarea0, /*query*/ ctx[1]);
    			}

    			if (dirty[0] & /*preview*/ 16) {
    				set_input_value(textarea1, /*preview*/ ctx[4]);
    			}

    			if (dirty[0] & /*previewHasError*/ 8) {
    				toggle_class(textarea1, "error", /*previewHasError*/ ctx[3]);
    			}

    			if (!current || dirty[0] & /*previewHasError*/ 8) {
    				prop_dev(button1, "disabled", /*previewHasError*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header.$$.fragment, local);
    			transition_in(icon.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header.$$.fragment, local);
    			transition_out(icon.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			destroy_component(header);
    			destroy_component(icon);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const DEFAULT_QUERY = "function query (data) {\n  return data\n}";

    function focus(element) {
    	element.focus();
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let selectedJson;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TransformModal", slots, []);
    	let { id } = $$props;
    	let { json } = $$props;
    	let { selectedPath } = $$props;
    	let { onTransform } = $$props;
    	let { indentation = 2 } = $$props;
    	const { close } = getContext("simple-modal");
    	const stateId = `${id}:${immutableJSONPatch.compileJSONPointer(selectedPath)}`;
    	const state = transformModalState[stateId] || {};
    	let query = state.query || DEFAULT_QUERY;
    	let previewHasError = false;
    	let preview = "";

    	// showWizard is not stored inside a stateId
    	let showWizard = transformModalState.showWizard !== false;

    	let filterField = state.filterField || null;
    	let filterRelation = state.filterRelation || null;
    	let filterValue = state.filterValue || null;
    	let sortField = state.sortField || null;
    	let sortDirection = state.sortDirection || null;
    	let pickFields = state.pickFields || null;

    	function evalTransform(json, query) {
    		// FIXME: replace unsafe new Function with a JS based query language
    		//  As long as we don't persist or fetch queries, there is no security risk.
    		// TODO: only import the most relevant subset of lodash instead of the full library?
    		// eslint-disable-next-line no-new-func
    		const queryFn = new Function("_", `'use strict'; return (${query})`)(_);

    		return queryFn(json);
    	}

    	function updateQuery(newQuery) {
    		console.log("updated query by wizard", newQuery);
    		$$invalidate(1, query = newQuery);
    	}

    	function previewTransform(json, query) {
    		try {
    			const jsonTransformed = evalTransform(json, query);
    			$$invalidate(4, preview = truncate(JSON.stringify(jsonTransformed, null, indentation), MAX_PREVIEW_CHARACTERS));
    			$$invalidate(3, previewHasError = false);
    		} catch(err) {
    			$$invalidate(4, preview = err.toString());
    			$$invalidate(3, previewHasError = true);
    		}
    	}

    	const previewTransformDebounced = debounce$1(previewTransform, DEBOUNCE_DELAY);

    	function handleTransform() {
    		try {
    			const jsonTransformed = evalTransform(selectedJson, query);

    			onTransform([
    				{
    					op: "replace",
    					path: immutableJSONPatch.compileJSONPointer(selectedPath),
    					value: jsonTransformed
    				}
    			]);

    			// remember the selected values for the next time we open the SortModal
    			// just in memory, not persisted
    			transformModalState[stateId] = {
    				query,
    				filterField,
    				filterRelation,
    				filterValue,
    				sortField,
    				sortDirection,
    				pickFields
    			};

    			close();
    		} catch(err) {
    			// this should never occur since we can only press the Transform
    			// button when creating a preview was successful
    			console.error(err);

    			$$invalidate(4, preview = err.toString());
    			$$invalidate(3, previewHasError = true);
    		}
    	}

    	function toggleShowWizard() {
    		$$invalidate(5, showWizard = !showWizard);

    		// not stored inside a stateId
    		transformModalState.showWizard = showWizard;
    	}

    	const writable_props = ["id", "json", "selectedPath", "onTransform", "indentation"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<TransformModal> was created with unknown prop '${key}'`);
    	});

    	function transformwizard_filterField_binding(value) {
    		filterField = value;
    		$$invalidate(6, filterField);
    	}

    	function transformwizard_filterRelation_binding(value) {
    		filterRelation = value;
    		$$invalidate(7, filterRelation);
    	}

    	function transformwizard_filterValue_binding(value) {
    		filterValue = value;
    		$$invalidate(8, filterValue);
    	}

    	function transformwizard_sortField_binding(value) {
    		sortField = value;
    		$$invalidate(9, sortField);
    	}

    	function transformwizard_sortDirection_binding(value) {
    		sortDirection = value;
    		$$invalidate(10, sortDirection);
    	}

    	function transformwizard_pickFields_binding(value) {
    		pickFields = value;
    		$$invalidate(11, pickFields);
    	}

    	function textarea0_input_handler() {
    		query = this.value;
    		$$invalidate(1, query);
    	}

    	function textarea1_input_handler() {
    		preview = this.value;
    		$$invalidate(4, preview);
    	}

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(15, id = $$props.id);
    		if ("json" in $$props) $$invalidate(16, json = $$props.json);
    		if ("selectedPath" in $$props) $$invalidate(0, selectedPath = $$props.selectedPath);
    		if ("onTransform" in $$props) $$invalidate(17, onTransform = $$props.onTransform);
    		if ("indentation" in $$props) $$invalidate(18, indentation = $$props.indentation);
    	};

    	$$self.$capture_state = () => ({
    		faCaretDown,
    		faCaretRight,
    		_,
    		debounce: debounce$1,
    		isEmpty,
    		getContext,
    		Icon,
    		DEBOUNCE_DELAY,
    		MAX_PREVIEW_CHARACTERS,
    		compileJSONPointer: immutableJSONPatch.compileJSONPointer,
    		getIn: immutableJSONPatch.getIn,
    		stringifyPath,
    		truncate,
    		Header,
    		transformModalState,
    		TransformWizard,
    		id,
    		json,
    		selectedPath,
    		onTransform,
    		indentation,
    		DEFAULT_QUERY,
    		close,
    		stateId,
    		state,
    		query,
    		previewHasError,
    		preview,
    		showWizard,
    		filterField,
    		filterRelation,
    		filterValue,
    		sortField,
    		sortDirection,
    		pickFields,
    		evalTransform,
    		updateQuery,
    		previewTransform,
    		previewTransformDebounced,
    		handleTransform,
    		toggleShowWizard,
    		focus,
    		selectedJson
    	});

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(15, id = $$props.id);
    		if ("json" in $$props) $$invalidate(16, json = $$props.json);
    		if ("selectedPath" in $$props) $$invalidate(0, selectedPath = $$props.selectedPath);
    		if ("onTransform" in $$props) $$invalidate(17, onTransform = $$props.onTransform);
    		if ("indentation" in $$props) $$invalidate(18, indentation = $$props.indentation);
    		if ("query" in $$props) $$invalidate(1, query = $$props.query);
    		if ("previewHasError" in $$props) $$invalidate(3, previewHasError = $$props.previewHasError);
    		if ("preview" in $$props) $$invalidate(4, preview = $$props.preview);
    		if ("showWizard" in $$props) $$invalidate(5, showWizard = $$props.showWizard);
    		if ("filterField" in $$props) $$invalidate(6, filterField = $$props.filterField);
    		if ("filterRelation" in $$props) $$invalidate(7, filterRelation = $$props.filterRelation);
    		if ("filterValue" in $$props) $$invalidate(8, filterValue = $$props.filterValue);
    		if ("sortField" in $$props) $$invalidate(9, sortField = $$props.sortField);
    		if ("sortDirection" in $$props) $$invalidate(10, sortDirection = $$props.sortDirection);
    		if ("pickFields" in $$props) $$invalidate(11, pickFields = $$props.pickFields);
    		if ("selectedJson" in $$props) $$invalidate(2, selectedJson = $$props.selectedJson);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*json, selectedPath*/ 65537) {
    			$$invalidate(2, selectedJson = immutableJSONPatch.getIn(json, selectedPath));
    		}

    		if ($$self.$$.dirty[0] & /*selectedJson, query*/ 6) {
    			{
    				previewTransformDebounced(selectedJson, query);
    			}
    		}
    	};

    	return [
    		selectedPath,
    		query,
    		selectedJson,
    		previewHasError,
    		preview,
    		showWizard,
    		filterField,
    		filterRelation,
    		filterValue,
    		sortField,
    		sortDirection,
    		pickFields,
    		updateQuery,
    		handleTransform,
    		toggleShowWizard,
    		id,
    		json,
    		onTransform,
    		indentation,
    		transformwizard_filterField_binding,
    		transformwizard_filterRelation_binding,
    		transformwizard_filterValue_binding,
    		transformwizard_sortField_binding,
    		transformwizard_sortDirection_binding,
    		transformwizard_pickFields_binding,
    		textarea0_input_handler,
    		textarea1_input_handler
    	];
    }

    class TransformModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$k,
    			create_fragment$k,
    			not_equal,
    			{
    				id: 15,
    				json: 16,
    				selectedPath: 0,
    				onTransform: 17,
    				indentation: 18
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TransformModal",
    			options,
    			id: create_fragment$k.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*id*/ ctx[15] === undefined && !("id" in props)) {
    			console_1$3.warn("<TransformModal> was created without expected prop 'id'");
    		}

    		if (/*json*/ ctx[16] === undefined && !("json" in props)) {
    			console_1$3.warn("<TransformModal> was created without expected prop 'json'");
    		}

    		if (/*selectedPath*/ ctx[0] === undefined && !("selectedPath" in props)) {
    			console_1$3.warn("<TransformModal> was created without expected prop 'selectedPath'");
    		}

    		if (/*onTransform*/ ctx[17] === undefined && !("onTransform" in props)) {
    			console_1$3.warn("<TransformModal> was created without expected prop 'onTransform'");
    		}
    	}

    	get id() {
    		throw new Error("<TransformModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<TransformModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get json() {
    		throw new Error("<TransformModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set json(value) {
    		throw new Error("<TransformModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedPath() {
    		throw new Error("<TransformModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedPath(value) {
    		throw new Error("<TransformModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onTransform() {
    		throw new Error("<TransformModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onTransform(value) {
    		throw new Error("<TransformModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indentation() {
    		throw new Error("<TransformModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indentation(value) {
    		throw new Error("<TransformModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* ***** BEGIN LICENSE BLOCK *****
     * Distributed under the BSD license:
     *
     * Copyright (c) 2010, Ajax.org B.V.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *     * Redistributions of source code must retain the above copyright
     *       notice, this list of conditions and the following disclaimer.
     *     * Redistributions in binary form must reproduce the above copyright
     *       notice, this list of conditions and the following disclaimer in the
     *       documentation and/or other materials provided with the distribution.
     *     * Neither the name of Ajax.org B.V. nor the
     *       names of its contributors may be used to endorse or promote products
     *       derived from this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
     * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
     * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     *
     * ***** END LICENSE BLOCK ***** */

    var ace_1 = createCommonjsModule(function (module, exports) {
    /**
     * Define a module along with a payload
     * @param module a name for the payload
     * @param payload a function to call with (require, exports, module) params
     */

    (function() {

    var ACE_NAMESPACE = "ace";

    var global = (function() { return this; })();
    if (!global && typeof window != "undefined") global = window; // strict mode


    var define = function(module, deps, payload) {
        if (typeof module !== "string") {
            if (define.original)
                define.original.apply(this, arguments);
            else {
                console.error("dropping module because define wasn\'t a string.");
                console.trace();
            }
            return;
        }
        if (arguments.length == 2)
            payload = deps;
        if (!define.modules[module]) {
            define.payloads[module] = payload;
            define.modules[module] = null;
        }
    };

    define.modules = {};
    define.payloads = {};

    /**
     * Get at functionality define()ed using the function above
     */
    var _require = function(parentId, module, callback) {
        if (typeof module === "string") {
            var payload = lookup(parentId, module);
            if (payload != undefined) {
                callback && callback();
                return payload;
            }
        } else if (Object.prototype.toString.call(module) === "[object Array]") {
            var params = [];
            for (var i = 0, l = module.length; i < l; ++i) {
                var dep = lookup(parentId, module[i]);
                if (dep == undefined && require.original)
                    return;
                params.push(dep);
            }
            return callback && callback.apply(null, params) || true;
        }
    };

    var require = function(module, callback) {
        var packagedModule = _require("", module, callback);
        if (packagedModule == undefined && require.original)
            return require.original.apply(this, arguments);
        return packagedModule;
    };

    var normalizeModule = function(parentId, moduleName) {
        // normalize plugin requires
        if (moduleName.indexOf("!") !== -1) {
            var chunks = moduleName.split("!");
            return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
        }
        // normalize relative requires
        if (moduleName.charAt(0) == ".") {
            var base = parentId.split("/").slice(0, -1).join("/");
            moduleName = base + "/" + moduleName;

            while(moduleName.indexOf(".") !== -1 && previous != moduleName) {
                var previous = moduleName;
                moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
            }
        }
        return moduleName;
    };

    /**
     * Internal function to lookup moduleNames and resolve them by calling the
     * definition function if needed.
     */
    var lookup = function(parentId, moduleName) {
        moduleName = normalizeModule(parentId, moduleName);

        var module = define.modules[moduleName];
        if (!module) {
            module = define.payloads[moduleName];
            if (typeof module === 'function') {
                var exports = {};
                var mod = {
                    id: moduleName,
                    uri: '',
                    exports: exports,
                    packaged: true
                };

                var req = function(module, callback) {
                    return _require(moduleName, module, callback);
                };

                var returnValue = module(req, exports, mod);
                exports = returnValue || mod.exports;
                define.modules[moduleName] = exports;
                delete define.payloads[moduleName];
            }
            module = define.modules[moduleName] = exports || module;
        }
        return module;
    };

    function exportAce(ns) {
        var root = global;
        if (ns) {
            if (!global[ns])
                global[ns] = {};
            root = global[ns];
        }

        if (!root.define || !root.define.packaged) {
            define.original = root.define;
            root.define = define;
            root.define.packaged = true;
        }

        if (!root.require || !root.require.packaged) {
            require.original = root.require;
            root.require = require;
            root.require.packaged = true;
        }
    }

    exportAce(ACE_NAMESPACE);

    })();

    ace.define("ace/lib/fixoldbrowsers",["require","exports","module"], function(require, exports, module) {
    if (typeof Element != "undefined" && !Element.prototype.remove) {
        Object.defineProperty(Element.prototype, "remove", {
            enumerable: false,
            writable: true,
            configurable: true,
            value: function() { this.parentNode && this.parentNode.removeChild(this); }
        });
    }


    });

    ace.define("ace/lib/useragent",["require","exports","module"], function(require, exports, module) {
    exports.OS = {
        LINUX: "LINUX",
        MAC: "MAC",
        WINDOWS: "WINDOWS"
    };
    exports.getOS = function() {
        if (exports.isMac) {
            return exports.OS.MAC;
        } else if (exports.isLinux) {
            return exports.OS.LINUX;
        } else {
            return exports.OS.WINDOWS;
        }
    };
    var _navigator = typeof navigator == "object" ? navigator : {};

    var os = (/mac|win|linux/i.exec(_navigator.platform) || ["other"])[0].toLowerCase();
    var ua = _navigator.userAgent || "";
    var appName = _navigator.appName || "";
    exports.isWin = (os == "win");
    exports.isMac = (os == "mac");
    exports.isLinux = (os == "linux");
    exports.isIE = 
        (appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0)
        ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1])
        : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]); // for ie
        
    exports.isOldIE = exports.isIE && exports.isIE < 9;
    exports.isGecko = exports.isMozilla = ua.match(/ Gecko\/\d+/);
    exports.isOpera = typeof opera == "object" && Object.prototype.toString.call(window.opera) == "[object Opera]";
    exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

    exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

    exports.isEdge = parseFloat(ua.split(" Edge/")[1]) || undefined;

    exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

    exports.isAndroid = ua.indexOf("Android") >= 0;

    exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;

    exports.isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;

    if (exports.isIOS) exports.isMac = true;

    exports.isMobile = exports.isIOS || exports.isAndroid;

    });

    ace.define("ace/lib/dom",["require","exports","module","ace/lib/useragent"], function(require, exports, module) {

    var useragent = require("./useragent"); 
    var XHTML_NS = "http://www.w3.org/1999/xhtml";

    exports.buildDom = function buildDom(arr, parent, refs) {
        if (typeof arr == "string" && arr) {
            var txt = document.createTextNode(arr);
            if (parent)
                parent.appendChild(txt);
            return txt;
        }
        
        if (!Array.isArray(arr)) {
            if (arr && arr.appendChild && parent)
                parent.appendChild(arr);
            return arr;
        }
        if (typeof arr[0] != "string" || !arr[0]) {
            var els = [];
            for (var i = 0; i < arr.length; i++) {
                var ch = buildDom(arr[i], parent, refs);
                ch && els.push(ch);
            }
            return els;
        }
        
        var el = document.createElement(arr[0]);
        var options = arr[1];
        var childIndex = 1;
        if (options && typeof options == "object" && !Array.isArray(options))
            childIndex = 2;
        for (var i = childIndex; i < arr.length; i++)
            buildDom(arr[i], el, refs);
        if (childIndex == 2) {
            Object.keys(options).forEach(function(n) {
                var val = options[n];
                if (n === "class") {
                    el.className = Array.isArray(val) ? val.join(" ") : val;
                } else if (typeof val == "function" || n == "value" || n[0] == "$") {
                    el[n] = val;
                } else if (n === "ref") {
                    if (refs) refs[val] = el;
                } else if (val != null) {
                    el.setAttribute(n, val);
                }
            });
        }
        if (parent)
            parent.appendChild(el);
        return el;
    };

    exports.getDocumentHead = function(doc) {
        if (!doc)
            doc = document;
        return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
    };

    exports.createElement = function(tag, ns) {
        return document.createElementNS ?
               document.createElementNS(ns || XHTML_NS, tag) :
               document.createElement(tag);
    };

    exports.removeChildren = function(element) {
        element.innerHTML = "";
    };

    exports.createTextNode = function(textContent, element) {
        var doc = element ? element.ownerDocument : document;
        return doc.createTextNode(textContent);
    };

    exports.createFragment = function(element) {
        var doc = element ? element.ownerDocument : document;
        return doc.createDocumentFragment();
    };

    exports.hasCssClass = function(el, name) {
        var classes = (el.className + "").split(/\s+/g);
        return classes.indexOf(name) !== -1;
    };
    exports.addCssClass = function(el, name) {
        if (!exports.hasCssClass(el, name)) {
            el.className += " " + name;
        }
    };
    exports.removeCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g);
        while (true) {
            var index = classes.indexOf(name);
            if (index == -1) {
                break;
            }
            classes.splice(index, 1);
        }
        el.className = classes.join(" ");
    };

    exports.toggleCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g), add = true;
        while (true) {
            var index = classes.indexOf(name);
            if (index == -1) {
                break;
            }
            add = false;
            classes.splice(index, 1);
        }
        if (add)
            classes.push(name);

        el.className = classes.join(" ");
        return add;
    };
    exports.setCssClass = function(node, className, include) {
        if (include) {
            exports.addCssClass(node, className);
        } else {
            exports.removeCssClass(node, className);
        }
    };

    exports.hasCssString = function(id, doc) {
        var index = 0, sheets;
        doc = doc || document;
        if ((sheets = doc.querySelectorAll("style"))) {
            while (index < sheets.length)
                if (sheets[index++].id === id)
                    return true;
        }
    };

    exports.importCssString = function importCssString(cssText, id, target) {
        var container = target;
        if (!target || !target.getRootNode) {
            container = document;
        } else {
            container = target.getRootNode();
            if (!container || container == target)
                container = document;
        }
        
        var doc = container.ownerDocument || container;
        if (id && exports.hasCssString(id, container))
            return null;
        
        if (id)
            cssText += "\n/*# sourceURL=ace/css/" + id + " */";
        
        var style = exports.createElement("style");
        style.appendChild(doc.createTextNode(cssText));
        if (id)
            style.id = id;

        if (container == doc)
            container = exports.getDocumentHead(doc);
        container.insertBefore(style, container.firstChild);
    };

    exports.importCssStylsheet = function(uri, doc) {
        exports.buildDom(["link", {rel: "stylesheet", href: uri}], exports.getDocumentHead(doc));
    };
    exports.scrollbarWidth = function(document) {
        var inner = exports.createElement("ace_inner");
        inner.style.width = "100%";
        inner.style.minWidth = "0px";
        inner.style.height = "200px";
        inner.style.display = "block";

        var outer = exports.createElement("ace_outer");
        var style = outer.style;

        style.position = "absolute";
        style.left = "-10000px";
        style.overflow = "hidden";
        style.width = "200px";
        style.minWidth = "0px";
        style.height = "150px";
        style.display = "block";

        outer.appendChild(inner);

        var body = document.documentElement;
        body.appendChild(outer);

        var noScrollbar = inner.offsetWidth;

        style.overflow = "scroll";
        var withScrollbar = inner.offsetWidth;

        if (noScrollbar == withScrollbar) {
            withScrollbar = outer.clientWidth;
        }

        body.removeChild(outer);

        return noScrollbar-withScrollbar;
    };

    if (typeof document == "undefined") {
        exports.importCssString = function() {};
    }

    exports.computedStyle = function(element, style) {
        return window.getComputedStyle(element, "") || {};
    };

    exports.setStyle = function(styles, property, value) {
        if (styles[property] !== value) {
            styles[property] = value;
        }
    };

    exports.HAS_CSS_ANIMATION = false;
    exports.HAS_CSS_TRANSFORMS = false;
    exports.HI_DPI = useragent.isWin
        ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5
        : true;

    if (typeof document !== "undefined") {
        var div = document.createElement("div");
        if (exports.HI_DPI && div.style.transform  !== undefined)
            exports.HAS_CSS_TRANSFORMS = true;
        if (!useragent.isEdge && typeof div.style.animationName !== "undefined")
            exports.HAS_CSS_ANIMATION = true;
        div = null;
    }

    if (exports.HAS_CSS_TRANSFORMS) {
        exports.translate = function(element, tx, ty) {
            element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) +"px)";
        };
    } else {
        exports.translate = function(element, tx, ty) {
            element.style.top = Math.round(ty) + "px";
            element.style.left = Math.round(tx) + "px";
        };
    }

    });

    ace.define("ace/lib/oop",["require","exports","module"], function(require, exports, module) {

    exports.inherits = function(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    };

    exports.mixin = function(obj, mixin) {
        for (var key in mixin) {
            obj[key] = mixin[key];
        }
        return obj;
    };

    exports.implement = function(proto, mixin) {
        exports.mixin(proto, mixin);
    };

    });

    ace.define("ace/lib/keys",["require","exports","module","ace/lib/oop"], function(require, exports, module) {

    var oop = require("./oop");
    var Keys = (function() {
        var ret = {
            MODIFIER_KEYS: {
                16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta',
                91: 'MetaLeft', 92: 'MetaRight', 93: 'ContextMenu'
            },

            KEY_MODS: {
                "ctrl": 1, "alt": 2, "option" : 2, "shift": 4,
                "super": 8, "meta": 8, "command": 8, "cmd": 8, 
                "control": 1
            },

            FUNCTION_KEYS : {
                8  : "Backspace",
                9  : "Tab",
                13 : "Return",
                19 : "Pause",
                27 : "Esc",
                32 : "Space",
                33 : "PageUp",
                34 : "PageDown",
                35 : "End",
                36 : "Home",
                37 : "Left",
                38 : "Up",
                39 : "Right",
                40 : "Down",
                44 : "Print",
                45 : "Insert",
                46 : "Delete",
                96 : "Numpad0",
                97 : "Numpad1",
                98 : "Numpad2",
                99 : "Numpad3",
                100: "Numpad4",
                101: "Numpad5",
                102: "Numpad6",
                103: "Numpad7",
                104: "Numpad8",
                105: "Numpad9",
                '-13': "NumpadEnter",
                112: "F1",
                113: "F2",
                114: "F3",
                115: "F4",
                116: "F5",
                117: "F6",
                118: "F7",
                119: "F8",
                120: "F9",
                121: "F10",
                122: "F11",
                123: "F12",
                144: "Numlock",
                145: "Scrolllock"
            },

            PRINTABLE_KEYS: {
               32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',
               54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',
               66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',
               73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',
               80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',
               87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',
              186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
              219: '[', 220: '\\',221: ']', 222: "'", 111: '/', 106: '*'
            }
        };
        var name, i;
        for (i in ret.FUNCTION_KEYS) {
            name = ret.FUNCTION_KEYS[i].toLowerCase();
            ret[name] = parseInt(i, 10);
        }
        for (i in ret.PRINTABLE_KEYS) {
            name = ret.PRINTABLE_KEYS[i].toLowerCase();
            ret[name] = parseInt(i, 10);
        }
        oop.mixin(ret, ret.MODIFIER_KEYS);
        oop.mixin(ret, ret.PRINTABLE_KEYS);
        oop.mixin(ret, ret.FUNCTION_KEYS);
        ret.enter = ret["return"];
        ret.escape = ret.esc;
        ret.del = ret["delete"];
        ret[173] = '-';
        
        (function() {
            var mods = ["cmd", "ctrl", "alt", "shift"];
            for (var i = Math.pow(2, mods.length); i--;) {            
                ret.KEY_MODS[i] = mods.filter(function(x) {
                    return i & ret.KEY_MODS[x];
                }).join("-") + "-";
            }
        })();

        ret.KEY_MODS[0] = "";
        ret.KEY_MODS[-1] = "input-";

        return ret;
    })();
    oop.mixin(exports, Keys);

    exports.keyCodeToString = function(keyCode) {
        var keyString = Keys[keyCode];
        if (typeof keyString != "string")
            keyString = String.fromCharCode(keyCode);
        return keyString.toLowerCase();
    };

    });

    ace.define("ace/lib/event",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(require, exports, module) {

    var keys = require("./keys");
    var useragent = require("./useragent");

    var pressedKeys = null;
    var ts = 0;

    var activeListenerOptions;
    function detectListenerOptionsSupport() {
        activeListenerOptions = false;
        try {
            document.createComment("").addEventListener("test", function() {}, { 
                get passive() { 
                    activeListenerOptions = {passive: false};
                }
            });
        } catch(e) {}
    }

    function getListenerOptions() {
        if (activeListenerOptions == undefined)
            detectListenerOptionsSupport();
        return activeListenerOptions;
    }

    function EventListener(elem, type, callback) {
        this.elem = elem;
        this.type = type;
        this.callback = callback;
    }
    EventListener.prototype.destroy = function() {
        removeListener(this.elem, this.type, this.callback);
        this.elem = this.type = this.callback = undefined;
    };

    var addListener = exports.addListener = function(elem, type, callback, destroyer) {
        elem.addEventListener(type, callback, getListenerOptions());
        if (destroyer)
            destroyer.$toDestroy.push(new EventListener(elem, type, callback));
    };

    var removeListener = exports.removeListener = function(elem, type, callback) {
        elem.removeEventListener(type, callback, getListenerOptions());
    };
    exports.stopEvent = function(e) {
        exports.stopPropagation(e);
        exports.preventDefault(e);
        return false;
    };

    exports.stopPropagation = function(e) {
        if (e.stopPropagation)
            e.stopPropagation();
    };

    exports.preventDefault = function(e) {
        if (e.preventDefault)
            e.preventDefault();
    };
    exports.getButton = function(e) {
        if (e.type == "dblclick")
            return 0;
        if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
            return 2;
        return e.button;
    };

    exports.capture = function(el, eventHandler, releaseCaptureHandler) {
        var ownerDocument = el && el.ownerDocument || document;
        function onMouseUp(e) {
            eventHandler && eventHandler(e);
            releaseCaptureHandler && releaseCaptureHandler(e);

            removeListener(ownerDocument, "mousemove", eventHandler);
            removeListener(ownerDocument, "mouseup", onMouseUp);
            removeListener(ownerDocument, "dragstart", onMouseUp);
        }

        addListener(ownerDocument, "mousemove", eventHandler);
        addListener(ownerDocument, "mouseup", onMouseUp);
        addListener(ownerDocument, "dragstart", onMouseUp);
        
        return onMouseUp;
    };

    exports.addMouseWheelListener = function(el, callback, destroyer) {
        if ("onmousewheel" in el) {
            addListener(el, "mousewheel", function(e) {
                var factor = 8;
                if (e.wheelDeltaX !== undefined) {
                    e.wheelX = -e.wheelDeltaX / factor;
                    e.wheelY = -e.wheelDeltaY / factor;
                } else {
                    e.wheelX = 0;
                    e.wheelY = -e.wheelDelta / factor;
                }
                callback(e);
            }, destroyer);
        } else if ("onwheel" in el) {
            addListener(el, "wheel",  function(e) {
                var factor = 0.35;
                switch (e.deltaMode) {
                    case e.DOM_DELTA_PIXEL:
                        e.wheelX = e.deltaX * factor || 0;
                        e.wheelY = e.deltaY * factor || 0;
                        break;
                    case e.DOM_DELTA_LINE:
                    case e.DOM_DELTA_PAGE:
                        e.wheelX = (e.deltaX || 0) * 5;
                        e.wheelY = (e.deltaY || 0) * 5;
                        break;
                }
                
                callback(e);
            }, destroyer);
        } else {
            addListener(el, "DOMMouseScroll", function(e) {
                if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
                    e.wheelX = (e.detail || 0) * 5;
                    e.wheelY = 0;
                } else {
                    e.wheelX = 0;
                    e.wheelY = (e.detail || 0) * 5;
                }
                callback(e);
            }, destroyer);
        }
    };

    exports.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName, destroyer) {
        var clicks = 0;
        var startX, startY, timer; 
        var eventNames = {
            2: "dblclick",
            3: "tripleclick",
            4: "quadclick"
        };

        function onMousedown(e) {
            if (exports.getButton(e) !== 0) {
                clicks = 0;
            } else if (e.detail > 1) {
                clicks++;
                if (clicks > 4)
                    clicks = 1;
            } else {
                clicks = 1;
            }
            if (useragent.isIE) {
                var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
                if (!timer || isNewClick)
                    clicks = 1;
                if (timer)
                    clearTimeout(timer);
                timer = setTimeout(function() {timer = null;}, timeouts[clicks - 1] || 600);

                if (clicks == 1) {
                    startX = e.clientX;
                    startY = e.clientY;
                }
            }
            
            e._clicks = clicks;

            eventHandler[callbackName]("mousedown", e);

            if (clicks > 4)
                clicks = 0;
            else if (clicks > 1)
                return eventHandler[callbackName](eventNames[clicks], e);
        }
        if (!Array.isArray(elements))
            elements = [elements];
        elements.forEach(function(el) {
            addListener(el, "mousedown", onMousedown, destroyer);
        });
    };

    var getModifierHash = function(e) {
        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
    };

    exports.getModifierString = function(e) {
        return keys.KEY_MODS[getModifierHash(e)];
    };

    function normalizeCommandKeys(callback, e, keyCode) {
        var hashId = getModifierHash(e);

        if (!useragent.isMac && pressedKeys) {
            if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
                hashId |= 8;
            if (pressedKeys.altGr) {
                if ((3 & hashId) != 3)
                    pressedKeys.altGr = 0;
                else
                    return;
            }
            if (keyCode === 18 || keyCode === 17) {
                var location = "location" in e ? e.location : e.keyLocation;
                if (keyCode === 17 && location === 1) {
                    if (pressedKeys[keyCode] == 1)
                        ts = e.timeStamp;
                } else if (keyCode === 18 && hashId === 3 && location === 2) {
                    var dt = e.timeStamp - ts;
                    if (dt < 50)
                        pressedKeys.altGr = true;
                }
            }
        }
        
        if (keyCode in keys.MODIFIER_KEYS) {
            keyCode = -1;
        }
        
        if (!hashId && keyCode === 13) {
            var location = "location" in e ? e.location : e.keyLocation;
            if (location === 3) {
                callback(e, hashId, -keyCode);
                if (e.defaultPrevented)
                    return;
            }
        }
        
        if (useragent.isChromeOS && hashId & 8) {
            callback(e, hashId, keyCode);
            if (e.defaultPrevented)
                return;
            else
                hashId &= ~8;
        }
        if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
            return false;
        }
        
        return callback(e, hashId, keyCode);
    }


    exports.addCommandKeyListener = function(el, callback, destroyer) {
        if (useragent.isOldGecko || (useragent.isOpera && !("KeyboardEvent" in window))) {
            var lastKeyDownKeyCode = null;
            addListener(el, "keydown", function(e) {
                lastKeyDownKeyCode = e.keyCode;
            }, destroyer);
            addListener(el, "keypress", function(e) {
                return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
            }, destroyer);
        } else {
            var lastDefaultPrevented = null;

            addListener(el, "keydown", function(e) {
                pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
                var result = normalizeCommandKeys(callback, e, e.keyCode);
                lastDefaultPrevented = e.defaultPrevented;
                return result;
            }, destroyer);

            addListener(el, "keypress", function(e) {
                if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                    exports.stopEvent(e);
                    lastDefaultPrevented = null;
                }
            }, destroyer);

            addListener(el, "keyup", function(e) {
                pressedKeys[e.keyCode] = null;
            }, destroyer);

            if (!pressedKeys) {
                resetPressedKeys();
                addListener(window, "focus", resetPressedKeys);
            }
        }
    };
    function resetPressedKeys() {
        pressedKeys = Object.create(null);
    }

    if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
        var postMessageId = 1;
        exports.nextTick = function(callback, win) {
            win = win || window;
            var messageName = "zero-timeout-message-" + (postMessageId++);
            
            var listener = function(e) {
                if (e.data == messageName) {
                    exports.stopPropagation(e);
                    removeListener(win, "message", listener);
                    callback();
                }
            };
            
            addListener(win, "message", listener);
            win.postMessage(messageName, "*");
        };
    }

    exports.$idleBlocked = false;
    exports.onIdle = function(cb, timeout) {
        return setTimeout(function handler() {
            if (!exports.$idleBlocked) {
                cb();
            } else {
                setTimeout(handler, 100);
            }
        }, timeout);
    };

    exports.$idleBlockId = null;
    exports.blockIdle = function(delay) {
        if (exports.$idleBlockId)
            clearTimeout(exports.$idleBlockId);
            
        exports.$idleBlocked = true;
        exports.$idleBlockId = setTimeout(function() {
            exports.$idleBlocked = false;
        }, delay || 100);
    };

    exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame
        || window.mozRequestAnimationFrame
        || window.webkitRequestAnimationFrame
        || window.msRequestAnimationFrame
        || window.oRequestAnimationFrame);

    if (exports.nextFrame)
        exports.nextFrame = exports.nextFrame.bind(window);
    else
        exports.nextFrame = function(callback) {
            setTimeout(callback, 17);
        };
    });

    ace.define("ace/range",["require","exports","module"], function(require, exports, module) {
    var comparePoints = function(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
    };
    var Range = function(startRow, startColumn, endRow, endColumn) {
        this.start = {
            row: startRow,
            column: startColumn
        };

        this.end = {
            row: endRow,
            column: endColumn
        };
    };

    (function() {
        this.isEqual = function(range) {
            return this.start.row === range.start.row &&
                this.end.row === range.end.row &&
                this.start.column === range.start.column &&
                this.end.column === range.end.column;
        };
        this.toString = function() {
            return ("Range: [" + this.start.row + "/" + this.start.column +
                "] -> [" + this.end.row + "/" + this.end.column + "]");
        };

        this.contains = function(row, column) {
            return this.compare(row, column) == 0;
        };
        this.compareRange = function(range) {
            var cmp,
                end = range.end,
                start = range.start;

            cmp = this.compare(end.row, end.column);
            if (cmp == 1) {
                cmp = this.compare(start.row, start.column);
                if (cmp == 1) {
                    return 2;
                } else if (cmp == 0) {
                    return 1;
                } else {
                    return 0;
                }
            } else if (cmp == -1) {
                return -2;
            } else {
                cmp = this.compare(start.row, start.column);
                if (cmp == -1) {
                    return -1;
                } else if (cmp == 1) {
                    return 42;
                } else {
                    return 0;
                }
            }
        };
        this.comparePoint = function(p) {
            return this.compare(p.row, p.column);
        };
        this.containsRange = function(range) {
            return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
        };
        this.intersects = function(range) {
            var cmp = this.compareRange(range);
            return (cmp == -1 || cmp == 0 || cmp == 1);
        };
        this.isEnd = function(row, column) {
            return this.end.row == row && this.end.column == column;
        };
        this.isStart = function(row, column) {
            return this.start.row == row && this.start.column == column;
        };
        this.setStart = function(row, column) {
            if (typeof row == "object") {
                this.start.column = row.column;
                this.start.row = row.row;
            } else {
                this.start.row = row;
                this.start.column = column;
            }
        };
        this.setEnd = function(row, column) {
            if (typeof row == "object") {
                this.end.column = row.column;
                this.end.row = row.row;
            } else {
                this.end.row = row;
                this.end.column = column;
            }
        };
        this.inside = function(row, column) {
            if (this.compare(row, column) == 0) {
                if (this.isEnd(row, column) || this.isStart(row, column)) {
                    return false;
                } else {
                    return true;
                }
            }
            return false;
        };
        this.insideStart = function(row, column) {
            if (this.compare(row, column) == 0) {
                if (this.isEnd(row, column)) {
                    return false;
                } else {
                    return true;
                }
            }
            return false;
        };
        this.insideEnd = function(row, column) {
            if (this.compare(row, column) == 0) {
                if (this.isStart(row, column)) {
                    return false;
                } else {
                    return true;
                }
            }
            return false;
        };
        this.compare = function(row, column) {
            if (!this.isMultiLine()) {
                if (row === this.start.row) {
                    return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
                }
            }

            if (row < this.start.row)
                return -1;

            if (row > this.end.row)
                return 1;

            if (this.start.row === row)
                return column >= this.start.column ? 0 : -1;

            if (this.end.row === row)
                return column <= this.end.column ? 0 : 1;

            return 0;
        };
        this.compareStart = function(row, column) {
            if (this.start.row == row && this.start.column == column) {
                return -1;
            } else {
                return this.compare(row, column);
            }
        };
        this.compareEnd = function(row, column) {
            if (this.end.row == row && this.end.column == column) {
                return 1;
            } else {
                return this.compare(row, column);
            }
        };
        this.compareInside = function(row, column) {
            if (this.end.row == row && this.end.column == column) {
                return 1;
            } else if (this.start.row == row && this.start.column == column) {
                return -1;
            } else {
                return this.compare(row, column);
            }
        };
        this.clipRows = function(firstRow, lastRow) {
            if (this.end.row > lastRow)
                var end = {row: lastRow + 1, column: 0};
            else if (this.end.row < firstRow)
                var end = {row: firstRow, column: 0};

            if (this.start.row > lastRow)
                var start = {row: lastRow + 1, column: 0};
            else if (this.start.row < firstRow)
                var start = {row: firstRow, column: 0};

            return Range.fromPoints(start || this.start, end || this.end);
        };
        this.extend = function(row, column) {
            var cmp = this.compare(row, column);

            if (cmp == 0)
                return this;
            else if (cmp == -1)
                var start = {row: row, column: column};
            else
                var end = {row: row, column: column};

            return Range.fromPoints(start || this.start, end || this.end);
        };

        this.isEmpty = function() {
            return (this.start.row === this.end.row && this.start.column === this.end.column);
        };
        this.isMultiLine = function() {
            return (this.start.row !== this.end.row);
        };
        this.clone = function() {
            return Range.fromPoints(this.start, this.end);
        };
        this.collapseRows = function() {
            if (this.end.column == 0)
                return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0);
            else
                return new Range(this.start.row, 0, this.end.row, 0);
        };
        this.toScreenRange = function(session) {
            var screenPosStart = session.documentToScreenPosition(this.start);
            var screenPosEnd = session.documentToScreenPosition(this.end);

            return new Range(
                screenPosStart.row, screenPosStart.column,
                screenPosEnd.row, screenPosEnd.column
            );
        };
        this.moveBy = function(row, column) {
            this.start.row += row;
            this.start.column += column;
            this.end.row += row;
            this.end.column += column;
        };

    }).call(Range.prototype);
    Range.fromPoints = function(start, end) {
        return new Range(start.row, start.column, end.row, end.column);
    };
    Range.comparePoints = comparePoints;

    Range.comparePoints = function(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
    };


    exports.Range = Range;
    });

    ace.define("ace/lib/lang",["require","exports","module"], function(require, exports, module) {

    exports.last = function(a) {
        return a[a.length - 1];
    };

    exports.stringReverse = function(string) {
        return string.split("").reverse().join("");
    };

    exports.stringRepeat = function (string, count) {
        var result = '';
        while (count > 0) {
            if (count & 1)
                result += string;

            if (count >>= 1)
                string += string;
        }
        return result;
    };

    var trimBeginRegexp = /^\s\s*/;
    var trimEndRegexp = /\s\s*$/;

    exports.stringTrimLeft = function (string) {
        return string.replace(trimBeginRegexp, '');
    };

    exports.stringTrimRight = function (string) {
        return string.replace(trimEndRegexp, '');
    };

    exports.copyObject = function(obj) {
        var copy = {};
        for (var key in obj) {
            copy[key] = obj[key];
        }
        return copy;
    };

    exports.copyArray = function(array){
        var copy = [];
        for (var i=0, l=array.length; i<l; i++) {
            if (array[i] && typeof array[i] == "object")
                copy[i] = this.copyObject(array[i]);
            else 
                copy[i] = array[i];
        }
        return copy;
    };

    exports.deepCopy = function deepCopy(obj) {
        if (typeof obj !== "object" || !obj)
            return obj;
        var copy;
        if (Array.isArray(obj)) {
            copy = [];
            for (var key = 0; key < obj.length; key++) {
                copy[key] = deepCopy(obj[key]);
            }
            return copy;
        }
        if (Object.prototype.toString.call(obj) !== "[object Object]")
            return obj;
        
        copy = {};
        for (var key in obj)
            copy[key] = deepCopy(obj[key]);
        return copy;
    };

    exports.arrayToMap = function(arr) {
        var map = {};
        for (var i=0; i<arr.length; i++) {
            map[arr[i]] = 1;
        }
        return map;

    };

    exports.createMap = function(props) {
        var map = Object.create(null);
        for (var i in props) {
            map[i] = props[i];
        }
        return map;
    };
    exports.arrayRemove = function(array, value) {
      for (var i = 0; i <= array.length; i++) {
        if (value === array[i]) {
          array.splice(i, 1);
        }
      }
    };

    exports.escapeRegExp = function(str) {
        return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
    };

    exports.escapeHTML = function(str) {
        return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
    };

    exports.getMatchOffsets = function(string, regExp) {
        var matches = [];

        string.replace(regExp, function(str) {
            matches.push({
                offset: arguments[arguments.length-2],
                length: str.length
            });
        });

        return matches;
    };
    exports.deferredCall = function(fcn) {
        var timer = null;
        var callback = function() {
            timer = null;
            fcn();
        };

        var deferred = function(timeout) {
            deferred.cancel();
            timer = setTimeout(callback, timeout || 0);
            return deferred;
        };

        deferred.schedule = deferred;

        deferred.call = function() {
            this.cancel();
            fcn();
            return deferred;
        };

        deferred.cancel = function() {
            clearTimeout(timer);
            timer = null;
            return deferred;
        };
        
        deferred.isPending = function() {
            return timer;
        };

        return deferred;
    };


    exports.delayedCall = function(fcn, defaultTimeout) {
        var timer = null;
        var callback = function() {
            timer = null;
            fcn();
        };

        var _self = function(timeout) {
            if (timer == null)
                timer = setTimeout(callback, timeout || defaultTimeout);
        };

        _self.delay = function(timeout) {
            timer && clearTimeout(timer);
            timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.schedule = _self;

        _self.call = function() {
            this.cancel();
            fcn();
        };

        _self.cancel = function() {
            timer && clearTimeout(timer);
            timer = null;
        };

        _self.isPending = function() {
            return timer;
        };

        return _self;
    };
    });

    ace.define("ace/clipboard",["require","exports","module"], function(require, exports, module) {

    var $cancelT;
    module.exports = { 
        lineMode: false,
        pasteCancelled: function() {
            if ($cancelT && $cancelT > Date.now() - 50)
                return true;
            return $cancelT = false;
        },
        cancel: function() {
            $cancelT = Date.now();
        }
    };

    });

    ace.define("ace/keyboard/textinput",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/lib/dom","ace/lib/lang","ace/clipboard","ace/lib/keys"], function(require, exports, module) {

    var event = require("../lib/event");
    var useragent = require("../lib/useragent");
    var dom = require("../lib/dom");
    var lang = require("../lib/lang");
    var clipboard = require("../clipboard");
    var BROKEN_SETDATA = useragent.isChrome < 18;
    var USE_IE_MIME_TYPE =  useragent.isIE;
    var HAS_FOCUS_ARGS = useragent.isChrome > 63;
    var MAX_LINE_LENGTH = 400;

    var KEYS = require("../lib/keys");
    var MODS = KEYS.KEY_MODS;
    var isIOS = useragent.isIOS;
    var valueResetRegex = isIOS ? /\s/ : /\n/;
    var isMobile = useragent.isMobile;

    var TextInput = function(parentNode, host) {
        var text = dom.createElement("textarea");
        text.className = "ace_text-input";

        text.setAttribute("wrap", "off");
        text.setAttribute("autocorrect", "off");
        text.setAttribute("autocapitalize", "off");
        text.setAttribute("spellcheck", false);

        text.style.opacity = "0";
        parentNode.insertBefore(text, parentNode.firstChild);

        var copied = false;
        var pasted = false;
        var inComposition = false;
        var sendingText = false;
        var tempStyle = '';
        
        if (!isMobile)
            text.style.fontSize = "1px";

        var commandMode = false;
        var ignoreFocusEvents = false;
        
        var lastValue = "";
        var lastSelectionStart = 0;
        var lastSelectionEnd = 0;
        var lastRestoreEnd = 0;
        try { var isFocused = document.activeElement === text; } catch(e) {}
        
        event.addListener(text, "blur", function(e) {
            if (ignoreFocusEvents) return;
            host.onBlur(e);
            isFocused = false;
        }, host);
        event.addListener(text, "focus", function(e) {
            if (ignoreFocusEvents) return;
            isFocused = true;
            if (useragent.isEdge) {
                try {
                    if (!document.hasFocus())
                        return;
                } catch(e) {}
            }
            host.onFocus(e);
            if (useragent.isEdge)
                setTimeout(resetSelection);
            else
                resetSelection();
        }, host);
        this.$focusScroll = false;
        this.focus = function() {
            if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser")
                return text.focus({ preventScroll: true });

            var top = text.style.top;
            text.style.position = "fixed";
            text.style.top = "0px";
            try {
                var isTransformed = text.getBoundingClientRect().top != 0;
            } catch(e) {
                return;
            }
            var ancestors = [];
            if (isTransformed) {
                var t = text.parentElement;
                while (t && t.nodeType == 1) {
                    ancestors.push(t);
                    t.setAttribute("ace_nocontext", true);
                    if (!t.parentElement && t.getRootNode)
                        t = t.getRootNode().host;
                    else
                        t = t.parentElement;
                }
            }
            text.focus({ preventScroll: true });
            if (isTransformed) {
                ancestors.forEach(function(p) {
                    p.removeAttribute("ace_nocontext");
                });
            }
            setTimeout(function() {
                text.style.position = "";
                if (text.style.top == "0px")
                    text.style.top = top;
            }, 0);
        };
        this.blur = function() {
            text.blur();
        };
        this.isFocused = function() {
            return isFocused;
        };
        
        host.on("beforeEndOperation", function() {
            var curOp = host.curOp;
            var commandName = curOp && curOp.command && curOp.command.name;
            if (commandName == "insertstring")
                return;
            var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
            if (inComposition && isUserAction) {
                lastValue = text.value = "";
                onCompositionEnd();
            }
            resetSelection();
        });
        
        var resetSelection = isIOS
        ? function(value) {
            if (!isFocused || (copied && !value) || sendingText) return;
            if (!value) 
                value = "";
            var newValue = "\n ab" + value + "cde fg\n";
            if (newValue != text.value)
                text.value = lastValue = newValue;
            
            var selectionStart = 4;
            var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));

            if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {
                text.setSelectionRange(selectionStart, selectionEnd);
            }
            lastSelectionStart = selectionStart;
            lastSelectionEnd = selectionEnd;
        }
        : function() {
            if (inComposition || sendingText)
                return;
            if (!isFocused && !afterContextMenu)
                return;
            inComposition = true;
            
            var selectionStart = 0;
            var selectionEnd = 0;
            var line = "";

            if (host.session) {
                var selection = host.selection;
                var range = selection.getRange();
                var row = selection.cursor.row;
                selectionStart = range.start.column;
                selectionEnd = range.end.column;
                line = host.session.getLine(row);

                if (range.start.row != row) {
                    var prevLine = host.session.getLine(row - 1);
                    selectionStart = range.start.row < row - 1 ? 0 : selectionStart;
                    selectionEnd += prevLine.length + 1;
                    line = prevLine + "\n" + line;
                }
                else if (range.end.row != row) {
                    var nextLine = host.session.getLine(row + 1);
                    selectionEnd = range.end.row > row  + 1 ? nextLine.length : selectionEnd;
                    selectionEnd += line.length + 1;
                    line = line + "\n" + nextLine;
                }
                else if (isMobile && row > 0) {
                    line = "\n" + line;
                    selectionEnd += 1;
                    selectionStart += 1;
                }

                if (line.length > MAX_LINE_LENGTH) {
                    if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
                        line = line.slice(0, MAX_LINE_LENGTH);
                    } else {
                        line = "\n";
                        if (selectionStart == selectionEnd) {
                            selectionStart = selectionEnd = 0;
                        }
                        else {
                            selectionStart = 0;
                            selectionEnd = 1;
                        }
                    }
                }
            }

            var newValue = line + "\n\n";
            if (newValue != lastValue) {
                text.value = lastValue = newValue;
                lastSelectionStart = lastSelectionEnd = newValue.length;
            }
            if (afterContextMenu) {
                lastSelectionStart = text.selectionStart;
                lastSelectionEnd = text.selectionEnd;
            }
            if (
                lastSelectionEnd != selectionEnd 
                || lastSelectionStart != selectionStart 
                || text.selectionEnd != lastSelectionEnd // on ie edge selectionEnd changes silently after the initialization
            ) {
                try {
                    text.setSelectionRange(selectionStart, selectionEnd);
                    lastSelectionStart = selectionStart;
                    lastSelectionEnd = selectionEnd;
                } catch(e){}
            }
            inComposition = false;
        };
        this.resetSelection = resetSelection;

        if (isFocused)
            host.onFocus();


        var isAllSelected = function(text) {
            return text.selectionStart === 0 && text.selectionEnd >= lastValue.length
                && text.value === lastValue && lastValue
                && text.selectionEnd !== lastSelectionEnd;
        };

        var onSelect = function(e) {
            if (inComposition)
                return;
            if (copied) {
                copied = false;
            } else if (isAllSelected(text)) {
                host.selectAll();
                resetSelection();
            } else if (isMobile && text.selectionStart != lastSelectionStart) {
                resetSelection();
            }
        };

        var inputHandler = null;
        this.setInputHandler = function(cb) {inputHandler = cb;};
        this.getInputHandler = function() {return inputHandler;};
        var afterContextMenu = false;
        
        var sendText = function(value, fromInput) {
            if (afterContextMenu)
                afterContextMenu = false;
            if (pasted) {
                resetSelection();
                if (value)
                    host.onPaste(value);
                pasted = false;
                return "";
            } else {
                var selectionStart = text.selectionStart;
                var selectionEnd = text.selectionEnd;
            
                var extendLeft = lastSelectionStart;
                var extendRight = lastValue.length - lastSelectionEnd;
                
                var inserted = value;
                var restoreStart = value.length - selectionStart;
                var restoreEnd = value.length - selectionEnd;
            
                var i = 0;
                while (extendLeft > 0 && lastValue[i] == value[i]) {
                    i++;
                    extendLeft--;
                }
                inserted = inserted.slice(i);
                i = 1;
                while (extendRight > 0 && lastValue.length - i > lastSelectionStart - 1  && lastValue[lastValue.length - i] == value[value.length - i]) {
                    i++;
                    extendRight--;
                }
                restoreStart -= i-1;
                restoreEnd -= i-1;
                var endIndex = inserted.length - i + 1;
                if (endIndex < 0) {
                    extendLeft = -endIndex;
                    endIndex = 0;
                } 
                inserted = inserted.slice(0, endIndex);
                if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)
                    return "";
                sendingText = true;
                var shouldReset = false;
                if (useragent.isAndroid && inserted == ". ") {
                    inserted = "  ";
                    shouldReset = true;
                }
                
                if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {
                    host.onTextInput(inserted);
                } else {
                    host.onTextInput(inserted, {
                        extendLeft: extendLeft,
                        extendRight: extendRight,
                        restoreStart: restoreStart,
                        restoreEnd: restoreEnd
                    });
                }
                sendingText = false;
                
                lastValue = value;
                lastSelectionStart = selectionStart;
                lastSelectionEnd = selectionEnd;
                lastRestoreEnd = restoreEnd;
                return shouldReset ? "\n" : inserted;
            }
        };
        var onInput = function(e) {
            if (inComposition)
                return onCompositionUpdate();
            if (e && e.inputType) {
                if (e.inputType == "historyUndo") return host.execCommand("undo");
                if (e.inputType == "historyRedo") return host.execCommand("redo");
            }
            var data = text.value;
            var inserted = sendText(data, true);
            if (
                data.length > MAX_LINE_LENGTH + 100 
                || valueResetRegex.test(inserted)
                || isMobile && lastSelectionStart < 1 && lastSelectionStart == lastSelectionEnd
            ) {
                resetSelection();
            }
        };
        
        var handleClipboardData = function(e, data, forceIEMime) {
            var clipboardData = e.clipboardData || window.clipboardData;
            if (!clipboardData || BROKEN_SETDATA)
                return;
            var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
            try {
                if (data) {
                    return clipboardData.setData(mime, data) !== false;
                } else {
                    return clipboardData.getData(mime);
                }
            } catch(e) {
                if (!forceIEMime)
                    return handleClipboardData(e, data, true);
            }
        };

        var doCopy = function(e, isCut) {
            var data = host.getCopyText();
            if (!data)
                return event.preventDefault(e);

            if (handleClipboardData(e, data)) {
                if (isIOS) {
                    resetSelection(data);
                    copied = data;
                    setTimeout(function () {
                        copied = false;
                    }, 10);
                }
                isCut ? host.onCut() : host.onCopy();
                event.preventDefault(e);
            } else {
                copied = true;
                text.value = data;
                text.select();
                setTimeout(function(){
                    copied = false;
                    resetSelection();
                    isCut ? host.onCut() : host.onCopy();
                });
            }
        };
        
        var onCut = function(e) {
            doCopy(e, true);
        };
        
        var onCopy = function(e) {
            doCopy(e, false);
        };
        
        var onPaste = function(e) {
            var data = handleClipboardData(e);
            if (clipboard.pasteCancelled())
                return;
            if (typeof data == "string") {
                if (data)
                    host.onPaste(data, e);
                if (useragent.isIE)
                    setTimeout(resetSelection);
                event.preventDefault(e);
            }
            else {
                text.value = "";
                pasted = true;
            }
        };

        event.addCommandKeyListener(text, host.onCommandKey.bind(host), host);

        event.addListener(text, "select", onSelect, host);
        event.addListener(text, "input", onInput, host);

        event.addListener(text, "cut", onCut, host);
        event.addListener(text, "copy", onCopy, host);
        event.addListener(text, "paste", onPaste, host);
        if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {
            event.addListener(parentNode, "keydown", function(e) {
                if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
                    return;

                switch (e.keyCode) {
                    case 67:
                        onCopy(e);
                        break;
                    case 86:
                        onPaste(e);
                        break;
                    case 88:
                        onCut(e);
                        break;
                }
            }, host);
        }
        var onCompositionStart = function(e) {
            if (inComposition || !host.onCompositionStart || host.$readOnly) 
                return;
            
            inComposition = {};

            if (commandMode)
                return;
            
            if (e.data)
                inComposition.useTextareaForIME = false;
            
            setTimeout(onCompositionUpdate, 0);
            host._signal("compositionStart");
            host.on("mousedown", cancelComposition);
            
            var range = host.getSelectionRange();
            range.end.row = range.start.row;
            range.end.column = range.start.column;
            inComposition.markerRange = range;
            inComposition.selectionStart = lastSelectionStart;
            host.onCompositionStart(inComposition);
            
            if (inComposition.useTextareaForIME) {
                lastValue = text.value = "";
                lastSelectionStart = 0;
                lastSelectionEnd = 0;
            }
            else {
                if (text.msGetInputContext)
                    inComposition.context = text.msGetInputContext();
                if (text.getInputContext)
                    inComposition.context = text.getInputContext();
            }
        };

        var onCompositionUpdate = function() {
            if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
                return;
            if (commandMode)
                return cancelComposition();
            
            if (inComposition.useTextareaForIME) {
                host.onCompositionUpdate(text.value);
            }
            else {
                var data = text.value;
                sendText(data);
                if (inComposition.markerRange) {
                    if (inComposition.context) {
                        inComposition.markerRange.start.column = inComposition.selectionStart
                            = inComposition.context.compositionStartOffset;
                    }
                    inComposition.markerRange.end.column = inComposition.markerRange.start.column
                        + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;
                }
            }
        };

        var onCompositionEnd = function(e) {
            if (!host.onCompositionEnd || host.$readOnly) return;
            inComposition = false;
            host.onCompositionEnd();
            host.off("mousedown", cancelComposition);
            if (e) onInput();
        };
        

        function cancelComposition() {
            ignoreFocusEvents = true;
            text.blur();
            text.focus();
            ignoreFocusEvents = false;
        }

        var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);
        
        function onKeyup(e) {
            if (e.keyCode == 27 && text.value.length < text.selectionStart) {
                if (!inComposition)
                    lastValue = text.value;
                lastSelectionStart = lastSelectionEnd = -1;
                resetSelection();
            }
            syncComposition();
        }

        event.addListener(text, "compositionstart", onCompositionStart, host);
        event.addListener(text, "compositionupdate", onCompositionUpdate, host);
        event.addListener(text, "keyup", onKeyup, host);
        event.addListener(text, "keydown", syncComposition, host);
        event.addListener(text, "compositionend", onCompositionEnd, host);

        this.getElement = function() {
            return text;
        };
        this.setCommandMode = function(value) {
           commandMode = value;
           text.readOnly = false;
        };
        
        this.setReadOnly = function(readOnly) {
            if (!commandMode)
                text.readOnly = readOnly;
        };

        this.setCopyWithEmptySelection = function(value) {
        };

        this.onContextMenu = function(e) {
            afterContextMenu = true;
            resetSelection();
            host._emit("nativecontextmenu", {target: host, domEvent: e});
            this.moveToMouse(e, true);
        };
        
        this.moveToMouse = function(e, bringToFront) {
            if (!tempStyle)
                tempStyle = text.style.cssText;
            text.style.cssText = (bringToFront ? "z-index:100000;" : "")
                + (useragent.isIE ? "opacity:0.1;" : "")
                + "text-indent: -" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + "px;";

            var rect = host.container.getBoundingClientRect();
            var style = dom.computedStyle(host.container);
            var top = rect.top + (parseInt(style.borderTopWidth) || 0);
            var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
            var maxTop = rect.bottom - top - text.clientHeight -2;
            var move = function(e) {
                dom.translate(text, e.clientX - left - 2, Math.min(e.clientY - top - 2, maxTop));
            }; 
            move(e);

            if (e.type != "mousedown")
                return;

            host.renderer.$isMousePressed = true;

            clearTimeout(closeTimeout);
            if (useragent.isWin)
                event.capture(host.container, move, onContextMenuClose);
        };

        this.onContextMenuClose = onContextMenuClose;
        var closeTimeout;
        function onContextMenuClose() {
            clearTimeout(closeTimeout);
            closeTimeout = setTimeout(function () {
                if (tempStyle) {
                    text.style.cssText = tempStyle;
                    tempStyle = '';
                }
                host.renderer.$isMousePressed = false;
                if (host.renderer.$keepTextAreaAtCursor)
                    host.renderer.$moveTextAreaToCursor();
            }, 0);
        }

        var onContextMenu = function(e) {
            host.textInput.onContextMenu(e);
            onContextMenuClose();
        };
        event.addListener(text, "mouseup", onContextMenu, host);
        event.addListener(text, "mousedown", function(e) {
            e.preventDefault();
            onContextMenuClose();
        }, host);
        event.addListener(host.renderer.scroller, "contextmenu", onContextMenu, host);
        event.addListener(text, "contextmenu", onContextMenu, host);
        
        if (isIOS)
            addIosSelectionHandler(parentNode, host, text);

        function addIosSelectionHandler(parentNode, host, text) {
            var typingResetTimeout = null;
            var typing = false;
     
            text.addEventListener("keydown", function (e) {
                if (typingResetTimeout) clearTimeout(typingResetTimeout);
                typing = true;
            }, true);

            text.addEventListener("keyup", function (e) {
                typingResetTimeout = setTimeout(function () {
                    typing = false;
                }, 100);
            }, true);
            var detectArrowKeys = function(e) {
                if (document.activeElement !== text) return;
                if (typing || inComposition || host.$mouseHandler.isMousePressed) return;

                if (copied) {
                    return;
                }
                var selectionStart = text.selectionStart;
                var selectionEnd = text.selectionEnd;
                
                var key = null;
                var modifier = 0;
                if (selectionStart == 0) {
                    key = KEYS.up;
                } else if (selectionStart == 1) {
                    key = KEYS.home;
                } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == "\n") {
                    key = KEYS.end;
                } else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == " ") {
                    key = KEYS.left;
                    modifier = MODS.option;
                } else if (
                    selectionStart < lastSelectionStart
                    || (
                        selectionStart == lastSelectionStart 
                        && lastSelectionEnd != lastSelectionStart
                        && selectionStart == selectionEnd
                    )
                ) {
                    key = KEYS.left;
                } else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split("\n").length > 2) {
                    key = KEYS.down;
                } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == " ") {
                    key = KEYS.right;
                    modifier = MODS.option;
                } else if (
                    selectionEnd > lastSelectionEnd
                    || (
                        selectionEnd == lastSelectionEnd 
                        && lastSelectionEnd != lastSelectionStart
                        && selectionStart == selectionEnd
                    )
                ) {
                    key = KEYS.right;
                }
                
                if (selectionStart !== selectionEnd)
                    modifier |= MODS.shift;

                if (key) {
                    var result = host.onCommandKey({}, modifier, key);
                    if (!result && host.commands) {
                        key = KEYS.keyCodeToString(key);
                        var command = host.commands.findKeyCommand(modifier, key);
                        if (command)
                            host.execCommand(command);
                    }
                    lastSelectionStart = selectionStart;
                    lastSelectionEnd = selectionEnd;
                    resetSelection("");
                }
            };
            document.addEventListener("selectionchange", detectArrowKeys);
            host.on("destroy", function() {
                document.removeEventListener("selectionchange", detectArrowKeys);
            });
        }
    };

    exports.TextInput = TextInput;
    exports.$setUserAgentForTests = function(_isMobile, _isIOS) {
        isMobile = _isMobile;
        isIOS = _isIOS;
    };
    });

    ace.define("ace/mouse/default_handlers",["require","exports","module","ace/lib/useragent"], function(require, exports, module) {

    var useragent = require("../lib/useragent");

    var DRAG_OFFSET = 0; // pixels
    var SCROLL_COOLDOWN_T = 550; // milliseconds

    function DefaultHandlers(mouseHandler) {
        mouseHandler.$clickSelection = null;

        var editor = mouseHandler.editor;
        editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
        editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
        editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
        editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
        editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));

        var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
            "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];

        exports.forEach(function(x) {
            mouseHandler[x] = this[x];
        }, this);

        mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
        mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
    }

    (function() {

        this.onMouseDown = function(ev) {
            var inSelection = ev.inSelection();
            var pos = ev.getDocumentPosition();
            this.mousedownEvent = ev;
            var editor = this.editor;

            var button = ev.getButton();
            if (button !== 0) {
                var selectionRange = editor.getSelectionRange();
                var selectionEmpty = selectionRange.isEmpty();
                if (selectionEmpty || button == 1)
                    editor.selection.moveToPosition(pos);
                if (button == 2) {
                    editor.textInput.onContextMenu(ev.domEvent);
                    if (!useragent.isMozilla)
                        ev.preventDefault();
                }
                return;
            }

            this.mousedownEvent.time = Date.now();
            if (inSelection && !editor.isFocused()) {
                editor.focus();
                if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {
                    this.setState("focusWait");
                    this.captureMouse(ev);
                    return;
                }
            }

            this.captureMouse(ev);
            this.startSelect(pos, ev.domEvent._clicks > 1);
            return ev.preventDefault();
        };

        this.startSelect = function(pos, waitForClickSelection) {
            pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
            var editor = this.editor;
            if (!this.mousedownEvent) return;
            if (this.mousedownEvent.getShiftKey())
                editor.selection.selectToPosition(pos);
            else if (!waitForClickSelection)
                editor.selection.moveToPosition(pos);
            if (!waitForClickSelection)
                this.select();
            if (editor.renderer.scroller.setCapture) {
                editor.renderer.scroller.setCapture();
            }
            editor.setStyle("ace_selecting");
            this.setState("select");
        };

        this.select = function() {
            var anchor, editor = this.editor;
            var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
            if (this.$clickSelection) {
                var cmp = this.$clickSelection.comparePoint(cursor);

                if (cmp == -1) {
                    anchor = this.$clickSelection.end;
                } else if (cmp == 1) {
                    anchor = this.$clickSelection.start;
                } else {
                    var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                    cursor = orientedRange.cursor;
                    anchor = orientedRange.anchor;
                }
                editor.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor.selection.selectToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
        };

        this.extendSelectionBy = function(unitName) {
            var anchor, editor = this.editor;
            var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
            var range = editor.selection[unitName](cursor.row, cursor.column);
            if (this.$clickSelection) {
                var cmpStart = this.$clickSelection.comparePoint(range.start);
                var cmpEnd = this.$clickSelection.comparePoint(range.end);

                if (cmpStart == -1 && cmpEnd <= 0) {
                    anchor = this.$clickSelection.end;
                    if (range.end.row != cursor.row || range.end.column != cursor.column)
                        cursor = range.start;
                } else if (cmpEnd == 1 && cmpStart >= 0) {
                    anchor = this.$clickSelection.start;
                    if (range.start.row != cursor.row || range.start.column != cursor.column)
                        cursor = range.end;
                } else if (cmpStart == -1 && cmpEnd == 1) {
                    cursor = range.end;
                    anchor = range.start;
                } else {
                    var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                    cursor = orientedRange.cursor;
                    anchor = orientedRange.anchor;
                }
                editor.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor.selection.selectToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
        };

        this.selectEnd =
        this.selectAllEnd =
        this.selectByWordsEnd =
        this.selectByLinesEnd = function() {
            this.$clickSelection = null;
            this.editor.unsetStyle("ace_selecting");
            if (this.editor.renderer.scroller.releaseCapture) {
                this.editor.renderer.scroller.releaseCapture();
            }
        };

        this.focusWait = function() {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            var time = Date.now();

            if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)
                this.startSelect(this.mousedownEvent.getDocumentPosition());
        };

        this.onDoubleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor = this.editor;
            var session = editor.session;

            var range = session.getBracketRange(pos);
            if (range) {
                if (range.isEmpty()) {
                    range.start.column--;
                    range.end.column++;
                }
                this.setState("select");
            } else {
                range = editor.selection.getWordRange(pos.row, pos.column);
                this.setState("selectByWords");
            }
            this.$clickSelection = range;
            this.select();
        };

        this.onTripleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor = this.editor;

            this.setState("selectByLines");
            var range = editor.getSelectionRange();
            if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
                this.$clickSelection = editor.selection.getLineRange(range.start.row);
                this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
            } else {
                this.$clickSelection = editor.selection.getLineRange(pos.row);
            }
            this.select();
        };

        this.onQuadClick = function(ev) {
            var editor = this.editor;

            editor.selectAll();
            this.$clickSelection = editor.getSelectionRange();
            this.setState("selectAll");
        };

        this.onMouseWheel = function(ev) {
            if (ev.getAccelKey())
                return;
            if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
                ev.wheelX = ev.wheelY;
                ev.wheelY = 0;
            }
            
            var editor = this.editor;
            
            if (!this.$lastScroll)
                this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };
            
            var prevScroll = this.$lastScroll;
            var t = ev.domEvent.timeStamp;
            var dt = t - prevScroll.t;
            var vx = dt ? ev.wheelX / dt : prevScroll.vx;
            var vy = dt ? ev.wheelY / dt : prevScroll.vy;
            if (dt < SCROLL_COOLDOWN_T) {
                vx = (vx + prevScroll.vx) / 2;
                vy = (vy + prevScroll.vy) / 2;
            }
            
            var direction = Math.abs(vx / vy);
            
            var canScroll = false;
            if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
                canScroll = true;
            if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
                canScroll = true;
                
            if (canScroll) {
                prevScroll.allowed = t;
            } else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {
                var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx)
                    && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);
                if (isSlower) {
                    canScroll = true;
                    prevScroll.allowed = t;
                }
                else {
                    prevScroll.allowed = 0;
                }
            }
            
            prevScroll.t = t;
            prevScroll.vx = vx;
            prevScroll.vy = vy;

            if (canScroll) {
                editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                return ev.stop();
            }
        };

    }).call(DefaultHandlers.prototype);

    exports.DefaultHandlers = DefaultHandlers;

    function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
    }

    function calcRangeOrientation(range, cursor) {
        if (range.start.row == range.end.row)
            var cmp = 2 * cursor.column - range.start.column - range.end.column;
        else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
            var cmp = cursor.column - 4;
        else
            var cmp = 2 * cursor.row - range.start.row - range.end.row;

        if (cmp < 0)
            return {cursor: range.start, anchor: range.end};
        else
            return {cursor: range.end, anchor: range.start};
    }

    });

    ace.define("ace/tooltip",["require","exports","module","ace/lib/oop","ace/lib/dom"], function(require, exports, module) {

    require("./lib/oop");
    var dom = require("./lib/dom");
    function Tooltip (parentNode) {
        this.isOpen = false;
        this.$element = null;
        this.$parentNode = parentNode;
    }

    (function() {
        this.$init = function() {
            this.$element = dom.createElement("div");
            this.$element.className = "ace_tooltip";
            this.$element.style.display = "none";
            this.$parentNode.appendChild(this.$element);
            return this.$element;
        };
        this.getElement = function() {
            return this.$element || this.$init();
        };
        this.setText = function(text) {
            this.getElement().textContent = text;
        };
        this.setHtml = function(html) {
            this.getElement().innerHTML = html;
        };
        this.setPosition = function(x, y) {
            this.getElement().style.left = x + "px";
            this.getElement().style.top = y + "px";
        };
        this.setClassName = function(className) {
            dom.addCssClass(this.getElement(), className);
        };
        this.show = function(text, x, y) {
            if (text != null)
                this.setText(text);
            if (x != null && y != null)
                this.setPosition(x, y);
            if (!this.isOpen) {
                this.getElement().style.display = "block";
                this.isOpen = true;
            }
        };

        this.hide = function() {
            if (this.isOpen) {
                this.getElement().style.display = "none";
                this.isOpen = false;
            }
        };
        this.getHeight = function() {
            return this.getElement().offsetHeight;
        };
        this.getWidth = function() {
            return this.getElement().offsetWidth;
        };
        
        this.destroy = function() {
            this.isOpen = false;
            if (this.$element && this.$element.parentNode) {
                this.$element.parentNode.removeChild(this.$element);
            }
        };

    }).call(Tooltip.prototype);

    exports.Tooltip = Tooltip;
    });

    ace.define("ace/mouse/default_gutter_handler",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/event","ace/tooltip"], function(require, exports, module) {
    var dom = require("../lib/dom");
    var oop = require("../lib/oop");
    var event = require("../lib/event");
    var Tooltip = require("../tooltip").Tooltip;

    function GutterHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var gutter = editor.renderer.$gutterLayer;
        var tooltip = new GutterTooltip(editor.container);

        mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
            if (!editor.isFocused() || e.getButton() != 0)
                return;
            var gutterRegion = gutter.getRegion(e);

            if (gutterRegion == "foldWidgets")
                return;

            var row = e.getDocumentPosition().row;
            var selection = editor.session.selection;

            if (e.getShiftKey())
                selection.selectTo(row, 0);
            else {
                if (e.domEvent.detail == 2) {
                    editor.selectAll();
                    return e.preventDefault();
                }
                mouseHandler.$clickSelection = editor.selection.getLineRange(row);
            }
            mouseHandler.setState("selectByLines");
            mouseHandler.captureMouse(e);
            return e.preventDefault();
        });


        var tooltipTimeout, mouseEvent, tooltipAnnotation;

        function showTooltip() {
            var row = mouseEvent.getDocumentPosition().row;
            var annotation = gutter.$annotations[row];
            if (!annotation)
                return hideTooltip();

            var maxRow = editor.session.getLength();
            if (row == maxRow) {
                var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
                var pos = mouseEvent.$pos;
                if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
                    return hideTooltip();
            }

            if (tooltipAnnotation == annotation)
                return;
            tooltipAnnotation = annotation.text.join("<br/>");

            tooltip.setHtml(tooltipAnnotation);
            tooltip.show();
            editor._signal("showGutterTooltip", tooltip);
            editor.on("mousewheel", hideTooltip);

            if (mouseHandler.$tooltipFollowsMouse) {
                moveTooltip(mouseEvent);
            } else {
                var gutterElement = mouseEvent.domEvent.target;
                var rect = gutterElement.getBoundingClientRect();
                var style = tooltip.getElement().style;
                style.left = rect.right + "px";
                style.top = rect.bottom + "px";
            }
        }

        function hideTooltip() {
            if (tooltipTimeout)
                tooltipTimeout = clearTimeout(tooltipTimeout);
            if (tooltipAnnotation) {
                tooltip.hide();
                tooltipAnnotation = null;
                editor._signal("hideGutterTooltip", tooltip);
                editor.off("mousewheel", hideTooltip);
            }
        }

        function moveTooltip(e) {
            tooltip.setPosition(e.x, e.y);
        }

        mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
            var target = e.domEvent.target || e.domEvent.srcElement;
            if (dom.hasCssClass(target, "ace_fold-widget"))
                return hideTooltip();

            if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
                moveTooltip(e);

            mouseEvent = e;
            if (tooltipTimeout)
                return;
            tooltipTimeout = setTimeout(function() {
                tooltipTimeout = null;
                if (mouseEvent && !mouseHandler.isMousePressed)
                    showTooltip();
                else
                    hideTooltip();
            }, 50);
        });

        event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
            mouseEvent = null;
            if (!tooltipAnnotation || tooltipTimeout)
                return;

            tooltipTimeout = setTimeout(function() {
                tooltipTimeout = null;
                hideTooltip();
            }, 50);
        }, editor);
        
        editor.on("changeSession", hideTooltip);
    }

    function GutterTooltip(parentNode) {
        Tooltip.call(this, parentNode);
    }

    oop.inherits(GutterTooltip, Tooltip);

    (function(){
        this.setPosition = function(x, y) {
            var windowWidth = window.innerWidth || document.documentElement.clientWidth;
            var windowHeight = window.innerHeight || document.documentElement.clientHeight;
            var width = this.getWidth();
            var height = this.getHeight();
            x += 15;
            y += 15;
            if (x + width > windowWidth) {
                x -= (x + width) - windowWidth;
            }
            if (y + height > windowHeight) {
                y -= 20 + height;
            }
            Tooltip.prototype.setPosition.call(this, x, y);
        };

    }).call(GutterTooltip.prototype);



    exports.GutterHandler = GutterHandler;

    });

    ace.define("ace/mouse/mouse_event",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(require, exports, module) {

    var event = require("../lib/event");
    var useragent = require("../lib/useragent");
    var MouseEvent = exports.MouseEvent = function(domEvent, editor) {
        this.domEvent = domEvent;
        this.editor = editor;
        
        this.x = this.clientX = domEvent.clientX;
        this.y = this.clientY = domEvent.clientY;

        this.$pos = null;
        this.$inSelection = null;
        
        this.propagationStopped = false;
        this.defaultPrevented = false;
    };

    (function() {  
        
        this.stopPropagation = function() {
            event.stopPropagation(this.domEvent);
            this.propagationStopped = true;
        };
        
        this.preventDefault = function() {
            event.preventDefault(this.domEvent);
            this.defaultPrevented = true;
        };
        
        this.stop = function() {
            this.stopPropagation();
            this.preventDefault();
        };
        this.getDocumentPosition = function() {
            if (this.$pos)
                return this.$pos;
            
            this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
            return this.$pos;
        };
        this.inSelection = function() {
            if (this.$inSelection !== null)
                return this.$inSelection;
                
            var editor = this.editor;
            

            var selectionRange = editor.getSelectionRange();
            if (selectionRange.isEmpty())
                this.$inSelection = false;
            else {
                var pos = this.getDocumentPosition();
                this.$inSelection = selectionRange.contains(pos.row, pos.column);
            }

            return this.$inSelection;
        };
        this.getButton = function() {
            return event.getButton(this.domEvent);
        };
        this.getShiftKey = function() {
            return this.domEvent.shiftKey;
        };
        
        this.getAccelKey = useragent.isMac
            ? function() { return this.domEvent.metaKey; }
            : function() { return this.domEvent.ctrlKey; };
        
    }).call(MouseEvent.prototype);

    });

    ace.define("ace/mouse/dragdrop_handler",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(require, exports, module) {

    var dom = require("../lib/dom");
    var event = require("../lib/event");
    var useragent = require("../lib/useragent");

    var AUTOSCROLL_DELAY = 200;
    var SCROLL_CURSOR_DELAY = 200;
    var SCROLL_CURSOR_HYSTERESIS = 5;

    function DragdropHandler(mouseHandler) {

        var editor = mouseHandler.editor;

        var blankImage = dom.createElement("img");
        blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        if (useragent.isOpera)
            blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";

        var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];

         exports.forEach(function(x) {
             mouseHandler[x] = this[x];
        }, this);
        editor.on("mousedown", this.onMouseDown.bind(mouseHandler));


        var mouseTarget = editor.container;
        var dragSelectionMarker, x, y;
        var timerId, range;
        var dragCursor, counter = 0;
        var dragOperation;
        var isInternal;
        var autoScrollStartTime;
        var cursorMovedTime;
        var cursorPointOnCaretMoved;

        this.onDragStart = function(e) {
            if (this.cancelDrag || !mouseTarget.draggable) {
                var self = this;
                setTimeout(function(){
                    self.startSelect();
                    self.captureMouse(e);
                }, 0);
                return e.preventDefault();
            }
            range = editor.getSelectionRange();

            var dataTransfer = e.dataTransfer;
            dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
            if (useragent.isOpera) {
                editor.container.appendChild(blankImage);
                blankImage.scrollTop = 0;
            }
            dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
            if (useragent.isOpera) {
                editor.container.removeChild(blankImage);
            }
            dataTransfer.clearData();
            dataTransfer.setData("Text", editor.session.getTextRange());

            isInternal = true;
            this.setState("drag");
        };

        this.onDragEnd = function(e) {
            mouseTarget.draggable = false;
            isInternal = false;
            this.setState(null);
            if (!editor.getReadOnly()) {
                var dropEffect = e.dataTransfer.dropEffect;
                if (!dragOperation && dropEffect == "move")
                    editor.session.remove(editor.getSelectionRange());
                editor.$resetCursorStyle();
            }
            this.editor.unsetStyle("ace_dragging");
            this.editor.renderer.setCursorStyle("");
        };

        this.onDragEnter = function(e) {
            if (editor.getReadOnly() || !canAccept(e.dataTransfer))
                return;
            x = e.clientX;
            y = e.clientY;
            if (!dragSelectionMarker)
                addDragMarker();
            counter++;
            e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
            return event.preventDefault(e);
        };

        this.onDragOver = function(e) {
            if (editor.getReadOnly() || !canAccept(e.dataTransfer))
                return;
            x = e.clientX;
            y = e.clientY;
            if (!dragSelectionMarker) {
                addDragMarker();
                counter++;
            }
            if (onMouseMoveTimer !== null)
                onMouseMoveTimer = null;

            e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
            return event.preventDefault(e);
        };

        this.onDragLeave = function(e) {
            counter--;
            if (counter <= 0 && dragSelectionMarker) {
                clearDragMarker();
                dragOperation = null;
                return event.preventDefault(e);
            }
        };

        this.onDrop = function(e) {
            if (!dragCursor)
                return;
            var dataTransfer = e.dataTransfer;
            if (isInternal) {
                switch (dragOperation) {
                    case "move":
                        if (range.contains(dragCursor.row, dragCursor.column)) {
                            range = {
                                start: dragCursor,
                                end: dragCursor
                            };
                        } else {
                            range = editor.moveText(range, dragCursor);
                        }
                        break;
                    case "copy":
                        range = editor.moveText(range, dragCursor, true);
                        break;
                }
            } else {
                var dropData = dataTransfer.getData('Text');
                range = {
                    start: dragCursor,
                    end: editor.session.insert(dragCursor, dropData)
                };
                editor.focus();
                dragOperation = null;
            }
            clearDragMarker();
            return event.preventDefault(e);
        };

        event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler), editor);

        function scrollCursorIntoView(cursor, prevCursor) {
            var now = Date.now();
            var vMovement = !prevCursor || cursor.row != prevCursor.row;
            var hMovement = !prevCursor || cursor.column != prevCursor.column;
            if (!cursorMovedTime || vMovement || hMovement) {
                editor.moveCursorToPosition(cursor);
                cursorMovedTime = now;
                cursorPointOnCaretMoved = {x: x, y: y};
            } else {
                var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
                if (distance > SCROLL_CURSOR_HYSTERESIS) {
                    cursorMovedTime = null;
                } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                    editor.renderer.scrollCursorIntoView();
                    cursorMovedTime = null;
                }
            }
        }

        function autoScroll(cursor, prevCursor) {
            var now = Date.now();
            var lineHeight = editor.renderer.layerConfig.lineHeight;
            var characterWidth = editor.renderer.layerConfig.characterWidth;
            var editorRect = editor.renderer.scroller.getBoundingClientRect();
            var offsets = {
               x: {
                   left: x - editorRect.left,
                   right: editorRect.right - x
               },
               y: {
                   top: y - editorRect.top,
                   bottom: editorRect.bottom - y
               }
            };
            var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
            var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
            var scrollCursor = {row: cursor.row, column: cursor.column};
            if (nearestXOffset / characterWidth <= 2) {
                scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
            }
            if (nearestYOffset / lineHeight <= 1) {
                scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
            }
            var vScroll = cursor.row != scrollCursor.row;
            var hScroll = cursor.column != scrollCursor.column;
            var vMovement = !prevCursor || cursor.row != prevCursor.row;
            if (vScroll || (hScroll && !vMovement)) {
                if (!autoScrollStartTime)
                    autoScrollStartTime = now;
                else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
                    editor.renderer.scrollCursorIntoView(scrollCursor);
            } else {
                autoScrollStartTime = null;
            }
        }

        function onDragInterval() {
            var prevCursor = dragCursor;
            dragCursor = editor.renderer.screenToTextCoordinates(x, y);
            scrollCursorIntoView(dragCursor, prevCursor);
            autoScroll(dragCursor, prevCursor);
        }

        function addDragMarker() {
            range = editor.selection.toOrientedRange();
            dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
            editor.clearSelection();
            if (editor.isFocused())
                editor.renderer.$cursorLayer.setBlinking(false);
            clearInterval(timerId);
            onDragInterval();
            timerId = setInterval(onDragInterval, 20);
            counter = 0;
            event.addListener(document, "mousemove", onMouseMove);
        }

        function clearDragMarker() {
            clearInterval(timerId);
            editor.session.removeMarker(dragSelectionMarker);
            dragSelectionMarker = null;
            editor.selection.fromOrientedRange(range);
            if (editor.isFocused() && !isInternal)
                editor.$resetCursorStyle();
            range = null;
            dragCursor = null;
            counter = 0;
            autoScrollStartTime = null;
            cursorMovedTime = null;
            event.removeListener(document, "mousemove", onMouseMove);
        }
        var onMouseMoveTimer = null;
        function onMouseMove() {
            if (onMouseMoveTimer == null) {
                onMouseMoveTimer = setTimeout(function() {
                    if (onMouseMoveTimer != null && dragSelectionMarker)
                        clearDragMarker();
                }, 20);
            }
        }

        function canAccept(dataTransfer) {
            var types = dataTransfer.types;
            return !types || Array.prototype.some.call(types, function(type) {
                return type == 'text/plain' || type == 'Text';
            });
        }

        function getDropEffect(e) {
            var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
            var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];

            var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
            var effectAllowed = "uninitialized";
            try {
                effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
            } catch (e) {}
            var dropEffect = "none";

            if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
                dropEffect = "copy";
            else if (moveAllowed.indexOf(effectAllowed) >= 0)
                dropEffect = "move";
            else if (copyAllowed.indexOf(effectAllowed) >= 0)
                dropEffect = "copy";

            return dropEffect;
        }
    }

    (function() {

        this.dragWait = function() {
            var interval = Date.now() - this.mousedownEvent.time;
            if (interval > this.editor.getDragDelay())
                this.startDrag();
        };

        this.dragWaitEnd = function() {
            var target = this.editor.container;
            target.draggable = false;
            this.startSelect(this.mousedownEvent.getDocumentPosition());
            this.selectEnd();
        };

        this.dragReadyEnd = function(e) {
            this.editor.$resetCursorStyle();
            this.editor.unsetStyle("ace_dragging");
            this.editor.renderer.setCursorStyle("");
            this.dragWaitEnd();
        };

        this.startDrag = function(){
            this.cancelDrag = false;
            var editor = this.editor;
            var target = editor.container;
            target.draggable = true;
            editor.renderer.$cursorLayer.setBlinking(false);
            editor.setStyle("ace_dragging");
            var cursorStyle = useragent.isWin ? "default" : "move";
            editor.renderer.setCursorStyle(cursorStyle);
            this.setState("dragReady");
        };

        this.onMouseDrag = function(e) {
            var target = this.editor.container;
            if (useragent.isIE && this.state == "dragReady") {
                var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                if (distance > 3)
                    target.dragDrop();
            }
            if (this.state === "dragWait") {
                var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                if (distance > 0) {
                    target.draggable = false;
                    this.startSelect(this.mousedownEvent.getDocumentPosition());
                }
            }
        };

        this.onMouseDown = function(e) {
            if (!this.$dragEnabled)
                return;
            this.mousedownEvent = e;
            var editor = this.editor;

            var inSelection = e.inSelection();
            var button = e.getButton();
            var clickCount = e.domEvent.detail || 1;
            if (clickCount === 1 && button === 0 && inSelection) {
                if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
                    return;
                this.mousedownEvent.time = Date.now();
                var eventTarget = e.domEvent.target || e.domEvent.srcElement;
                if ("unselectable" in eventTarget)
                    eventTarget.unselectable = "on";
                if (editor.getDragDelay()) {
                    if (useragent.isWebKit) {
                        this.cancelDrag = true;
                        var mouseTarget = editor.container;
                        mouseTarget.draggable = true;
                    }
                    this.setState("dragWait");
                } else {
                    this.startDrag();
                }
                this.captureMouse(e, this.onMouseDrag.bind(this));
                e.defaultPrevented = true;
            }
        };

    }).call(DragdropHandler.prototype);


    function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
    }

    exports.DragdropHandler = DragdropHandler;

    });

    ace.define("ace/mouse/touch_handler",["require","exports","module","ace/mouse/mouse_event","ace/lib/event","ace/lib/dom"], function(require, exports, module) {

    var MouseEvent = require("./mouse_event").MouseEvent;
    var event = require("../lib/event");
    var dom = require("../lib/dom");

    exports.addTouchListeners = function(el, editor) {
        var mode = "scroll";
        var startX;
        var startY;
        var touchStartT;
        var lastT;
        var longTouchTimer;
        var animationTimer;
        var animationSteps = 0;
        var pos;
        var clickCount = 0;
        var vX = 0;
        var vY = 0;
        var pressed;
        var contextMenu;
        
        function createContextMenu() {
            var clipboard = window.navigator && window.navigator.clipboard;
            var isOpen = false;
            var updateMenu = function() {
                var selected = editor.getCopyText();
                var hasUndo = editor.session.getUndoManager().hasUndo();
                contextMenu.replaceChild(
                    dom.buildDom(isOpen ? ["span",
                        !selected && ["span", { class: "ace_mobile-button", action: "selectall" }, "Select All"],
                        selected && ["span", { class: "ace_mobile-button", action: "copy" }, "Copy"],
                        selected && ["span", { class: "ace_mobile-button", action: "cut" }, "Cut"],
                        clipboard && ["span", { class: "ace_mobile-button", action: "paste" }, "Paste"],
                        hasUndo && ["span", { class: "ace_mobile-button", action: "undo" }, "Undo"],
                        ["span", { class: "ace_mobile-button", action: "find" }, "Find"],
                        ["span", { class: "ace_mobile-button", action: "openCommandPallete" }, "Pallete"]
                    ] : ["span"]),
                    contextMenu.firstChild
                );
            };
            var handleClick = function(e) {
                var action = e.target.getAttribute("action");

                if (action == "more" || !isOpen) {
                    isOpen = !isOpen;
                    return updateMenu();
                }
                if (action == "paste") {
                    clipboard.readText().then(function (text) {
                        editor.execCommand(action, text);
                    });
                }
                else if (action) {
                    if (action == "cut" || action == "copy") {
                        if (clipboard)
                            clipboard.writeText(editor.getCopyText());
                        else
                            document.execCommand("copy");
                    }
                    editor.execCommand(action);
                }
                contextMenu.firstChild.style.display = "none";
                isOpen = false;
                if (action != "openCommandPallete")
                    editor.focus();
            };
            contextMenu = dom.buildDom(["div",
                {
                    class: "ace_mobile-menu",
                    ontouchstart: function(e) {
                        mode = "menu";
                        e.stopPropagation();
                        e.preventDefault();
                        editor.textInput.focus();
                    },
                    ontouchend: function(e) {
                        e.stopPropagation();
                        e.preventDefault();
                        handleClick(e);
                    },
                    onclick: handleClick
                },
                ["span"],
                ["span", { class: "ace_mobile-button", action: "more" }, "..."]
            ], editor.container);
        }
        function showContextMenu() {
            if (!contextMenu) createContextMenu();
            var cursor = editor.selection.cursor;
            var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);
            var leftOffset = editor.renderer.textToScreenCoordinates(0, 0).pageX;
            var scrollLeft = editor.renderer.scrollLeft;
            var rect = editor.container.getBoundingClientRect();
            contextMenu.style.top = pagePos.pageY - rect.top - 3 + "px";
            if (pagePos.pageX - rect.left < rect.width - 70) {
                contextMenu.style.left = "";
                contextMenu.style.right = "10px";
            } else {
                contextMenu.style.right = "";
                contextMenu.style.left = leftOffset + scrollLeft - rect.left + "px";
            }
            contextMenu.style.display = "";
            contextMenu.firstChild.style.display = "none";
            editor.on("input", hideContextMenu);
        }
        function hideContextMenu(e) {
            if (contextMenu)
                contextMenu.style.display = "none";
            editor.off("input", hideContextMenu);
        }

        function handleLongTap() {
            longTouchTimer = null;
            clearTimeout(longTouchTimer);
            var range = editor.selection.getRange();
            var inSelection = range.contains(pos.row, pos.column);
            if (range.isEmpty() || !inSelection) {
                editor.selection.moveToPosition(pos);
                editor.selection.selectWord();
            }
            mode = "wait";
            showContextMenu();
        }
        function switchToSelectionMode() {
            longTouchTimer = null;
            clearTimeout(longTouchTimer);
            editor.selection.moveToPosition(pos);
            var range = clickCount >= 2
                ? editor.selection.getLineRange(pos.row)
                : editor.session.getBracketRange(pos);
            if (range && !range.isEmpty()) {
                editor.selection.setRange(range);
            } else {
                editor.selection.selectWord();
            }
            mode = "wait";
        }
        event.addListener(el, "contextmenu", function(e) {
            if (!pressed) return;
            var textarea = editor.textInput.getElement();
            textarea.focus();
        }, editor);
        event.addListener(el, "touchstart", function (e) {
            var touches = e.touches;
            if (longTouchTimer || touches.length > 1) {
                clearTimeout(longTouchTimer);
                longTouchTimer = null;
                touchStartT = -1;
                mode = "zoom";
                return;
            }
            
            pressed = editor.$mouseHandler.isMousePressed = true;
            var h = editor.renderer.layerConfig.lineHeight;
            var w = editor.renderer.layerConfig.lineHeight;
            var t = e.timeStamp;
            lastT = t;
            var touchObj = touches[0];
            var x = touchObj.clientX;
            var y = touchObj.clientY;
            if (Math.abs(startX - x) + Math.abs(startY - y) > h)
                touchStartT = -1;
            
            startX = e.clientX = x;
            startY = e.clientY = y;
            vX = vY = 0;
            
            var ev = new MouseEvent(e, editor);
            pos = ev.getDocumentPosition();

            if (t - touchStartT < 500 && touches.length == 1 && !animationSteps) {
                clickCount++;
                e.preventDefault();
                e.button = 0;
                switchToSelectionMode();
            } else {
                clickCount = 0;
                var cursor = editor.selection.cursor;
                var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;
                
                var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);
                var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);
                var rect = editor.renderer.scroller.getBoundingClientRect();
                var offsetTop = editor.renderer.layerConfig.offset;
                var offsetLeft = editor.renderer.scrollLeft;
                var weightedDistance = function(x, y) {
                    x = x / w;
                    y = y / h - 0.75;
                    return x * x + y * y;
                };
                
                if (e.clientX < rect.left) {
                    mode = "zoom";
                    return;
                }
                
                var diff1 = weightedDistance(
                    e.clientX - rect.left - cursorPos.left + offsetLeft,
                    e.clientY - rect.top - cursorPos.top + offsetTop
                );
                var diff2 = weightedDistance(
                    e.clientX - rect.left - anchorPos.left + offsetLeft,
                    e.clientY - rect.top - anchorPos.top + offsetTop
                );
                if (diff1 < 3.5 && diff2 < 3.5)
                    mode = diff1 > diff2 ? "cursor" : "anchor";
                    
                if (diff2 < 3.5)
                    mode = "anchor";
                else if (diff1 < 3.5)
                    mode = "cursor";
                else
                    mode = "scroll";
                longTouchTimer = setTimeout(handleLongTap, 450);
            }
            touchStartT = t;
        }, editor);

        event.addListener(el, "touchend", function (e) {
            pressed = editor.$mouseHandler.isMousePressed = false;
            if (animationTimer) clearInterval(animationTimer);
            if (mode == "zoom") {
                mode = "";
                animationSteps = 0;
            } else if (longTouchTimer) {
                editor.selection.moveToPosition(pos);
                animationSteps = 0;
                showContextMenu();
            } else if (mode == "scroll") {
                animate();
                hideContextMenu();
            } else {
                showContextMenu();
            }
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
        }, editor);
        event.addListener(el, "touchmove", function (e) {
            if (longTouchTimer) {
                clearTimeout(longTouchTimer);
                longTouchTimer = null;
            }
            var touches = e.touches;
            if (touches.length > 1 || mode == "zoom") return;

            var touchObj = touches[0];

            var wheelX = startX - touchObj.clientX;
            var wheelY = startY - touchObj.clientY;

            if (mode == "wait") {
                if (wheelX * wheelX + wheelY * wheelY > 4)
                    mode = "cursor";
                else
                    return e.preventDefault();
            }

            startX = touchObj.clientX;
            startY = touchObj.clientY;

            e.clientX = touchObj.clientX;
            e.clientY = touchObj.clientY;

            var t = e.timeStamp;
            var dt = t - lastT;
            lastT = t;
            if (mode == "scroll") {
                var mouseEvent = new MouseEvent(e, editor);
                mouseEvent.speed = 1;
                mouseEvent.wheelX = wheelX;
                mouseEvent.wheelY = wheelY;
                if (10 * Math.abs(wheelX) < Math.abs(wheelY)) wheelX = 0;
                if (10 * Math.abs(wheelY) < Math.abs(wheelX)) wheelY = 0;
                if (dt != 0) {
                    vX = wheelX / dt;
                    vY = wheelY / dt;
                }
                editor._emit("mousewheel", mouseEvent);
                if (!mouseEvent.propagationStopped) {
                    vX = vY = 0;
                }
            }
            else {
                var ev = new MouseEvent(e, editor);
                var pos = ev.getDocumentPosition();
                if (mode == "cursor")
                    editor.selection.moveCursorToPosition(pos);
                else if (mode == "anchor")
                    editor.selection.setSelectionAnchor(pos.row, pos.column);
                editor.renderer.scrollCursorIntoView(pos);
                e.preventDefault();
            }
        }, editor);

        function animate() {
            animationSteps += 60;
            animationTimer = setInterval(function() {
                if (animationSteps-- <= 0) {
                    clearInterval(animationTimer);
                    animationTimer = null;
                }
                if (Math.abs(vX) < 0.01) vX = 0;
                if (Math.abs(vY) < 0.01) vY = 0;
                if (animationSteps < 20) vX = 0.9 * vX;
                if (animationSteps < 20) vY = 0.9 * vY;
                var oldScrollTop = editor.session.getScrollTop();
                editor.renderer.scrollBy(10 * vX, 10 * vY);
                if (oldScrollTop == editor.session.getScrollTop())
                    animationSteps = 0;
            }, 10);
        }
    };

    });

    ace.define("ace/lib/net",["require","exports","module","ace/lib/dom"], function(require, exports, module) {
    var dom = require("./dom");

    exports.get = function (url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                callback(xhr.responseText);
            }
        };
        xhr.send(null);
    };

    exports.loadScript = function(path, callback) {
        var head = dom.getDocumentHead();
        var s = document.createElement('script');

        s.src = path;
        head.appendChild(s);

        s.onload = s.onreadystatechange = function(_, isAbort) {
            if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
                s = s.onload = s.onreadystatechange = null;
                if (!isAbort)
                    callback();
            }
        };
    };
    exports.qualifyURL = function(url) {
        var a = document.createElement('a');
        a.href = url;
        return a.href;
    };

    });

    ace.define("ace/lib/event_emitter",["require","exports","module"], function(require, exports, module) {

    var EventEmitter = {};
    var stopPropagation = function() { this.propagationStopped = true; };
    var preventDefault = function() { this.defaultPrevented = true; };

    EventEmitter._emit =
    EventEmitter._dispatchEvent = function(eventName, e) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});

        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length && !defaultHandler)
            return;

        if (typeof e != "object" || !e)
            e = {};

        if (!e.type)
            e.type = eventName;
        if (!e.stopPropagation)
            e.stopPropagation = stopPropagation;
        if (!e.preventDefault)
            e.preventDefault = preventDefault;

        listeners = listeners.slice();
        for (var i=0; i<listeners.length; i++) {
            listeners[i](e, this);
            if (e.propagationStopped)
                break;
        }
        
        if (defaultHandler && !e.defaultPrevented)
            return defaultHandler(e, this);
    };


    EventEmitter._signal = function(eventName, e) {
        var listeners = (this._eventRegistry || {})[eventName];
        if (!listeners)
            return;
        listeners = listeners.slice();
        for (var i=0; i<listeners.length; i++)
            listeners[i](e, this);
    };

    EventEmitter.once = function(eventName, callback) {
        var _self = this;
        this.on(eventName, function newCallback() {
            _self.off(eventName, newCallback);
            callback.apply(null, arguments);
        });
        if (!callback) {
            return new Promise(function(resolve) {
                callback = resolve;
            });
        }
    };


    EventEmitter.setDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
            handlers = this._defaultHandlers = {_disabled_: {}};
        
        if (handlers[eventName]) {
            var old = handlers[eventName];
            var disabled = handlers._disabled_[eventName];
            if (!disabled)
                handlers._disabled_[eventName] = disabled = [];
            disabled.push(old);
            var i = disabled.indexOf(callback);
            if (i != -1) 
                disabled.splice(i, 1);
        }
        handlers[eventName] = callback;
    };
    EventEmitter.removeDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
            return;
        var disabled = handlers._disabled_[eventName];
        
        if (handlers[eventName] == callback) {
            if (disabled)
                this.setDefaultHandler(eventName, disabled.pop());
        } else if (disabled) {
            var i = disabled.indexOf(callback);
            if (i != -1)
                disabled.splice(i, 1);
        }
    };

    EventEmitter.on =
    EventEmitter.addEventListener = function(eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};

        var listeners = this._eventRegistry[eventName];
        if (!listeners)
            listeners = this._eventRegistry[eventName] = [];

        if (listeners.indexOf(callback) == -1)
            listeners[capturing ? "unshift" : "push"](callback);
        return callback;
    };

    EventEmitter.off =
    EventEmitter.removeListener =
    EventEmitter.removeEventListener = function(eventName, callback) {
        this._eventRegistry = this._eventRegistry || {};

        var listeners = this._eventRegistry[eventName];
        if (!listeners)
            return;

        var index = listeners.indexOf(callback);
        if (index !== -1)
            listeners.splice(index, 1);
    };

    EventEmitter.removeAllListeners = function(eventName) {
        if (!eventName) this._eventRegistry = this._defaultHandlers = undefined;
        if (this._eventRegistry) this._eventRegistry[eventName] = undefined;
        if (this._defaultHandlers) this._defaultHandlers[eventName] = undefined;
    };

    exports.EventEmitter = EventEmitter;

    });

    ace.define("ace/lib/app_config",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module) {
    "no use strict";

    var oop = require("./oop");
    var EventEmitter = require("./event_emitter").EventEmitter;

    var optionsProvider = {
        setOptions: function(optList) {
            Object.keys(optList).forEach(function(key) {
                this.setOption(key, optList[key]);
            }, this);
        },
        getOptions: function(optionNames) {
            var result = {};
            if (!optionNames) {
                var options = this.$options;
                optionNames = Object.keys(options).filter(function(key) {
                    return !options[key].hidden;
                });
            } else if (!Array.isArray(optionNames)) {
                result = optionNames;
                optionNames = Object.keys(result);
            }
            optionNames.forEach(function(key) {
                result[key] = this.getOption(key);
            }, this);
            return result;
        },
        setOption: function(name, value) {
            if (this["$" + name] === value)
                return;
            var opt = this.$options[name];
            if (!opt) {
                return warn('misspelled option "' + name + '"');
            }
            if (opt.forwardTo)
                return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);

            if (!opt.handlesSet)
                this["$" + name] = value;
            if (opt && opt.set)
                opt.set.call(this, value);
        },
        getOption: function(name) {
            var opt = this.$options[name];
            if (!opt) {
                return warn('misspelled option "' + name + '"');
            }
            if (opt.forwardTo)
                return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
            return opt && opt.get ? opt.get.call(this) : this["$" + name];
        }
    };

    function warn(message) {
        if (typeof console != "undefined" && console.warn)
            console.warn.apply(console, arguments);
    }

    function reportError(msg, data) {
        var e = new Error(msg);
        e.data = data;
        if (typeof console == "object" && console.error)
            console.error(e);
        setTimeout(function() { throw e; });
    }

    var AppConfig = function() {
        this.$defaultOptions = {};
    };

    (function() {
        oop.implement(this, EventEmitter);
        this.defineOptions = function(obj, path, options) {
            if (!obj.$options)
                this.$defaultOptions[path] = obj.$options = {};

            Object.keys(options).forEach(function(key) {
                var opt = options[key];
                if (typeof opt == "string")
                    opt = {forwardTo: opt};

                opt.name || (opt.name = key);
                obj.$options[opt.name] = opt;
                if ("initialValue" in opt)
                    obj["$" + opt.name] = opt.initialValue;
            });
            oop.implement(obj, optionsProvider);

            return this;
        };

        this.resetOptions = function(obj) {
            Object.keys(obj.$options).forEach(function(key) {
                var opt = obj.$options[key];
                if ("value" in opt)
                    obj.setOption(key, opt.value);
            });
        };

        this.setDefaultValue = function(path, name, value) {
            if (!path) {
                for (path in this.$defaultOptions)
                    if (this.$defaultOptions[path][name])
                        break;
                if (!this.$defaultOptions[path][name])
                    return false;
            }
            var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
            if (opts[name]) {
                if (opts.forwardTo)
                    this.setDefaultValue(opts.forwardTo, name, value);
                else
                    opts[name].value = value;
            }
        };

        this.setDefaultValues = function(path, optionHash) {
            Object.keys(optionHash).forEach(function(key) {
                this.setDefaultValue(path, key, optionHash[key]);
            }, this);
        };
        
        this.warn = warn;
        this.reportError = reportError;
        
    }).call(AppConfig.prototype);

    exports.AppConfig = AppConfig;

    });

    ace.define("ace/config",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/lib/net","ace/lib/app_config"], function(require, exports, module) {
    "no use strict";

    var lang = require("./lib/lang");
    require("./lib/oop");
    var net = require("./lib/net");
    var AppConfig = require("./lib/app_config").AppConfig;

    module.exports = exports = new AppConfig();

    var global = (function() {
        return this || typeof window != "undefined" && window;
    })();

    var options = {
        packaged: false,
        workerPath: null,
        modePath: null,
        themePath: null,
        basePath: "",
        suffix: ".js",
        $moduleUrls: {},
        loadWorkerFromBlob: true,
        sharedPopups: false
    };

    exports.get = function(key) {
        if (!options.hasOwnProperty(key))
            throw new Error("Unknown config key: " + key);

        return options[key];
    };

    exports.set = function(key, value) {
        if (options.hasOwnProperty(key))
            options[key] = value;
        else if (this.setDefaultValue("", key, value) == false)
            throw new Error("Unknown config key: " + key);
    };

    exports.all = function() {
        return lang.copyObject(options);
    };

    exports.$modes = {};
    exports.moduleUrl = function(name, component) {
        if (options.$moduleUrls[name])
            return options.$moduleUrls[name];

        var parts = name.split("/");
        component = component || parts[parts.length - 2] || "";
        var sep = component == "snippets" ? "/" : "-";
        var base = parts[parts.length - 1];
        if (component == "worker" && sep == "-") {
            var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
            base = base.replace(re, "");
        }

        if ((!base || base == component) && parts.length > 1)
            base = parts[parts.length - 2];
        var path = options[component + "Path"];
        if (path == null) {
            path = options.basePath;
        } else if (sep == "/") {
            component = sep = "";
        }
        if (path && path.slice(-1) != "/")
            path += "/";
        return path + component + sep + base + this.get("suffix");
    };

    exports.setModuleUrl = function(name, subst) {
        return options.$moduleUrls[name] = subst;
    };

    exports.$loading = {};
    exports.loadModule = function(moduleName, onLoad) {
        var module, moduleType;
        if (Array.isArray(moduleName)) {
            moduleType = moduleName[0];
            moduleName = moduleName[1];
        }

        try {
            module = require(moduleName);
        } catch (e) {}
        if (module && !exports.$loading[moduleName])
            return onLoad && onLoad(module);

        if (!exports.$loading[moduleName])
            exports.$loading[moduleName] = [];

        exports.$loading[moduleName].push(onLoad);

        if (exports.$loading[moduleName].length > 1)
            return;

        var afterLoad = function() {
            require([moduleName], function(module) {
                exports._emit("load.module", {name: moduleName, module: module});
                var listeners = exports.$loading[moduleName];
                exports.$loading[moduleName] = null;
                listeners.forEach(function(onLoad) {
                    onLoad && onLoad(module);
                });
            });
        };

        if (!exports.get("packaged"))
            return afterLoad();
        
        net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
        reportErrorIfPathIsNotConfigured();
    };

    var reportErrorIfPathIsNotConfigured = function() {
        if (
            !options.basePath && !options.workerPath 
            && !options.modePath && !options.themePath
            && !Object.keys(options.$moduleUrls).length
        ) {
            console.error(
                "Unable to infer path to ace from script src,",
                "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes",
                "or with webpack use ace/webpack-resolver"
            );
            reportErrorIfPathIsNotConfigured = function() {};
        }
    };
    init(true);function init(packaged) {

        if (!global || !global.document)
            return;
        
        options.packaged = packaged || require.packaged || module.packaged || (global.define && undefined.packaged);

        var scriptOptions = {};
        var scriptUrl = "";
        var currentScript = (document.currentScript || document._currentScript ); // native or polyfill
        var currentDocument = currentScript && currentScript.ownerDocument || document;
        
        var scripts = currentDocument.getElementsByTagName("script");
        for (var i=0; i<scripts.length; i++) {
            var script = scripts[i];

            var src = script.src || script.getAttribute("src");
            if (!src)
                continue;

            var attributes = script.attributes;
            for (var j=0, l=attributes.length; j < l; j++) {
                var attr = attributes[j];
                if (attr.name.indexOf("data-ace-") === 0) {
                    scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
                }
            }

            var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
            if (m)
                scriptUrl = m[1];
        }

        if (scriptUrl) {
            scriptOptions.base = scriptOptions.base || scriptUrl;
            scriptOptions.packaged = true;
        }

        scriptOptions.basePath = scriptOptions.base;
        scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
        scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
        scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
        delete scriptOptions.base;

        for (var key in scriptOptions)
            if (typeof scriptOptions[key] !== "undefined")
                exports.set(key, scriptOptions[key]);
    }

    exports.init = init;

    function deHyphenate(str) {
        return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });
    }

    exports.version = "1.4.12";

    });

    ace.define("ace/mouse/mouse_handler",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/mouse/default_handlers","ace/mouse/default_gutter_handler","ace/mouse/mouse_event","ace/mouse/dragdrop_handler","ace/mouse/touch_handler","ace/config"], function(require, exports, module) {

    var event = require("../lib/event");
    var useragent = require("../lib/useragent");
    var DefaultHandlers = require("./default_handlers").DefaultHandlers;
    var DefaultGutterHandler = require("./default_gutter_handler").GutterHandler;
    var MouseEvent = require("./mouse_event").MouseEvent;
    var DragdropHandler = require("./dragdrop_handler").DragdropHandler;
    var addTouchListeners = require("./touch_handler").addTouchListeners;
    var config = require("../config");

    var MouseHandler = function(editor) {
        var _self = this;
        this.editor = editor;

        new DefaultHandlers(this);
        new DefaultGutterHandler(this);
        new DragdropHandler(this);

        var focusEditor = function(e) {
            var windowBlurred = !document.hasFocus || !document.hasFocus()
                || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
            if (windowBlurred)
                window.focus();
            editor.focus();
        };

        var mouseTarget = editor.renderer.getMouseEventTarget();
        event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"), editor);
        event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"), editor);
        event.addMultiMouseDownListener([
            mouseTarget,
            editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
            editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
            editor.textInput && editor.textInput.getElement()
        ].filter(Boolean), [400, 300, 250], this, "onMouseEvent", editor);
        event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"), editor);
        addTouchListeners(editor.container, editor);

        var gutterEl = editor.renderer.$gutter;
        event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), editor);
        event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"), editor);
        event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), editor);
        event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), editor);

        event.addListener(mouseTarget, "mousedown", focusEditor, editor);
        event.addListener(gutterEl, "mousedown", focusEditor, editor);
        if (useragent.isIE && editor.renderer.scrollBarV) {
            event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor, editor);
            event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor, editor);
        }

        editor.on("mousemove", function(e){
            if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
                return;

            var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
            var range = editor.session.selection.getRange();
            var renderer = editor.renderer;

            if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
                renderer.setCursorStyle("default");
            } else {
                renderer.setCursorStyle("");
            }
        }, editor);
    };

    (function() {
        this.onMouseEvent = function(name, e) {
            this.editor._emit(name, new MouseEvent(e, this.editor));
        };

        this.onMouseMove = function(name, e) {
            var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
            if (!listeners || !listeners.length)
                return;

            this.editor._emit(name, new MouseEvent(e, this.editor));
        };

        this.onMouseWheel = function(name, e) {
            var mouseEvent = new MouseEvent(e, this.editor);
            mouseEvent.speed = this.$scrollSpeed * 2;
            mouseEvent.wheelX = e.wheelX;
            mouseEvent.wheelY = e.wheelY;

            this.editor._emit(name, mouseEvent);
        };
        
        this.setState = function(state) {
            this.state = state;
        };

        this.captureMouse = function(ev, mouseMoveHandler) {
            this.x = ev.x;
            this.y = ev.y;

            this.isMousePressed = true;
            var editor = this.editor;
            var renderer = this.editor.renderer;
            renderer.$isMousePressed = true;

            var self = this;
            var onMouseMove = function(e) {
                if (!e) return;
                if (useragent.isWebKit && !e.which && self.releaseMouse)
                    return self.releaseMouse();

                self.x = e.clientX;
                self.y = e.clientY;
                mouseMoveHandler && mouseMoveHandler(e);
                self.mouseEvent = new MouseEvent(e, self.editor);
                self.$mouseMoved = true;
            };

            var onCaptureEnd = function(e) {
                editor.off("beforeEndOperation", onOperationEnd);
                clearInterval(timerId);
                onCaptureInterval();
                self[self.state + "End"] && self[self.state + "End"](e);
                self.state = "";
                self.isMousePressed = renderer.$isMousePressed = false;
                if (renderer.$keepTextAreaAtCursor)
                    renderer.$moveTextAreaToCursor();
                self.$onCaptureMouseMove = self.releaseMouse = null;
                e && self.onMouseEvent("mouseup", e);
                editor.endOperation();
            };

            var onCaptureInterval = function() {
                self[self.state] && self[self.state]();
                self.$mouseMoved = false;
            };

            if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
                return setTimeout(function() {onCaptureEnd(ev);});
            }

            var onOperationEnd = function(e) {
                if (!self.releaseMouse) return;
                if (editor.curOp.command.name && editor.curOp.selectionChanged) {
                    self[self.state + "End"] && self[self.state + "End"]();
                    self.state = "";
                    self.releaseMouse();
                }
            };

            editor.on("beforeEndOperation", onOperationEnd);
            editor.startOperation({command: {name: "mouse"}});

            self.$onCaptureMouseMove = onMouseMove;
            self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
            var timerId = setInterval(onCaptureInterval, 20);
        };
        this.releaseMouse = null;
        this.cancelContextMenu = function() {
            var stop = function(e) {
                if (e && e.domEvent && e.domEvent.type != "contextmenu")
                    return;
                this.editor.off("nativecontextmenu", stop);
                if (e && e.domEvent)
                    event.stopEvent(e.domEvent);
            }.bind(this);
            setTimeout(stop, 10);
            this.editor.on("nativecontextmenu", stop);
        };
        this.destroy = function() {
            if (this.releaseMouse) this.releaseMouse();
        };
    }).call(MouseHandler.prototype);

    config.defineOptions(MouseHandler.prototype, "mouseHandler", {
        scrollSpeed: {initialValue: 2},
        dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},
        dragEnabled: {initialValue: true},
        focusTimeout: {initialValue: 0},
        tooltipFollowsMouse: {initialValue: true}
    });


    exports.MouseHandler = MouseHandler;
    });

    ace.define("ace/mouse/fold_handler",["require","exports","module","ace/lib/dom"], function(require, exports, module) {
    var dom = require("../lib/dom");

    function FoldHandler(editor) {

        editor.on("click", function(e) {
            var position = e.getDocumentPosition();
            var session = editor.session;
            var fold = session.getFoldAt(position.row, position.column, 1);
            if (fold) {
                if (e.getAccelKey())
                    session.removeFold(fold);
                else
                    session.expandFold(fold);

                e.stop();
            }
            
            var target = e.domEvent && e.domEvent.target;
            if (target && dom.hasCssClass(target, "ace_inline_button")) {
                if (dom.hasCssClass(target, "ace_toggle_wrap")) {
                    session.setOption("wrap", !session.getUseWrapMode());
                    editor.renderer.scrollCursorIntoView();
                }
            }
        });

        editor.on("gutterclick", function(e) {
            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

            if (gutterRegion == "foldWidgets") {
                var row = e.getDocumentPosition().row;
                var session = editor.session;
                if (session.foldWidgets && session.foldWidgets[row])
                    editor.session.onFoldWidgetClick(row, e);
                if (!editor.isFocused())
                    editor.focus();
                e.stop();
            }
        });

        editor.on("gutterdblclick", function(e) {
            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

            if (gutterRegion == "foldWidgets") {
                var row = e.getDocumentPosition().row;
                var session = editor.session;
                var data = session.getParentFoldRangeData(row, true);
                var range = data.range || data.firstRange;

                if (range) {
                    row = range.start.row;
                    var fold = session.getFoldAt(row, session.getLine(row).length, 1);

                    if (fold) {
                        session.removeFold(fold);
                    } else {
                        session.addFold("...", range);
                        editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});
                    }
                }
                e.stop();
            }
        });
    }

    exports.FoldHandler = FoldHandler;

    });

    ace.define("ace/keyboard/keybinding",["require","exports","module","ace/lib/keys","ace/lib/event"], function(require, exports, module) {

    var keyUtil  = require("../lib/keys");
    var event = require("../lib/event");

    var KeyBinding = function(editor) {
        this.$editor = editor;
        this.$data = {editor: editor};
        this.$handlers = [];
        this.setDefaultHandler(editor.commands);
    };

    (function() {
        this.setDefaultHandler = function(kb) {
            this.removeKeyboardHandler(this.$defaultHandler);
            this.$defaultHandler = kb;
            this.addKeyboardHandler(kb, 0);
        };

        this.setKeyboardHandler = function(kb) {
            var h = this.$handlers;
            if (h[h.length - 1] == kb)
                return;

            while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
                this.removeKeyboardHandler(h[h.length - 1]);

            this.addKeyboardHandler(kb, 1);
        };

        this.addKeyboardHandler = function(kb, pos) {
            if (!kb)
                return;
            if (typeof kb == "function" && !kb.handleKeyboard)
                kb.handleKeyboard = kb;
            var i = this.$handlers.indexOf(kb);
            if (i != -1)
                this.$handlers.splice(i, 1);

            if (pos == undefined)
                this.$handlers.push(kb);
            else
                this.$handlers.splice(pos, 0, kb);

            if (i == -1 && kb.attach)
                kb.attach(this.$editor);
        };

        this.removeKeyboardHandler = function(kb) {
            var i = this.$handlers.indexOf(kb);
            if (i == -1)
                return false;
            this.$handlers.splice(i, 1);
            kb.detach && kb.detach(this.$editor);
            return true;
        };

        this.getKeyboardHandler = function() {
            return this.$handlers[this.$handlers.length - 1];
        };
        
        this.getStatusText = function() {
            var data = this.$data;
            var editor = data.editor;
            return this.$handlers.map(function(h) {
                return h.getStatusText && h.getStatusText(editor, data) || "";
            }).filter(Boolean).join(" ");
        };

        this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
            var toExecute;
            var success = false;
            var commands = this.$editor.commands;

            for (var i = this.$handlers.length; i--;) {
                toExecute = this.$handlers[i].handleKeyboard(
                    this.$data, hashId, keyString, keyCode, e
                );
                if (!toExecute || !toExecute.command)
                    continue;
                if (toExecute.command == "null") {
                    success = true;
                } else {
                    success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
                }
                if (success && e && hashId != -1 && 
                    toExecute.passEvent != true && toExecute.command.passEvent != true
                ) {
                    event.stopEvent(e);
                }
                if (success)
                    break;
            }
            
            if (!success && hashId == -1) {
                toExecute = {command: "insertstring"};
                success = commands.exec("insertstring", this.$editor, keyString);
            }
            
            if (success && this.$editor._signal)
                this.$editor._signal("keyboardActivity", toExecute);
            
            return success;
        };

        this.onCommandKey = function(e, hashId, keyCode) {
            var keyString = keyUtil.keyCodeToString(keyCode);
            return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
        };

        this.onTextInput = function(text) {
            return this.$callKeyboardHandlers(-1, text);
        };

    }).call(KeyBinding.prototype);

    exports.KeyBinding = KeyBinding;
    });

    ace.define("ace/lib/bidiutil",["require","exports","module"], function(require, exports, module) {
    var dir = 0, hiLevel = 0;
    var lastArabic = false, hasUBAT_B = false,  hasUBAT_S = false;

    var impTab_LTR = [	[	0,		3,		0,		1,		0,		0,		0	],	[	0,		3,		0,		1,		2,		2,		0	],	[	0,		3,		0,		0x11,		2,		0,		1	],	[	0,		3,		5,		5,		4,		1,		0	],	[	0,		3,		0x15,		0x15,		4,		0,		1	],	[	0,		3,		5,		5,		4,		2,		0	]
    ];

    var impTab_RTL = [	[	2,		0,		1,		1,		0,		1,		0	],	[	2,		0,		1,		1,		0,		2,		0	],	[	2,		0,		2,		1,		3,		2,		0	],	[	2,		0,		2,		0x21,		3,		1,		1	]
    ];

    var LTR = 0, RTL = 1;

    var L = 0;
    var R = 1;
    var EN = 2;
    var AN = 3;
    var ON = 4;
    var B = 5;
    var S = 6;
    var AL = 7;
    var WS = 8;
    var CS = 9;
    var ES = 10;
    var ET = 11;
    var NSM = 12;
    var LRE = 13;
    var RLE = 14;
    var PDF = 15;
    var LRO = 16;
    var RLO = 17;
    var BN = 18;

    var UnicodeTBL00 = [
    BN,BN,BN,BN,BN,BN,BN,BN,BN,S,B,S,WS,B,BN,BN,
    BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,B,B,B,S,
    WS,ON,ON,ET,ET,ET,ON,ON,ON,ON,ON,ES,CS,ES,CS,CS,
    EN,EN,EN,EN,EN,EN,EN,EN,EN,EN,CS,ON,ON,ON,ON,ON,
    ON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,
    L,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,ON,
    ON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,
    L,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,BN,
    BN,BN,BN,BN,BN,B,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,
    BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,
    CS,ON,ET,ET,ET,ET,ON,ON,ON,ON,L,ON,ON,BN,ON,ON,
    ET,ET,EN,EN,ON,L,ON,ON,ON,EN,L,ON,ON,ON,ON,ON
    ];

    var UnicodeTBL20 = [
    WS,WS,WS,WS,WS,WS,WS,WS,WS,WS,WS,BN,BN,BN,L,R	,
    ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
    ON,ON,ON,ON,ON,ON,ON,ON,WS,B,LRE,RLE,PDF,LRO,RLO,CS,
    ET,ET,ET,ET,ET,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
    ON,ON,ON,ON,CS,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
    ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,WS
    ];

    function _computeLevels(chars, levels, len, charTypes) {
    	var impTab = dir ? impTab_RTL : impTab_LTR
    		, prevState = null, newClass = null, newLevel = null, newState = 0
    		, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];

    	if (!charTypes) {
    		for (i = 0, charTypes = []; i < len; i++) {
    			charTypes[i] = _getCharacterType(chars[i]);
    		}
    	}
    	hiLevel = dir;
    	lastArabic = false;
    	hasUBAT_B = false;
    	hasUBAT_S = false;
    	for (ix = 0; ix < len; ix++){
    		prevState = newState;
    		classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
    		newState = impTab[prevState][newClass];
    		action = newState & 0xF0;
    		newState &= 0x0F;
    		levels[ix] = newLevel = impTab[newState][5];
    		if (action > 0){
    			if (action == 0x10){
    				for(i = condPos; i < ix; i++){
    					levels[i] = 1;
    				}
    				condPos = -1;
    			} else {
    				condPos = -1;
    			}
    		}
    		cond = impTab[newState][6];
    		if (cond){
    			if(condPos == -1){
    				condPos = ix;
    			}
    		}else {
    			if (condPos > -1){
    				for(i = condPos; i < ix; i++){
    					levels[i] = newLevel;
    				}
    				condPos = -1;
    			}
    		}
    		if (charTypes[ix] == B){
    			levels[ix] = 0;
    		}
    		hiLevel |= newLevel;
    	}
    	if (hasUBAT_S){
    		for(i = 0; i < len; i++){
    			if(charTypes[i] == S){
    				levels[i] = dir;
    				for(var j = i - 1; j >= 0; j--){
    					if(charTypes[j] == WS){
    						levels[j] = dir;
    					}else {
    						break;
    					}
    				}
    			}
    		}
    	}
    }

    function _invertLevel(lev, levels, _array) {
    	if (hiLevel < lev){
    		return;
    	}
    	if (lev == 1 && dir == RTL && !hasUBAT_B){
    		_array.reverse();
    		return;
    	}
    	var len = _array.length, start = 0, end, lo, hi, tmp;
    	while(start < len){
    		if (levels[start] >= lev){
    			end = start + 1;
    		while(end < len && levels[end] >= lev){
    			end++;
    		}
    		for(lo = start, hi = end - 1 ; lo < hi; lo++, hi--){
    			tmp = _array[lo];
    			_array[lo] = _array[hi];
    			_array[hi] = tmp;
    		}
    		start = end;
    	}
    	start++;
    	}
    }

    function _getCharClass(chars, types, classes, ix) {			
    	var cType = types[ix], wType, nType, len, i;
    	switch(cType){
    		case L:
    		case R:
    			lastArabic = false;
    		case ON:
    		case AN:
    			return cType;
    		case EN:
    			return lastArabic ? AN : EN;
    		case AL:
    			lastArabic = true;
    			return R;
    		case WS:
    			return ON;
    		case CS:
    			if (ix < 1 || (ix + 1) >= types.length ||
    				((wType = classes[ix - 1]) != EN && wType != AN) ||
    				((nType = types[ix + 1]) != EN && nType != AN)){
    				return ON;
    			}
    			if (lastArabic){nType = AN;}
    			return nType == wType ? nType : ON;
    		case ES:
    			wType = ix > 0 ? classes[ix - 1] : B;
    			if (wType == EN && (ix + 1) < types.length && types[ix + 1] == EN){
    				return EN;
    			}
    			return ON;
    		case ET:
    			if (ix > 0 && classes[ix - 1] == EN){
    				return EN;
    			}
    			if (lastArabic){
    				return ON;
    			}
    			i = ix + 1;
    			len = types.length;
    			while (i < len && types[i] == ET){
    				i++;
    			}
    			if (i < len && types[i] == EN){
    				return EN;
    			}
    			return ON;
    		case NSM:
    			len = types.length;
    			i = ix + 1;
    			while (i < len && types[i] == NSM){
    				i++;
    			}
    			if (i < len){
    				var c = chars[ix], rtlCandidate = (c >= 0x0591 && c <= 0x08FF) || c == 0xFB1E;
    				
    				wType = types[i];
    				if (rtlCandidate && (wType == R || wType == AL)){
    					return R;
    				}
    			}

    			if (ix < 1 || (wType = types[ix - 1]) == B){
    				return ON;
    			}
    			return classes[ix - 1];
    		case B:
    			lastArabic = false;
    			hasUBAT_B = true;
    			return dir;
    		case S:
    			hasUBAT_S = true;
    			return ON;
    		case LRE:
    		case RLE:
    		case LRO:
    		case RLO:
    		case PDF:
    			lastArabic = false;
    		case BN:
    			return ON;
    	}
    }

    function _getCharacterType( ch ) {		
    	var uc = ch.charCodeAt(0), hi = uc >> 8;
    	
    	if (hi == 0) {		
    		return ((uc > 0x00BF) ? L : UnicodeTBL00[uc]);
    	} else if (hi == 5) {
    		return (/[\u0591-\u05f4]/.test(ch) ? R : L);
    	} else if (hi == 6) {
    		if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
    			return NSM;
    		else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
    			return AN;
    		else if (uc == 0x066A)
    			return ET;
    		else if (/[\u06f0-\u06f9]/.test(ch))
    			return EN;			
    		else
    			return AL;
    	} else if (hi == 0x20 && uc <= 0x205F) {
    		return UnicodeTBL20[uc & 0xFF];
    	} else if (hi == 0xFE) {
    		return (uc >= 0xFE70 ? AL : ON);
    	}		
    	return ON;	
    }
    exports.L = L;
    exports.R = R;
    exports.EN = EN;
    exports.ON_R = 3;
    exports.AN = 4;
    exports.R_H = 5;
    exports.B = 6;
    exports.RLE = 7;

    exports.DOT = "\xB7";
    exports.doBidiReorder = function(text, textCharTypes, isRtl) {
    	if (text.length < 2)
    		return {};
    		
    	var chars = text.split(""), logicalFromVisual = new Array(chars.length),
    		bidiLevels = new Array(chars.length), levels = []; 

    	dir = isRtl ? RTL : LTR;

    	_computeLevels(chars, levels, chars.length, textCharTypes);

    	for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++);

    	_invertLevel(2, levels, logicalFromVisual);
    	_invertLevel(1, levels, logicalFromVisual);

    	for (var i = 0; i < logicalFromVisual.length - 1; i++) { //fix levels to reflect character width
    		if (textCharTypes[i] === AN) {
    			levels[i] = exports.AN;
    		} else if (levels[i] === R && ((textCharTypes[i] > AL && textCharTypes[i] < LRE) 
    			|| textCharTypes[i] === ON || textCharTypes[i] === BN)) {
    			levels[i] = exports.ON_R;
    		} else if ((i > 0 && chars[i - 1] === '\u0644') && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
    			levels[i - 1] = levels[i] = exports.R_H;
    			i++;
    		}
    	}
    	if (chars[chars.length - 1] === exports.DOT)
    		levels[chars.length - 1] = exports.B;
    				
    	if (chars[0] === '\u202B')
    		levels[0] = exports.RLE;
    				
    	for (var i = 0; i < logicalFromVisual.length; i++) {
    		bidiLevels[i] = levels[logicalFromVisual[i]];
    	}

    	return {'logicalFromVisual': logicalFromVisual, 'bidiLevels': bidiLevels};
    };
    exports.hasBidiCharacters = function(text, textCharTypes){
    	var ret = false;
    	for (var i = 0; i < text.length; i++){
    		textCharTypes[i] = _getCharacterType(text.charAt(i));
    		if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN))
    			ret = true;
    	}
    	return ret;
    };	
    exports.getVisualFromLogicalIdx = function(logIdx, rowMap) {
    	for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {
    		if (rowMap.logicalFromVisual[i] == logIdx)
    			return i;
    	}
    	return 0;
    };

    });

    ace.define("ace/bidihandler",["require","exports","module","ace/lib/bidiutil","ace/lib/lang"], function(require, exports, module) {

    var bidiUtil = require("./lib/bidiutil");
    var lang = require("./lib/lang");
    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/;
    var BidiHandler = function(session) {
        this.session = session;
        this.bidiMap = {};
        this.currentRow = null;
        this.bidiUtil = bidiUtil;
        this.charWidths = [];
        this.EOL = "\xAC";
        this.showInvisibles = true;
        this.isRtlDir = false;
        this.$isRtl = false;
        this.line = "";
        this.wrapIndent = 0;
        this.EOF = "\xB6";
        this.RLE = "\u202B";
        this.contentWidth = 0;
        this.fontMetrics = null;
        this.rtlLineOffset = 0;
        this.wrapOffset = 0;
        this.isMoveLeftOperation = false;
        this.seenBidi = bidiRE.test(session.getValue());
    };

    (function() {
        this.isBidiRow = function(screenRow, docRow, splitIndex) {
            if (!this.seenBidi)
                return false;
            if (screenRow !== this.currentRow) {
                this.currentRow = screenRow;
                this.updateRowLine(docRow, splitIndex);
                this.updateBidiMap();
            }
            return this.bidiMap.bidiLevels;
        };

        this.onChange = function(delta) {
            if (!this.seenBidi) {
                if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
                    this.seenBidi = true;
                    this.currentRow = null;
                }
            } 
            else {
                this.currentRow = null;
            }
        };

        this.getDocumentRow = function() {
            var docRow = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
                var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
                if (index >= 0)
                    docRow = this.session.$docRowCache[index];
            }

            return docRow;
        };

        this.getSplitIndex = function() {
            var splitIndex = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
                var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
                while (this.currentRow - splitIndex > 0) {
                    currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
                    if (currentIndex !== prevIndex)
                        break;

                    prevIndex = currentIndex;
                    splitIndex++;
                }
            } else {
                splitIndex = this.currentRow;
            }

            return splitIndex;
        };

        this.updateRowLine = function(docRow, splitIndex) {
            if (docRow === undefined)
                docRow = this.getDocumentRow();
                
            var isLastRow = (docRow === this.session.getLength() - 1),
                endOfLine = isLastRow ? this.EOF : this.EOL;

            this.wrapIndent = 0;
            this.line = this.session.getLine(docRow);
            this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
            if (this.session.$useWrapMode) {
                var splits = this.session.$wrapData[docRow];
                if (splits) {
                    if (splitIndex === undefined)
                        splitIndex = this.getSplitIndex();

                    if(splitIndex > 0 && splits.length) {
                        this.wrapIndent = splits.indent;
                        this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];
                        this.line = (splitIndex < splits.length) ?
                            this.line.substring(splits[splitIndex - 1], splits[splitIndex]) :
                                this.line.substring(splits[splits.length - 1]);
                    } else {
                        this.line = this.line.substring(0, splits[splitIndex]);
                    }
                }
                if (splitIndex == splits.length)
                    this.line += (this.showInvisibles) ? endOfLine : bidiUtil.DOT;
            } else {
                this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
            }
            var session = this.session, shift = 0, size;
            this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(ch, i){
                if (ch === '\t' || session.isFullWidth(ch.charCodeAt(0))) {
                    size = (ch === '\t') ? session.getScreenTabSize(i + shift) : 2;
                    shift += size - 1;
                    return lang.stringRepeat(bidiUtil.DOT, size);
                }
                return ch;
            });

            if (this.isRtlDir) {
                this.fontMetrics.$main.textContent = (this.line.charAt(this.line.length - 1) == bidiUtil.DOT) ? this.line.substr(0, this.line.length - 1) : this.line;
                this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;
            }
        };
        
        this.updateBidiMap = function() {
            var textCharTypes = [];
            if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {
                 this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);
            } else {
                this.bidiMap = {};
            }
        };
        this.markAsDirty = function() {
            this.currentRow = null;
        };
        this.updateCharacterWidths = function(fontMetrics) {
            if (this.characterWidth === fontMetrics.$characterSize.width)
                return;

            this.fontMetrics = fontMetrics;
            var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
            var bidiCharWidth = fontMetrics.$measureCharWidth("\u05d4");

            this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
            this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
            this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;
            this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;

            this.currentRow = null;
        };

        this.setShowInvisibles = function(showInvisibles) {
            this.showInvisibles = showInvisibles;
            this.currentRow = null;
        };

        this.setEolChar = function(eolChar) {
            this.EOL = eolChar; 
        };

        this.setContentWidth = function(width) {
            this.contentWidth = width;
        };

        this.isRtlLine = function(row) {
            if (this.$isRtl) return true;
            if (row != undefined)
                return (this.session.getLine(row).charAt(0) == this.RLE);
            else
                return this.isRtlDir; 
        };

        this.setRtlDirection = function(editor, isRtlDir) {
            var cursor = editor.getCursorPosition(); 
            for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {
                if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)
                    editor.session.doc.removeInLine(row, 0, 1);
                else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)
                    editor.session.doc.insert({column: 0, row: row}, editor.session.$bidiHandler.RLE);
            }
        };
        this.getPosLeft = function(col) {
            col -= this.wrapIndent;
            var leftBoundary = (this.line.charAt(0) === this.RLE) ? 1 : 0;
            var logicalIdx = (col > leftBoundary) ? (this.session.getOverwrite() ? col : col - 1) : leftBoundary;
            var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap),
                levels = this.bidiMap.bidiLevels, left = 0;

            if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)
                visualIdx++;
                
            for (var i = 0; i < visualIdx; i++) {
                left += this.charWidths[levels[i]];
            }

            if (!this.session.getOverwrite() && (col > leftBoundary) && (levels[visualIdx] % 2 === 0))
                left += this.charWidths[levels[visualIdx]];

            if (this.wrapIndent)
                left += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;

            if (this.isRtlDir)
                left += this.rtlLineOffset;

            return left;
        };
        this.getSelections = function(startCol, endCol) {
            var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0,
                selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent,
                    isSelected = false, isSelectedPrev = false, selectionStart = 0;
                
            if (this.wrapIndent)
                offset += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;

            for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
                logIdx = map.logicalFromVisual[visIdx];
                level = levels[visIdx];
                isSelected = (logIdx >= selColMin) && (logIdx < selColMax);
                if (isSelected && !isSelectedPrev) {
                    selectionStart = offset;
                } else if (!isSelected && isSelectedPrev) {
                    selections.push({left: selectionStart, width: offset - selectionStart});
                }
                offset += this.charWidths[level];
                isSelectedPrev = isSelected;
            }

            if (isSelected && (visIdx === levels.length)) {
                selections.push({left: selectionStart, width: offset - selectionStart});
            }

            if(this.isRtlDir) {
                for (var i = 0; i < selections.length; i++) {
                    selections[i].left += this.rtlLineOffset;
                }
            }
            return selections;
        };
        this.offsetToCol = function(posX) {
            if(this.isRtlDir)
                posX -= this.rtlLineOffset;

            var logicalIdx = 0, posX = Math.max(posX, 0),
                offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels,
                    charWidth = this.charWidths[levels[visualIdx]];

            if (this.wrapIndent)
               posX -= this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;
        
            while(posX > offset + charWidth/2) {
                offset += charWidth;
                if(visualIdx === levels.length - 1) {
                    charWidth = 0;
                    break;
                }
                charWidth = this.charWidths[levels[++visualIdx]];
            }
        
            if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && (levels[visualIdx] % 2 === 0)){
                if(posX < offset)
                    visualIdx--;
                logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];

            } else if (visualIdx > 0 && (levels[visualIdx - 1] % 2 === 0) && (levels[visualIdx] % 2 !== 0)){
                logicalIdx = 1 + ((posX > offset) ? this.bidiMap.logicalFromVisual[visualIdx]
                        : this.bidiMap.logicalFromVisual[visualIdx - 1]);

            } else if ((this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && (levels[visualIdx - 1] % 2 === 0))
                    || (!this.isRtlDir && visualIdx === 0 && (levels[visualIdx] % 2 !== 0))){
                logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
            } else {
                if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && charWidth !== 0)
                    visualIdx--;
                logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
            }

            if (logicalIdx === 0 && this.isRtlDir)
                logicalIdx++;

            return (logicalIdx + this.wrapIndent);
        };

    }).call(BidiHandler.prototype);

    exports.BidiHandler = BidiHandler;
    });

    ace.define("ace/selection",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/range"], function(require, exports, module) {

    var oop = require("./lib/oop");
    var lang = require("./lib/lang");
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var Range = require("./range").Range;
    var Selection = function(session) {
        this.session = session;
        this.doc = session.getDocument();

        this.clearSelection();
        this.cursor = this.lead = this.doc.createAnchor(0, 0);
        this.anchor = this.doc.createAnchor(0, 0);
        this.$silent = false;

        var self = this;
        this.cursor.on("change", function(e) {
            self.$cursorChanged = true;
            if (!self.$silent)
                self._emit("changeCursor");
            if (!self.$isEmpty && !self.$silent)
                self._emit("changeSelection");
            if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
                self.$desiredColumn = null;
        });

        this.anchor.on("change", function() {
            self.$anchorChanged = true;
            if (!self.$isEmpty && !self.$silent)
                self._emit("changeSelection");
        });
    };

    (function() {

        oop.implement(this, EventEmitter);
        this.isEmpty = function() {
            return this.$isEmpty || (
                this.anchor.row == this.lead.row &&
                this.anchor.column == this.lead.column
            );
        };
        this.isMultiLine = function() {
            return !this.$isEmpty && this.anchor.row != this.cursor.row;
        };
        this.getCursor = function() {
            return this.lead.getPosition();
        };
        this.setSelectionAnchor = function(row, column) {
            this.$isEmpty = false;
            this.anchor.setPosition(row, column);
        };
        this.getAnchor = 
        this.getSelectionAnchor = function() {
            if (this.$isEmpty)
                return this.getSelectionLead();
            
            return this.anchor.getPosition();
        };
        this.getSelectionLead = function() {
            return this.lead.getPosition();
        };
        this.isBackwards = function() {
            var anchor = this.anchor;
            var lead = this.lead;
            return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
        };
        this.getRange = function() {
            var anchor = this.anchor;
            var lead = this.lead;

            if (this.$isEmpty)
                return Range.fromPoints(lead, lead);

            return this.isBackwards()
                ? Range.fromPoints(lead, anchor)
                : Range.fromPoints(anchor, lead);
        };
        this.clearSelection = function() {
            if (!this.$isEmpty) {
                this.$isEmpty = true;
                this._emit("changeSelection");
            }
        };
        this.selectAll = function() {
            this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
        };
        this.setRange =
        this.setSelectionRange = function(range, reverse) {
            var start = reverse ? range.end : range.start;
            var end = reverse ? range.start : range.end;
            this.$setSelection(start.row, start.column, end.row, end.column);
        };

        this.$setSelection = function(anchorRow, anchorColumn, cursorRow, cursorColumn) {
            if (this.$silent)
                return;
            var wasEmpty = this.$isEmpty;
            var wasMultiselect = this.inMultiSelectMode;
            this.$silent = true;
            this.$cursorChanged = this.$anchorChanged = false;
            this.anchor.setPosition(anchorRow, anchorColumn);
            this.cursor.setPosition(cursorRow, cursorColumn);
            this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);
            this.$silent = false;
            if (this.$cursorChanged)
                this._emit("changeCursor");
            if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)
                this._emit("changeSelection");
        };

        this.$moveSelection = function(mover) {
            var lead = this.lead;
            if (this.$isEmpty)
                this.setSelectionAnchor(lead.row, lead.column);

            mover.call(this);
        };
        this.selectTo = function(row, column) {
            this.$moveSelection(function() {
                this.moveCursorTo(row, column);
            });
        };
        this.selectToPosition = function(pos) {
            this.$moveSelection(function() {
                this.moveCursorToPosition(pos);
            });
        };
        this.moveTo = function(row, column) {
            this.clearSelection();
            this.moveCursorTo(row, column);
        };
        this.moveToPosition = function(pos) {
            this.clearSelection();
            this.moveCursorToPosition(pos);
        };
        this.selectUp = function() {
            this.$moveSelection(this.moveCursorUp);
        };
        this.selectDown = function() {
            this.$moveSelection(this.moveCursorDown);
        };
        this.selectRight = function() {
            this.$moveSelection(this.moveCursorRight);
        };
        this.selectLeft = function() {
            this.$moveSelection(this.moveCursorLeft);
        };
        this.selectLineStart = function() {
            this.$moveSelection(this.moveCursorLineStart);
        };
        this.selectLineEnd = function() {
            this.$moveSelection(this.moveCursorLineEnd);
        };
        this.selectFileEnd = function() {
            this.$moveSelection(this.moveCursorFileEnd);
        };
        this.selectFileStart = function() {
            this.$moveSelection(this.moveCursorFileStart);
        };
        this.selectWordRight = function() {
            this.$moveSelection(this.moveCursorWordRight);
        };
        this.selectWordLeft = function() {
            this.$moveSelection(this.moveCursorWordLeft);
        };
        this.getWordRange = function(row, column) {
            if (typeof column == "undefined") {
                var cursor = row || this.lead;
                row = cursor.row;
                column = cursor.column;
            }
            return this.session.getWordRange(row, column);
        };
        this.selectWord = function() {
            this.setSelectionRange(this.getWordRange());
        };
        this.selectAWord = function() {
            var cursor = this.getCursor();
            var range = this.session.getAWordRange(cursor.row, cursor.column);
            this.setSelectionRange(range);
        };

        this.getLineRange = function(row, excludeLastChar) {
            var rowStart = typeof row == "number" ? row : this.lead.row;
            var rowEnd;

            var foldLine = this.session.getFoldLine(rowStart);
            if (foldLine) {
                rowStart = foldLine.start.row;
                rowEnd = foldLine.end.row;
            } else {
                rowEnd = rowStart;
            }
            if (excludeLastChar === true)
                return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
            else
                return new Range(rowStart, 0, rowEnd + 1, 0);
        };
        this.selectLine = function() {
            this.setSelectionRange(this.getLineRange());
        };
        this.moveCursorUp = function() {
            this.moveCursorBy(-1, 0);
        };
        this.moveCursorDown = function() {
            this.moveCursorBy(1, 0);
        };
        this.wouldMoveIntoSoftTab = function(cursor, tabSize, direction) {
            var start = cursor.column;
            var end = cursor.column + tabSize;

            if (direction < 0) {
                start = cursor.column - tabSize;
                end = cursor.column;
            }
            return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length-1 == tabSize;
        };
        this.moveCursorLeft = function() {
            var cursor = this.lead.getPosition(),
                fold;

            if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
                this.moveCursorTo(fold.start.row, fold.start.column);
            } else if (cursor.column === 0) {
                if (cursor.row > 0) {
                    this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
                }
            }
            else {
                var tabSize = this.session.getTabSize();
                if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
                    this.moveCursorBy(0, -tabSize);
                } else {
                    this.moveCursorBy(0, -1);
                }
            }
        };
        this.moveCursorRight = function() {
            var cursor = this.lead.getPosition(),
                fold;
            if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
                this.moveCursorTo(fold.end.row, fold.end.column);
            }
            else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
                if (this.lead.row < this.doc.getLength() - 1) {
                    this.moveCursorTo(this.lead.row + 1, 0);
                }
            }
            else {
                var tabSize = this.session.getTabSize();
                var cursor = this.lead;
                if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
                    this.moveCursorBy(0, tabSize);
                } else {
                    this.moveCursorBy(0, 1);
                }
            }
        };
        this.moveCursorLineStart = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var screenRow = this.session.documentToScreenRow(row, column);
            var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
            var beforeCursor = this.session.getDisplayLine(
                row, null, firstColumnPosition.row,
                firstColumnPosition.column
            );

            var leadingSpace = beforeCursor.match(/^\s*/);
            if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
                firstColumnPosition.column += leadingSpace[0].length;
            this.moveCursorToPosition(firstColumnPosition);
        };
        this.moveCursorLineEnd = function() {
            var lead = this.lead;
            var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
            if (this.lead.column == lineEnd.column) {
                var line = this.session.getLine(lineEnd.row);
                if (lineEnd.column == line.length) {
                    var textEnd = line.search(/\s+$/);
                    if (textEnd > 0)
                        lineEnd.column = textEnd;
                }
            }

            this.moveCursorTo(lineEnd.row, lineEnd.column);
        };
        this.moveCursorFileEnd = function() {
            var row = this.doc.getLength() - 1;
            var column = this.doc.getLine(row).length;
            this.moveCursorTo(row, column);
        };
        this.moveCursorFileStart = function() {
            this.moveCursorTo(0, 0);
        };
        this.moveCursorLongWordRight = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var line = this.doc.getLine(row);
            var rightOfCursor = line.substring(column);

            this.session.nonTokenRe.lastIndex = 0;
            this.session.tokenRe.lastIndex = 0;
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold) {
                this.moveCursorTo(fold.end.row, fold.end.column);
                return;
            }
            if (this.session.nonTokenRe.exec(rightOfCursor)) {
                column += this.session.nonTokenRe.lastIndex;
                this.session.nonTokenRe.lastIndex = 0;
                rightOfCursor = line.substring(column);
            }
            if (column >= line.length) {
                this.moveCursorTo(row, line.length);
                this.moveCursorRight();
                if (row < this.doc.getLength() - 1)
                    this.moveCursorWordRight();
                return;
            }
            if (this.session.tokenRe.exec(rightOfCursor)) {
                column += this.session.tokenRe.lastIndex;
                this.session.tokenRe.lastIndex = 0;
            }

            this.moveCursorTo(row, column);
        };
        this.moveCursorLongWordLeft = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var fold;
            if (fold = this.session.getFoldAt(row, column, -1)) {
                this.moveCursorTo(fold.start.row, fold.start.column);
                return;
            }

            var str = this.session.getFoldStringAt(row, column, -1);
            if (str == null) {
                str = this.doc.getLine(row).substring(0, column);
            }

            var leftOfCursor = lang.stringReverse(str);
            this.session.nonTokenRe.lastIndex = 0;
            this.session.tokenRe.lastIndex = 0;
            if (this.session.nonTokenRe.exec(leftOfCursor)) {
                column -= this.session.nonTokenRe.lastIndex;
                leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
                this.session.nonTokenRe.lastIndex = 0;
            }
            if (column <= 0) {
                this.moveCursorTo(row, 0);
                this.moveCursorLeft();
                if (row > 0)
                    this.moveCursorWordLeft();
                return;
            }
            if (this.session.tokenRe.exec(leftOfCursor)) {
                column -= this.session.tokenRe.lastIndex;
                this.session.tokenRe.lastIndex = 0;
            }

            this.moveCursorTo(row, column);
        };

        this.$shortWordEndIndex = function(rightOfCursor) {
            var index = 0, ch;
            var whitespaceRe = /\s/;
            var tokenRe = this.session.tokenRe;

            tokenRe.lastIndex = 0;
            if (this.session.tokenRe.exec(rightOfCursor)) {
                index = this.session.tokenRe.lastIndex;
            } else {
                while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                    index ++;

                if (index < 1) {
                    tokenRe.lastIndex = 0;
                     while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                        tokenRe.lastIndex = 0;
                        index ++;
                        if (whitespaceRe.test(ch)) {
                            if (index > 2) {
                                index--;
                                break;
                            } else {
                                while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                                    index ++;
                                if (index > 2)
                                    break;
                            }
                        }
                    }
                }
            }
            tokenRe.lastIndex = 0;

            return index;
        };

        this.moveCursorShortWordRight = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var line = this.doc.getLine(row);
            var rightOfCursor = line.substring(column);

            var fold = this.session.getFoldAt(row, column, 1);
            if (fold)
                return this.moveCursorTo(fold.end.row, fold.end.column);

            if (column == line.length) {
                var l = this.doc.getLength();
                do {
                    row++;
                    rightOfCursor = this.doc.getLine(row);
                } while (row < l && /^\s*$/.test(rightOfCursor));

                if (!/^\s+/.test(rightOfCursor))
                    rightOfCursor = "";
                column = 0;
            }

            var index = this.$shortWordEndIndex(rightOfCursor);

            this.moveCursorTo(row, column + index);
        };

        this.moveCursorShortWordLeft = function() {
            var row = this.lead.row;
            var column = this.lead.column;

            var fold;
            if (fold = this.session.getFoldAt(row, column, -1))
                return this.moveCursorTo(fold.start.row, fold.start.column);

            var line = this.session.getLine(row).substring(0, column);
            if (column === 0) {
                do {
                    row--;
                    line = this.doc.getLine(row);
                } while (row > 0 && /^\s*$/.test(line));

                column = line.length;
                if (!/\s+$/.test(line))
                    line = "";
            }

            var leftOfCursor = lang.stringReverse(line);
            var index = this.$shortWordEndIndex(leftOfCursor);

            return this.moveCursorTo(row, column - index);
        };

        this.moveCursorWordRight = function() {
            if (this.session.$selectLongWords)
                this.moveCursorLongWordRight();
            else
                this.moveCursorShortWordRight();
        };

        this.moveCursorWordLeft = function() {
            if (this.session.$selectLongWords)
                this.moveCursorLongWordLeft();
            else
                this.moveCursorShortWordLeft();
        };
        this.moveCursorBy = function(rows, chars) {
            var screenPos = this.session.documentToScreenPosition(
                this.lead.row,
                this.lead.column
            );

            var offsetX;

            if (chars === 0) {
                if (rows !== 0) {
                    if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                        offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                        screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
                    } else {
                        offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
                    }
                }

                if (this.$desiredColumn)
                    screenPos.column = this.$desiredColumn;
                else
                    this.$desiredColumn = screenPos.column;
            }
            
            if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
                var widget = this.session.lineWidgets[this.lead.row];
                if (rows < 0)
                    rows -= widget.rowsAbove || 0;
                else if (rows > 0)
                    rows += widget.rowCount - (widget.rowsAbove || 0);
            }
            
            var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
            
            if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) ;
            this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
        };
        this.moveCursorToPosition = function(position) {
            this.moveCursorTo(position.row, position.column);
        };
        this.moveCursorTo = function(row, column, keepDesiredColumn) {
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold) {
                row = fold.start.row;
                column = fold.start.column;
            }

            this.$keepDesiredColumnOnChange = true;
            var line = this.session.getLine(row);
            if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
                if (this.lead.row == row && this.lead.column == column + 1)
                    column = column - 1;
                else
                    column = column + 1;
            }
            this.lead.setPosition(row, column);
            this.$keepDesiredColumnOnChange = false;

            if (!keepDesiredColumn)
                this.$desiredColumn = null;
        };
        this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
            var pos = this.session.screenToDocumentPosition(row, column);
            this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
        };
        this.detach = function() {
            this.lead.detach();
            this.anchor.detach();
            this.session = this.doc = null;
        };

        this.fromOrientedRange = function(range) {
            this.setSelectionRange(range, range.cursor == range.start);
            this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
        };

        this.toOrientedRange = function(range) {
            var r = this.getRange();
            if (range) {
                range.start.column = r.start.column;
                range.start.row = r.start.row;
                range.end.column = r.end.column;
                range.end.row = r.end.row;
            } else {
                range = r;
            }

            range.cursor = this.isBackwards() ? range.start : range.end;
            range.desiredColumn = this.$desiredColumn;
            return range;
        };
        this.getRangeOfMovements = function(func) {
            var start = this.getCursor();
            try {
                func(this);
                var end = this.getCursor();
                return Range.fromPoints(start, end);
            } catch(e) {
                return Range.fromPoints(start, start);
            } finally {
                this.moveCursorToPosition(start);
            }
        };

        this.toJSON = function() {
            if (this.rangeCount) {
                var data = this.ranges.map(function(r) {
                    var r1 = r.clone();
                    r1.isBackwards = r.cursor == r.start;
                    return r1;
                });
            } else {
                var data = this.getRange();
                data.isBackwards = this.isBackwards();
            }
            return data;
        };

        this.fromJSON = function(data) {
            if (data.start == undefined) {
                if (this.rangeList && data.length > 1) {
                    this.toSingleRange(data[0]);
                    for (var i = data.length; i--; ) {
                        var r = Range.fromPoints(data[i].start, data[i].end);
                        if (data[i].isBackwards)
                            r.cursor = r.start;
                        this.addRange(r, true);
                    }
                    return;
                } else {
                    data = data[0];
                }
            }
            if (this.rangeList)
                this.toSingleRange(data);
            this.setSelectionRange(data, data.isBackwards);
        };

        this.isEqual = function(data) {
            if ((data.length || this.rangeCount) && data.length != this.rangeCount)
                return false;
            if (!data.length || !this.ranges)
                return this.getRange().isEqual(data);

            for (var i = this.ranges.length; i--; ) {
                if (!this.ranges[i].isEqual(data[i]))
                    return false;
            }
            return true;
        };

    }).call(Selection.prototype);

    exports.Selection = Selection;
    });

    ace.define("ace/tokenizer",["require","exports","module","ace/config"], function(require, exports, module) {

    var config = require("./config");
    var MAX_TOKEN_COUNT = 2000;
    var Tokenizer = function(rules) {
        this.states = rules;

        this.regExps = {};
        this.matchMappings = {};
        for (var key in this.states) {
            var state = this.states[key];
            var ruleRegExps = [];
            var matchTotal = 0;
            var mapping = this.matchMappings[key] = {defaultToken: "text"};
            var flag = "g";

            var splitterRurles = [];
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (rule.defaultToken)
                    mapping.defaultToken = rule.defaultToken;
                if (rule.caseInsensitive)
                    flag = "gi";
                if (rule.regex == null)
                    continue;

                if (rule.regex instanceof RegExp)
                    rule.regex = rule.regex.toString().slice(1, -1);
                var adjustedregex = rule.regex;
                var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
                if (Array.isArray(rule.token)) {
                    if (rule.token.length == 1 || matchcount == 1) {
                        rule.token = rule.token[0];
                    } else if (matchcount - 1 != rule.token.length) {
                        this.reportError("number of classes and regexp groups doesn't match", { 
                            rule: rule,
                            groupCount: matchcount - 1
                        });
                        rule.token = rule.token[0];
                    } else {
                        rule.tokenArray = rule.token;
                        rule.token = null;
                        rule.onMatch = this.$arrayTokens;
                    }
                } else if (typeof rule.token == "function" && !rule.onMatch) {
                    if (matchcount > 1)
                        rule.onMatch = this.$applyToken;
                    else
                        rule.onMatch = rule.token;
                }

                if (matchcount > 1) {
                    if (/\\\d/.test(rule.regex)) {
                        adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                            return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                        });
                    } else {
                        matchcount = 1;
                        adjustedregex = this.removeCapturingGroups(rule.regex);
                    }
                    if (!rule.splitRegex && typeof rule.token != "string")
                        splitterRurles.push(rule); // flag will be known only at the very end
                }

                mapping[matchTotal] = i;
                matchTotal += matchcount;

                ruleRegExps.push(adjustedregex);
                if (!rule.onMatch)
                    rule.onMatch = null;
            }
            
            if (!ruleRegExps.length) {
                mapping[0] = 0;
                ruleRegExps.push("$");
            }
            
            splitterRurles.forEach(function(rule) {
                rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
            }, this);

            this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
        }
    };

    (function() {
        this.$setMaxTokenCount = function(m) {
            MAX_TOKEN_COUNT = m | 0;
        };
        
        this.$applyToken = function(str) {
            var values = this.splitRegex.exec(str).slice(1);
            var types = this.token.apply(this, values);
            if (typeof types === "string")
                return [{type: types, value: str}];

            var tokens = [];
            for (var i = 0, l = types.length; i < l; i++) {
                if (values[i])
                    tokens[tokens.length] = {
                        type: types[i],
                        value: values[i]
                    };
            }
            return tokens;
        };

        this.$arrayTokens = function(str) {
            if (!str)
                return [];
            var values = this.splitRegex.exec(str);
            if (!values)
                return "text";
            var tokens = [];
            var types = this.tokenArray;
            for (var i = 0, l = types.length; i < l; i++) {
                if (values[i + 1])
                    tokens[tokens.length] = {
                        type: types[i],
                        value: values[i + 1]
                    };
            }
            return tokens;
        };

        this.removeCapturingGroups = function(src) {
            var r = src.replace(
                /\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!]|(\()/g,
                function(x, y) {return y ? "(?:" : x;}
            );
            return r;
        };

        this.createSplitterRegexp = function(src, flag) {
            if (src.indexOf("(?=") != -1) {
                var stack = 0;
                var inChClass = false;
                var lastCapture = {};
                src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(
                    m, esc, parenOpen, parenClose, square, index
                ) {
                    if (inChClass) {
                        inChClass = square != "]";
                    } else if (square) {
                        inChClass = true;
                    } else if (parenClose) {
                        if (stack == lastCapture.stack) {
                            lastCapture.end = index+1;
                            lastCapture.stack = -1;
                        }
                        stack--;
                    } else if (parenOpen) {
                        stack++;
                        if (parenOpen.length != 1) {
                            lastCapture.stack = stack;
                            lastCapture.start = index;
                        }
                    }
                    return m;
                });

                if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
                    src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
            }
            if (src.charAt(0) != "^") src = "^" + src;
            if (src.charAt(src.length - 1) != "$") src += "$";
            
            return new RegExp(src, (flag||"").replace("g", ""));
        };
        this.getLineTokens = function(line, startState) {
            if (startState && typeof startState != "string") {
                var stack = startState.slice(0);
                startState = stack[0];
                if (startState === "#tmp") {
                    stack.shift();
                    startState = stack.shift();
                }
            } else
                var stack = [];

            var currentState = startState || "start";
            var state = this.states[currentState];
            if (!state) {
                currentState = "start";
                state = this.states[currentState];
            }
            var mapping = this.matchMappings[currentState];
            var re = this.regExps[currentState];
            re.lastIndex = 0;

            var match, tokens = [];
            var lastIndex = 0;
            var matchAttempts = 0;

            var token = {type: null, value: ""};

            while (match = re.exec(line)) {
                var type = mapping.defaultToken;
                var rule = null;
                var value = match[0];
                var index = re.lastIndex;

                if (index - value.length > lastIndex) {
                    var skipped = line.substring(lastIndex, index - value.length);
                    if (token.type == type) {
                        token.value += skipped;
                    } else {
                        if (token.type)
                            tokens.push(token);
                        token = {type: type, value: skipped};
                    }
                }

                for (var i = 0; i < match.length-2; i++) {
                    if (match[i + 1] === undefined)
                        continue;

                    rule = state[mapping[i]];

                    if (rule.onMatch)
                        type = rule.onMatch(value, currentState, stack, line);
                    else
                        type = rule.token;

                    if (rule.next) {
                        if (typeof rule.next == "string") {
                            currentState = rule.next;
                        } else {
                            currentState = rule.next(currentState, stack);
                        }
                        
                        state = this.states[currentState];
                        if (!state) {
                            this.reportError("state doesn't exist", currentState);
                            currentState = "start";
                            state = this.states[currentState];
                        }
                        mapping = this.matchMappings[currentState];
                        lastIndex = index;
                        re = this.regExps[currentState];
                        re.lastIndex = index;
                    }
                    if (rule.consumeLineEnd)
                        lastIndex = index;
                    break;
                }

                if (value) {
                    if (typeof type === "string") {
                        if ((!rule || rule.merge !== false) && token.type === type) {
                            token.value += value;
                        } else {
                            if (token.type)
                                tokens.push(token);
                            token = {type: type, value: value};
                        }
                    } else if (type) {
                        if (token.type)
                            tokens.push(token);
                        token = {type: null, value: ""};
                        for (var i = 0; i < type.length; i++)
                            tokens.push(type[i]);
                    }
                }

                if (lastIndex == line.length)
                    break;

                lastIndex = index;

                if (matchAttempts++ > MAX_TOKEN_COUNT) {
                    if (matchAttempts > 2 * line.length) {
                        this.reportError("infinite loop with in ace tokenizer", {
                            startState: startState,
                            line: line
                        });
                    }
                    while (lastIndex < line.length) {
                        if (token.type)
                            tokens.push(token);
                        token = {
                            value: line.substring(lastIndex, lastIndex += 500),
                            type: "overflow"
                        };
                    }
                    currentState = "start";
                    stack = [];
                    break;
                }
            }

            if (token.type)
                tokens.push(token);
            
            if (stack.length > 1) {
                if (stack[0] !== currentState)
                    stack.unshift("#tmp", currentState);
            }
            return {
                tokens : tokens,
                state : stack.length ? stack : currentState
            };
        };
        
        this.reportError = config.reportError;
        
    }).call(Tokenizer.prototype);

    exports.Tokenizer = Tokenizer;
    });

    ace.define("ace/mode/text_highlight_rules",["require","exports","module","ace/lib/lang"], function(require, exports, module) {

    var lang = require("../lib/lang");

    var TextHighlightRules = function() {

        this.$rules = {
            "start" : [{
                token : "empty_line",
                regex : '^$'
            }, {
                defaultToken : "text"
            }]
        };
    };

    (function() {

        this.addRules = function(rules, prefix) {
            if (!prefix) {
                for (var key in rules)
                    this.$rules[key] = rules[key];
                return;
            }
            for (var key in rules) {
                var state = rules[key];
                for (var i = 0; i < state.length; i++) {
                    var rule = state[i];
                    if (rule.next || rule.onMatch) {
                        if (typeof rule.next == "string") {
                            if (rule.next.indexOf(prefix) !== 0)
                                rule.next = prefix + rule.next;
                        }
                        if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                            rule.nextState = prefix + rule.nextState;
                    }
                }
                this.$rules[prefix + key] = state;
            }
        };

        this.getRules = function() {
            return this.$rules;
        };

        this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
            var embedRules = typeof HighlightRules == "function"
                ? new HighlightRules().getRules()
                : HighlightRules;
            if (states) {
                for (var i = 0; i < states.length; i++)
                    states[i] = prefix + states[i];
            } else {
                states = [];
                for (var key in embedRules)
                    states.push(prefix + key);
            }

            this.addRules(embedRules, prefix);

            if (escapeRules) {
                var addRules = Array.prototype[append ? "push" : "unshift"];
                for (var i = 0; i < states.length; i++)
                    addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
            }

            if (!this.$embeds)
                this.$embeds = [];
            this.$embeds.push(prefix);
        };

        this.getEmbeds = function() {
            return this.$embeds;
        };

        var pushState = function(currentState, stack) {
            if (currentState != "start" || stack.length)
                stack.unshift(this.nextState, currentState);
            return this.nextState;
        };
        var popState = function(currentState, stack) {
            stack.shift();
            return stack.shift() || "start";
        };

        this.normalizeRules = function() {
            var id = 0;
            var rules = this.$rules;
            function processState(key) {
                var state = rules[key];
                state.processed = true;
                for (var i = 0; i < state.length; i++) {
                    var rule = state[i];
                    var toInsert = null;
                    if (Array.isArray(rule)) {
                        toInsert = rule;
                        rule = {};
                    }
                    if (!rule.regex && rule.start) {
                        rule.regex = rule.start;
                        if (!rule.next)
                            rule.next = [];
                        rule.next.push({
                            defaultToken: rule.token
                        }, {
                            token: rule.token + ".end",
                            regex: rule.end || rule.start,
                            next: "pop"
                        });
                        rule.token = rule.token + ".start";
                        rule.push = true;
                    }
                    var next = rule.next || rule.push;
                    if (next && Array.isArray(next)) {
                        var stateName = rule.stateName;
                        if (!stateName)  {
                            stateName = rule.token;
                            if (typeof stateName != "string")
                                stateName = stateName[0] || "";
                            if (rules[stateName])
                                stateName += id++;
                        }
                        rules[stateName] = next;
                        rule.next = stateName;
                        processState(stateName);
                    } else if (next == "pop") {
                        rule.next = popState;
                    }

                    if (rule.push) {
                        rule.nextState = rule.next || rule.push;
                        rule.next = pushState;
                        delete rule.push;
                    }

                    if (rule.rules) {
                        for (var r in rule.rules) {
                            if (rules[r]) {
                                if (rules[r].push)
                                    rules[r].push.apply(rules[r], rule.rules[r]);
                            } else {
                                rules[r] = rule.rules[r];
                            }
                        }
                    }
                    var includeName = typeof rule == "string" ? rule : rule.include;
                    if (includeName) {
                        if (Array.isArray(includeName))
                            toInsert = includeName.map(function(x) { return rules[x]; });
                        else
                            toInsert = rules[includeName];
                    }

                    if (toInsert) {
                        var args = [i, 1].concat(toInsert);
                        if (rule.noEscape)
                            args = args.filter(function(x) {return !x.next;});
                        state.splice.apply(state, args);
                        i--;
                    }
                    
                    if (rule.keywordMap) {
                        rule.token = this.createKeywordMapper(
                            rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive
                        );
                        delete rule.defaultToken;
                    }
                }
            }
            Object.keys(rules).forEach(processState, this);
        };

        this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
            var keywords = Object.create(null);
            this.$keywordList = [];
            Object.keys(map).forEach(function(className) {
                var a = map[className];
                var list = a.split(splitChar || "|");
                for (var i = list.length; i--; ) {
                    var word = list[i];
                    this.$keywordList.push(word);
                    if (ignoreCase)
                        word = word.toLowerCase(); 
                    keywords[word] = className;
                }
            }, this);
            map = null;
            return ignoreCase
                ? function(value) {return keywords[value.toLowerCase()] || defaultToken; }
                : function(value) {return keywords[value] || defaultToken; };
        };

        this.getKeywords = function() {
            return this.$keywords;
        };

    }).call(TextHighlightRules.prototype);

    exports.TextHighlightRules = TextHighlightRules;
    });

    ace.define("ace/mode/behaviour",["require","exports","module"], function(require, exports, module) {

    var Behaviour = function() {
       this.$behaviours = {};
    };

    (function () {

        this.add = function (name, action, callback) {
            switch (undefined) {
              case this.$behaviours:
                  this.$behaviours = {};
              case this.$behaviours[name]:
                  this.$behaviours[name] = {};
            }
            this.$behaviours[name][action] = callback;
        };
        
        this.addBehaviours = function (behaviours) {
            for (var key in behaviours) {
                for (var action in behaviours[key]) {
                    this.add(key, action, behaviours[key][action]);
                }
            }
        };
        
        this.remove = function (name) {
            if (this.$behaviours && this.$behaviours[name]) {
                delete this.$behaviours[name];
            }
        };
        
        this.inherit = function (mode, filter) {
            if (typeof mode === "function") {
                var behaviours = new mode().getBehaviours(filter);
            } else {
                var behaviours = mode.getBehaviours(filter);
            }
            this.addBehaviours(behaviours);
        };
        
        this.getBehaviours = function (filter) {
            if (!filter) {
                return this.$behaviours;
            } else {
                var ret = {};
                for (var i = 0; i < filter.length; i++) {
                    if (this.$behaviours[filter[i]]) {
                        ret[filter[i]] = this.$behaviours[filter[i]];
                    }
                }
                return ret;
            }
        };

    }).call(Behaviour.prototype);

    exports.Behaviour = Behaviour;
    });

    ace.define("ace/token_iterator",["require","exports","module","ace/range"], function(require, exports, module) {

    var Range = require("./range").Range;
    var TokenIterator = function(session, initialRow, initialColumn) {
        this.$session = session;
        this.$row = initialRow;
        this.$rowTokens = session.getTokens(initialRow);

        var token = session.getTokenAt(initialRow, initialColumn);
        this.$tokenIndex = token ? token.index : -1;
    };

    (function() { 
        this.stepBackward = function() {
            this.$tokenIndex -= 1;
            
            while (this.$tokenIndex < 0) {
                this.$row -= 1;
                if (this.$row < 0) {
                    this.$row = 0;
                    return null;
                }
                    
                this.$rowTokens = this.$session.getTokens(this.$row);
                this.$tokenIndex = this.$rowTokens.length - 1;
            }
                
            return this.$rowTokens[this.$tokenIndex];
        };   
        this.stepForward = function() {
            this.$tokenIndex += 1;
            var rowCount;
            while (this.$tokenIndex >= this.$rowTokens.length) {
                this.$row += 1;
                if (!rowCount)
                    rowCount = this.$session.getLength();
                if (this.$row >= rowCount) {
                    this.$row = rowCount - 1;
                    return null;
                }

                this.$rowTokens = this.$session.getTokens(this.$row);
                this.$tokenIndex = 0;
            }
                
            return this.$rowTokens[this.$tokenIndex];
        };      
        this.getCurrentToken = function () {
            return this.$rowTokens[this.$tokenIndex];
        };      
        this.getCurrentTokenRow = function () {
            return this.$row;
        };     
        this.getCurrentTokenColumn = function() {
            var rowTokens = this.$rowTokens;
            var tokenIndex = this.$tokenIndex;
            var column = rowTokens[tokenIndex].start;
            if (column !== undefined)
                return column;
                
            column = 0;
            while (tokenIndex > 0) {
                tokenIndex -= 1;
                column += rowTokens[tokenIndex].value.length;
            }
            
            return column;  
        };
        this.getCurrentTokenPosition = function() {
            return {row: this.$row, column: this.getCurrentTokenColumn()};
        };
        this.getCurrentTokenRange = function() {
            var token = this.$rowTokens[this.$tokenIndex];
            var column = this.getCurrentTokenColumn();
            return new Range(this.$row, column, this.$row, column + token.value.length);
        };
        
    }).call(TokenIterator.prototype);

    exports.TokenIterator = TokenIterator;
    });

    ace.define("ace/mode/behaviour/cstyle",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(require, exports, module) {

    var oop = require("../../lib/oop");
    var Behaviour = require("../behaviour").Behaviour;
    var TokenIterator = require("../../token_iterator").TokenIterator;
    var lang = require("../../lib/lang");

    var SAFE_INSERT_IN_TOKENS =
        ["text", "paren.rparen", "rparen", "paren", "punctuation.operator"];
    var SAFE_INSERT_BEFORE_TOKENS =
        ["text", "paren.rparen", "rparen", "paren", "punctuation.operator", "comment"];

    var context;
    var contextCache = {};
    var defaultQuotes = {'"' : '"', "'" : "'"};

    var initContext = function(editor) {
        var id = -1;
        if (editor.multiSelect) {
            id = editor.selection.index;
            if (contextCache.rangeCount != editor.multiSelect.rangeCount)
                contextCache = {rangeCount: editor.multiSelect.rangeCount};
        }
        if (contextCache[id])
            return context = contextCache[id];
        context = contextCache[id] = {
            autoInsertedBrackets: 0,
            autoInsertedRow: -1,
            autoInsertedLineEnd: "",
            maybeInsertedBrackets: 0,
            maybeInsertedRow: -1,
            maybeInsertedLineStart: "",
            maybeInsertedLineEnd: ""
        };
    };

    var getWrapped = function(selection, selected, opening, closing) {
        var rowDiff = selection.end.row - selection.start.row;
        return {
            text: opening + selected + closing,
            selection: [
                    0,
                    selection.start.column + 1,
                    rowDiff,
                    selection.end.column + (rowDiff ? 0 : 1)
                ]
        };
    };

    var CstyleBehaviour = function(options) {
        this.add("braces", "insertion", function(state, action, editor, session, text) {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            if (text == '{') {
                initContext(editor);
                var selection = editor.getSelectionRange();
                var selected = session.doc.getTextRange(selection);
                if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                    return getWrapped(selection, selected, '{', '}');
                } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                    if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options && options.braces) {
                        CstyleBehaviour.recordAutoInsert(editor, session, "}");
                        return {
                            text: '{}',
                            selection: [1, 1]
                        };
                    } else {
                        CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                        return {
                            text: '{',
                            selection: [1, 1]
                        };
                    }
                }
            } else if (text == '}') {
                initContext(editor);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar == '}') {
                    var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
                    if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                        CstyleBehaviour.popAutoInsertedClosing();
                        return {
                            text: '',
                            selection: [1, 1]
                        };
                    }
                }
            } else if (text == "\n" || text == "\r\n") {
                initContext(editor);
                var closing = "";
                if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                    closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                    CstyleBehaviour.clearMaybeInsertedClosing();
                }
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar === '}') {
                    var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');
                    if (!openBracePos)
                         return null;
                    var next_indent = this.$getIndent(session.getLine(openBracePos.row));
                } else if (closing) {
                    var next_indent = this.$getIndent(line);
                } else {
                    CstyleBehaviour.clearMaybeInsertedClosing();
                    return;
                }
                var indent = next_indent + session.getTabString();

                return {
                    text: '\n' + indent + '\n' + next_indent + closing,
                    selection: [1, indent.length, 1, indent.length]
                };
            } else {
                CstyleBehaviour.clearMaybeInsertedClosing();
            }
        });

        this.add("braces", "deletion", function(state, action, editor, session, range) {
            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && selected == '{') {
                initContext(editor);
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.end.column, range.end.column + 1);
                if (rightChar == '}') {
                    range.end.column++;
                    return range;
                } else {
                    context.maybeInsertedBrackets--;
                }
            }
        });

        this.add("parens", "insertion", function(state, action, editor, session, text) {
            if (text == '(') {
                initContext(editor);
                var selection = editor.getSelectionRange();
                var selected = session.doc.getTextRange(selection);
                if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                    return getWrapped(selection, selected, '(', ')');
                } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                    CstyleBehaviour.recordAutoInsert(editor, session, ")");
                    return {
                        text: '()',
                        selection: [1, 1]
                    };
                }
            } else if (text == ')') {
                initContext(editor);
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar == ')') {
                    var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});
                    if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                        CstyleBehaviour.popAutoInsertedClosing();
                        return {
                            text: '',
                            selection: [1, 1]
                        };
                    }
                }
            }
        });

        this.add("parens", "deletion", function(state, action, editor, session, range) {
            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && selected == '(') {
                initContext(editor);
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                if (rightChar == ')') {
                    range.end.column++;
                    return range;
                }
            }
        });

        this.add("brackets", "insertion", function(state, action, editor, session, text) {
            if (text == '[') {
                initContext(editor);
                var selection = editor.getSelectionRange();
                var selected = session.doc.getTextRange(selection);
                if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                    return getWrapped(selection, selected, '[', ']');
                } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                    CstyleBehaviour.recordAutoInsert(editor, session, "]");
                    return {
                        text: '[]',
                        selection: [1, 1]
                    };
                }
            } else if (text == ']') {
                initContext(editor);
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar == ']') {
                    var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});
                    if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                        CstyleBehaviour.popAutoInsertedClosing();
                        return {
                            text: '',
                            selection: [1, 1]
                        };
                    }
                }
            }
        });

        this.add("brackets", "deletion", function(state, action, editor, session, range) {
            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && selected == '[') {
                initContext(editor);
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                if (rightChar == ']') {
                    range.end.column++;
                    return range;
                }
            }
        });

        this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
            var quotes = session.$mode.$quotes || defaultQuotes;
            if (text.length == 1 && quotes[text]) {
                if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1) 
                    return;
                initContext(editor);
                var quote = text;
                var selection = editor.getSelectionRange();
                var selected = session.doc.getTextRange(selection);
                if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
                    return getWrapped(selection, selected, quote, quote);
                } else if (!selected) {
                    var cursor = editor.getCursorPosition();
                    var line = session.doc.getLine(cursor.row);
                    var leftChar = line.substring(cursor.column-1, cursor.column);
                    var rightChar = line.substring(cursor.column, cursor.column + 1);
                    
                    var token = session.getTokenAt(cursor.row, cursor.column);
                    var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                    if (leftChar == "\\" && token && /escape/.test(token.type))
                        return null;
                    
                    var stringBefore = token && /string|escape/.test(token.type);
                    var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
                    
                    var pair;
                    if (rightChar == quote) {
                        pair = stringBefore !== stringAfter;
                        if (pair && /string\.end/.test(rightToken.type))
                            pair = false;
                    } else {
                        if (stringBefore && !stringAfter)
                            return null; // wrap string with different quote
                        if (stringBefore && stringAfter)
                            return null; // do not pair quotes inside strings
                        var wordRe = session.$mode.tokenRe;
                        wordRe.lastIndex = 0;
                        var isWordBefore = wordRe.test(leftChar);
                        wordRe.lastIndex = 0;
                        var isWordAfter = wordRe.test(leftChar);
                        if (isWordBefore || isWordAfter)
                            return null; // before or after alphanumeric
                        if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                            return null; // there is rightChar and it isn't closing
                        var charBefore = line[cursor.column - 2];
                        if (leftChar == quote &&  (charBefore == quote || wordRe.test(charBefore)))
                            return null;
                        pair = true;
                    }
                    return {
                        text: pair ? quote + quote : "",
                        selection: [1,1]
                    };
                }
            }
        });

        this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
            var quotes = session.$mode.$quotes || defaultQuotes;

            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {
                initContext(editor);
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                if (rightChar == selected) {
                    range.end.column++;
                    return range;
                }
            }
        });

    };

        
    CstyleBehaviour.isSaneInsertion = function(editor, session) {
        var cursor = editor.getCursorPosition();
        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
            if (/[)}\]]/.test(editor.session.getLine(cursor.row)[cursor.column]))
                return true;
            var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
            if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
                return false;
        }
        iterator.stepForward();
        return iterator.getCurrentTokenRow() !== cursor.row ||
            this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
    };

    CstyleBehaviour.$matchTokenType = function(token, types) {
        return types.indexOf(token.type || token) > -1;
    };

    CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
            context.autoInsertedBrackets = 0;
        context.autoInsertedRow = cursor.row;
        context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
        context.autoInsertedBrackets++;
    };

    CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this.isMaybeInsertedClosing(cursor, line))
            context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = cursor.row;
        context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
        context.maybeInsertedLineEnd = line.substr(cursor.column);
        context.maybeInsertedBrackets++;
    };

    CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
        return context.autoInsertedBrackets > 0 &&
            cursor.row === context.autoInsertedRow &&
            bracket === context.autoInsertedLineEnd[0] &&
            line.substr(cursor.column) === context.autoInsertedLineEnd;
    };

    CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
        return context.maybeInsertedBrackets > 0 &&
            cursor.row === context.maybeInsertedRow &&
            line.substr(cursor.column) === context.maybeInsertedLineEnd &&
            line.substr(0, cursor.column) == context.maybeInsertedLineStart;
    };

    CstyleBehaviour.popAutoInsertedClosing = function() {
        context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
        context.autoInsertedBrackets--;
    };

    CstyleBehaviour.clearMaybeInsertedClosing = function() {
        if (context) {
            context.maybeInsertedBrackets = 0;
            context.maybeInsertedRow = -1;
        }
    };



    oop.inherits(CstyleBehaviour, Behaviour);

    exports.CstyleBehaviour = CstyleBehaviour;
    });

    ace.define("ace/unicode",["require","exports","module"], function(require, exports, module) {
    var wordChars = [48,9,8,25,5,0,2,25,48,0,11,0,5,0,6,22,2,30,2,457,5,11,15,4,8,0,2,0,18,116,2,1,3,3,9,0,2,2,2,0,2,19,2,82,2,138,2,4,3,155,12,37,3,0,8,38,10,44,2,0,2,1,2,1,2,0,9,26,6,2,30,10,7,61,2,9,5,101,2,7,3,9,2,18,3,0,17,58,3,100,15,53,5,0,6,45,211,57,3,18,2,5,3,11,3,9,2,1,7,6,2,2,2,7,3,1,3,21,2,6,2,0,4,3,3,8,3,1,3,3,9,0,5,1,2,4,3,11,16,2,2,5,5,1,3,21,2,6,2,1,2,1,2,1,3,0,2,4,5,1,3,2,4,0,8,3,2,0,8,15,12,2,2,8,2,2,2,21,2,6,2,1,2,4,3,9,2,2,2,2,3,0,16,3,3,9,18,2,2,7,3,1,3,21,2,6,2,1,2,4,3,8,3,1,3,2,9,1,5,1,2,4,3,9,2,0,17,1,2,5,4,2,2,3,4,1,2,0,2,1,4,1,4,2,4,11,5,4,4,2,2,3,3,0,7,0,15,9,18,2,2,7,2,2,2,22,2,9,2,4,4,7,2,2,2,3,8,1,2,1,7,3,3,9,19,1,2,7,2,2,2,22,2,9,2,4,3,8,2,2,2,3,8,1,8,0,2,3,3,9,19,1,2,7,2,2,2,22,2,15,4,7,2,2,2,3,10,0,9,3,3,9,11,5,3,1,2,17,4,23,2,8,2,0,3,6,4,0,5,5,2,0,2,7,19,1,14,57,6,14,2,9,40,1,2,0,3,1,2,0,3,0,7,3,2,6,2,2,2,0,2,0,3,1,2,12,2,2,3,4,2,0,2,5,3,9,3,1,35,0,24,1,7,9,12,0,2,0,2,0,5,9,2,35,5,19,2,5,5,7,2,35,10,0,58,73,7,77,3,37,11,42,2,0,4,328,2,3,3,6,2,0,2,3,3,40,2,3,3,32,2,3,3,6,2,0,2,3,3,14,2,56,2,3,3,66,5,0,33,15,17,84,13,619,3,16,2,25,6,74,22,12,2,6,12,20,12,19,13,12,2,2,2,1,13,51,3,29,4,0,5,1,3,9,34,2,3,9,7,87,9,42,6,69,11,28,4,11,5,11,11,39,3,4,12,43,5,25,7,10,38,27,5,62,2,28,3,10,7,9,14,0,89,75,5,9,18,8,13,42,4,11,71,55,9,9,4,48,83,2,2,30,14,230,23,280,3,5,3,37,3,5,3,7,2,0,2,0,2,0,2,30,3,52,2,6,2,0,4,2,2,6,4,3,3,5,5,12,6,2,2,6,67,1,20,0,29,0,14,0,17,4,60,12,5,0,4,11,18,0,5,0,3,9,2,0,4,4,7,0,2,0,2,0,2,3,2,10,3,3,6,4,5,0,53,1,2684,46,2,46,2,132,7,6,15,37,11,53,10,0,17,22,10,6,2,6,2,6,2,6,2,6,2,6,2,6,2,6,2,31,48,0,470,1,36,5,2,4,6,1,5,85,3,1,3,2,2,89,2,3,6,40,4,93,18,23,57,15,513,6581,75,20939,53,1164,68,45,3,268,4,27,21,31,3,13,13,1,2,24,9,69,11,1,38,8,3,102,3,1,111,44,25,51,13,68,12,9,7,23,4,0,5,45,3,35,13,28,4,64,15,10,39,54,10,13,3,9,7,22,4,1,5,66,25,2,227,42,2,1,3,9,7,11171,13,22,5,48,8453,301,3,61,3,105,39,6,13,4,6,11,2,12,2,4,2,0,2,1,2,1,2,107,34,362,19,63,3,53,41,11,5,15,17,6,13,1,25,2,33,4,2,134,20,9,8,25,5,0,2,25,12,88,4,5,3,5,3,5,3,2];

    var code = 0;
    var str = [];
    for (var i = 0; i < wordChars.length; i += 2) {
        str.push(code += wordChars[i]);
        if (wordChars[i + 1])
            str.push(45, code += wordChars[i + 1]);
    }

    exports.wordChars = String.fromCharCode.apply(null, str);

    });

    ace.define("ace/mode/text",["require","exports","module","ace/config","ace/tokenizer","ace/mode/text_highlight_rules","ace/mode/behaviour/cstyle","ace/unicode","ace/lib/lang","ace/token_iterator","ace/range"], function(require, exports, module) {
    var config = require("../config");

    var Tokenizer = require("../tokenizer").Tokenizer;
    var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
    var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
    var unicode = require("../unicode");
    var lang = require("../lib/lang");
    var TokenIterator = require("../token_iterator").TokenIterator;
    var Range = require("../range").Range;

    var Mode = function() {
        this.HighlightRules = TextHighlightRules;
    };

    (function() {
        this.$defaultBehaviour = new CstyleBehaviour();

        this.tokenRe = new RegExp("^[" + unicode.wordChars + "\\$_]+", "g");

        this.nonTokenRe = new RegExp("^(?:[^" + unicode.wordChars + "\\$_]|\\s])+", "g");

        this.getTokenizer = function() {
            if (!this.$tokenizer) {
                this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
                this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
            }
            return this.$tokenizer;
        };

        this.lineCommentStart = "";
        this.blockComment = "";

        this.toggleCommentLines = function(state, session, startRow, endRow) {
            var doc = session.doc;

            var ignoreBlankLines = true;
            var shouldRemove = true;
            var minIndent = Infinity;
            var tabSize = session.getTabSize();
            var insertAtTabStop = false;

            if (!this.lineCommentStart) {
                if (!this.blockComment)
                    return false;
                var lineCommentStart = this.blockComment.start;
                var lineCommentEnd = this.blockComment.end;
                var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
                var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");

                var comment = function(line, i) {
                    if (testRemove(line, i))
                        return;
                    if (!ignoreBlankLines || /\S/.test(line)) {
                        doc.insertInLine({row: i, column: line.length}, lineCommentEnd);
                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                    }
                };

                var uncomment = function(line, i) {
                    var m;
                    if (m = line.match(regexpEnd))
                        doc.removeInLine(i, line.length - m[0].length, line.length);
                    if (m = line.match(regexpStart))
                        doc.removeInLine(i, m[1].length, m[0].length);
                };

                var testRemove = function(line, row) {
                    if (regexpStart.test(line))
                        return true;
                    var tokens = session.getTokens(row);
                    for (var i = 0; i < tokens.length; i++) {
                        if (tokens[i].type === "comment")
                            return true;
                    }
                };
            } else {
                if (Array.isArray(this.lineCommentStart)) {
                    var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                    var lineCommentStart = this.lineCommentStart[0];
                } else {
                    var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                    var lineCommentStart = this.lineCommentStart;
                }
                regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
                
                insertAtTabStop = session.getUseSoftTabs();

                var uncomment = function(line, i) {
                    var m = line.match(regexpStart);
                    if (!m) return;
                    var start = m[1].length, end = m[0].length;
                    if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                        end--;
                    doc.removeInLine(i, start, end);
                };
                var commentWithSpace = lineCommentStart + " ";
                var comment = function(line, i) {
                    if (!ignoreBlankLines || /\S/.test(line)) {
                        if (shouldInsertSpace(line, minIndent, minIndent))
                            doc.insertInLine({row: i, column: minIndent}, commentWithSpace);
                        else
                            doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                    }
                };
                var testRemove = function(line, i) {
                    return regexpStart.test(line);
                };
                
                var shouldInsertSpace = function(line, before, after) {
                    var spaces = 0;
                    while (before-- && line.charAt(before) == " ")
                        spaces++;
                    if (spaces % tabSize != 0)
                        return false;
                    var spaces = 0;
                    while (line.charAt(after++) == " ")
                        spaces++;
                    if (tabSize > 2)
                        return spaces % tabSize != tabSize - 1;
                    else
                        return spaces % tabSize == 0;
                };
            }

            function iter(fun) {
                for (var i = startRow; i <= endRow; i++)
                    fun(doc.getLine(i), i);
            }


            var minEmptyLength = Infinity;
            iter(function(line, i) {
                var indent = line.search(/\S/);
                if (indent !== -1) {
                    if (indent < minIndent)
                        minIndent = indent;
                    if (shouldRemove && !testRemove(line, i))
                        shouldRemove = false;
                } else if (minEmptyLength > line.length) {
                    minEmptyLength = line.length;
                }
            });

            if (minIndent == Infinity) {
                minIndent = minEmptyLength;
                ignoreBlankLines = false;
                shouldRemove = false;
            }

            if (insertAtTabStop && minIndent % tabSize != 0)
                minIndent = Math.floor(minIndent / tabSize) * tabSize;

            iter(shouldRemove ? uncomment : comment);
        };

        this.toggleBlockComment = function(state, session, range, cursor) {
            var comment = this.blockComment;
            if (!comment)
                return;
            if (!comment.start && comment[0])
                comment = comment[0];

            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();

            session.selection;
            var initialRange = session.selection.toOrientedRange();
            var startRow, colDiff;

            if (token && /comment/.test(token.type)) {
                var startRange, endRange;
                while (token && /comment/.test(token.type)) {
                    var i = token.value.indexOf(comment.start);
                    if (i != -1) {
                        var row = iterator.getCurrentTokenRow();
                        var column = iterator.getCurrentTokenColumn() + i;
                        startRange = new Range(row, column, row, column + comment.start.length);
                        break;
                    }
                    token = iterator.stepBackward();
                }

                var iterator = new TokenIterator(session, cursor.row, cursor.column);
                var token = iterator.getCurrentToken();
                while (token && /comment/.test(token.type)) {
                    var i = token.value.indexOf(comment.end);
                    if (i != -1) {
                        var row = iterator.getCurrentTokenRow();
                        var column = iterator.getCurrentTokenColumn() + i;
                        endRange = new Range(row, column, row, column + comment.end.length);
                        break;
                    }
                    token = iterator.stepForward();
                }
                if (endRange)
                    session.remove(endRange);
                if (startRange) {
                    session.remove(startRange);
                    startRow = startRange.start.row;
                    colDiff = -comment.start.length;
                }
            } else {
                colDiff = comment.start.length;
                startRow = range.start.row;
                session.insert(range.end, comment.end);
                session.insert(range.start, comment.start);
            }
            if (initialRange.start.row == startRow)
                initialRange.start.column += colDiff;
            if (initialRange.end.row == startRow)
                initialRange.end.column += colDiff;
            session.selection.fromOrientedRange(initialRange);
        };

        this.getNextLineIndent = function(state, line, tab) {
            return this.$getIndent(line);
        };

        this.checkOutdent = function(state, line, input) {
            return false;
        };

        this.autoOutdent = function(state, doc, row) {
        };

        this.$getIndent = function(line) {
            return line.match(/^\s*/)[0];
        };

        this.createWorker = function(session) {
            return null;
        };

        this.createModeDelegates = function (mapping) {
            this.$embeds = [];
            this.$modes = {};
            for (var i in mapping) {
                if (mapping[i]) {
                    var Mode = mapping[i];
                    var id = Mode.prototype.$id;
                    var mode = config.$modes[id];
                    if (!mode)
                        config.$modes[id] = mode = new Mode();
                    if (!config.$modes[i])
                        config.$modes[i] = mode;
                    this.$embeds.push(i);
                    this.$modes[i] = mode;
                }
            }

            var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent", 
                "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];

            for (var i = 0; i < delegations.length; i++) {
                (function(scope) {
                  var functionName = delegations[i];
                  var defaultHandler = scope[functionName];
                  scope[delegations[i]] = function() {
                      return this.$delegator(functionName, arguments, defaultHandler);
                  };
                }(this));
            }
        };

        this.$delegator = function(method, args, defaultHandler) {
            var state = args[0] || "start";
            if (typeof state != "string") {
                if (Array.isArray(state[2])) {
                    var language = state[2][state[2].length - 1];
                    var mode = this.$modes[language];
                    if (mode)
                        return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));
                }
                state = state[0] || "start";
            }
                
            for (var i = 0; i < this.$embeds.length; i++) {
                if (!this.$modes[this.$embeds[i]]) continue;

                var split = state.split(this.$embeds[i]);
                if (!split[0] && split[1]) {
                    args[0] = split[1];
                    var mode = this.$modes[this.$embeds[i]];
                    return mode[method].apply(mode, args);
                }
            }
            var ret = defaultHandler.apply(this, args);
            return defaultHandler ? ret : undefined;
        };

        this.transformAction = function(state, action, editor, session, param) {
            if (this.$behaviour) {
                var behaviours = this.$behaviour.getBehaviours();
                for (var key in behaviours) {
                    if (behaviours[key][action]) {
                        var ret = behaviours[key][action].apply(this, arguments);
                        if (ret) {
                            return ret;
                        }
                    }
                }
            }
        };
        
        this.getKeywords = function(append) {
            if (!this.completionKeywords) {
                var rules = this.$tokenizer.rules;
                var completionKeywords = [];
                for (var rule in rules) {
                    var ruleItr = rules[rule];
                    for (var r = 0, l = ruleItr.length; r < l; r++) {
                        if (typeof ruleItr[r].token === "string") {
                            if (/keyword|support|storage/.test(ruleItr[r].token))
                                completionKeywords.push(ruleItr[r].regex);
                        }
                        else if (typeof ruleItr[r].token === "object") {
                            for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {    
                                if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                    var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                    completionKeywords.push(rule.substr(1, rule.length - 2));
                                }
                            }
                        }
                    }
                }
                this.completionKeywords = completionKeywords;
            }
            if (!append)
                return this.$keywordList;
            return completionKeywords.concat(this.$keywordList || []);
        };
        
        this.$createKeywordList = function() {
            if (!this.$highlightRules)
                this.getTokenizer();
            return this.$keywordList = this.$highlightRules.$keywordList || [];
        };

        this.getCompletions = function(state, session, pos, prefix) {
            var keywords = this.$keywordList || this.$createKeywordList();
            return keywords.map(function(word) {
                return {
                    name: word,
                    value: word,
                    score: 0,
                    meta: "keyword"
                };
            });
        };

        this.$id = "ace/mode/text";
    }).call(Mode.prototype);

    exports.Mode = Mode;
    });

    ace.define("ace/apply_delta",["require","exports","module"], function(require, exports, module) {

    exports.applyDelta = function(docLines, delta, doNotValidate) {
        
        var row = delta.start.row;
        var startColumn = delta.start.column;
        var line = docLines[row] || "";
        switch (delta.action) {
            case "insert":
                var lines = delta.lines;
                if (lines.length === 1) {
                    docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
                } else {
                    var args = [row, 1].concat(delta.lines);
                    docLines.splice.apply(docLines, args);
                    docLines[row] = line.substring(0, startColumn) + docLines[row];
                    docLines[row + delta.lines.length - 1] += line.substring(startColumn);
                }
                break;
            case "remove":
                var endColumn = delta.end.column;
                var endRow = delta.end.row;
                if (row === endRow) {
                    docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
                } else {
                    docLines.splice(
                        row, endRow - row + 1,
                        line.substring(0, startColumn) + docLines[endRow].substring(endColumn)
                    );
                }
                break;
        }
    };
    });

    ace.define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module) {

    var oop = require("./lib/oop");
    var EventEmitter = require("./lib/event_emitter").EventEmitter;

    var Anchor = exports.Anchor = function(doc, row, column) {
        this.$onChange = this.onChange.bind(this);
        this.attach(doc);
        
        if (typeof column == "undefined")
            this.setPosition(row.row, row.column);
        else
            this.setPosition(row, column);
    };

    (function() {

        oop.implement(this, EventEmitter);
        this.getPosition = function() {
            return this.$clipPositionToDocument(this.row, this.column);
        };
        this.getDocument = function() {
            return this.document;
        };
        this.$insertRight = false;
        this.onChange = function(delta) {
            if (delta.start.row == delta.end.row && delta.start.row != this.row)
                return;

            if (delta.start.row > this.row)
                return;
                
            var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);
            this.setPosition(point.row, point.column, true);
        };
        
        function $pointsInOrder(point1, point2, equalPointsInOrder) {
            var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
            return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
        }
                
        function $getTransformedPoint(delta, point, moveIfEqual) {
            var deltaIsInsert = delta.action == "insert";
            var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);
            var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
            var deltaStart = delta.start;
            var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
            if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
                return {
                    row: point.row,
                    column: point.column
                };
            }
            if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
                return {
                    row: point.row + deltaRowShift,
                    column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
                };
            }
            
            return {
                row: deltaStart.row,
                column: deltaStart.column
            };
        }
        this.setPosition = function(row, column, noClip) {
            var pos;
            if (noClip) {
                pos = {
                    row: row,
                    column: column
                };
            } else {
                pos = this.$clipPositionToDocument(row, column);
            }

            if (this.row == pos.row && this.column == pos.column)
                return;

            var old = {
                row: this.row,
                column: this.column
            };

            this.row = pos.row;
            this.column = pos.column;
            this._signal("change", {
                old: old,
                value: pos
            });
        };
        this.detach = function() {
            this.document.off("change", this.$onChange);
        };
        this.attach = function(doc) {
            this.document = doc || this.document;
            this.document.on("change", this.$onChange);
        };
        this.$clipPositionToDocument = function(row, column) {
            var pos = {};

            if (row >= this.document.getLength()) {
                pos.row = Math.max(0, this.document.getLength() - 1);
                pos.column = this.document.getLine(pos.row).length;
            }
            else if (row < 0) {
                pos.row = 0;
                pos.column = 0;
            }
            else {
                pos.row = row;
                pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
            }

            if (column < 0)
                pos.column = 0;

            return pos;
        };

    }).call(Anchor.prototype);

    });

    ace.define("ace/document",["require","exports","module","ace/lib/oop","ace/apply_delta","ace/lib/event_emitter","ace/range","ace/anchor"], function(require, exports, module) {

    var oop = require("./lib/oop");
    var applyDelta = require("./apply_delta").applyDelta;
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var Range = require("./range").Range;
    var Anchor = require("./anchor").Anchor;

    var Document = function(textOrLines) {
        this.$lines = [""];
        if (textOrLines.length === 0) {
            this.$lines = [""];
        } else if (Array.isArray(textOrLines)) {
            this.insertMergedLines({row: 0, column: 0}, textOrLines);
        } else {
            this.insert({row: 0, column:0}, textOrLines);
        }
    };

    (function() {

        oop.implement(this, EventEmitter);
        this.setValue = function(text) {
            var len = this.getLength() - 1;
            this.remove(new Range(0, 0, len, this.getLine(len).length));
            this.insert({row: 0, column: 0}, text);
        };
        this.getValue = function() {
            return this.getAllLines().join(this.getNewLineCharacter());
        };
        this.createAnchor = function(row, column) {
            return new Anchor(this, row, column);
        };
        if ("aaa".split(/a/).length === 0) {
            this.$split = function(text) {
                return text.replace(/\r\n|\r/g, "\n").split("\n");
            };
        } else {
            this.$split = function(text) {
                return text.split(/\r\n|\r|\n/);
            };
        }


        this.$detectNewLine = function(text) {
            var match = text.match(/^.*?(\r\n|\r|\n)/m);
            this.$autoNewLine = match ? match[1] : "\n";
            this._signal("changeNewLineMode");
        };
        this.getNewLineCharacter = function() {
            switch (this.$newLineMode) {
              case "windows":
                return "\r\n";
              case "unix":
                return "\n";
              default:
                return this.$autoNewLine || "\n";
            }
        };

        this.$autoNewLine = "";
        this.$newLineMode = "auto";
        this.setNewLineMode = function(newLineMode) {
            if (this.$newLineMode === newLineMode)
                return;

            this.$newLineMode = newLineMode;
            this._signal("changeNewLineMode");
        };
        this.getNewLineMode = function() {
            return this.$newLineMode;
        };
        this.isNewLine = function(text) {
            return (text == "\r\n" || text == "\r" || text == "\n");
        };
        this.getLine = function(row) {
            return this.$lines[row] || "";
        };
        this.getLines = function(firstRow, lastRow) {
            return this.$lines.slice(firstRow, lastRow + 1);
        };
        this.getAllLines = function() {
            return this.getLines(0, this.getLength());
        };
        this.getLength = function() {
            return this.$lines.length;
        };
        this.getTextRange = function(range) {
            return this.getLinesForRange(range).join(this.getNewLineCharacter());
        };
        this.getLinesForRange = function(range) {
            var lines;
            if (range.start.row === range.end.row) {
                lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
            } else {
                lines = this.getLines(range.start.row, range.end.row);
                lines[0] = (lines[0] || "").substring(range.start.column);
                var l = lines.length - 1;
                if (range.end.row - range.start.row == l)
                    lines[l] = lines[l].substring(0, range.end.column);
            }
            return lines;
        };
        this.insertLines = function(row, lines) {
            console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
            return this.insertFullLines(row, lines);
        };
        this.removeLines = function(firstRow, lastRow) {
            console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
            return this.removeFullLines(firstRow, lastRow);
        };
        this.insertNewLine = function(position) {
            console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
            return this.insertMergedLines(position, ["", ""]);
        };
        this.insert = function(position, text) {
            if (this.getLength() <= 1)
                this.$detectNewLine(text);
            
            return this.insertMergedLines(position, this.$split(text));
        };
        this.insertInLine = function(position, text) {
            var start = this.clippedPos(position.row, position.column);
            var end = this.pos(position.row, position.column + text.length);
            
            this.applyDelta({
                start: start,
                end: end,
                action: "insert",
                lines: [text]
            }, true);
            
            return this.clonePos(end);
        };
        
        this.clippedPos = function(row, column) {
            var length = this.getLength();
            if (row === undefined) {
                row = length;
            } else if (row < 0) {
                row = 0;
            } else if (row >= length) {
                row = length - 1;
                column = undefined;
            }
            var line = this.getLine(row);
            if (column == undefined)
                column = line.length;
            column = Math.min(Math.max(column, 0), line.length);
            return {row: row, column: column};
        };
        
        this.clonePos = function(pos) {
            return {row: pos.row, column: pos.column};
        };
        
        this.pos = function(row, column) {
            return {row: row, column: column};
        };
        
        this.$clipPosition = function(position) {
            var length = this.getLength();
            if (position.row >= length) {
                position.row = Math.max(0, length - 1);
                position.column = this.getLine(length - 1).length;
            } else {
                position.row = Math.max(0, position.row);
                position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
            }
            return position;
        };
        this.insertFullLines = function(row, lines) {
            row = Math.min(Math.max(row, 0), this.getLength());
            var column = 0;
            if (row < this.getLength()) {
                lines = lines.concat([""]);
                column = 0;
            } else {
                lines = [""].concat(lines);
                row--;
                column = this.$lines[row].length;
            }
            this.insertMergedLines({row: row, column: column}, lines);
        };    
        this.insertMergedLines = function(position, lines) {
            var start = this.clippedPos(position.row, position.column);
            var end = {
                row: start.row + lines.length - 1,
                column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
            };
            
            this.applyDelta({
                start: start,
                end: end,
                action: "insert",
                lines: lines
            });
            
            return this.clonePos(end);
        };
        this.remove = function(range) {
            var start = this.clippedPos(range.start.row, range.start.column);
            var end = this.clippedPos(range.end.row, range.end.column);
            this.applyDelta({
                start: start,
                end: end,
                action: "remove",
                lines: this.getLinesForRange({start: start, end: end})
            });
            return this.clonePos(start);
        };
        this.removeInLine = function(row, startColumn, endColumn) {
            var start = this.clippedPos(row, startColumn);
            var end = this.clippedPos(row, endColumn);
            
            this.applyDelta({
                start: start,
                end: end,
                action: "remove",
                lines: this.getLinesForRange({start: start, end: end})
            }, true);
            
            return this.clonePos(start);
        };
        this.removeFullLines = function(firstRow, lastRow) {
            firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
            lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);
            var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
            var deleteLastNewLine  = lastRow  < this.getLength() - 1;
            var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );
            var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );
            var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );
            var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); 
            var range = new Range(startRow, startCol, endRow, endCol);
            var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
            
            this.applyDelta({
                start: range.start,
                end: range.end,
                action: "remove",
                lines: this.getLinesForRange(range)
            });
            return deletedLines;
        };
        this.removeNewLine = function(row) {
            if (row < this.getLength() - 1 && row >= 0) {
                this.applyDelta({
                    start: this.pos(row, this.getLine(row).length),
                    end: this.pos(row + 1, 0),
                    action: "remove",
                    lines: ["", ""]
                });
            }
        };
        this.replace = function(range, text) {
            if (!(range instanceof Range))
                range = Range.fromPoints(range.start, range.end);
            if (text.length === 0 && range.isEmpty())
                return range.start;
            if (text == this.getTextRange(range))
                return range.end;

            this.remove(range);
            var end;
            if (text) {
                end = this.insert(range.start, text);
            }
            else {
                end = range.start;
            }
            
            return end;
        };
        this.applyDeltas = function(deltas) {
            for (var i=0; i<deltas.length; i++) {
                this.applyDelta(deltas[i]);
            }
        };
        this.revertDeltas = function(deltas) {
            for (var i=deltas.length-1; i>=0; i--) {
                this.revertDelta(deltas[i]);
            }
        };
        this.applyDelta = function(delta, doNotValidate) {
            var isInsert = delta.action == "insert";
            if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
                : !Range.comparePoints(delta.start, delta.end)) {
                return;
            }
            
            if (isInsert && delta.lines.length > 20000) {
                this.$splitAndapplyLargeDelta(delta, 20000);
            }
            else {
                applyDelta(this.$lines, delta, doNotValidate);
                this._signal("change", delta);
            }
        };
        
        this.$safeApplyDelta = function(delta) {
            var docLength = this.$lines.length;
            if (
                delta.action == "remove" && delta.start.row < docLength && delta.end.row < docLength
                || delta.action == "insert" && delta.start.row <= docLength
            ) {
                this.applyDelta(delta);
            }
        };
        
        this.$splitAndapplyLargeDelta = function(delta, MAX) {
            var lines = delta.lines;
            var l = lines.length - MAX + 1;
            var row = delta.start.row; 
            var column = delta.start.column;
            for (var from = 0, to = 0; from < l; from = to) {
                to += MAX - 1;
                var chunk = lines.slice(from, to);
                chunk.push("");
                this.applyDelta({
                    start: this.pos(row + from, column),
                    end: this.pos(row + to, column = 0),
                    action: delta.action,
                    lines: chunk
                }, true);
            }
            delta.lines = lines.slice(from);
            delta.start.row = row + from;
            delta.start.column = column;
            this.applyDelta(delta, true);
        };
        this.revertDelta = function(delta) {
            this.$safeApplyDelta({
                start: this.clonePos(delta.start),
                end: this.clonePos(delta.end),
                action: (delta.action == "insert" ? "remove" : "insert"),
                lines: delta.lines.slice()
            });
        };
        this.indexToPosition = function(index, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            for (var i = startRow || 0, l = lines.length; i < l; i++) {
                index -= lines[i].length + newlineLength;
                if (index < 0)
                    return {row: i, column: index + lines[i].length + newlineLength};
            }
            return {row: l-1, column: index + lines[l-1].length + newlineLength};
        };
        this.positionToIndex = function(pos, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            var index = 0;
            var row = Math.min(pos.row, lines.length);
            for (var i = startRow || 0; i < row; ++i)
                index += lines[i].length + newlineLength;

            return index + pos.column;
        };

    }).call(Document.prototype);

    exports.Document = Document;
    });

    ace.define("ace/background_tokenizer",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module) {

    var oop = require("./lib/oop");
    var EventEmitter = require("./lib/event_emitter").EventEmitter;

    var BackgroundTokenizer = function(tokenizer, editor) {
        this.running = false;
        this.lines = [];
        this.states = [];
        this.currentLine = 0;
        this.tokenizer = tokenizer;

        var self = this;

        this.$worker = function() {
            if (!self.running) { return; }

            var workerStart = new Date();
            var currentLine = self.currentLine;
            var endLine = -1;
            var doc = self.doc;

            var startLine = currentLine;
            while (self.lines[currentLine])
                currentLine++;
            
            var len = doc.getLength();
            var processedLines = 0;
            self.running = false;
            while (currentLine < len) {
                self.$tokenizeRow(currentLine);
                endLine = currentLine;
                do {
                    currentLine++;
                } while (self.lines[currentLine]);
                processedLines ++;
                if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {
                    self.running = setTimeout(self.$worker, 20);
                    break;
                }
            }
            self.currentLine = currentLine;
            
            if (endLine == -1)
                endLine = currentLine;
            
            if (startLine <= endLine)
                self.fireUpdateEvent(startLine, endLine);
        };
    };

    (function(){

        oop.implement(this, EventEmitter);
        this.setTokenizer = function(tokenizer) {
            this.tokenizer = tokenizer;
            this.lines = [];
            this.states = [];

            this.start(0);
        };
        this.setDocument = function(doc) {
            this.doc = doc;
            this.lines = [];
            this.states = [];

            this.stop();
        };
        this.fireUpdateEvent = function(firstRow, lastRow) {
            var data = {
                first: firstRow,
                last: lastRow
            };
            this._signal("update", {data: data});
        };
        this.start = function(startRow) {
            this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
            this.lines.splice(this.currentLine, this.lines.length);
            this.states.splice(this.currentLine, this.states.length);

            this.stop();
            this.running = setTimeout(this.$worker, 700);
        };
        
        this.scheduleStart = function() {
            if (!this.running)
                this.running = setTimeout(this.$worker, 700);
        };

        this.$updateOnChange = function(delta) {
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;

            if (len === 0) {
                this.lines[startRow] = null;
            } else if (delta.action == "remove") {
                this.lines.splice(startRow, len + 1, null);
                this.states.splice(startRow, len + 1, null);
            } else {
                var args = Array(len + 1);
                args.unshift(startRow, 1);
                this.lines.splice.apply(this.lines, args);
                this.states.splice.apply(this.states, args);
            }

            this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());

            this.stop();
        };
        this.stop = function() {
            if (this.running)
                clearTimeout(this.running);
            this.running = false;
        };
        this.getTokens = function(row) {
            return this.lines[row] || this.$tokenizeRow(row);
        };
        this.getState = function(row) {
            if (this.currentLine == row)
                this.$tokenizeRow(row);
            return this.states[row] || "start";
        };

        this.$tokenizeRow = function(row) {
            var line = this.doc.getLine(row);
            var state = this.states[row - 1];

            var data = this.tokenizer.getLineTokens(line, state, row);

            if (this.states[row] + "" !== data.state + "") {
                this.states[row] = data.state;
                this.lines[row + 1] = null;
                if (this.currentLine > row + 1)
                    this.currentLine = row + 1;
            } else if (this.currentLine == row) {
                this.currentLine = row + 1;
            }

            return this.lines[row] = data.tokens;
        };

    }).call(BackgroundTokenizer.prototype);

    exports.BackgroundTokenizer = BackgroundTokenizer;
    });

    ace.define("ace/search_highlight",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(require, exports, module) {

    var lang = require("./lib/lang");
    require("./lib/oop");
    var Range = require("./range").Range;

    var SearchHighlight = function(regExp, clazz, type) {
        this.setRegexp(regExp);
        this.clazz = clazz;
        this.type = type || "text";
    };

    (function() {
        this.MAX_RANGES = 500;
        
        this.setRegexp = function(regExp) {
            if (this.regExp+"" == regExp+"")
                return;
            this.regExp = regExp;
            this.cache = [];
        };

        this.update = function(html, markerLayer, session, config) {
            if (!this.regExp)
                return;
            var start = config.firstRow, end = config.lastRow;

            for (var i = start; i <= end; i++) {
                var ranges = this.cache[i];
                if (ranges == null) {
                    ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                    if (ranges.length > this.MAX_RANGES)
                        ranges = ranges.slice(0, this.MAX_RANGES);
                    ranges = ranges.map(function(match) {
                        return new Range(i, match.offset, i, match.offset + match.length);
                    });
                    this.cache[i] = ranges.length ? ranges : "";
                }

                for (var j = ranges.length; j --; ) {
                    markerLayer.drawSingleLineMarker(
                        html, ranges[j].toScreenRange(session), this.clazz, config);
                }
            }
        };

    }).call(SearchHighlight.prototype);

    exports.SearchHighlight = SearchHighlight;
    });

    ace.define("ace/edit_session/fold_line",["require","exports","module","ace/range"], function(require, exports, module) {

    var Range = require("../range").Range;
    function FoldLine(foldData, folds) {
        this.foldData = foldData;
        if (Array.isArray(folds)) {
            this.folds = folds;
        } else {
            folds = this.folds = [ folds ];
        }

        var last = folds[folds.length - 1];
        this.range = new Range(folds[0].start.row, folds[0].start.column,
                               last.end.row, last.end.column);
        this.start = this.range.start;
        this.end   = this.range.end;

        this.folds.forEach(function(fold) {
            fold.setFoldLine(this);
        }, this);
    }

    (function() {
        this.shiftRow = function(shift) {
            this.start.row += shift;
            this.end.row += shift;
            this.folds.forEach(function(fold) {
                fold.start.row += shift;
                fold.end.row += shift;
            });
        };

        this.addFold = function(fold) {
            if (fold.sameRow) {
                if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                    throw new Error("Can't add a fold to this FoldLine as it has no connection");
                }
                this.folds.push(fold);
                this.folds.sort(function(a, b) {
                    return -a.range.compareEnd(b.start.row, b.start.column);
                });
                if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                    this.end.row = fold.end.row;
                    this.end.column =  fold.end.column;
                } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                    this.start.row = fold.start.row;
                    this.start.column = fold.start.column;
                }
            } else if (fold.start.row == this.end.row) {
                this.folds.push(fold);
                this.end.row = fold.end.row;
                this.end.column = fold.end.column;
            } else if (fold.end.row == this.start.row) {
                this.folds.unshift(fold);
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
            } else {
                throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
            }
            fold.foldLine = this;
        };

        this.containsRow = function(row) {
            return row >= this.start.row && row <= this.end.row;
        };

        this.walk = function(callback, endRow, endColumn) {
            var lastEnd = 0,
                folds = this.folds,
                fold,
                cmp, stop, isNewRow = true;

            if (endRow == null) {
                endRow = this.end.row;
                endColumn = this.end.column;
            }

            for (var i = 0; i < folds.length; i++) {
                fold = folds[i];

                cmp = fold.range.compareStart(endRow, endColumn);
                if (cmp == -1) {
                    callback(null, endRow, endColumn, lastEnd, isNewRow);
                    return;
                }

                stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
                stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
                if (stop || cmp === 0) {
                    return;
                }
                isNewRow = !fold.sameRow;
                lastEnd = fold.end.column;
            }
            callback(null, endRow, endColumn, lastEnd, isNewRow);
        };

        this.getNextFoldTo = function(row, column) {
            var fold, cmp;
            for (var i = 0; i < this.folds.length; i++) {
                fold = this.folds[i];
                cmp = fold.range.compareEnd(row, column);
                if (cmp == -1) {
                    return {
                        fold: fold,
                        kind: "after"
                    };
                } else if (cmp === 0) {
                    return {
                        fold: fold,
                        kind: "inside"
                    };
                }
            }
            return null;
        };

        this.addRemoveChars = function(row, column, len) {
            var ret = this.getNextFoldTo(row, column),
                fold, folds;
            if (ret) {
                fold = ret.fold;
                if (ret.kind == "inside"
                    && fold.start.column != column
                    && fold.start.row != row)
                {
                    window.console && window.console.log(row, column, fold);
                } else if (fold.start.row == row) {
                    folds = this.folds;
                    var i = folds.indexOf(fold);
                    if (i === 0) {
                        this.start.column += len;
                    }
                    for (i; i < folds.length; i++) {
                        fold = folds[i];
                        fold.start.column += len;
                        if (!fold.sameRow) {
                            return;
                        }
                        fold.end.column += len;
                    }
                    this.end.column += len;
                }
            }
        };

        this.split = function(row, column) {
            var pos = this.getNextFoldTo(row, column);
            
            if (!pos || pos.kind == "inside")
                return null;
                
            var fold = pos.fold;
            var folds = this.folds;
            var foldData = this.foldData;
            
            var i = folds.indexOf(fold);
            var foldBefore = folds[i - 1];
            this.end.row = foldBefore.end.row;
            this.end.column = foldBefore.end.column;
            folds = folds.splice(i, folds.length - i);

            var newFoldLine = new FoldLine(foldData, folds);
            foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
            return newFoldLine;
        };

        this.merge = function(foldLineNext) {
            var folds = foldLineNext.folds;
            for (var i = 0; i < folds.length; i++) {
                this.addFold(folds[i]);
            }
            var foldData = this.foldData;
            foldData.splice(foldData.indexOf(foldLineNext), 1);
        };

        this.toString = function() {
            var ret = [this.range.toString() + ": [" ];

            this.folds.forEach(function(fold) {
                ret.push("  " + fold.toString());
            });
            ret.push("]");
            return ret.join("\n");
        };

        this.idxToPosition = function(idx) {
            var lastFoldEndColumn = 0;

            for (var i = 0; i < this.folds.length; i++) {
                var fold = this.folds[i];

                idx -= fold.start.column - lastFoldEndColumn;
                if (idx < 0) {
                    return {
                        row: fold.start.row,
                        column: fold.start.column + idx
                    };
                }

                idx -= fold.placeholder.length;
                if (idx < 0) {
                    return fold.start;
                }

                lastFoldEndColumn = fold.end.column;
            }

            return {
                row: this.end.row,
                column: this.end.column + idx
            };
        };
    }).call(FoldLine.prototype);

    exports.FoldLine = FoldLine;
    });

    ace.define("ace/range_list",["require","exports","module","ace/range"], function(require, exports, module) {
    var Range = require("./range").Range;
    var comparePoints = Range.comparePoints;

    var RangeList = function() {
        this.ranges = [];
        this.$bias = 1;
    };

    (function() {
        this.comparePoints = comparePoints;

        this.pointIndex = function(pos, excludeEdges, startIndex) {
            var list = this.ranges;

            for (var i = startIndex || 0; i < list.length; i++) {
                var range = list[i];
                var cmpEnd = comparePoints(pos, range.end);
                if (cmpEnd > 0)
                    continue;
                var cmpStart = comparePoints(pos, range.start);
                if (cmpEnd === 0)
                    return excludeEdges && cmpStart !== 0 ? -i-2 : i;
                if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
                    return i;

                return -i-1;
            }
            return -i - 1;
        };

        this.add = function(range) {
            var excludeEdges = !range.isEmpty();
            var startIndex = this.pointIndex(range.start, excludeEdges);
            if (startIndex < 0)
                startIndex = -startIndex - 1;

            var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);

            if (endIndex < 0)
                endIndex = -endIndex - 1;
            else
                endIndex++;
            return this.ranges.splice(startIndex, endIndex - startIndex, range);
        };

        this.addList = function(list) {
            var removed = [];
            for (var i = list.length; i--; ) {
                removed.push.apply(removed, this.add(list[i]));
            }
            return removed;
        };

        this.substractPoint = function(pos) {
            var i = this.pointIndex(pos);

            if (i >= 0)
                return this.ranges.splice(i, 1);
        };
        this.merge = function() {
            var removed = [];
            var list = this.ranges;
            
            list = list.sort(function(a, b) {
                return comparePoints(a.start, b.start);
            });
            
            var next = list[0], range;
            for (var i = 1; i < list.length; i++) {
                range = next;
                next = list[i];
                var cmp = comparePoints(range.end, next.start);
                if (cmp < 0)
                    continue;

                if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                    continue;

                if (comparePoints(range.end, next.end) < 0) {
                    range.end.row = next.end.row;
                    range.end.column = next.end.column;
                }

                list.splice(i, 1);
                removed.push(next);
                next = range;
                i--;
            }
            
            this.ranges = list;

            return removed;
        };

        this.contains = function(row, column) {
            return this.pointIndex({row: row, column: column}) >= 0;
        };

        this.containsPoint = function(pos) {
            return this.pointIndex(pos) >= 0;
        };

        this.rangeAtPoint = function(pos) {
            var i = this.pointIndex(pos);
            if (i >= 0)
                return this.ranges[i];
        };


        this.clipRows = function(startRow, endRow) {
            var list = this.ranges;
            if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
                return [];

            var startIndex = this.pointIndex({row: startRow, column: 0});
            if (startIndex < 0)
                startIndex = -startIndex - 1;
            var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);
            if (endIndex < 0)
                endIndex = -endIndex - 1;

            var clipped = [];
            for (var i = startIndex; i < endIndex; i++) {
                clipped.push(list[i]);
            }
            return clipped;
        };

        this.removeAll = function() {
            return this.ranges.splice(0, this.ranges.length);
        };

        this.attach = function(session) {
            if (this.session)
                this.detach();

            this.session = session;
            this.onChange = this.$onChange.bind(this);

            this.session.on('change', this.onChange);
        };

        this.detach = function() {
            if (!this.session)
                return;
            this.session.removeListener('change', this.onChange);
            this.session = null;
        };

        this.$onChange = function(delta) {
            var start = delta.start;
            var end = delta.end;
            var startRow = start.row;
            var endRow = end.row;
            var ranges = this.ranges;
            for (var i = 0, n = ranges.length; i < n; i++) {
                var r = ranges[i];
                if (r.end.row >= startRow)
                    break;
            }
            
            if (delta.action == "insert") {
                var lineDif = endRow - startRow;
                var colDiff = -start.column + end.column;
                for (; i < n; i++) {
                    var r = ranges[i];
                    if (r.start.row > startRow)
                        break;
        
                    if (r.start.row == startRow && r.start.column >= start.column) {
                        if (r.start.column == start.column && this.$bias <= 0) ; else {
                            r.start.column += colDiff;
                            r.start.row += lineDif;
                        }
                    }
                    if (r.end.row == startRow && r.end.column >= start.column) {
                        if (r.end.column == start.column && this.$bias < 0) {
                            continue;
                        }
                        if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                            if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)
                                r.end.column -= colDiff;
                        }
                        r.end.column += colDiff;
                        r.end.row += lineDif;
                    }
                }
            } else {
                var lineDif = startRow - endRow;
                var colDiff = start.column - end.column;
                for (; i < n; i++) {
                    var r = ranges[i];
                    
                    if (r.start.row > endRow)
                        break;
                        
                    if (r.end.row < endRow
                        && (
                            startRow < r.end.row 
                            || startRow == r.end.row && start.column < r.end.column
                        )
                    ) {
                        r.end.row = startRow;
                        r.end.column = start.column;
                    }
                    else if (r.end.row == endRow) {
                        if (r.end.column <= end.column) {
                            if (lineDif || r.end.column > start.column) {
                                r.end.column = start.column;
                                r.end.row = start.row;
                            }
                        }
                        else {
                            r.end.column += colDiff;
                            r.end.row += lineDif;
                        }
                    }
                    else if (r.end.row > endRow) {
                        r.end.row += lineDif;
                    }
                    
                    if (r.start.row < endRow
                        && (
                            startRow < r.start.row 
                            || startRow == r.start.row && start.column < r.start.column
                        )
                    ) {
                        r.start.row = startRow;
                        r.start.column = start.column;
                    }
                    else if (r.start.row == endRow) {
                        if (r.start.column <= end.column) {
                            if (lineDif || r.start.column > start.column) {
                                r.start.column = start.column;
                                r.start.row = start.row;
                            }
                        }
                        else {
                            r.start.column += colDiff;
                            r.start.row += lineDif;
                        }
                    }
                    else if (r.start.row > endRow) {
                        r.start.row += lineDif;
                    }
                }
            }

            if (lineDif != 0 && i < n) {
                for (; i < n; i++) {
                    var r = ranges[i];
                    r.start.row += lineDif;
                    r.end.row += lineDif;
                }
            }
        };

    }).call(RangeList.prototype);

    exports.RangeList = RangeList;
    });

    ace.define("ace/edit_session/fold",["require","exports","module","ace/range_list","ace/lib/oop"], function(require, exports, module) {

    var RangeList = require("../range_list").RangeList;
    var oop = require("../lib/oop");
    var Fold = exports.Fold = function(range, placeholder) {
        this.foldLine = null;
        this.placeholder = placeholder;
        this.range = range;
        this.start = range.start;
        this.end = range.end;

        this.sameRow = range.start.row == range.end.row;
        this.subFolds = this.ranges = [];
    };

    oop.inherits(Fold, RangeList);

    (function() {

        this.toString = function() {
            return '"' + this.placeholder + '" ' + this.range.toString();
        };

        this.setFoldLine = function(foldLine) {
            this.foldLine = foldLine;
            this.subFolds.forEach(function(fold) {
                fold.setFoldLine(foldLine);
            });
        };

        this.clone = function() {
            var range = this.range.clone();
            var fold = new Fold(range, this.placeholder);
            this.subFolds.forEach(function(subFold) {
                fold.subFolds.push(subFold.clone());
            });
            fold.collapseChildren = this.collapseChildren;
            return fold;
        };

        this.addSubFold = function(fold) {
            if (this.range.isEqual(fold))
                return;
            consumeRange(fold, this.start);

            var row = fold.start.row, column = fold.start.column;
            for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
                cmp = this.subFolds[i].range.compare(row, column);
                if (cmp != 1)
                    break;
            }
            var afterStart = this.subFolds[i];
            var firstConsumed = 0;

            if (cmp == 0) {
                if (afterStart.range.containsRange(fold))
                    return afterStart.addSubFold(fold);
                else
                    firstConsumed = 1;
            }
            var row = fold.range.end.row, column = fold.range.end.column;
            for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
                cmp = this.subFolds[j].range.compare(row, column);
                if (cmp != 1)
                    break;
            }
            if (cmp == 0)  j++;
            var consumedFolds = this.subFolds.splice(i, j - i, fold);
            var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;
            for (var k = firstConsumed; k < last; k++) {
                fold.addSubFold(consumedFolds[k]);
            }
            fold.setFoldLine(this.foldLine);

            return fold;
        };
        
        this.restoreRange = function(range) {
            return restoreRange(range, this.start);
        };

    }).call(Fold.prototype);

    function consumePoint(point, anchor) {
        point.row -= anchor.row;
        if (point.row == 0)
            point.column -= anchor.column;
    }
    function consumeRange(range, anchor) {
        consumePoint(range.start, anchor);
        consumePoint(range.end, anchor);
    }
    function restorePoint(point, anchor) {
        if (point.row == 0)
            point.column += anchor.column;
        point.row += anchor.row;
    }
    function restoreRange(range, anchor) {
        restorePoint(range.start, anchor);
        restorePoint(range.end, anchor);
    }

    });

    ace.define("ace/edit_session/folding",["require","exports","module","ace/range","ace/edit_session/fold_line","ace/edit_session/fold","ace/token_iterator"], function(require, exports, module) {

    var Range = require("../range").Range;
    var FoldLine = require("./fold_line").FoldLine;
    var Fold = require("./fold").Fold;
    var TokenIterator = require("../token_iterator").TokenIterator;

    function Folding() {
        this.getFoldAt = function(row, column, side) {
            var foldLine = this.getFoldLine(row);
            if (!foldLine)
                return null;

            var folds = foldLine.folds;
            for (var i = 0; i < folds.length; i++) {
                var range = folds[i].range;
                if (range.contains(row, column)) {
                    if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {
                        continue;
                    } else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {
                        continue;
                    }
                    return folds[i];
                }
            }
        };
        this.getFoldsInRange = function(range) {
            var start = range.start;
            var end = range.end;
            var foldLines = this.$foldData;
            var foundFolds = [];

            start.column += 1;
            end.column -= 1;

            for (var i = 0; i < foldLines.length; i++) {
                var cmp = foldLines[i].range.compareRange(range);
                if (cmp == 2) {
                    continue;
                }
                else if (cmp == -2) {
                    break;
                }

                var folds = foldLines[i].folds;
                for (var j = 0; j < folds.length; j++) {
                    var fold = folds[j];
                    cmp = fold.range.compareRange(range);
                    if (cmp == -2) {
                        break;
                    } else if (cmp == 2) {
                        continue;
                    } else
                    if (cmp == 42) {
                        break;
                    }
                    foundFolds.push(fold);
                }
            }
            start.column -= 1;
            end.column += 1;

            return foundFolds;
        };

        this.getFoldsInRangeList = function(ranges) {
            if (Array.isArray(ranges)) {
                var folds = [];
                ranges.forEach(function(range) {
                    folds = folds.concat(this.getFoldsInRange(range));
                }, this);
            } else {
                var folds = this.getFoldsInRange(ranges);
            }
            return folds;
        };
        this.getAllFolds = function() {
            var folds = [];
            var foldLines = this.$foldData;
            
            for (var i = 0; i < foldLines.length; i++)
                for (var j = 0; j < foldLines[i].folds.length; j++)
                    folds.push(foldLines[i].folds[j]);

            return folds;
        };
        this.getFoldStringAt = function(row, column, trim, foldLine) {
            foldLine = foldLine || this.getFoldLine(row);
            if (!foldLine)
                return null;

            var lastFold = {
                end: { column: 0 }
            };
            var str, fold;
            for (var i = 0; i < foldLine.folds.length; i++) {
                fold = foldLine.folds[i];
                var cmp = fold.range.compareEnd(row, column);
                if (cmp == -1) {
                    str = this
                        .getLine(fold.start.row)
                        .substring(lastFold.end.column, fold.start.column);
                    break;
                }
                else if (cmp === 0) {
                    return null;
                }
                lastFold = fold;
            }
            if (!str)
                str = this.getLine(fold.start.row).substring(lastFold.end.column);

            if (trim == -1)
                return str.substring(0, column - lastFold.end.column);
            else if (trim == 1)
                return str.substring(column - lastFold.end.column);
            else
                return str;
        };

        this.getFoldLine = function(docRow, startFoldLine) {
            var foldData = this.$foldData;
            var i = 0;
            if (startFoldLine)
                i = foldData.indexOf(startFoldLine);
            if (i == -1)
                i = 0;
            for (i; i < foldData.length; i++) {
                var foldLine = foldData[i];
                if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                    return foldLine;
                } else if (foldLine.end.row > docRow) {
                    return null;
                }
            }
            return null;
        };
        this.getNextFoldLine = function(docRow, startFoldLine) {
            var foldData = this.$foldData;
            var i = 0;
            if (startFoldLine)
                i = foldData.indexOf(startFoldLine);
            if (i == -1)
                i = 0;
            for (i; i < foldData.length; i++) {
                var foldLine = foldData[i];
                if (foldLine.end.row >= docRow) {
                    return foldLine;
                }
            }
            return null;
        };

        this.getFoldedRowCount = function(first, last) {
            var foldData = this.$foldData, rowCount = last-first+1;
            for (var i = 0; i < foldData.length; i++) {
                var foldLine = foldData[i],
                    end = foldLine.end.row,
                    start = foldLine.start.row;
                if (end >= last) {
                    if (start < last) {
                        if (start >= first)
                            rowCount -= last-start;
                        else
                            rowCount = 0; // in one fold
                    }
                    break;
                } else if (end >= first){
                    if (start >= first) // fold inside range
                        rowCount -=  end-start;
                    else
                        rowCount -=  end-first+1;
                }
            }
            return rowCount;
        };

        this.$addFoldLine = function(foldLine) {
            this.$foldData.push(foldLine);
            this.$foldData.sort(function(a, b) {
                return a.start.row - b.start.row;
            });
            return foldLine;
        };
        this.addFold = function(placeholder, range) {
            var foldData = this.$foldData;
            var added = false;
            var fold;
            
            if (placeholder instanceof Fold)
                fold = placeholder;
            else {
                fold = new Fold(range, placeholder);
                fold.collapseChildren = range.collapseChildren;
            }
            this.$clipRangeToDocument(fold.range);

            var startRow = fold.start.row;
            var startColumn = fold.start.column;
            var endRow = fold.end.row;
            var endColumn = fold.end.column;

            var startFold = this.getFoldAt(startRow, startColumn, 1);
            var endFold = this.getFoldAt(endRow, endColumn, -1);
            if (startFold && endFold == startFold)
                return startFold.addSubFold(fold);

            if (startFold && !startFold.range.isStart(startRow, startColumn))
                this.removeFold(startFold);
            
            if (endFold && !endFold.range.isEnd(endRow, endColumn))
                this.removeFold(endFold);
            var folds = this.getFoldsInRange(fold.range);
            if (folds.length > 0) {
                this.removeFolds(folds);
                if (!fold.collapseChildren) {
                    folds.forEach(function(subFold) {
                        fold.addSubFold(subFold);
                    });
                }
            }

            for (var i = 0; i < foldData.length; i++) {
                var foldLine = foldData[i];
                if (endRow == foldLine.start.row) {
                    foldLine.addFold(fold);
                    added = true;
                    break;
                } else if (startRow == foldLine.end.row) {
                    foldLine.addFold(fold);
                    added = true;
                    if (!fold.sameRow) {
                        var foldLineNext = foldData[i + 1];
                        if (foldLineNext && foldLineNext.start.row == endRow) {
                            foldLine.merge(foldLineNext);
                            break;
                        }
                    }
                    break;
                } else if (endRow <= foldLine.start.row) {
                    break;
                }
            }

            if (!added)
                foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

            if (this.$useWrapMode)
                this.$updateWrapData(foldLine.start.row, foldLine.start.row);
            else
                this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
            this.$modified = true;
            this._signal("changeFold", { data: fold, action: "add" });

            return fold;
        };

        this.addFolds = function(folds) {
            folds.forEach(function(fold) {
                this.addFold(fold);
            }, this);
        };

        this.removeFold = function(fold) {
            var foldLine = fold.foldLine;
            var startRow = foldLine.start.row;
            var endRow = foldLine.end.row;

            var foldLines = this.$foldData;
            var folds = foldLine.folds;
            if (folds.length == 1) {
                foldLines.splice(foldLines.indexOf(foldLine), 1);
            } else
            if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
                folds.pop();
                foldLine.end.row = folds[folds.length - 1].end.row;
                foldLine.end.column = folds[folds.length - 1].end.column;
            } else
            if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
                folds.shift();
                foldLine.start.row = folds[0].start.row;
                foldLine.start.column = folds[0].start.column;
            } else
            if (fold.sameRow) {
                folds.splice(folds.indexOf(fold), 1);
            } else
            {
                var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
                folds = newFoldLine.folds;
                folds.shift();
                newFoldLine.start.row = folds[0].start.row;
                newFoldLine.start.column = folds[0].start.column;
            }

            if (!this.$updating) {
                if (this.$useWrapMode)
                    this.$updateWrapData(startRow, endRow);
                else
                    this.$updateRowLengthCache(startRow, endRow);
            }
            this.$modified = true;
            this._signal("changeFold", { data: fold, action: "remove" });
        };

        this.removeFolds = function(folds) {
            var cloneFolds = [];
            for (var i = 0; i < folds.length; i++) {
                cloneFolds.push(folds[i]);
            }

            cloneFolds.forEach(function(fold) {
                this.removeFold(fold);
            }, this);
            this.$modified = true;
        };

        this.expandFold = function(fold) {
            this.removeFold(fold);
            fold.subFolds.forEach(function(subFold) {
                fold.restoreRange(subFold);
                this.addFold(subFold);
            }, this);
            if (fold.collapseChildren > 0) {
                this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);
            }
            fold.subFolds = [];
        };

        this.expandFolds = function(folds) {
            folds.forEach(function(fold) {
                this.expandFold(fold);
            }, this);
        };

        this.unfold = function(location, expandInner) {
            var range, folds;
            if (location == null) {
                range = new Range(0, 0, this.getLength(), 0);
                if (expandInner == null) expandInner = true;
            } else if (typeof location == "number")
                range = new Range(location, 0, location, this.getLine(location).length);
            else if ("row" in location)
                range = Range.fromPoints(location, location);
            else
                range = location;
            
            folds = this.getFoldsInRangeList(range);
            if (expandInner != false) {
                this.removeFolds(folds);
            } else {
                this.expandFolds(folds);
            }
            if (folds.length)
                return folds;
        };
        this.isRowFolded = function(docRow, startFoldRow) {
            return !!this.getFoldLine(docRow, startFoldRow);
        };

        this.getRowFoldEnd = function(docRow, startFoldRow) {
            var foldLine = this.getFoldLine(docRow, startFoldRow);
            return foldLine ? foldLine.end.row : docRow;
        };

        this.getRowFoldStart = function(docRow, startFoldRow) {
            var foldLine = this.getFoldLine(docRow, startFoldRow);
            return foldLine ? foldLine.start.row : docRow;
        };

        this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
            if (startRow == null)
                startRow = foldLine.start.row;
            if (startColumn == null)
                startColumn = 0;
            if (endRow == null)
                endRow = foldLine.end.row;
            if (endColumn == null)
                endColumn = this.getLine(endRow).length;
            var doc = this.doc;
            var textLine = "";

            foldLine.walk(function(placeholder, row, column, lastColumn) {
                if (row < startRow)
                    return;
                if (row == startRow) {
                    if (column < startColumn)
                        return;
                    lastColumn = Math.max(startColumn, lastColumn);
                }

                if (placeholder != null) {
                    textLine += placeholder;
                } else {
                    textLine += doc.getLine(row).substring(lastColumn, column);
                }
            }, endRow, endColumn);
            return textLine;
        };

        this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
            var foldLine = this.getFoldLine(row);

            if (!foldLine) {
                var line;
                line = this.doc.getLine(row);
                return line.substring(startColumn || 0, endColumn || line.length);
            } else {
                return this.getFoldDisplayLine(
                    foldLine, row, endColumn, startRow, startColumn);
            }
        };

        this.$cloneFoldData = function() {
            var fd = [];
            fd = this.$foldData.map(function(foldLine) {
                var folds = foldLine.folds.map(function(fold) {
                    return fold.clone();
                });
                return new FoldLine(fd, folds);
            });

            return fd;
        };

        this.toggleFold = function(tryToUnfold) {
            var selection = this.selection;
            var range = selection.getRange();
            var fold;
            var bracketPos;

            if (range.isEmpty()) {
                var cursor = range.start;
                fold = this.getFoldAt(cursor.row, cursor.column);

                if (fold) {
                    this.expandFold(fold);
                    return;
                } else if (bracketPos = this.findMatchingBracket(cursor)) {
                    if (range.comparePoint(bracketPos) == 1) {
                        range.end = bracketPos;
                    } else {
                        range.start = bracketPos;
                        range.start.column++;
                        range.end.column--;
                    }
                } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
                    if (range.comparePoint(bracketPos) == 1)
                        range.end = bracketPos;
                    else
                        range.start = bracketPos;

                    range.start.column++;
                } else {
                    range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
                }
            } else {
                var folds = this.getFoldsInRange(range);
                if (tryToUnfold && folds.length) {
                    this.expandFolds(folds);
                    return;
                } else if (folds.length == 1 ) {
                    fold = folds[0];
                }
            }

            if (!fold)
                fold = this.getFoldAt(range.start.row, range.start.column);

            if (fold && fold.range.toString() == range.toString()) {
                this.expandFold(fold);
                return;
            }

            var placeholder = "...";
            if (!range.isMultiLine()) {
                placeholder = this.getTextRange(range);
                if (placeholder.length < 4)
                    return;
                placeholder = placeholder.trim().substring(0, 2) + "..";
            }

            this.addFold(placeholder, range);
        };

        this.getCommentFoldRange = function(row, column, dir) {
            var iterator = new TokenIterator(this, row, column);
            var token = iterator.getCurrentToken();
            var type = token && token.type;
            if (token && /^comment|string/.test(type)) {
                type = type.match(/comment|string/)[0];
                if (type == "comment")
                    type += "|doc-start";
                var re = new RegExp(type);
                var range = new Range();
                if (dir != 1) {
                    do {
                        token = iterator.stepBackward();
                    } while (token && re.test(token.type));
                    iterator.stepForward();
                }
                
                range.start.row = iterator.getCurrentTokenRow();
                range.start.column = iterator.getCurrentTokenColumn() + 2;

                iterator = new TokenIterator(this, row, column);
                
                if (dir != -1) {
                    var lastRow = -1;
                    do {
                        token = iterator.stepForward();
                        if (lastRow == -1) {
                            var state = this.getState(iterator.$row);
                            if (!re.test(state))
                                lastRow = iterator.$row;
                        } else if (iterator.$row > lastRow) {
                            break;
                        }
                    } while (token && re.test(token.type));
                    token = iterator.stepBackward();
                } else
                    token = iterator.getCurrentToken();

                range.end.row = iterator.getCurrentTokenRow();
                range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
                return range;
            }
        };

        this.foldAll = function(startRow, endRow, depth, test) {
            if (depth == undefined)
                depth = 100000; // JSON.stringify doesn't hanle Infinity
            var foldWidgets = this.foldWidgets;
            if (!foldWidgets)
                return; // mode doesn't support folding
            endRow = endRow || this.getLength();
            startRow = startRow || 0;
            for (var row = startRow; row < endRow; row++) {
                if (foldWidgets[row] == null)
                    foldWidgets[row] = this.getFoldWidget(row);
                if (foldWidgets[row] != "start")
                    continue;
                
                if (test && !test(row)) continue;

                var range = this.getFoldWidgetRange(row);
                if (range && range.isMultiLine()
                    && range.end.row <= endRow
                    && range.start.row >= startRow
                ) {
                    row = range.end.row;
                    range.collapseChildren = depth;
                    this.addFold("...", range);
                }
            }
        };
        
        this.foldToLevel = function(level) {
            this.foldAll();
            while (level-- > 0)
                this.unfold(null, false);
        };
        
        this.foldAllComments = function() {
            var session = this;
            this.foldAll(null, null, null, function(row) {
                var tokens = session.getTokens(row);
                for (var i = 0; i < tokens.length; i++) {
                    var token = tokens[i];
                    if (token.type == "text" && /^\s+$/.test(token.value))
                        continue;
                    if (/comment/.test(token.type))
                        return true;
                    return false;
                }
            });
        };
        this.$foldStyles = {
            "manual": 1,
            "markbegin": 1,
            "markbeginend": 1
        };
        this.$foldStyle = "markbegin";
        this.setFoldStyle = function(style) {
            if (!this.$foldStyles[style])
                throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
            
            if (this.$foldStyle == style)
                return;

            this.$foldStyle = style;
            
            if (style == "manual")
                this.unfold();
            var mode = this.$foldMode;
            this.$setFolding(null);
            this.$setFolding(mode);
        };

        this.$setFolding = function(foldMode) {
            if (this.$foldMode == foldMode)
                return;
                
            this.$foldMode = foldMode;
            
            this.off('change', this.$updateFoldWidgets);
            this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
            this._signal("changeAnnotation");
            
            if (!foldMode || this.$foldStyle == "manual") {
                this.foldWidgets = null;
                return;
            }
            
            this.foldWidgets = [];
            this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
            this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
            
            this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
            this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
            this.on('change', this.$updateFoldWidgets);
            this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
        };

        this.getParentFoldRangeData = function (row, ignoreCurrent) {
            var fw = this.foldWidgets;
            if (!fw || (ignoreCurrent && fw[row]))
                return {};

            var i = row - 1, firstRange;
            while (i >= 0) {
                var c = fw[i];
                if (c == null)
                    c = fw[i] = this.getFoldWidget(i);

                if (c == "start") {
                    var range = this.getFoldWidgetRange(i);
                    if (!firstRange)
                        firstRange = range;
                    if (range && range.end.row >= row)
                        break;
                }
                i--;
            }

            return {
                range: i !== -1 && range,
                firstRange: firstRange
            };
        };

        this.onFoldWidgetClick = function(row, e) {
            e = e.domEvent;
            var options = {
                children: e.shiftKey,
                all: e.ctrlKey || e.metaKey,
                siblings: e.altKey
            };
            
            var range = this.$toggleFoldWidget(row, options);
            if (!range) {
                var el = (e.target || e.srcElement);
                if (el && /ace_fold-widget/.test(el.className))
                    el.className += " ace_invalid";
            }
        };
        
        this.$toggleFoldWidget = function(row, options) {
            if (!this.getFoldWidget)
                return;
            var type = this.getFoldWidget(row);
            var line = this.getLine(row);

            var dir = type === "end" ? -1 : 1;
            var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

            if (fold) {
                if (options.children || options.all)
                    this.removeFold(fold);
                else
                    this.expandFold(fold);
                return fold;
            }

            var range = this.getFoldWidgetRange(row, true);
            if (range && !range.isMultiLine()) {
                fold = this.getFoldAt(range.start.row, range.start.column, 1);
                if (fold && range.isEqual(fold.range)) {
                    this.removeFold(fold);
                    return fold;
                }
            }
            
            if (options.siblings) {
                var data = this.getParentFoldRangeData(row);
                if (data.range) {
                    var startRow = data.range.start.row + 1;
                    var endRow = data.range.end.row;
                }
                this.foldAll(startRow, endRow, options.all ? 10000 : 0);
            } else if (options.children) {
                endRow = range ? range.end.row : this.getLength();
                this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
            } else if (range) {
                if (options.all) 
                    range.collapseChildren = 10000;
                this.addFold("...", range);
            }
            
            return range;
        };
        
        
        
        this.toggleFoldWidget = function(toggleParent) {
            var row = this.selection.getCursor().row;
            row = this.getRowFoldStart(row);
            var range = this.$toggleFoldWidget(row, {});
            
            if (range)
                return;
            var data = this.getParentFoldRangeData(row, true);
            range = data.range || data.firstRange;
            
            if (range) {
                row = range.start.row;
                var fold = this.getFoldAt(row, this.getLine(row).length, 1);

                if (fold) {
                    this.removeFold(fold);
                } else {
                    this.addFold("...", range);
                }
            }
        };

        this.updateFoldWidgets = function(delta) {
            var firstRow = delta.start.row;
            var len = delta.end.row - firstRow;

            if (len === 0) {
                this.foldWidgets[firstRow] = null;
            } else if (delta.action == 'remove') {
                this.foldWidgets.splice(firstRow, len + 1, null);
            } else {
                var args = Array(len + 1);
                args.unshift(firstRow, 1);
                this.foldWidgets.splice.apply(this.foldWidgets, args);
            }
        };
        this.tokenizerUpdateFoldWidgets = function(e) {
            var rows = e.data;
            if (rows.first != rows.last) {
                if (this.foldWidgets.length > rows.first)
                    this.foldWidgets.splice(rows.first, this.foldWidgets.length);
            }
        };
    }

    exports.Folding = Folding;

    });

    ace.define("ace/edit_session/bracket_match",["require","exports","module","ace/token_iterator","ace/range"], function(require, exports, module) {

    var TokenIterator = require("../token_iterator").TokenIterator;
    var Range = require("../range").Range;


    function BracketMatch() {

        this.findMatchingBracket = function(position, chr) {
            if (position.column == 0) return null;

            var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);
            if (charBeforeCursor == "") return null;

            var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
            if (!match)
                return null;

            if (match[1])
                return this.$findClosingBracket(match[1], position);
            else
                return this.$findOpeningBracket(match[2], position);
        };
        
        this.getBracketRange = function(pos) {
            var line = this.getLine(pos.row);
            var before = true, range;

            var chr = line.charAt(pos.column - 1);
            var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            if (!match) {
                chr = line.charAt(pos.column);
                pos = {row: pos.row, column: pos.column + 1};
                match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
                before = false;
            }
            if (!match)
                return null;

            if (match[1]) {
                var bracketPos = this.$findClosingBracket(match[1], pos);
                if (!bracketPos)
                    return null;
                range = Range.fromPoints(pos, bracketPos);
                if (!before) {
                    range.end.column++;
                    range.start.column--;
                }
                range.cursor = range.end;
            } else {
                var bracketPos = this.$findOpeningBracket(match[2], pos);
                if (!bracketPos)
                    return null;
                range = Range.fromPoints(bracketPos, pos);
                if (!before) {
                    range.start.column++;
                    range.end.column--;
                }
                range.cursor = range.start;
            }
            
            return range;
        };
        this.getMatchingBracketRanges = function(pos) {
            var line = this.getLine(pos.row);

            var chr = line.charAt(pos.column - 1);
            var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            if (!match) {
                chr = line.charAt(pos.column);
                pos = {row: pos.row, column: pos.column + 1};
                match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            }

            if (!match)
                return null;

            var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);
            var bracketPos = match[1] ? this.$findClosingBracket(match[1], pos)
                : this.$findOpeningBracket(match[2], pos);
            if (!bracketPos)
                return [startRange];
            var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);

            return [startRange, endRange];
        };

        this.$brackets = {
            ")": "(",
            "(": ")",
            "]": "[",
            "[": "]",
            "{": "}",
            "}": "{",
            "<": ">",
            ">": "<"
        };

        this.$findOpeningBracket = function(bracket, position, typeRe) {
            var openBracket = this.$brackets[bracket];
            var depth = 1;

            var iterator = new TokenIterator(this, position.row, position.column);
            var token = iterator.getCurrentToken();
            if (!token)
                token = iterator.stepForward();
            if (!token)
                return;
            
             if (!typeRe){
                typeRe = new RegExp(
                    "(\\.?" +
                    token.type.replace(".", "\\.").replace("rparen", ".paren")
                        .replace(/\b(?:end)\b/, "(?:start|begin|end)")
                    + ")+"
                );
            }
            var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
            var value = token.value;
            
            while (true) {
            
                while (valueIndex >= 0) {
                    var chr = value.charAt(valueIndex);
                    if (chr == openBracket) {
                        depth -= 1;
                        if (depth == 0) {
                            return {row: iterator.getCurrentTokenRow(),
                                column: valueIndex + iterator.getCurrentTokenColumn()};
                        }
                    }
                    else if (chr == bracket) {
                        depth += 1;
                    }
                    valueIndex -= 1;
                }
                do {
                    token = iterator.stepBackward();
                } while (token && !typeRe.test(token.type));

                if (token == null)
                    break;
                    
                value = token.value;
                valueIndex = value.length - 1;
            }
            
            return null;
        };

        this.$findClosingBracket = function(bracket, position, typeRe) {
            var closingBracket = this.$brackets[bracket];
            var depth = 1;

            var iterator = new TokenIterator(this, position.row, position.column);
            var token = iterator.getCurrentToken();
            if (!token)
                token = iterator.stepForward();
            if (!token)
                return;

            if (!typeRe){
                typeRe = new RegExp(
                    "(\\.?" +
                    token.type.replace(".", "\\.").replace("lparen", ".paren")
                        .replace(/\b(?:start|begin)\b/, "(?:start|begin|end)")
                    + ")+"
                );
            }
            var valueIndex = position.column - iterator.getCurrentTokenColumn();

            while (true) {

                var value = token.value;
                var valueLength = value.length;
                while (valueIndex < valueLength) {
                    var chr = value.charAt(valueIndex);
                    if (chr == closingBracket) {
                        depth -= 1;
                        if (depth == 0) {
                            return {row: iterator.getCurrentTokenRow(),
                                column: valueIndex + iterator.getCurrentTokenColumn()};
                        }
                    }
                    else if (chr == bracket) {
                        depth += 1;
                    }
                    valueIndex += 1;
                }
                do {
                    token = iterator.stepForward();
                } while (token && !typeRe.test(token.type));

                if (token == null)
                    break;

                valueIndex = 0;
            }
            
            return null;
        };
    }
    exports.BracketMatch = BracketMatch;

    });

    ace.define("ace/edit_session",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/bidihandler","ace/config","ace/lib/event_emitter","ace/selection","ace/mode/text","ace/range","ace/document","ace/background_tokenizer","ace/search_highlight","ace/edit_session/folding","ace/edit_session/bracket_match"], function(require, exports, module) {

    var oop = require("./lib/oop");
    var lang = require("./lib/lang");
    var BidiHandler = require("./bidihandler").BidiHandler;
    var config = require("./config");
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var Selection = require("./selection").Selection;
    var TextMode = require("./mode/text").Mode;
    var Range = require("./range").Range;
    var Document = require("./document").Document;
    var BackgroundTokenizer = require("./background_tokenizer").BackgroundTokenizer;
    var SearchHighlight = require("./search_highlight").SearchHighlight;

    var EditSession = function(text, mode) {
        this.$breakpoints = [];
        this.$decorations = [];
        this.$frontMarkers = {};
        this.$backMarkers = {};
        this.$markerId = 1;
        this.$undoSelect = true;

        this.$foldData = [];
        this.id = "session" + (++EditSession.$uid);
        this.$foldData.toString = function() {
            return this.join("\n");
        };
        this.on("changeFold", this.onChangeFold.bind(this));
        this.$onChange = this.onChange.bind(this);

        if (typeof text != "object" || !text.getLine)
            text = new Document(text);

        this.setDocument(text);
        this.selection = new Selection(this);
        this.$bidiHandler = new BidiHandler(this);

        config.resetOptions(this);
        this.setMode(mode);
        config._signal("session", this);
    };


    EditSession.$uid = 0;

    (function() {

        oop.implement(this, EventEmitter);
        this.setDocument = function(doc) {
            if (this.doc)
                this.doc.removeListener("change", this.$onChange);

            this.doc = doc;
            doc.on("change", this.$onChange);

            if (this.bgTokenizer)
                this.bgTokenizer.setDocument(this.getDocument());

            this.resetCaches();
        };
        this.getDocument = function() {
            return this.doc;
        };
        this.$resetRowCache = function(docRow) {
            if (!docRow) {
                this.$docRowCache = [];
                this.$screenRowCache = [];
                return;
            }
            var l = this.$docRowCache.length;
            var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
            if (l > i) {
                this.$docRowCache.splice(i, l);
                this.$screenRowCache.splice(i, l);
            }
        };

        this.$getRowCacheIndex = function(cacheArray, val) {
            var low = 0;
            var hi = cacheArray.length - 1;

            while (low <= hi) {
                var mid = (low + hi) >> 1;
                var c = cacheArray[mid];

                if (val > c)
                    low = mid + 1;
                else if (val < c)
                    hi = mid - 1;
                else
                    return mid;
            }

            return low -1;
        };

        this.resetCaches = function() {
            this.$modified = true;
            this.$wrapData = [];
            this.$rowLengthCache = [];
            this.$resetRowCache(0);
            if (this.bgTokenizer)
                this.bgTokenizer.start(0);
        };

        this.onChangeFold = function(e) {
            var fold = e.data;
            this.$resetRowCache(fold.start.row);
        };

        this.onChange = function(delta) {
            this.$modified = true;
            this.$bidiHandler.onChange(delta);
            this.$resetRowCache(delta.start.row);

            var removedFolds = this.$updateInternalDataOnChange(delta);
            if (!this.$fromUndo && this.$undoManager) {
                if (removedFolds && removedFolds.length) {
                    this.$undoManager.add({
                        action: "removeFolds",
                        folds:  removedFolds
                    }, this.mergeUndoDeltas);
                    this.mergeUndoDeltas = true;
                }
                this.$undoManager.add(delta, this.mergeUndoDeltas);
                this.mergeUndoDeltas = true;
                
                this.$informUndoManager.schedule();
            }

            this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
            this._signal("change", delta);
        };
        this.setValue = function(text) {
            this.doc.setValue(text);
            this.selection.moveTo(0, 0);

            this.$resetRowCache(0);
            this.setUndoManager(this.$undoManager);
            this.getUndoManager().reset();
        };
        this.getValue =
        this.toString = function() {
            return this.doc.getValue();
        };
        this.getSelection = function() {
            return this.selection;
        };
        this.getState = function(row) {
            return this.bgTokenizer.getState(row);
        };
        this.getTokens = function(row) {
            return this.bgTokenizer.getTokens(row);
        };
        this.getTokenAt = function(row, column) {
            var tokens = this.bgTokenizer.getTokens(row);
            var token, c = 0;
            if (column == null) {
                var i = tokens.length - 1;
                c = this.getLine(row).length;
            } else {
                for (var i = 0; i < tokens.length; i++) {
                    c += tokens[i].value.length;
                    if (c >= column)
                        break;
                }
            }
            token = tokens[i];
            if (!token)
                return null;
            token.index = i;
            token.start = c - token.value.length;
            return token;
        };
        this.setUndoManager = function(undoManager) {
            this.$undoManager = undoManager;
            
            if (this.$informUndoManager)
                this.$informUndoManager.cancel();
            
            if (undoManager) {
                var self = this;
                undoManager.addSession(this);
                this.$syncInformUndoManager = function() {
                    self.$informUndoManager.cancel();
                    self.mergeUndoDeltas = false;
                };
                this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
            } else {
                this.$syncInformUndoManager = function() {};
            }
        };
        this.markUndoGroup = function() {
            if (this.$syncInformUndoManager)
                this.$syncInformUndoManager();
        };
        
        this.$defaultUndoManager = {
            undo: function() {},
            redo: function() {},
            hasUndo: function() {},
            hasRedo: function() {},
            reset: function() {},
            add: function() {},
            addSelection: function() {},
            startNewGroup: function() {},
            addSession: function() {}
        };
        this.getUndoManager = function() {
            return this.$undoManager || this.$defaultUndoManager;
        };
        this.getTabString = function() {
            if (this.getUseSoftTabs()) {
                return lang.stringRepeat(" ", this.getTabSize());
            } else {
                return "\t";
            }
        };
        this.setUseSoftTabs = function(val) {
            this.setOption("useSoftTabs", val);
        };
        this.getUseSoftTabs = function() {
            return this.$useSoftTabs && !this.$mode.$indentWithTabs;
        };
        this.setTabSize = function(tabSize) {
            this.setOption("tabSize", tabSize);
        };
        this.getTabSize = function() {
            return this.$tabSize;
        };
        this.isTabStop = function(position) {
            return this.$useSoftTabs && (position.column % this.$tabSize === 0);
        };
        this.setNavigateWithinSoftTabs = function (navigateWithinSoftTabs) {
            this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
        };
        this.getNavigateWithinSoftTabs = function() {
            return this.$navigateWithinSoftTabs;
        };

        this.$overwrite = false;
        this.setOverwrite = function(overwrite) {
            this.setOption("overwrite", overwrite);
        };
        this.getOverwrite = function() {
            return this.$overwrite;
        };
        this.toggleOverwrite = function() {
            this.setOverwrite(!this.$overwrite);
        };
        this.addGutterDecoration = function(row, className) {
            if (!this.$decorations[row])
                this.$decorations[row] = "";
            this.$decorations[row] += " " + className;
            this._signal("changeBreakpoint", {});
        };
        this.removeGutterDecoration = function(row, className) {
            this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
            this._signal("changeBreakpoint", {});
        };
        this.getBreakpoints = function() {
            return this.$breakpoints;
        };
        this.setBreakpoints = function(rows) {
            this.$breakpoints = [];
            for (var i=0; i<rows.length; i++) {
                this.$breakpoints[rows[i]] = "ace_breakpoint";
            }
            this._signal("changeBreakpoint", {});
        };
        this.clearBreakpoints = function() {
            this.$breakpoints = [];
            this._signal("changeBreakpoint", {});
        };
        this.setBreakpoint = function(row, className) {
            if (className === undefined)
                className = "ace_breakpoint";
            if (className)
                this.$breakpoints[row] = className;
            else
                delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
        };
        this.clearBreakpoint = function(row) {
            delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
        };
        this.addMarker = function(range, clazz, type, inFront) {
            var id = this.$markerId++;

            var marker = {
                range : range,
                type : type || "line",
                renderer: typeof type == "function" ? type : null,
                clazz : clazz,
                inFront: !!inFront,
                id: id
            };

            if (inFront) {
                this.$frontMarkers[id] = marker;
                this._signal("changeFrontMarker");
            } else {
                this.$backMarkers[id] = marker;
                this._signal("changeBackMarker");
            }

            return id;
        };
        this.addDynamicMarker = function(marker, inFront) {
            if (!marker.update)
                return;
            var id = this.$markerId++;
            marker.id = id;
            marker.inFront = !!inFront;

            if (inFront) {
                this.$frontMarkers[id] = marker;
                this._signal("changeFrontMarker");
            } else {
                this.$backMarkers[id] = marker;
                this._signal("changeBackMarker");
            }

            return marker;
        };
        this.removeMarker = function(markerId) {
            var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
            if (!marker)
                return;

            var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
            delete (markers[markerId]);
            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
        };
        this.getMarkers = function(inFront) {
            return inFront ? this.$frontMarkers : this.$backMarkers;
        };

        this.highlight = function(re) {
            if (!this.$searchHighlight) {
                var highlight = new SearchHighlight(null, "ace_selected-word", "text");
                this.$searchHighlight = this.addDynamicMarker(highlight);
            }
            this.$searchHighlight.setRegexp(re);
        };
        this.highlightLines = function(startRow, endRow, clazz, inFront) {
            if (typeof endRow != "number") {
                clazz = endRow;
                endRow = startRow;
            }
            if (!clazz)
                clazz = "ace_step";

            var range = new Range(startRow, 0, endRow, Infinity);
            range.id = this.addMarker(range, clazz, "fullLine", inFront);
            return range;
        };
        this.setAnnotations = function(annotations) {
            this.$annotations = annotations;
            this._signal("changeAnnotation", {});
        };
        this.getAnnotations = function() {
            return this.$annotations || [];
        };
        this.clearAnnotations = function() {
            this.setAnnotations([]);
        };
        this.$detectNewLine = function(text) {
            var match = text.match(/^.*?(\r?\n)/m);
            if (match) {
                this.$autoNewLine = match[1];
            } else {
                this.$autoNewLine = "\n";
            }
        };
        this.getWordRange = function(row, column) {
            var line = this.getLine(row);

            var inToken = false;
            if (column > 0)
                inToken = !!line.charAt(column - 1).match(this.tokenRe);

            if (!inToken)
                inToken = !!line.charAt(column).match(this.tokenRe);

            if (inToken)
                var re = this.tokenRe;
            else if (/^\s+$/.test(line.slice(column-1, column+1)))
                var re = /\s/;
            else
                var re = this.nonTokenRe;

            var start = column;
            if (start > 0) {
                do {
                    start--;
                }
                while (start >= 0 && line.charAt(start).match(re));
                start++;
            }

            var end = column;
            while (end < line.length && line.charAt(end).match(re)) {
                end++;
            }

            return new Range(row, start, row, end);
        };
        this.getAWordRange = function(row, column) {
            var wordRange = this.getWordRange(row, column);
            var line = this.getLine(wordRange.end.row);

            while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
                wordRange.end.column += 1;
            }
            return wordRange;
        };
        this.setNewLineMode = function(newLineMode) {
            this.doc.setNewLineMode(newLineMode);
        };
        this.getNewLineMode = function() {
            return this.doc.getNewLineMode();
        };
        this.setUseWorker = function(useWorker) { this.setOption("useWorker", useWorker); };
        this.getUseWorker = function() { return this.$useWorker; };
        this.onReloadTokenizer = function(e) {
            var rows = e.data;
            this.bgTokenizer.start(rows.first);
            this._signal("tokenizerUpdate", e);
        };

        this.$modes = config.$modes;
        this.$mode = null;
        this.$modeId = null;
        this.setMode = function(mode, cb) {
            if (mode && typeof mode === "object") {
                if (mode.getTokenizer)
                    return this.$onChangeMode(mode);
                var options = mode;
                var path = options.path;
            } else {
                path = mode || "ace/mode/text";
            }
            if (!this.$modes["ace/mode/text"])
                this.$modes["ace/mode/text"] = new TextMode();

            if (this.$modes[path] && !options) {
                this.$onChangeMode(this.$modes[path]);
                cb && cb();
                return;
            }
            this.$modeId = path;
            config.loadModule(["mode", path], function(m) {
                if (this.$modeId !== path)
                    return cb && cb();
                if (this.$modes[path] && !options) {
                    this.$onChangeMode(this.$modes[path]);
                } else if (m && m.Mode) {
                    m = new m.Mode(options);
                    if (!options) {
                        this.$modes[path] = m;
                        m.$id = path;
                    }
                    this.$onChangeMode(m);
                }
                cb && cb();
            }.bind(this));
            if (!this.$mode)
                this.$onChangeMode(this.$modes["ace/mode/text"], true);
        };

        this.$onChangeMode = function(mode, $isPlaceholder) {
            if (!$isPlaceholder)
                this.$modeId = mode.$id;
            if (this.$mode === mode) 
                return;
                
            var oldMode = this.$mode;
            this.$mode = mode;

            this.$stopWorker();

            if (this.$useWorker)
                this.$startWorker();

            var tokenizer = mode.getTokenizer();

            if(tokenizer.on !== undefined) {
                var onReloadTokenizer = this.onReloadTokenizer.bind(this);
                tokenizer.on("update", onReloadTokenizer);
            }

            if (!this.bgTokenizer) {
                this.bgTokenizer = new BackgroundTokenizer(tokenizer);
                var _self = this;
                this.bgTokenizer.on("update", function(e) {
                    _self._signal("tokenizerUpdate", e);
                });
            } else {
                this.bgTokenizer.setTokenizer(tokenizer);
            }

            this.bgTokenizer.setDocument(this.getDocument());

            this.tokenRe = mode.tokenRe;
            this.nonTokenRe = mode.nonTokenRe;

            
            if (!$isPlaceholder) {
                if (mode.attachToSession)
                    mode.attachToSession(this);
                this.$options.wrapMethod.set.call(this, this.$wrapMethod);
                this.$setFolding(mode.foldingRules);
                this.bgTokenizer.start(0);
                this._emit("changeMode", {oldMode: oldMode, mode: mode});
            }
        };

        this.$stopWorker = function() {
            if (this.$worker) {
                this.$worker.terminate();
                this.$worker = null;
            }
        };

        this.$startWorker = function() {
            try {
                this.$worker = this.$mode.createWorker(this);
            } catch (e) {
                config.warn("Could not load worker", e);
                this.$worker = null;
            }
        };
        this.getMode = function() {
            return this.$mode;
        };

        this.$scrollTop = 0;
        this.setScrollTop = function(scrollTop) {
            if (this.$scrollTop === scrollTop || isNaN(scrollTop))
                return;

            this.$scrollTop = scrollTop;
            this._signal("changeScrollTop", scrollTop);
        };
        this.getScrollTop = function() {
            return this.$scrollTop;
        };

        this.$scrollLeft = 0;
        this.setScrollLeft = function(scrollLeft) {
            if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
                return;

            this.$scrollLeft = scrollLeft;
            this._signal("changeScrollLeft", scrollLeft);
        };
        this.getScrollLeft = function() {
            return this.$scrollLeft;
        };
        this.getScreenWidth = function() {
            this.$computeWidth();
            if (this.lineWidgets) 
                return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
            return this.screenWidth;
        };
        
        this.getLineWidgetMaxWidth = function() {
            if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
            var width = 0;
            this.lineWidgets.forEach(function(w) {
                if (w && w.screenWidth > width)
                    width = w.screenWidth;
            });
            return this.lineWidgetWidth = width;
        };

        this.$computeWidth = function(force) {
            if (this.$modified || force) {
                this.$modified = false;

                if (this.$useWrapMode)
                    return this.screenWidth = this.$wrapLimit;

                var lines = this.doc.getAllLines();
                var cache = this.$rowLengthCache;
                var longestScreenLine = 0;
                var foldIndex = 0;
                var foldLine = this.$foldData[foldIndex];
                var foldStart = foldLine ? foldLine.start.row : Infinity;
                var len = lines.length;

                for (var i = 0; i < len; i++) {
                    if (i > foldStart) {
                        i = foldLine.end.row + 1;
                        if (i >= len)
                            break;
                        foldLine = this.$foldData[foldIndex++];
                        foldStart = foldLine ? foldLine.start.row : Infinity;
                    }

                    if (cache[i] == null)
                        cache[i] = this.$getStringScreenWidth(lines[i])[0];

                    if (cache[i] > longestScreenLine)
                        longestScreenLine = cache[i];
                }
                this.screenWidth = longestScreenLine;
            }
        };
        this.getLine = function(row) {
            return this.doc.getLine(row);
        };
        this.getLines = function(firstRow, lastRow) {
            return this.doc.getLines(firstRow, lastRow);
        };
        this.getLength = function() {
            return this.doc.getLength();
        };
        this.getTextRange = function(range) {
            return this.doc.getTextRange(range || this.selection.getRange());
        };
        this.insert = function(position, text) {
            return this.doc.insert(position, text);
        };
        this.remove = function(range) {
            return this.doc.remove(range);
        };
        this.removeFullLines = function(firstRow, lastRow){
            return this.doc.removeFullLines(firstRow, lastRow);
        };
        this.undoChanges = function(deltas, dontSelect) {
            if (!deltas.length)
                return;

            this.$fromUndo = true;
            for (var i = deltas.length - 1; i != -1; i--) {
                var delta = deltas[i];
                if (delta.action == "insert" || delta.action == "remove") {
                    this.doc.revertDelta(delta);
                } else if (delta.folds) {
                    this.addFolds(delta.folds);
                }
            }
            if (!dontSelect && this.$undoSelect) {
                if (deltas.selectionBefore)
                    this.selection.fromJSON(deltas.selectionBefore);
                else
                    this.selection.setRange(this.$getUndoSelection(deltas, true));
            }
            this.$fromUndo = false;
        };
        this.redoChanges = function(deltas, dontSelect) {
            if (!deltas.length)
                return;

            this.$fromUndo = true;
            for (var i = 0; i < deltas.length; i++) {
                var delta = deltas[i];
                if (delta.action == "insert" || delta.action == "remove") {
                    this.doc.$safeApplyDelta(delta);
                }
            }

            if (!dontSelect && this.$undoSelect) {
                if (deltas.selectionAfter)
                    this.selection.fromJSON(deltas.selectionAfter);
                else
                    this.selection.setRange(this.$getUndoSelection(deltas, false));
            }
            this.$fromUndo = false;
        };
        this.setUndoSelect = function(enable) {
            this.$undoSelect = enable;
        };

        this.$getUndoSelection = function(deltas, isUndo) {
            function isInsert(delta) {
                return isUndo ? delta.action !== "insert" : delta.action === "insert";
            }

            var range, point;

            for (var i = 0; i < deltas.length; i++) {
                var delta = deltas[i];
                if (!delta.start) continue; // skip folds
                if (!range) {
                    if (isInsert(delta)) {
                        range = Range.fromPoints(delta.start, delta.end);
                    } else {
                        range = Range.fromPoints(delta.start, delta.start);
                    }
                    continue;
                }
                
                if (isInsert(delta)) {
                    point = delta.start;
                    if (range.compare(point.row, point.column) == -1) {
                        range.setStart(point);
                    }
                    point = delta.end;
                    if (range.compare(point.row, point.column) == 1) {
                        range.setEnd(point);
                    }
                } else {
                    point = delta.start;
                    if (range.compare(point.row, point.column) == -1) {
                        range = Range.fromPoints(delta.start, delta.start);
                    }
                }
            }
            return range;
        };
        this.replace = function(range, text) {
            return this.doc.replace(range, text);
        };
        this.moveText = function(fromRange, toPosition, copy) {
            var text = this.getTextRange(fromRange);
            var folds = this.getFoldsInRange(fromRange);

            var toRange = Range.fromPoints(toPosition, toPosition);
            if (!copy) {
                this.remove(fromRange);
                var rowDiff = fromRange.start.row - fromRange.end.row;
                var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
                if (collDiff) {
                    if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                        toRange.start.column += collDiff;
                    if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                        toRange.end.column += collDiff;
                }
                if (rowDiff && toRange.start.row >= fromRange.end.row) {
                    toRange.start.row += rowDiff;
                    toRange.end.row += rowDiff;
                }
            }

            toRange.end = this.insert(toRange.start, text);
            if (folds.length) {
                var oldStart = fromRange.start;
                var newStart = toRange.start;
                var rowDiff = newStart.row - oldStart.row;
                var collDiff = newStart.column - oldStart.column;
                this.addFolds(folds.map(function(x) {
                    x = x.clone();
                    if (x.start.row == oldStart.row)
                        x.start.column += collDiff;
                    if (x.end.row == oldStart.row)
                        x.end.column += collDiff;
                    x.start.row += rowDiff;
                    x.end.row += rowDiff;
                    return x;
                }));
            }

            return toRange;
        };
        this.indentRows = function(startRow, endRow, indentString) {
            indentString = indentString.replace(/\t/g, this.getTabString());
            for (var row=startRow; row<=endRow; row++)
                this.doc.insertInLine({row: row, column: 0}, indentString);
        };
        this.outdentRows = function (range) {
            var rowRange = range.collapseRows();
            var deleteRange = new Range(0, 0, 0, 0);
            var size = this.getTabSize();

            for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
                var line = this.getLine(i);

                deleteRange.start.row = i;
                deleteRange.end.row = i;
                for (var j = 0; j < size; ++j)
                    if (line.charAt(j) != ' ')
                        break;
                if (j < size && line.charAt(j) == '\t') {
                    deleteRange.start.column = j;
                    deleteRange.end.column = j + 1;
                } else {
                    deleteRange.start.column = 0;
                    deleteRange.end.column = j;
                }
                this.remove(deleteRange);
            }
        };

        this.$moveLines = function(firstRow, lastRow, dir) {
            firstRow = this.getRowFoldStart(firstRow);
            lastRow = this.getRowFoldEnd(lastRow);
            if (dir < 0) {
                var row = this.getRowFoldStart(firstRow + dir);
                if (row < 0) return 0;
                var diff = row-firstRow;
            } else if (dir > 0) {
                var row = this.getRowFoldEnd(lastRow + dir);
                if (row > this.doc.getLength()-1) return 0;
                var diff = row-lastRow;
            } else {
                firstRow = this.$clipRowToDocument(firstRow);
                lastRow = this.$clipRowToDocument(lastRow);
                var diff = lastRow - firstRow + 1;
            }

            var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
            var folds = this.getFoldsInRange(range).map(function(x){
                x = x.clone();
                x.start.row += diff;
                x.end.row += diff;
                return x;
            });
            
            var lines = dir == 0
                ? this.doc.getLines(firstRow, lastRow)
                : this.doc.removeFullLines(firstRow, lastRow);
            this.doc.insertFullLines(firstRow+diff, lines);
            folds.length && this.addFolds(folds);
            return diff;
        };
        this.moveLinesUp = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, -1);
        };
        this.moveLinesDown = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 1);
        };
        this.duplicateLines = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 0);
        };


        this.$clipRowToDocument = function(row) {
            return Math.max(0, Math.min(row, this.doc.getLength()-1));
        };

        this.$clipColumnToRow = function(row, column) {
            if (column < 0)
                return 0;
            return Math.min(this.doc.getLine(row).length, column);
        };


        this.$clipPositionToDocument = function(row, column) {
            column = Math.max(0, column);

            if (row < 0) {
                row = 0;
                column = 0;
            } else {
                var len = this.doc.getLength();
                if (row >= len) {
                    row = len - 1;
                    column = this.doc.getLine(len-1).length;
                } else {
                    column = Math.min(this.doc.getLine(row).length, column);
                }
            }

            return {
                row: row,
                column: column
            };
        };

        this.$clipRangeToDocument = function(range) {
            if (range.start.row < 0) {
                range.start.row = 0;
                range.start.column = 0;
            } else {
                range.start.column = this.$clipColumnToRow(
                    range.start.row,
                    range.start.column
                );
            }

            var len = this.doc.getLength() - 1;
            if (range.end.row > len) {
                range.end.row = len;
                range.end.column = this.doc.getLine(len).length;
            } else {
                range.end.column = this.$clipColumnToRow(
                    range.end.row,
                    range.end.column
                );
            }
            return range;
        };
        this.$wrapLimit = 80;
        this.$useWrapMode = false;
        this.$wrapLimitRange = {
            min : null,
            max : null
        };
        this.setUseWrapMode = function(useWrapMode) {
            if (useWrapMode != this.$useWrapMode) {
                this.$useWrapMode = useWrapMode;
                this.$modified = true;
                this.$resetRowCache(0);
                if (useWrapMode) {
                    var len = this.getLength();
                    this.$wrapData = Array(len);
                    this.$updateWrapData(0, len - 1);
                }

                this._signal("changeWrapMode");
            }
        };
        this.getUseWrapMode = function() {
            return this.$useWrapMode;
        };
        this.setWrapLimitRange = function(min, max) {
            if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
                this.$wrapLimitRange = { min: min, max: max };
                this.$modified = true;
                this.$bidiHandler.markAsDirty();
                if (this.$useWrapMode)
                    this._signal("changeWrapMode");
            }
        };
        this.adjustWrapLimit = function(desiredLimit, $printMargin) {
            var limits = this.$wrapLimitRange;
            if (limits.max < 0)
                limits = {min: $printMargin, max: $printMargin};
            var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
            if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
                this.$wrapLimit = wrapLimit;
                this.$modified = true;
                if (this.$useWrapMode) {
                    this.$updateWrapData(0, this.getLength() - 1);
                    this.$resetRowCache(0);
                    this._signal("changeWrapLimit");
                }
                return true;
            }
            return false;
        };

        this.$constrainWrapLimit = function(wrapLimit, min, max) {
            if (min)
                wrapLimit = Math.max(min, wrapLimit);

            if (max)
                wrapLimit = Math.min(max, wrapLimit);

            return wrapLimit;
        };
        this.getWrapLimit = function() {
            return this.$wrapLimit;
        };
        this.setWrapLimit = function (limit) {
            this.setWrapLimitRange(limit, limit);
        };
        this.getWrapLimitRange = function() {
            return {
                min : this.$wrapLimitRange.min,
                max : this.$wrapLimitRange.max
            };
        };

        this.$updateInternalDataOnChange = function(delta) {
            var useWrapMode = this.$useWrapMode;
            var action = delta.action;
            var start = delta.start;
            var end = delta.end;
            var firstRow = start.row;
            var lastRow = end.row;
            var len = lastRow - firstRow;
            var removedFolds = null;
            
            this.$updating = true;
            if (len != 0) {
                if (action === "remove") {
                    this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);

                    var foldLines = this.$foldData;
                    removedFolds = this.getFoldsInRange(delta);
                    this.removeFolds(removedFolds);

                    var foldLine = this.getFoldLine(end.row);
                    var idx = 0;
                    if (foldLine) {
                        foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                        foldLine.shiftRow(-len);

                        var foldLineBefore = this.getFoldLine(firstRow);
                        if (foldLineBefore && foldLineBefore !== foldLine) {
                            foldLineBefore.merge(foldLine);
                            foldLine = foldLineBefore;
                        }
                        idx = foldLines.indexOf(foldLine) + 1;
                    }

                    for (idx; idx < foldLines.length; idx++) {
                        var foldLine = foldLines[idx];
                        if (foldLine.start.row >= end.row) {
                            foldLine.shiftRow(-len);
                        }
                    }

                    lastRow = firstRow;
                } else {
                    var args = Array(len);
                    args.unshift(firstRow, 0);
                    var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                    arr.splice.apply(arr, args);
                    var foldLines = this.$foldData;
                    var foldLine = this.getFoldLine(firstRow);
                    var idx = 0;
                    if (foldLine) {
                        var cmp = foldLine.range.compareInside(start.row, start.column);
                        if (cmp == 0) {
                            foldLine = foldLine.split(start.row, start.column);
                            if (foldLine) {
                                foldLine.shiftRow(len);
                                foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                            }
                        } else
                        if (cmp == -1) {
                            foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                            foldLine.shiftRow(len);
                        }
                        idx = foldLines.indexOf(foldLine) + 1;
                    }

                    for (idx; idx < foldLines.length; idx++) {
                        var foldLine = foldLines[idx];
                        if (foldLine.start.row >= firstRow) {
                            foldLine.shiftRow(len);
                        }
                    }
                }
            } else {
                len = Math.abs(delta.start.column - delta.end.column);
                if (action === "remove") {
                    removedFolds = this.getFoldsInRange(delta);
                    this.removeFolds(removedFolds);

                    len = -len;
                }
                var foldLine = this.getFoldLine(firstRow);
                if (foldLine) {
                    foldLine.addRemoveChars(firstRow, start.column, len);
                }
            }

            if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
                console.error("doc.getLength() and $wrapData.length have to be the same!");
            }
            this.$updating = false;

            if (useWrapMode)
                this.$updateWrapData(firstRow, lastRow);
            else
                this.$updateRowLengthCache(firstRow, lastRow);

            return removedFolds;
        };

        this.$updateRowLengthCache = function(firstRow, lastRow, b) {
            this.$rowLengthCache[firstRow] = null;
            this.$rowLengthCache[lastRow] = null;
        };

        this.$updateWrapData = function(firstRow, lastRow) {
            var lines = this.doc.getAllLines();
            var tabSize = this.getTabSize();
            var wrapData = this.$wrapData;
            var wrapLimit = this.$wrapLimit;
            var tokens;
            var foldLine;

            var row = firstRow;
            lastRow = Math.min(lastRow, lines.length - 1);
            while (row <= lastRow) {
                foldLine = this.getFoldLine(row, foldLine);
                if (!foldLine) {
                    tokens = this.$getDisplayTokens(lines[row]);
                    wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                    row ++;
                } else {
                    tokens = [];
                    foldLine.walk(function(placeholder, row, column, lastColumn) {
                            var walkTokens;
                            if (placeholder != null) {
                                walkTokens = this.$getDisplayTokens(
                                                placeholder, tokens.length);
                                walkTokens[0] = PLACEHOLDER_START;
                                for (var i = 1; i < walkTokens.length; i++) {
                                    walkTokens[i] = PLACEHOLDER_BODY;
                                }
                            } else {
                                walkTokens = this.$getDisplayTokens(
                                    lines[row].substring(lastColumn, column),
                                    tokens.length);
                            }
                            tokens = tokens.concat(walkTokens);
                        }.bind(this),
                        foldLine.end.row,
                        lines[foldLine.end.row].length + 1
                    );

                    wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                    row = foldLine.end.row + 1;
                }
            }
        };
        var CHAR = 1,
            CHAR_EXT = 2,
            PLACEHOLDER_START = 3,
            PLACEHOLDER_BODY =  4,
            PUNCTUATION = 9,
            SPACE = 10,
            TAB = 11,
            TAB_SPACE = 12;


        this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
            if (tokens.length == 0) {
                return [];
            }

            var splits = [];
            var displayLength = tokens.length;
            var lastSplit = 0, lastDocSplit = 0;

            var isCode = this.$wrapAsCode;

            var indentedSoftWrap = this.$indentedSoftWrap;
            var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)
                || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);

            function getWrapIndent() {
                var indentation = 0;
                if (maxIndent === 0)
                    return indentation;
                if (indentedSoftWrap) {
                    for (var i = 0; i < tokens.length; i++) {
                        var token = tokens[i];
                        if (token == SPACE)
                            indentation += 1;
                        else if (token == TAB)
                            indentation += tabSize;
                        else if (token == TAB_SPACE)
                            continue;
                        else
                            break;
                    }
                }
                if (isCode && indentedSoftWrap !== false)
                    indentation += tabSize;
                return Math.min(indentation, maxIndent);
            }
            function addSplit(screenPos) {
                var len = screenPos - lastSplit;
                for (var i = lastSplit; i < screenPos; i++) {
                    var ch = tokens[i];
                    if (ch === 12 || ch === 2) len -= 1;
                }

                if (!splits.length) {
                    indent = getWrapIndent();
                    splits.indent = indent;
                }
                lastDocSplit += len;
                splits.push(lastDocSplit);
                lastSplit = screenPos;
            }
            var indent = 0;
            while (displayLength - lastSplit > wrapLimit - indent) {
                var split = lastSplit + wrapLimit - indent;
                if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                    addSplit(split);
                    continue;
                }
                if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                    for (split; split != lastSplit - 1; split--) {
                        if (tokens[split] == PLACEHOLDER_START) {
                            break;
                        }
                    }
                    if (split > lastSplit) {
                        addSplit(split);
                        continue;
                    }
                    split = lastSplit + wrapLimit;
                    for (split; split < tokens.length; split++) {
                        if (tokens[split] != PLACEHOLDER_BODY) {
                            break;
                        }
                    }
                    if (split == tokens.length) {
                        break;  // Breaks the while-loop.
                    }
                    addSplit(split);
                    continue;
                }
                var minSplit = Math.max(split - (wrapLimit -(wrapLimit>>2)), lastSplit - 1);
                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                    split --;
                }
                if (isCode) {
                    while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                        split --;
                    }
                    while (split > minSplit && tokens[split] == PUNCTUATION) {
                        split --;
                    }
                } else {
                    while (split > minSplit && tokens[split] < SPACE) {
                        split --;
                    }
                }
                if (split > minSplit) {
                    addSplit(++split);
                    continue;
                }
                split = lastSplit + wrapLimit;
                if (tokens[split] == CHAR_EXT)
                    split--;
                addSplit(split - indent);
            }
            return splits;
        };
        this.$getDisplayTokens = function(str, offset) {
            var arr = [];
            var tabSize;
            offset = offset || 0;

            for (var i = 0; i < str.length; i++) {
                var c = str.charCodeAt(i);
                if (c == 9) {
                    tabSize = this.getScreenTabSize(arr.length + offset);
                    arr.push(TAB);
                    for (var n = 1; n < tabSize; n++) {
                        arr.push(TAB_SPACE);
                    }
                }
                else if (c == 32) {
                    arr.push(SPACE);
                } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {
                    arr.push(PUNCTUATION);
                }
                else if (c >= 0x1100 && isFullWidth(c)) {
                    arr.push(CHAR, CHAR_EXT);
                } else {
                    arr.push(CHAR);
                }
            }
            return arr;
        };
        this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn == 0)
                return [0, 0];
            if (maxScreenColumn == null)
                maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;

            var c, column;
            for (column = 0; column < str.length; column++) {
                c = str.charCodeAt(column);
                if (c == 9) {
                    screenColumn += this.getScreenTabSize(screenColumn);
                }
                else if (c >= 0x1100 && isFullWidth(c)) {
                    screenColumn += 2;
                } else {
                    screenColumn += 1;
                }
                if (screenColumn > maxScreenColumn) {
                    break;
                }
            }

            return [screenColumn, column];
        };

        this.lineWidgets = null;
        this.getRowLength = function(row) {
            var h = 1;
            if (this.lineWidgets)
                h += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            
            if (!this.$useWrapMode || !this.$wrapData[row])
                return h;
            else
                return this.$wrapData[row].length + h;
        };
        this.getRowLineCount = function(row) {
            if (!this.$useWrapMode || !this.$wrapData[row]) {
                return 1;
            } else {
                return this.$wrapData[row].length + 1;
            }
        };

        this.getRowWrapIndent = function(screenRow) {
            if (this.$useWrapMode) {
                var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
                var splits = this.$wrapData[pos.row];
                return splits.length && splits[0] < pos.column ? splits.indent : 0;
            } else {
                return 0;
            }
        };
        this.getScreenLastRowColumn = function(screenRow) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            return this.documentToScreenColumn(pos.row, pos.column);
        };
        this.getDocumentLastRowColumn = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.getScreenLastRowColumn(screenRow);
        };
        this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
        };
        this.getRowSplitData = function(row) {
            if (!this.$useWrapMode) {
                return undefined;
            } else {
                return this.$wrapData[row];
            }
        };
        this.getScreenTabSize = function(screenColumn) {
            return this.$tabSize - (screenColumn % this.$tabSize | 0);
        };


        this.screenToDocumentRow = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).row;
        };


        this.screenToDocumentColumn = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).column;
        };
        this.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {
            if (screenRow < 0)
                return {row: 0, column: 0};

            var line;
            var docRow = 0;
            var docColumn = 0;
            var column;
            var row = 0;
            var rowLength = 0;

            var rowCache = this.$screenRowCache;
            var i = this.$getRowCacheIndex(rowCache, screenRow);
            var l = rowCache.length;
            if (l && i >= 0) {
                var row = rowCache[i];
                var docRow = this.$docRowCache[i];
                var doCache = screenRow > rowCache[l - 1];
            } else {
                var doCache = !l;
            }

            var maxRow = this.getLength() - 1;
            var foldLine = this.getNextFoldLine(docRow);
            var foldStart = foldLine ? foldLine.start.row : Infinity;

            while (row <= screenRow) {
                rowLength = this.getRowLength(docRow);
                if (row + rowLength > screenRow || docRow >= maxRow) {
                    break;
                } else {
                    row += rowLength;
                    docRow++;
                    if (docRow > foldStart) {
                        docRow = foldLine.end.row+1;
                        foldLine = this.getNextFoldLine(docRow, foldLine);
                        foldStart = foldLine ? foldLine.start.row : Infinity;
                    }
                }

                if (doCache) {
                    this.$docRowCache.push(docRow);
                    this.$screenRowCache.push(row);
                }
            }

            if (foldLine && foldLine.start.row <= docRow) {
                line = this.getFoldDisplayLine(foldLine);
                docRow = foldLine.start.row;
            } else if (row + rowLength <= screenRow || docRow > maxRow) {
                return {
                    row: maxRow,
                    column: this.getLine(maxRow).length
                };
            } else {
                line = this.getLine(docRow);
                foldLine = null;
            }
            var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
            if (this.$useWrapMode) {
                var splits = this.$wrapData[docRow];
                if (splits) {
                    column = splits[splitIndex];
                    if(splitIndex > 0 && splits.length) {
                        wrapIndent = splits.indent;
                        docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                        line = line.substring(docColumn);
                    }
                }
            }

            if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
                screenColumn = this.$bidiHandler.offsetToCol(offsetX);

            docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
            if (this.$useWrapMode && docColumn >= column)
                docColumn = column - 1;

            if (foldLine)
                return foldLine.idxToPosition(docColumn);

            return {row: docRow, column: docColumn};
        };
        this.documentToScreenPosition = function(docRow, docColumn) {
            if (typeof docColumn === "undefined")
                var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
            else
                pos = this.$clipPositionToDocument(docRow, docColumn);

            docRow = pos.row;
            docColumn = pos.column;

            var screenRow = 0;
            var foldStartRow = null;
            var fold = null;
            fold = this.getFoldAt(docRow, docColumn, 1);
            if (fold) {
                docRow = fold.start.row;
                docColumn = fold.start.column;
            }

            var rowEnd, row = 0;


            var rowCache = this.$docRowCache;
            var i = this.$getRowCacheIndex(rowCache, docRow);
            var l = rowCache.length;
            if (l && i >= 0) {
                var row = rowCache[i];
                var screenRow = this.$screenRowCache[i];
                var doCache = docRow > rowCache[l - 1];
            } else {
                var doCache = !l;
            }

            var foldLine = this.getNextFoldLine(row);
            var foldStart = foldLine ?foldLine.start.row :Infinity;

            while (row < docRow) {
                if (row >= foldStart) {
                    rowEnd = foldLine.end.row + 1;
                    if (rowEnd > docRow)
                        break;
                    foldLine = this.getNextFoldLine(rowEnd, foldLine);
                    foldStart = foldLine ?foldLine.start.row :Infinity;
                }
                else {
                    rowEnd = row + 1;
                }

                screenRow += this.getRowLength(row);
                row = rowEnd;

                if (doCache) {
                    this.$docRowCache.push(row);
                    this.$screenRowCache.push(screenRow);
                }
            }
            var textLine = "";
            if (foldLine && row >= foldStart) {
                textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
                foldStartRow = foldLine.start.row;
            } else {
                textLine = this.getLine(docRow).substring(0, docColumn);
                foldStartRow = docRow;
            }
            var wrapIndent = 0;
            if (this.$useWrapMode) {
                var wrapRow = this.$wrapData[foldStartRow];
                if (wrapRow) {
                    var screenRowOffset = 0;
                    while (textLine.length >= wrapRow[screenRowOffset]) {
                        screenRow ++;
                        screenRowOffset++;
                    }
                    textLine = textLine.substring(
                        wrapRow[screenRowOffset - 1] || 0, textLine.length
                    );
                    wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
                }
            }
            
            if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove)
                screenRow += this.lineWidgets[row].rowsAbove;

            return {
                row: screenRow,
                column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
            };
        };
        this.documentToScreenColumn = function(row, docColumn) {
            return this.documentToScreenPosition(row, docColumn).column;
        };
        this.documentToScreenRow = function(docRow, docColumn) {
            return this.documentToScreenPosition(docRow, docColumn).row;
        };
        this.getScreenLength = function() {
            var screenRows = 0;
            var fold = null;
            if (!this.$useWrapMode) {
                screenRows = this.getLength();
                var foldData = this.$foldData;
                for (var i = 0; i < foldData.length; i++) {
                    fold = foldData[i];
                    screenRows -= fold.end.row - fold.start.row;
                }
            } else {
                var lastRow = this.$wrapData.length;
                var row = 0, i = 0;
                var fold = this.$foldData[i++];
                var foldStart = fold ? fold.start.row :Infinity;

                while (row < lastRow) {
                    var splits = this.$wrapData[row];
                    screenRows += splits ? splits.length + 1 : 1;
                    row ++;
                    if (row > foldStart) {
                        row = fold.end.row+1;
                        fold = this.$foldData[i++];
                        foldStart = fold ?fold.start.row :Infinity;
                    }
                }
            }
            if (this.lineWidgets)
                screenRows += this.$getWidgetScreenLength();

            return screenRows;
        };
        this.$setFontMetrics = function(fm) {
            if (!this.$enableVarChar) return;
            this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
                if (maxScreenColumn === 0)
                    return [0, 0];
                if (!maxScreenColumn)
                    maxScreenColumn = Infinity;
                screenColumn = screenColumn || 0;
                
                var c, column;
                for (column = 0; column < str.length; column++) {
                    c = str.charAt(column);
                    if (c === "\t") {
                        screenColumn += this.getScreenTabSize(screenColumn);
                    } else {
                        screenColumn += fm.getCharacterWidth(c);
                    }
                    if (screenColumn > maxScreenColumn) {
                        break;
                    }
                }
                
                return [screenColumn, column];
            };
        };
        
        this.destroy = function() {
            if (this.bgTokenizer) {
                this.bgTokenizer.setDocument(null);
                this.bgTokenizer = null;
            }
            this.$stopWorker();
            this.removeAllListeners();
            this.selection.detach();
        };

        this.isFullWidth = isFullWidth;
        function isFullWidth(c) {
            if (c < 0x1100)
                return false;
            return c >= 0x1100 && c <= 0x115F ||
                   c >= 0x11A3 && c <= 0x11A7 ||
                   c >= 0x11FA && c <= 0x11FF ||
                   c >= 0x2329 && c <= 0x232A ||
                   c >= 0x2E80 && c <= 0x2E99 ||
                   c >= 0x2E9B && c <= 0x2EF3 ||
                   c >= 0x2F00 && c <= 0x2FD5 ||
                   c >= 0x2FF0 && c <= 0x2FFB ||
                   c >= 0x3000 && c <= 0x303E ||
                   c >= 0x3041 && c <= 0x3096 ||
                   c >= 0x3099 && c <= 0x30FF ||
                   c >= 0x3105 && c <= 0x312D ||
                   c >= 0x3131 && c <= 0x318E ||
                   c >= 0x3190 && c <= 0x31BA ||
                   c >= 0x31C0 && c <= 0x31E3 ||
                   c >= 0x31F0 && c <= 0x321E ||
                   c >= 0x3220 && c <= 0x3247 ||
                   c >= 0x3250 && c <= 0x32FE ||
                   c >= 0x3300 && c <= 0x4DBF ||
                   c >= 0x4E00 && c <= 0xA48C ||
                   c >= 0xA490 && c <= 0xA4C6 ||
                   c >= 0xA960 && c <= 0xA97C ||
                   c >= 0xAC00 && c <= 0xD7A3 ||
                   c >= 0xD7B0 && c <= 0xD7C6 ||
                   c >= 0xD7CB && c <= 0xD7FB ||
                   c >= 0xF900 && c <= 0xFAFF ||
                   c >= 0xFE10 && c <= 0xFE19 ||
                   c >= 0xFE30 && c <= 0xFE52 ||
                   c >= 0xFE54 && c <= 0xFE66 ||
                   c >= 0xFE68 && c <= 0xFE6B ||
                   c >= 0xFF01 && c <= 0xFF60 ||
                   c >= 0xFFE0 && c <= 0xFFE6;
        }

    }).call(EditSession.prototype);

    require("./edit_session/folding").Folding.call(EditSession.prototype);
    require("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);


    config.defineOptions(EditSession.prototype, "session", {
        wrap: {
            set: function(value) {
                if (!value || value == "off")
                    value = false;
                else if (value == "free")
                    value = true;
                else if (value == "printMargin")
                    value = -1;
                else if (typeof value == "string")
                    value = parseInt(value, 10) || false;

                if (this.$wrap == value)
                    return;
                this.$wrap = value;
                if (!value) {
                    this.setUseWrapMode(false);
                } else {
                    var col = typeof value == "number" ? value : null;
                    this.setWrapLimitRange(col, col);
                    this.setUseWrapMode(true);
                }
            },
            get: function() {
                if (this.getUseWrapMode()) {
                    if (this.$wrap == -1)
                        return "printMargin";
                    if (!this.getWrapLimitRange().min)
                        return "free";
                    return this.$wrap;
                }
                return "off";
            },
            handlesSet: true
        },    
        wrapMethod: {
            set: function(val) {
                val = val == "auto"
                    ? this.$mode.type != "text"
                    : val != "text";
                if (val != this.$wrapAsCode) {
                    this.$wrapAsCode = val;
                    if (this.$useWrapMode) {
                        this.$useWrapMode = false;
                        this.setUseWrapMode(true);
                    }
                }
            },
            initialValue: "auto"
        },
        indentedSoftWrap: {
            set: function() {
                if (this.$useWrapMode) {
                    this.$useWrapMode = false;
                    this.setUseWrapMode(true);
                }
            },
            initialValue: true 
        },
        firstLineNumber: {
            set: function() {this._signal("changeBreakpoint");},
            initialValue: 1
        },
        useWorker: {
            set: function(useWorker) {
                this.$useWorker = useWorker;

                this.$stopWorker();
                if (useWorker)
                    this.$startWorker();
            },
            initialValue: true
        },
        useSoftTabs: {initialValue: true},
        tabSize: {
            set: function(tabSize) {
                tabSize = parseInt(tabSize);
                if (tabSize > 0 && this.$tabSize !== tabSize) {
                    this.$modified = true;
                    this.$rowLengthCache = [];
                    this.$tabSize = tabSize;
                    this._signal("changeTabSize");
                }
            },
            initialValue: 4,
            handlesSet: true
        },
        navigateWithinSoftTabs: {initialValue: false},
        foldStyle: {
            set: function(val) {this.setFoldStyle(val);},
            handlesSet: true
        },
        overwrite: {
            set: function(val) {this._signal("changeOverwrite");},
            initialValue: false
        },
        newLineMode: {
            set: function(val) {this.doc.setNewLineMode(val);},
            get: function() {return this.doc.getNewLineMode();},
            handlesSet: true
        },
        mode: {
            set: function(val) { this.setMode(val); },
            get: function() { return this.$modeId; },
            handlesSet: true
        }
    });

    exports.EditSession = EditSession;
    });

    ace.define("ace/search",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(require, exports, module) {

    var lang = require("./lib/lang");
    var oop = require("./lib/oop");
    var Range = require("./range").Range;

    var Search = function() {
        this.$options = {};
    };

    (function() {
        this.set = function(options) {
            oop.mixin(this.$options, options);
            return this;
        };
        this.getOptions = function() {
            return lang.copyObject(this.$options);
        };
        this.setOptions = function(options) {
            this.$options = options;
        };
        this.find = function(session) {
            var options = this.$options;
            var iterator = this.$matchIterator(session, options);
            if (!iterator)
                return false;

            var firstRange = null;
            iterator.forEach(function(sr, sc, er, ec) {
                firstRange = new Range(sr, sc, er, ec);
                if (sc == ec && options.start && options.start.start
                    && options.skipCurrent != false && firstRange.isEqual(options.start)
                ) {
                    firstRange = null;
                    return false;
                }
                
                return true;
            });

            return firstRange;
        };
        this.findAll = function(session) {
            var options = this.$options;
            if (!options.needle)
                return [];
            this.$assembleRegExp(options);

            var range = options.range;
            var lines = range
                ? session.getLines(range.start.row, range.end.row)
                : session.doc.getAllLines();

            var ranges = [];
            var re = options.re;
            if (options.$isMultiLine) {
                var len = re.length;
                var maxRow = lines.length - len;
                var prevRange;
                outer: for (var row = re.offset || 0; row <= maxRow; row++) {
                    for (var j = 0; j < len; j++)
                        if (lines[row + j].search(re[j]) == -1)
                            continue outer;
                    
                    var startLine = lines[row];
                    var line = lines[row + len - 1];
                    var startIndex = startLine.length - startLine.match(re[0])[0].length;
                    var endIndex = line.match(re[len - 1])[0].length;
                    
                    if (prevRange && prevRange.end.row === row &&
                        prevRange.end.column > startIndex
                    ) {
                        continue;
                    }
                    ranges.push(prevRange = new Range(
                        row, startIndex, row + len - 1, endIndex
                    ));
                    if (len > 2)
                        row = row + len - 2;
                }
            } else {
                for (var i = 0; i < lines.length; i++) {
                    var matches = lang.getMatchOffsets(lines[i], re);
                    for (var j = 0; j < matches.length; j++) {
                        var match = matches[j];
                        ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                    }
                }
            }

            if (range) {
                var startColumn = range.start.column;
                var endColumn = range.start.column;
                var i = 0, j = ranges.length - 1;
                while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
                    i++;

                while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
                    j--;
                
                ranges = ranges.slice(i, j + 1);
                for (i = 0, j = ranges.length; i < j; i++) {
                    ranges[i].start.row += range.start.row;
                    ranges[i].end.row += range.start.row;
                }
            }

            return ranges;
        };
        this.replace = function(input, replacement) {
            var options = this.$options;

            var re = this.$assembleRegExp(options);
            if (options.$isMultiLine)
                return replacement;

            if (!re)
                return;

            var match = re.exec(input);
            if (!match || match[0].length != input.length)
                return null;
            
            replacement = input.replace(re, replacement);
            if (options.preserveCase) {
                replacement = replacement.split("");
                for (var i = Math.min(input.length, input.length); i--; ) {
                    var ch = input[i];
                    if (ch && ch.toLowerCase() != ch)
                        replacement[i] = replacement[i].toUpperCase();
                    else
                        replacement[i] = replacement[i].toLowerCase();
                }
                replacement = replacement.join("");
            }
            
            return replacement;
        };

        this.$assembleRegExp = function(options, $disableFakeMultiline) {
            if (options.needle instanceof RegExp)
                return options.re = options.needle;

            var needle = options.needle;

            if (!options.needle)
                return options.re = false;

            if (!options.regExp)
                needle = lang.escapeRegExp(needle);

            if (options.wholeWord)
                needle = addWordBoundary(needle, options);

            var modifier = options.caseSensitive ? "gm" : "gmi";

            options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
            if (options.$isMultiLine)
                return options.re = this.$assembleMultilineRegExp(needle, modifier);

            try {
                var re = new RegExp(needle, modifier);
            } catch(e) {
                re = false;
            }
            return options.re = re;
        };

        this.$assembleMultilineRegExp = function(needle, modifier) {
            var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
            var re = [];
            for (var i = 0; i < parts.length; i++) try {
                re.push(new RegExp(parts[i], modifier));
            } catch(e) {
                return false;
            }
            return re;
        };

        this.$matchIterator = function(session, options) {
            var re = this.$assembleRegExp(options);
            if (!re)
                return false;
            var backwards = options.backwards == true;
            var skipCurrent = options.skipCurrent != false;

            var range = options.range;
            var start = options.start;
            if (!start)
                start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
             
            if (start.start)
                start = start[skipCurrent != backwards ? "end" : "start"];

            var firstRow = range ? range.start.row : 0;
            var lastRow = range ? range.end.row : session.getLength() - 1;
            
            if (backwards) {
                var forEach = function(callback) {
                    var row = start.row;
                    if (forEachInLine(row, start.column, callback))
                        return;
                    for (row--; row >= firstRow; row--)
                        if (forEachInLine(row, Number.MAX_VALUE, callback))
                            return;
                    if (options.wrap == false)
                        return;
                    for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                        if (forEachInLine(row, Number.MAX_VALUE, callback))
                            return;
                };
            }
            else {
                var forEach = function(callback) {
                    var row = start.row;
                    if (forEachInLine(row, start.column, callback))
                        return;
                    for (row = row + 1; row <= lastRow; row++)
                        if (forEachInLine(row, 0, callback))
                            return;
                    if (options.wrap == false)
                        return;
                    for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                        if (forEachInLine(row, 0, callback))
                            return;
                };
            }
            
            if (options.$isMultiLine) {
                var len = re.length;
                var forEachInLine = function(row, offset, callback) {
                    var startRow = backwards ? row - len + 1 : row;
                    if (startRow < 0) return;
                    var line = session.getLine(startRow);
                    var startIndex = line.search(re[0]);
                    if (!backwards && startIndex < offset || startIndex === -1) return;
                    for (var i = 1; i < len; i++) {
                        line = session.getLine(startRow + i);
                        if (line.search(re[i]) == -1)
                            return;
                    }
                    var endIndex = line.match(re[len - 1])[0].length;
                    if (backwards && endIndex > offset) return;
                    if (callback(startRow, startIndex, startRow + len - 1, endIndex))
                        return true;
                };
            }
            else if (backwards) {
                var forEachInLine = function(row, endIndex, callback) {
                    var line = session.getLine(row);
                    var matches = [];
                    var m, last = 0;
                    re.lastIndex = 0;
                    while((m = re.exec(line))) {
                        var length = m[0].length;
                        last = m.index;
                        if (!length) {
                            if (last >= line.length) break;
                            re.lastIndex = last += 1;
                        }
                        if (m.index + length > endIndex)
                            break;
                        matches.push(m.index, length);
                    }
                    for (var i = matches.length - 1; i >= 0; i -= 2) {
                        var column = matches[i - 1];
                        var length = matches[i];
                        if (callback(row, column, row, column + length))
                            return true;
                    }
                };
            }
            else {
                var forEachInLine = function(row, startIndex, callback) {
                    var line = session.getLine(row);
                    var last;
                    var m;
                    re.lastIndex = startIndex;
                    while((m = re.exec(line))) {
                        var length = m[0].length;
                        last = m.index;
                        if (callback(row, last, row,last + length))
                            return true;
                        if (!length) {
                            re.lastIndex = last += 1;
                            if (last >= line.length) return false;
                        }
                    }
                };
            }
            return {forEach: forEach};
        };

    }).call(Search.prototype);

    function addWordBoundary(needle, options) {
        function wordBoundary(c) {
            if (/\w/.test(c) || options.regExp) return "\\b";
            return "";
        }
        return wordBoundary(needle[0]) + needle
            + wordBoundary(needle[needle.length - 1]);
    }

    exports.Search = Search;
    });

    ace.define("ace/keyboard/hash_handler",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(require, exports, module) {

    var keyUtil = require("../lib/keys");
    var useragent = require("../lib/useragent");
    var KEY_MODS = keyUtil.KEY_MODS;

    function HashHandler(config, platform) {
        this.platform = platform || (useragent.isMac ? "mac" : "win");
        this.commands = {};
        this.commandKeyBinding = {};
        this.addCommands(config);
        this.$singleCommand = true;
    }

    function MultiHashHandler(config, platform) {
        HashHandler.call(this, config, platform);
        this.$singleCommand = false;
    }

    MultiHashHandler.prototype = HashHandler.prototype;

    (function() {
        

        this.addCommand = function(command) {
            if (this.commands[command.name])
                this.removeCommand(command);

            this.commands[command.name] = command;

            if (command.bindKey)
                this._buildKeyHash(command);
        };

        this.removeCommand = function(command, keepCommand) {
            var name = command && (typeof command === 'string' ? command : command.name);
            command = this.commands[name];
            if (!keepCommand)
                delete this.commands[name];
            var ckb = this.commandKeyBinding;
            for (var keyId in ckb) {
                var cmdGroup = ckb[keyId];
                if (cmdGroup == command) {
                    delete ckb[keyId];
                } else if (Array.isArray(cmdGroup)) {
                    var i = cmdGroup.indexOf(command);
                    if (i != -1) {
                        cmdGroup.splice(i, 1);
                        if (cmdGroup.length == 1)
                            ckb[keyId] = cmdGroup[0];
                    }
                }
            }
        };

        this.bindKey = function(key, command, position) {
            if (typeof key == "object" && key) {
                if (position == undefined)
                    position = key.position;
                key = key[this.platform];
            }
            if (!key)
                return;
            if (typeof command == "function")
                return this.addCommand({exec: command, bindKey: key, name: command.name || key});
            
            key.split("|").forEach(function(keyPart) {
                var chain = "";
                if (keyPart.indexOf(" ") != -1) {
                    var parts = keyPart.split(/\s+/);
                    keyPart = parts.pop();
                    parts.forEach(function(keyPart) {
                        var binding = this.parseKeys(keyPart);
                        var id = KEY_MODS[binding.hashId] + binding.key;
                        chain += (chain ? " " : "") + id;
                        this._addCommandToBinding(chain, "chainKeys");
                    }, this);
                    chain += " ";
                }
                var binding = this.parseKeys(keyPart);
                var id = KEY_MODS[binding.hashId] + binding.key;
                this._addCommandToBinding(chain + id, command, position);
            }, this);
        };
        
        function getPosition(command) {
            return typeof command == "object" && command.bindKey
                && command.bindKey.position 
                || (command.isDefault ? -100 : 0);
        }
        this._addCommandToBinding = function(keyId, command, position) {
            var ckb = this.commandKeyBinding, i;
            if (!command) {
                delete ckb[keyId];
            } else if (!ckb[keyId] || this.$singleCommand) {
                ckb[keyId] = command;
            } else {
                if (!Array.isArray(ckb[keyId])) {
                    ckb[keyId] = [ckb[keyId]];
                } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                    ckb[keyId].splice(i, 1);
                }
                
                if (typeof position != "number") {
                    position = getPosition(command);
                }

                var commands = ckb[keyId];
                for (i = 0; i < commands.length; i++) {
                    var other = commands[i];
                    var otherPos = getPosition(other);
                    if (otherPos > position)
                        break;
                }
                commands.splice(i, 0, command);
            }
        };

        this.addCommands = function(commands) {
            commands && Object.keys(commands).forEach(function(name) {
                var command = commands[name];
                if (!command)
                    return;
                
                if (typeof command === "string")
                    return this.bindKey(command, name);

                if (typeof command === "function")
                    command = { exec: command };

                if (typeof command !== "object")
                    return;

                if (!command.name)
                    command.name = name;

                this.addCommand(command);
            }, this);
        };

        this.removeCommands = function(commands) {
            Object.keys(commands).forEach(function(name) {
                this.removeCommand(commands[name]);
            }, this);
        };

        this.bindKeys = function(keyList) {
            Object.keys(keyList).forEach(function(key) {
                this.bindKey(key, keyList[key]);
            }, this);
        };

        this._buildKeyHash = function(command) {
            this.bindKey(command.bindKey, command);
        };
        this.parseKeys = function(keys) {
            var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x){return x;});
            var key = parts.pop();

            var keyCode = keyUtil[key];
            if (keyUtil.FUNCTION_KEYS[keyCode])
                key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
            else if (!parts.length)
                return {key: key, hashId: -1};
            else if (parts.length == 1 && parts[0] == "shift")
                return {key: key.toUpperCase(), hashId: -1};

            var hashId = 0;
            for (var i = parts.length; i--;) {
                var modifier = keyUtil.KEY_MODS[parts[i]];
                if (modifier == null) {
                    if (typeof console != "undefined")
                        console.error("invalid modifier " + parts[i] + " in " + keys);
                    return false;
                }
                hashId |= modifier;
            }
            return {key: key, hashId: hashId};
        };

        this.findKeyCommand = function findKeyCommand(hashId, keyString) {
            var key = KEY_MODS[hashId] + keyString;
            return this.commandKeyBinding[key];
        };

        this.handleKeyboard = function(data, hashId, keyString, keyCode) {
            if (keyCode < 0) return;
            var key = KEY_MODS[hashId] + keyString;
            var command = this.commandKeyBinding[key];
            if (data.$keyChain) {
                data.$keyChain += " " + key;
                command = this.commandKeyBinding[data.$keyChain] || command;
            }
            
            if (command) {
                if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                    data.$keyChain = data.$keyChain || key;
                    return {command: "null"};
                }
            }
            
            if (data.$keyChain) {
                if ((!hashId || hashId == 4) && keyString.length == 1)
                    data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
                else if (hashId == -1 || keyCode > 0)
                    data.$keyChain = ""; // reset keyChain
            }
            return {command: command};
        };
        
        this.getStatusText = function(editor, data) {
            return data.$keyChain || "";
        };

    }).call(HashHandler.prototype);

    exports.HashHandler = HashHandler;
    exports.MultiHashHandler = MultiHashHandler;
    });

    ace.define("ace/commands/command_manager",["require","exports","module","ace/lib/oop","ace/keyboard/hash_handler","ace/lib/event_emitter"], function(require, exports, module) {

    var oop = require("../lib/oop");
    var MultiHashHandler = require("../keyboard/hash_handler").MultiHashHandler;
    var EventEmitter = require("../lib/event_emitter").EventEmitter;

    var CommandManager = function(platform, commands) {
        MultiHashHandler.call(this, commands, platform);
        this.byName = this.commands;
        this.setDefaultHandler("exec", function(e) {
            return e.command.exec(e.editor, e.args || {});
        });
    };

    oop.inherits(CommandManager, MultiHashHandler);

    (function() {

        oop.implement(this, EventEmitter);

        this.exec = function(command, editor, args) {
            if (Array.isArray(command)) {
                for (var i = command.length; i--; ) {
                    if (this.exec(command[i], editor, args)) return true;
                }
                return false;
            }

            if (typeof command === "string")
                command = this.commands[command];

            if (!command)
                return false;

            if (editor && editor.$readOnly && !command.readOnly)
                return false;

            if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))
                return false;

            var e = {editor: editor, command: command, args: args};
            e.returnValue = this._emit("exec", e);
            this._signal("afterExec", e);

            return e.returnValue === false ? false : true;
        };

        this.toggleRecording = function(editor) {
            if (this.$inReplay)
                return;

            editor && editor._emit("changeStatus");
            if (this.recording) {
                this.macro.pop();
                this.off("exec", this.$addCommandToMacro);

                if (!this.macro.length)
                    this.macro = this.oldMacro;

                return this.recording = false;
            }
            if (!this.$addCommandToMacro) {
                this.$addCommandToMacro = function(e) {
                    this.macro.push([e.command, e.args]);
                }.bind(this);
            }

            this.oldMacro = this.macro;
            this.macro = [];
            this.on("exec", this.$addCommandToMacro);
            return this.recording = true;
        };

        this.replay = function(editor) {
            if (this.$inReplay || !this.macro)
                return;

            if (this.recording)
                return this.toggleRecording(editor);

            try {
                this.$inReplay = true;
                this.macro.forEach(function(x) {
                    if (typeof x == "string")
                        this.exec(x, editor);
                    else
                        this.exec(x[0], editor, x[1]);
                }, this);
            } finally {
                this.$inReplay = false;
            }
        };

        this.trimMacro = function(m) {
            return m.map(function(x){
                if (typeof x[0] != "string")
                    x[0] = x[0].name;
                if (!x[1])
                    x = x[0];
                return x;
            });
        };

    }).call(CommandManager.prototype);

    exports.CommandManager = CommandManager;

    });

    ace.define("ace/commands/default_commands",["require","exports","module","ace/lib/lang","ace/config","ace/range"], function(require, exports, module) {

    var lang = require("../lib/lang");
    var config = require("../config");
    var Range = require("../range").Range;

    function bindKey(win, mac) {
        return {win: win, mac: mac};
    }
    exports.commands = [{
        name: "showSettingsMenu",
        bindKey: bindKey("Ctrl-,", "Command-,"),
        exec: function(editor) {
            config.loadModule("ace/ext/settings_menu", function(module) {
                module.init(editor);
                editor.showSettingsMenu();
            });
        },
        readOnly: true
    }, {
        name: "goToNextError",
        bindKey: bindKey("Alt-E", "F4"),
        exec: function(editor) {
            config.loadModule("./ext/error_marker", function(module) {
                module.showErrorMarker(editor, 1);
            });
        },
        scrollIntoView: "animate",
        readOnly: true
    }, {
        name: "goToPreviousError",
        bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
        exec: function(editor) {
            config.loadModule("./ext/error_marker", function(module) {
                module.showErrorMarker(editor, -1);
            });
        },
        scrollIntoView: "animate",
        readOnly: true
    }, {
        name: "selectall",
        description: "Select all",
        bindKey: bindKey("Ctrl-A", "Command-A"),
        exec: function(editor) { editor.selectAll(); },
        readOnly: true
    }, {
        name: "centerselection",
        description: "Center selection",
        bindKey: bindKey(null, "Ctrl-L"),
        exec: function(editor) { editor.centerSelection(); },
        readOnly: true
    }, {
        name: "gotoline",
        description: "Go to line...",
        bindKey: bindKey("Ctrl-L", "Command-L"),
        exec: function(editor, line) {
            if (typeof line === "number" && !isNaN(line))
                editor.gotoLine(line);
            editor.prompt({ $type: "gotoLine" });
        },
        readOnly: true
    }, {
        name: "fold",
        bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
        exec: function(editor) { editor.session.toggleFold(false); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "unfold",
        bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
        exec: function(editor) { editor.session.toggleFold(true); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "toggleFoldWidget",
        bindKey: bindKey("F2", "F2"),
        exec: function(editor) { editor.session.toggleFoldWidget(); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "toggleParentFoldWidget",
        bindKey: bindKey("Alt-F2", "Alt-F2"),
        exec: function(editor) { editor.session.toggleFoldWidget(true); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "foldall",
        description: "Fold all",
        bindKey: bindKey(null, "Ctrl-Command-Option-0"),
        exec: function(editor) { editor.session.foldAll(); },
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "foldAllComments",
        description: "Fold all comments",
        bindKey: bindKey(null, "Ctrl-Command-Option-0"),
        exec: function(editor) { editor.session.foldAllComments(); },
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "foldOther",
        description: "Fold other",
        bindKey: bindKey("Alt-0", "Command-Option-0"),
        exec: function(editor) { 
            editor.session.foldAll();
            editor.session.unfold(editor.selection.getAllRanges());
        },
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "unfoldall",
        description: "Unfold all",
        bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
        exec: function(editor) { editor.session.unfold(); },
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "findnext",
        description: "Find next",
        bindKey: bindKey("Ctrl-K", "Command-G"),
        exec: function(editor) { editor.findNext(); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "findprevious",
        description: "Find previous",
        bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
        exec: function(editor) { editor.findPrevious(); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "selectOrFindNext",
        description: "Select or find next",
        bindKey: bindKey("Alt-K", "Ctrl-G"),
        exec: function(editor) {
            if (editor.selection.isEmpty())
                editor.selection.selectWord();
            else
                editor.findNext(); 
        },
        readOnly: true
    }, {
        name: "selectOrFindPrevious",
        description: "Select or find previous",
        bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
        exec: function(editor) { 
            if (editor.selection.isEmpty())
                editor.selection.selectWord();
            else
                editor.findPrevious();
        },
        readOnly: true
    }, {
        name: "find",
        description: "Find",
        bindKey: bindKey("Ctrl-F", "Command-F"),
        exec: function(editor) {
            config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor);});
        },
        readOnly: true
    }, {
        name: "overwrite",
        description: "Overwrite",
        bindKey: "Insert",
        exec: function(editor) { editor.toggleOverwrite(); },
        readOnly: true
    }, {
        name: "selecttostart",
        description: "Select to start",
        bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
        exec: function(editor) { editor.getSelection().selectFileStart(); },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
    }, {
        name: "gotostart",
        description: "Go to start",
        bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
        exec: function(editor) { editor.navigateFileStart(); },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
    }, {
        name: "selectup",
        description: "Select up",
        bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
        exec: function(editor) { editor.getSelection().selectUp(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "golineup",
        description: "Go line up",
        bindKey: bindKey("Up", "Up|Ctrl-P"),
        exec: function(editor, args) { editor.navigateUp(args.times); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selecttoend",
        description: "Select to end",
        bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
        exec: function(editor) { editor.getSelection().selectFileEnd(); },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
    }, {
        name: "gotoend",
        description: "Go to end",
        bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
        exec: function(editor) { editor.navigateFileEnd(); },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
    }, {
        name: "selectdown",
        description: "Select down",
        bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
        exec: function(editor) { editor.getSelection().selectDown(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "golinedown",
        description: "Go line down",
        bindKey: bindKey("Down", "Down|Ctrl-N"),
        exec: function(editor, args) { editor.navigateDown(args.times); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectwordleft",
        description: "Select word left",
        bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
        exec: function(editor) { editor.getSelection().selectWordLeft(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotowordleft",
        description: "Go to word left",
        bindKey: bindKey("Ctrl-Left", "Option-Left"),
        exec: function(editor) { editor.navigateWordLeft(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selecttolinestart",
        description: "Select to line start",
        bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
        exec: function(editor) { editor.getSelection().selectLineStart(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotolinestart",
        description: "Go to line start",
        bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
        exec: function(editor) { editor.navigateLineStart(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectleft",
        description: "Select left",
        bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
        exec: function(editor) { editor.getSelection().selectLeft(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotoleft",
        description: "Go to left",
        bindKey: bindKey("Left", "Left|Ctrl-B"),
        exec: function(editor, args) { editor.navigateLeft(args.times); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectwordright",
        description: "Select word right",
        bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
        exec: function(editor) { editor.getSelection().selectWordRight(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotowordright",
        description: "Go to word right",
        bindKey: bindKey("Ctrl-Right", "Option-Right"),
        exec: function(editor) { editor.navigateWordRight(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selecttolineend",
        description: "Select to line end",
        bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
        exec: function(editor) { editor.getSelection().selectLineEnd(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotolineend",
        description: "Go to line end",
        bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
        exec: function(editor) { editor.navigateLineEnd(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectright",
        description: "Select right",
        bindKey: bindKey("Shift-Right", "Shift-Right"),
        exec: function(editor) { editor.getSelection().selectRight(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotoright",
        description: "Go to right",
        bindKey: bindKey("Right", "Right|Ctrl-F"),
        exec: function(editor, args) { editor.navigateRight(args.times); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectpagedown",
        description: "Select page down",
        bindKey: "Shift-PageDown",
        exec: function(editor) { editor.selectPageDown(); },
        readOnly: true
    }, {
        name: "pagedown",
        description: "Page down",
        bindKey: bindKey(null, "Option-PageDown"),
        exec: function(editor) { editor.scrollPageDown(); },
        readOnly: true
    }, {
        name: "gotopagedown",
        description: "Go to page down",
        bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
        exec: function(editor) { editor.gotoPageDown(); },
        readOnly: true
    }, {
        name: "selectpageup",
        description: "Select page up",
        bindKey: "Shift-PageUp",
        exec: function(editor) { editor.selectPageUp(); },
        readOnly: true
    }, {
        name: "pageup",
        description: "Page up",
        bindKey: bindKey(null, "Option-PageUp"),
        exec: function(editor) { editor.scrollPageUp(); },
        readOnly: true
    }, {
        name: "gotopageup",
        description: "Go to page up",
        bindKey: "PageUp",
        exec: function(editor) { editor.gotoPageUp(); },
        readOnly: true
    }, {
        name: "scrollup",
        description: "Scroll up",
        bindKey: bindKey("Ctrl-Up", null),
        exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
        readOnly: true
    }, {
        name: "scrolldown",
        description: "Scroll down",
        bindKey: bindKey("Ctrl-Down", null),
        exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
        readOnly: true
    }, {
        name: "selectlinestart",
        description: "Select line start",
        bindKey: "Shift-Home",
        exec: function(editor) { editor.getSelection().selectLineStart(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectlineend",
        description: "Select line end",
        bindKey: "Shift-End",
        exec: function(editor) { editor.getSelection().selectLineEnd(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "togglerecording",
        description: "Toggle recording",
        bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
        exec: function(editor) { editor.commands.toggleRecording(editor); },
        readOnly: true
    }, {
        name: "replaymacro",
        description: "Replay macro",
        bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
        exec: function(editor) { editor.commands.replay(editor); },
        readOnly: true
    }, {
        name: "jumptomatching",
        description: "Jump to matching",
        bindKey: bindKey("Ctrl-\\|Ctrl-P", "Command-\\"),
        exec: function(editor) { editor.jumpToMatching(); },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
    }, {
        name: "selecttomatching",
        description: "Select to matching",
        bindKey: bindKey("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
        exec: function(editor) { editor.jumpToMatching(true); },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
    }, {
        name: "expandToMatching",
        description: "Expand to matching",
        bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
        exec: function(editor) { editor.jumpToMatching(true, true); },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
    }, {
        name: "passKeysToBrowser",
        description: "Pass keys to browser",
        bindKey: bindKey(null, null),
        exec: function() {},
        passEvent: true,
        readOnly: true
    }, {
        name: "copy",
        description: "Copy",
        exec: function(editor) {
        },
        readOnly: true
    },
    {
        name: "cut",
        description: "Cut",
        exec: function(editor) {
            var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();
            var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();
            editor._emit("cut", range);

            if (!range.isEmpty())
                editor.session.remove(range);
            editor.clearSelection();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
    }, {
        name: "paste",
        description: "Paste",
        exec: function(editor, args) {
            editor.$handlePaste(args);
        },
        scrollIntoView: "cursor"
    }, {
        name: "removeline",
        description: "Remove line",
        bindKey: bindKey("Ctrl-D", "Command-D"),
        exec: function(editor) { editor.removeLines(); },
        scrollIntoView: "cursor",
        multiSelectAction: "forEachLine"
    }, {
        name: "duplicateSelection",
        description: "Duplicate selection",
        bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
        exec: function(editor) { editor.duplicateSelection(); },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
    }, {
        name: "sortlines",
        description: "Sort lines",
        bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
        exec: function(editor) { editor.sortLines(); },
        scrollIntoView: "selection",
        multiSelectAction: "forEachLine"
    }, {
        name: "togglecomment",
        description: "Toggle comment",
        bindKey: bindKey("Ctrl-/", "Command-/"),
        exec: function(editor) { editor.toggleCommentLines(); },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
    }, {
        name: "toggleBlockComment",
        description: "Toggle block comment",
        bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
        exec: function(editor) { editor.toggleBlockComment(); },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
    }, {
        name: "modifyNumberUp",
        description: "Modify number up",
        bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
        exec: function(editor) { editor.modifyNumber(1); },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
    }, {
        name: "modifyNumberDown",
        description: "Modify number down",
        bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
        exec: function(editor) { editor.modifyNumber(-1); },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
    }, {
        name: "replace",
        description: "Replace",
        bindKey: bindKey("Ctrl-H", "Command-Option-F"),
        exec: function(editor) {
            config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor, true);});
        }
    }, {
        name: "undo",
        description: "Undo",
        bindKey: bindKey("Ctrl-Z", "Command-Z"),
        exec: function(editor) { editor.undo(); }
    }, {
        name: "redo",
        description: "Redo",
        bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
        exec: function(editor) { editor.redo(); }
    }, {
        name: "copylinesup",
        description: "Copy lines up",
        bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
        exec: function(editor) { editor.copyLinesUp(); },
        scrollIntoView: "cursor"
    }, {
        name: "movelinesup",
        description: "Move lines up",
        bindKey: bindKey("Alt-Up", "Option-Up"),
        exec: function(editor) { editor.moveLinesUp(); },
        scrollIntoView: "cursor"
    }, {
        name: "copylinesdown",
        description: "Copy lines down",
        bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
        exec: function(editor) { editor.copyLinesDown(); },
        scrollIntoView: "cursor"
    }, {
        name: "movelinesdown",
        description: "Move lines down",
        bindKey: bindKey("Alt-Down", "Option-Down"),
        exec: function(editor) { editor.moveLinesDown(); },
        scrollIntoView: "cursor"
    }, {
        name: "del",
        description: "Delete",
        bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
        exec: function(editor) { editor.remove("right"); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "backspace",
        description: "Backspace",
        bindKey: bindKey(
            "Shift-Backspace|Backspace",
            "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"
        ),
        exec: function(editor) { editor.remove("left"); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "cut_or_delete",
        description: "Cut or delete",
        bindKey: bindKey("Shift-Delete", null),
        exec: function(editor) { 
            if (editor.selection.isEmpty()) {
                editor.remove("left");
            } else {
                return false;
            }
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removetolinestart",
        description: "Remove to line start",
        bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
        exec: function(editor) { editor.removeToLineStart(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removetolineend",
        description: "Remove to line end",
        bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
        exec: function(editor) { editor.removeToLineEnd(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removetolinestarthard",
        description: "Remove to line start hard",
        bindKey: bindKey("Ctrl-Shift-Backspace", null),
        exec: function(editor) {
            var range = editor.selection.getRange();
            range.start.column = 0;
            editor.session.remove(range);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removetolineendhard",
        description: "Remove to line end hard",
        bindKey: bindKey("Ctrl-Shift-Delete", null),
        exec: function(editor) {
            var range = editor.selection.getRange();
            range.end.column = Number.MAX_VALUE;
            editor.session.remove(range);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removewordleft",
        description: "Remove word left",
        bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
        exec: function(editor) { editor.removeWordLeft(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removewordright",
        description: "Remove word right",
        bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
        exec: function(editor) { editor.removeWordRight(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "outdent",
        description: "Outdent",
        bindKey: bindKey("Shift-Tab", "Shift-Tab"),
        exec: function(editor) { editor.blockOutdent(); },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
    }, {
        name: "indent",
        description: "Indent",
        bindKey: bindKey("Tab", "Tab"),
        exec: function(editor) { editor.indent(); },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
    }, {
        name: "blockoutdent",
        description: "Block outdent",
        bindKey: bindKey("Ctrl-[", "Ctrl-["),
        exec: function(editor) { editor.blockOutdent(); },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
    }, {
        name: "blockindent",
        description: "Block indent",
        bindKey: bindKey("Ctrl-]", "Ctrl-]"),
        exec: function(editor) { editor.blockIndent(); },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
    }, {
        name: "insertstring",
        description: "Insert string",
        exec: function(editor, str) { editor.insert(str); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "inserttext",
        description: "Insert text",
        exec: function(editor, args) {
            editor.insert(lang.stringRepeat(args.text  || "", args.times || 1));
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "splitline",
        description: "Split line",
        bindKey: bindKey(null, "Ctrl-O"),
        exec: function(editor) { editor.splitLine(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "transposeletters",
        description: "Transpose letters",
        bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
        exec: function(editor) { editor.transposeLetters(); },
        multiSelectAction: function(editor) {editor.transposeSelections(1); },
        scrollIntoView: "cursor"
    }, {
        name: "touppercase",
        description: "To uppercase",
        bindKey: bindKey("Ctrl-U", "Ctrl-U"),
        exec: function(editor) { editor.toUpperCase(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "tolowercase",
        description: "To lowercase",
        bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
        exec: function(editor) { editor.toLowerCase(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "autoindent",
        description: "Auto Indent",
        bindKey: bindKey(null, null),
        exec: function(editor) { editor.autoIndent(); },
        multiSelectAction: "forEachLine",
        scrollIntoView: "animate"
    }, {
        name: "expandtoline",
        description: "Expand to line",
        bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
        exec: function(editor) {
            var range = editor.selection.getRange();

            range.start.column = range.end.column = 0;
            range.end.row++;
            editor.selection.setRange(range, false);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "joinlines",
        description: "Join lines",
        bindKey: bindKey(null, null),
        exec: function(editor) {
            var isBackwards = editor.selection.isBackwards();
            var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
            var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
            var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
            var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
            var selectedCount = selectedText.replace(/\n\s*/, " ").length;
            var insertLine = editor.session.doc.getLine(selectionStart.row);

            for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
                var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
                if (curLine.length !== 0) {
                    curLine = " " + curLine;
                }
                insertLine += curLine;
            }

            if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
                insertLine += editor.session.doc.getNewLineCharacter();
            }

            editor.clearSelection();
            editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);

            if (selectedCount > 0) {
                editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
                editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
            } else {
                firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
                editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
            }
        },
        multiSelectAction: "forEach",
        readOnly: true
    }, {
        name: "invertSelection",
        description: "Invert selection",
        bindKey: bindKey(null, null),
        exec: function(editor) {
            var endRow = editor.session.doc.getLength() - 1;
            var endCol = editor.session.doc.getLine(endRow).length;
            var ranges = editor.selection.rangeList.ranges;
            var newRanges = [];
            if (ranges.length < 1) {
                ranges = [editor.selection.getRange()];
            }

            for (var i = 0; i < ranges.length; i++) {
                if (i == (ranges.length - 1)) {
                    if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                        newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                    }
                }

                if (i === 0) {
                    if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                        newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                    }
                } else {
                    newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));
                }
            }

            editor.exitMultiSelectMode();
            editor.clearSelection();

            for(var i = 0; i < newRanges.length; i++) {
                editor.selection.addRange(newRanges[i], false);
            }
        },
        readOnly: true,
        scrollIntoView: "none"
    }, {
        name: "addLineAfter",
        exec: function(editor) {
            editor.selection.clearSelection();
            editor.navigateLineEnd();
            editor.insert("\n");
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "addLineBefore",
        exec: function(editor) {
            editor.selection.clearSelection();
            var cursor = editor.getCursorPosition();
            editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);
            editor.insert("\n");
            if (cursor.row === 0) editor.navigateUp();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "openCommandPallete",
        description: "Open command pallete",
        bindKey: bindKey("F1", "F1"),
        exec: function(editor) {
            editor.prompt({ $type: "commands" });
        },
        readOnly: true
    }, {
        name: "modeSelect",
        description: "Change language mode...",
        bindKey: bindKey(null, null),
        exec: function(editor) {
            editor.prompt({ $type: "modes" });
        },
        readOnly: true
    }];

    for (var i = 1; i < 9; i++) {
        exports.commands.push({
            name: "foldToLevel" + i,
            description: "Fold To Level " + i,
            level: i,
            exec: function(editor) { editor.session.foldToLevel(this.level); },
            scrollIntoView: "center",
            readOnly: true
        });
    }

    });

    ace.define("ace/editor",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/keyboard/textinput","ace/mouse/mouse_handler","ace/mouse/fold_handler","ace/keyboard/keybinding","ace/edit_session","ace/search","ace/range","ace/lib/event_emitter","ace/commands/command_manager","ace/commands/default_commands","ace/config","ace/token_iterator","ace/clipboard"], function(require, exports, module) {

    require("./lib/fixoldbrowsers");

    var oop = require("./lib/oop");
    var dom = require("./lib/dom");
    var lang = require("./lib/lang");
    var useragent = require("./lib/useragent");
    var TextInput = require("./keyboard/textinput").TextInput;
    var MouseHandler = require("./mouse/mouse_handler").MouseHandler;
    var FoldHandler = require("./mouse/fold_handler").FoldHandler;
    var KeyBinding = require("./keyboard/keybinding").KeyBinding;
    var EditSession = require("./edit_session").EditSession;
    var Search = require("./search").Search;
    var Range = require("./range").Range;
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var CommandManager = require("./commands/command_manager").CommandManager;
    var defaultCommands = require("./commands/default_commands").commands;
    var config = require("./config");
    var TokenIterator = require("./token_iterator").TokenIterator;

    var clipboard = require("./clipboard");
    var Editor = function(renderer, session, options) {
        this.$toDestroy = [];
        var container = renderer.getContainerElement();
        this.container = container;
        this.renderer = renderer;
        this.id = "editor" + (++Editor.$uid);

        this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
        if (typeof document == "object") {
            this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
            this.renderer.textarea = this.textInput.getElement();
            this.$mouseHandler = new MouseHandler(this);
            new FoldHandler(this);
        }

        this.keyBinding = new KeyBinding(this);

        this.$search = new Search().set({
            wrap: true
        });

        this.$historyTracker = this.$historyTracker.bind(this);
        this.commands.on("exec", this.$historyTracker);

        this.$initOperationListeners();
        
        this._$emitInputEvent = lang.delayedCall(function() {
            this._signal("input", {});
            if (this.session && this.session.bgTokenizer)
                this.session.bgTokenizer.scheduleStart();
        }.bind(this));
        
        this.on("change", function(_, _self) {
            _self._$emitInputEvent.schedule(31);
        });

        this.setSession(session || options && options.session || new EditSession(""));
        config.resetOptions(this);
        if (options)
            this.setOptions(options);
        config._signal("editor", this);
    };

    Editor.$uid = 0;

    (function(){

        oop.implement(this, EventEmitter);

        this.$initOperationListeners = function() {
            this.commands.on("exec", this.startOperation.bind(this), true);
            this.commands.on("afterExec", this.endOperation.bind(this), true);

            this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this, true));
            this.on("change", function() {
                if (!this.curOp) {
                    this.startOperation();
                    this.curOp.selectionBefore = this.$lastSel;
                }
                this.curOp.docChanged = true;
            }.bind(this), true);
            
            this.on("changeSelection", function() {
                if (!this.curOp) {
                    this.startOperation();
                    this.curOp.selectionBefore = this.$lastSel;
                }
                this.curOp.selectionChanged = true;
            }.bind(this), true);
        };

        this.curOp = null;
        this.prevOp = {};
        this.startOperation = function(commandEvent) {
            if (this.curOp) {
                if (!commandEvent || this.curOp.command)
                    return;
                this.prevOp = this.curOp;
            }
            if (!commandEvent) {
                this.previousCommand = null;
                commandEvent = {};
            }

            this.$opResetTimer.schedule();
            this.curOp = this.session.curOp = {
                command: commandEvent.command || {},
                args: commandEvent.args,
                scrollTop: this.renderer.scrollTop
            };
            this.curOp.selectionBefore = this.selection.toJSON();
        };

        this.endOperation = function(e) {
            if (this.curOp && this.session) {
                if (e && e.returnValue === false || !this.session)
                    return (this.curOp = null);
                if (e == true && this.curOp.command && this.curOp.command.name == "mouse")
                    return;
                this._signal("beforeEndOperation");
                if (!this.curOp) return;
                var command = this.curOp.command;
                var scrollIntoView = command && command.scrollIntoView;
                if (scrollIntoView) {
                    switch (scrollIntoView) {
                        case "center-animate":
                            scrollIntoView = "animate";
                        case "center":
                            this.renderer.scrollCursorIntoView(null, 0.5);
                            break;
                        case "animate":
                        case "cursor":
                            this.renderer.scrollCursorIntoView();
                            break;
                        case "selectionPart":
                            var range = this.selection.getRange();
                            var config = this.renderer.layerConfig;
                            if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                                this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                            }
                            break;
                    }
                    if (scrollIntoView == "animate")
                        this.renderer.animateScrolling(this.curOp.scrollTop);
                }
                var sel = this.selection.toJSON();
                this.curOp.selectionAfter = sel;
                this.$lastSel = this.selection.toJSON();
                this.session.getUndoManager().addSelection(sel);
                this.prevOp = this.curOp;
                this.curOp = null;
            }
        };
        this.$mergeableCommands = ["backspace", "del", "insertstring"];
        this.$historyTracker = function(e) {
            if (!this.$mergeUndoDeltas)
                return;

            var prev = this.prevOp;
            var mergeableCommands = this.$mergeableCommands;
            var shouldMerge = prev.command && (e.command.name == prev.command.name);
            if (e.command.name == "insertstring") {
                var text = e.args;
                if (this.mergeNextCommand === undefined)
                    this.mergeNextCommand = true;

                shouldMerge = shouldMerge
                    && this.mergeNextCommand // previous command allows to coalesce with
                    && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

                this.mergeNextCommand = true;
            } else {
                shouldMerge = shouldMerge
                    && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
            }

            if (
                this.$mergeUndoDeltas != "always"
                && Date.now() - this.sequenceStartTime > 2000
            ) {
                shouldMerge = false; // the sequence is too long
            }

            if (shouldMerge)
                this.session.mergeUndoDeltas = true;
            else if (mergeableCommands.indexOf(e.command.name) !== -1)
                this.sequenceStartTime = Date.now();
        };
        this.setKeyboardHandler = function(keyboardHandler, cb) {
            if (keyboardHandler && typeof keyboardHandler === "string" && keyboardHandler != "ace") {
                this.$keybindingId = keyboardHandler;
                var _self = this;
                config.loadModule(["keybinding", keyboardHandler], function(module) {
                    if (_self.$keybindingId == keyboardHandler)
                        _self.keyBinding.setKeyboardHandler(module && module.handler);
                    cb && cb();
                });
            } else {
                this.$keybindingId = null;
                this.keyBinding.setKeyboardHandler(keyboardHandler);
                cb && cb();
            }
        };
        this.getKeyboardHandler = function() {
            return this.keyBinding.getKeyboardHandler();
        };
        this.setSession = function(session) {
            if (this.session == session)
                return;
            if (this.curOp) this.endOperation();
            this.curOp = {};

            var oldSession = this.session;
            if (oldSession) {
                this.session.off("change", this.$onDocumentChange);
                this.session.off("changeMode", this.$onChangeMode);
                this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
                this.session.off("changeTabSize", this.$onChangeTabSize);
                this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
                this.session.off("changeWrapMode", this.$onChangeWrapMode);
                this.session.off("changeFold", this.$onChangeFold);
                this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
                this.session.off("changeBackMarker", this.$onChangeBackMarker);
                this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
                this.session.off("changeAnnotation", this.$onChangeAnnotation);
                this.session.off("changeOverwrite", this.$onCursorChange);
                this.session.off("changeScrollTop", this.$onScrollTopChange);
                this.session.off("changeScrollLeft", this.$onScrollLeftChange);

                var selection = this.session.getSelection();
                selection.off("changeCursor", this.$onCursorChange);
                selection.off("changeSelection", this.$onSelectionChange);
            }

            this.session = session;
            if (session) {
                this.$onDocumentChange = this.onDocumentChange.bind(this);
                session.on("change", this.$onDocumentChange);
                this.renderer.setSession(session);
        
                this.$onChangeMode = this.onChangeMode.bind(this);
                session.on("changeMode", this.$onChangeMode);
        
                this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
                session.on("tokenizerUpdate", this.$onTokenizerUpdate);
        
                this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
                session.on("changeTabSize", this.$onChangeTabSize);
        
                this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
                session.on("changeWrapLimit", this.$onChangeWrapLimit);
        
                this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
                session.on("changeWrapMode", this.$onChangeWrapMode);
        
                this.$onChangeFold = this.onChangeFold.bind(this);
                session.on("changeFold", this.$onChangeFold);
        
                this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
                this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
        
                this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
                this.session.on("changeBackMarker", this.$onChangeBackMarker);
        
                this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
                this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
        
                this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
                this.session.on("changeAnnotation", this.$onChangeAnnotation);
        
                this.$onCursorChange = this.onCursorChange.bind(this);
                this.session.on("changeOverwrite", this.$onCursorChange);
        
                this.$onScrollTopChange = this.onScrollTopChange.bind(this);
                this.session.on("changeScrollTop", this.$onScrollTopChange);
        
                this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
                this.session.on("changeScrollLeft", this.$onScrollLeftChange);
        
                this.selection = session.getSelection();
                this.selection.on("changeCursor", this.$onCursorChange);
        
                this.$onSelectionChange = this.onSelectionChange.bind(this);
                this.selection.on("changeSelection", this.$onSelectionChange);
        
                this.onChangeMode();
        
                this.onCursorChange();
        
                this.onScrollTopChange();
                this.onScrollLeftChange();
                this.onSelectionChange();
                this.onChangeFrontMarker();
                this.onChangeBackMarker();
                this.onChangeBreakpoint();
                this.onChangeAnnotation();
                this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
                this.renderer.updateFull();
            } else {
                this.selection = null;
                this.renderer.setSession(session);
            }

            this._signal("changeSession", {
                session: session,
                oldSession: oldSession
            });
            
            this.curOp = null;
            
            oldSession && oldSession._signal("changeEditor", {oldEditor: this});
            session && session._signal("changeEditor", {editor: this});
            
            if (session && session.bgTokenizer)
                session.bgTokenizer.scheduleStart();
        };
        this.getSession = function() {
            return this.session;
        };
        this.setValue = function(val, cursorPos) {
            this.session.doc.setValue(val);

            if (!cursorPos)
                this.selectAll();
            else if (cursorPos == 1)
                this.navigateFileEnd();
            else if (cursorPos == -1)
                this.navigateFileStart();

            return val;
        };
        this.getValue = function() {
            return this.session.getValue();
        };
        this.getSelection = function() {
            return this.selection;
        };
        this.resize = function(force) {
            this.renderer.onResize(force);
        };
        this.setTheme = function(theme, cb) {
            this.renderer.setTheme(theme, cb);
        };
        this.getTheme = function() {
            return this.renderer.getTheme();
        };
        this.setStyle = function(style) {
            this.renderer.setStyle(style);
        };
        this.unsetStyle = function(style) {
            this.renderer.unsetStyle(style);
        };
        this.getFontSize = function () {
            return this.getOption("fontSize") ||
               dom.computedStyle(this.container).fontSize;
        };
        this.setFontSize = function(size) {
            this.setOption("fontSize", size);
        };

        this.$highlightBrackets = function() {
            if (this.$highlightPending) {
                return;
            }
            var self = this;
            this.$highlightPending = true;
            setTimeout(function () {
                self.$highlightPending = false;
                var session = self.session;
                if (!session || !session.bgTokenizer) return;
                if (session.$bracketHighlight) {
                    session.$bracketHighlight.markerIds.forEach(function(id) {
                        session.removeMarker(id);
                    });
                    session.$bracketHighlight = null;
                }
                var ranges = session.getMatchingBracketRanges(self.getCursorPosition());
                if (!ranges && session.$mode.getMatching) 
                    ranges = session.$mode.getMatching(self.session);
                if (!ranges)
                    return;

                var markerType = "ace_bracket";
                if (!Array.isArray(ranges)) {
                    ranges = [ranges];
                } else if (ranges.length == 1) {
                    markerType = "ace_error_bracket";
                }
                if (ranges.length == 2) {
                    if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0)
                        ranges = [Range.fromPoints(ranges[0].start, ranges[1].end)];
                    else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0)
                        ranges = [Range.fromPoints(ranges[1].start, ranges[0].end)];
                }

                session.$bracketHighlight = {
                    ranges: ranges,
                    markerIds: ranges.map(function(range) {
                        return session.addMarker(range, markerType, "text");
                    })
                };
            }, 50);
        };
        this.$highlightTags = function() {
            if (this.$highlightTagPending)
                return;
            var self = this;
            this.$highlightTagPending = true;
            setTimeout(function() {
                self.$highlightTagPending = false;
                
                var session = self.session;
                if (!session || !session.bgTokenizer) return;
                
                var pos = self.getCursorPosition();
                var iterator = new TokenIterator(self.session, pos.row, pos.column);
                var token = iterator.getCurrentToken();
                
                if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
                    session.removeMarker(session.$tagHighlight);
                    session.$tagHighlight = null;
                    return;
                }
                
                if (token.type.indexOf("tag-open") !== -1) {
                    token = iterator.stepForward();
                    if (!token)
                        return;
                }
                
                var tag = token.value;
                var currentTag = token.value;
                var depth = 0;
                var prevToken = iterator.stepBackward();
                
                if (prevToken.value === '<'){
                    do {
                        prevToken = token;
                        token = iterator.stepForward();

                        if (token) {
                            if (token.type.indexOf('tag-name') !== -1) {
                                currentTag = token.value;
                                if (tag === currentTag) {
                                    if (prevToken.value === '<') {
                                        depth++;
                                    } else if (prevToken.value === '</') {
                                        depth--;
                                    }
                                }
                            } else if (tag === currentTag && token.value === '/>') { // self closing tag
                                depth--;
                            }
                        }
                        
                    } while (token && depth >= 0);
                } else {
                    do {
                        token = prevToken;
                        prevToken = iterator.stepBackward();

                        if (token) {
                            if (token.type.indexOf('tag-name') !== -1) {
                                if (tag === token.value) {
                                    if (prevToken.value === '<') {
                                        depth++;
                                    } else if (prevToken.value === '</') {
                                        depth--;
                                    }
                                }
                            } else if (token.value === '/>') { // self closing tag
                                var stepCount = 0;
                                var tmpToken = prevToken;
                                while (tmpToken) {
                                    if (tmpToken.type.indexOf('tag-name') !== -1 && tmpToken.value === tag) {
                                        depth--;
                                        break;
                                    } else if (tmpToken.value === '<') {
                                        break;
                                    }
                                    tmpToken = iterator.stepBackward();
                                    stepCount++;
                                }
                                for (var i = 0; i < stepCount; i++) {
                                    iterator.stepForward();
                                }
                            }
                        }
                    } while (prevToken && depth <= 0);
                    iterator.stepForward();
                }
                
                if (!token) {
                    session.removeMarker(session.$tagHighlight);
                    session.$tagHighlight = null;
                    return;
                }
                
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn();
                var range = new Range(row, column, row, column+token.value.length);
                var sbm = session.$backMarkers[session.$tagHighlight];
                if (session.$tagHighlight && sbm != undefined && range.compareRange(sbm.range) !== 0) {
                    session.removeMarker(session.$tagHighlight);
                    session.$tagHighlight = null;
                }
                
                if (!session.$tagHighlight)
                    session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
            }, 50);
        };
        this.focus = function() {
            var _self = this;
            setTimeout(function() {
                if (!_self.isFocused())
                    _self.textInput.focus();
            });
            this.textInput.focus();
        };
        this.isFocused = function() {
            return this.textInput.isFocused();
        };
        this.blur = function() {
            this.textInput.blur();
        };
        this.onFocus = function(e) {
            if (this.$isFocused)
                return;
            this.$isFocused = true;
            this.renderer.showCursor();
            this.renderer.visualizeFocus();
            this._emit("focus", e);
        };
        this.onBlur = function(e) {
            if (!this.$isFocused)
                return;
            this.$isFocused = false;
            this.renderer.hideCursor();
            this.renderer.visualizeBlur();
            this._emit("blur", e);
        };

        this.$cursorChange = function() {
            this.renderer.updateCursor();
            this.$highlightBrackets();
            this.$highlightTags();
            this.$updateHighlightActiveLine();
        };
        this.onDocumentChange = function(delta) {
            var wrap = this.session.$useWrapMode;
            var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);
            this.renderer.updateLines(delta.start.row, lastRow, wrap);

            this._signal("change", delta);
            this.$cursorChange();
        };

        this.onTokenizerUpdate = function(e) {
            var rows = e.data;
            this.renderer.updateLines(rows.first, rows.last);
        };


        this.onScrollTopChange = function() {
            this.renderer.scrollToY(this.session.getScrollTop());
        };

        this.onScrollLeftChange = function() {
            this.renderer.scrollToX(this.session.getScrollLeft());
        };
        this.onCursorChange = function() {
            this.$cursorChange();
            this._signal("changeSelection");
        };

        this.$updateHighlightActiveLine = function() {
            var session = this.getSession();

            var highlight;
            if (this.$highlightActiveLine) {
                if (this.$selectionStyle != "line" || !this.selection.isMultiLine())
                    highlight = this.getCursorPosition();
                if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())
                    highlight = false;
                if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
                    highlight = false;
            }

            if (session.$highlightLineMarker && !highlight) {
                session.removeMarker(session.$highlightLineMarker.id);
                session.$highlightLineMarker = null;
            } else if (!session.$highlightLineMarker && highlight) {
                var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
                range.id = session.addMarker(range, "ace_active-line", "screenLine");
                session.$highlightLineMarker = range;
            } else if (highlight) {
                session.$highlightLineMarker.start.row = highlight.row;
                session.$highlightLineMarker.end.row = highlight.row;
                session.$highlightLineMarker.start.column = highlight.column;
                session._signal("changeBackMarker");
            }
        };

        this.onSelectionChange = function(e) {
            var session = this.session;

            if (session.$selectionMarker) {
                session.removeMarker(session.$selectionMarker);
            }
            session.$selectionMarker = null;

            if (!this.selection.isEmpty()) {
                var range = this.selection.getRange();
                var style = this.getSelectionStyle();
                session.$selectionMarker = session.addMarker(range, "ace_selection", style);
            } else {
                this.$updateHighlightActiveLine();
            }

            var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
            this.session.highlight(re);

            this._signal("changeSelection");
        };

        this.$getSelectionHighLightRegexp = function() {
            var session = this.session;

            var selection = this.getSelectionRange();
            if (selection.isEmpty() || selection.isMultiLine())
                return;

            var startColumn = selection.start.column;
            var endColumn = selection.end.column;
            var line = session.getLine(selection.start.row);
            
            var needle = line.substring(startColumn, endColumn);
            if (needle.length > 5000 || !/[\w\d]/.test(needle))
                return;

            var re = this.$search.$assembleRegExp({
                wholeWord: true,
                caseSensitive: true,
                needle: needle
            });
            
            var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
            if (!re.test(wordWithBoundary))
                return;
            
            return re;
        };


        this.onChangeFrontMarker = function() {
            this.renderer.updateFrontMarkers();
        };

        this.onChangeBackMarker = function() {
            this.renderer.updateBackMarkers();
        };


        this.onChangeBreakpoint = function() {
            this.renderer.updateBreakpoints();
        };

        this.onChangeAnnotation = function() {
            this.renderer.setAnnotations(this.session.getAnnotations());
        };


        this.onChangeMode = function(e) {
            this.renderer.updateText();
            this._emit("changeMode", e);
        };


        this.onChangeWrapLimit = function() {
            this.renderer.updateFull();
        };

        this.onChangeWrapMode = function() {
            this.renderer.onResize(true);
        };


        this.onChangeFold = function() {
            this.$updateHighlightActiveLine();
            this.renderer.updateFull();
        };
        this.getSelectedText = function() {
            return this.session.getTextRange(this.getSelectionRange());
        };
        this.getCopyText = function() {
            var text = this.getSelectedText();
            var nl = this.session.doc.getNewLineCharacter();
            var copyLine= false;
            if (!text && this.$copyWithEmptySelection) {
                copyLine = true;
                var ranges = this.selection.getAllRanges();
                for (var i = 0; i < ranges.length; i++) {
                    var range = ranges[i];
                    if (i && ranges[i - 1].start.row == range.start.row)
                        continue;
                    text += this.session.getLine(range.start.row) + nl;
                }
            }
            var e = {text: text};
            this._signal("copy", e);
            clipboard.lineMode = copyLine ? e.text : "";
            return e.text;
        };
        this.onCopy = function() {
            this.commands.exec("copy", this);
        };
        this.onCut = function() {
            this.commands.exec("cut", this);
        };
        this.onPaste = function(text, event) {
            var e = {text: text, event: event};
            this.commands.exec("paste", this, e);
        };
        
        this.$handlePaste = function(e) {
            if (typeof e == "string") 
                e = {text: e};
            this._signal("paste", e);
            var text = e.text;

            var lineMode = text == clipboard.lineMode;
            var session = this.session;
            if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
                if (lineMode)
                    session.insert({ row: this.selection.lead.row, column: 0 }, text);
                else
                    this.insert(text);
            } else if (lineMode) {
                this.selection.rangeList.ranges.forEach(function(range) {
                    session.insert({ row: range.start.row, column: 0 }, text);
                });
            } else {
                var lines = text.split(/\r\n|\r|\n/);
                var ranges = this.selection.rangeList.ranges;
        
                var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);
                if (lines.length != ranges.length || isFullLine)
                    return this.commands.exec("insertstring", this, text);
        
                for (var i = ranges.length; i--;) {
                    var range = ranges[i];
                    if (!range.isEmpty())
                        session.remove(range);
        
                    session.insert(range.start, lines[i]);
                }
            }
        };

        this.execCommand = function(command, args) {
            return this.commands.exec(command, this, args);
        };
        this.insert = function(text, pasted) {
            var session = this.session;
            var mode = session.getMode();
            var cursor = this.getCursorPosition();

            if (this.getBehavioursEnabled() && !pasted) {
                var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
                if (transform) {
                    if (text !== transform.text) {
                        if (!this.inVirtualSelectionMode) {
                            this.session.mergeUndoDeltas = false;
                            this.mergeNextCommand = false;
                        }
                    }
                    text = transform.text;

                }
            }
            
            if (text == "\t")
                text = this.session.getTabString();
            if (!this.selection.isEmpty()) {
                var range = this.getSelectionRange();
                cursor = this.session.remove(range);
                this.clearSelection();
            }
            else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
                var range = new Range.fromPoints(cursor, cursor);
                range.end.column += text.length;
                this.session.remove(range);
            }

            if (text == "\n" || text == "\r\n") {
                var line = session.getLine(cursor.row);
                if (cursor.column > line.search(/\S|$/)) {
                    var d = line.substr(cursor.column).search(/\S|$/);
                    session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
                }
            }
            this.clearSelection();

            var start = cursor.column;
            var lineState = session.getState(cursor.row);
            var line = session.getLine(cursor.row);
            var shouldOutdent = mode.checkOutdent(lineState, line, text);
            session.insert(cursor, text);

            if (transform && transform.selection) {
                if (transform.selection.length == 2) { // Transform relative to the current column
                    this.selection.setSelectionRange(
                        new Range(cursor.row, start + transform.selection[0],
                                  cursor.row, start + transform.selection[1]));
                } else { // Transform relative to the current row.
                    this.selection.setSelectionRange(
                        new Range(cursor.row + transform.selection[0],
                                  transform.selection[1],
                                  cursor.row + transform.selection[2],
                                  transform.selection[3]));
                }
            }
            if (this.$enableAutoIndent) {
                if (session.getDocument().isNewLine(text)) {
                    var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

                    session.insert({row: cursor.row+1, column: 0}, lineIndent);
                }
                if (shouldOutdent)
                    mode.autoOutdent(lineState, session, cursor.row);
            }
        };

        this.autoIndent = function () {
            var session = this.session;
            var mode = session.getMode();

            var startRow, endRow;
            if (this.selection.isEmpty()) {
                startRow = 0;
                endRow = session.doc.getLength() - 1;
            } else {
                var selectedRange = this.getSelectionRange();

                startRow = selectedRange.start.row;
                endRow = selectedRange.end.row;
            }

            var prevLineState = "";
            var prevLine = "";
            var lineIndent = "";
            var line, currIndent, range;
            var tab = session.getTabString();

            for (var row = startRow; row <= endRow; row++) {
                if (row > 0) {
                    prevLineState = session.getState(row - 1);
                    prevLine = session.getLine(row - 1);
                    lineIndent = mode.getNextLineIndent(prevLineState, prevLine, tab);
                }

                line = session.getLine(row);
                currIndent = mode.$getIndent(line);
                if (lineIndent !== currIndent) {
                    if (currIndent.length > 0) {
                        range = new Range(row, 0, row, currIndent.length);
                        session.remove(range);
                    }
                    if (lineIndent.length > 0) {
                        session.insert({row: row, column: 0}, lineIndent);
                    }
                }

                mode.autoOutdent(prevLineState, session, row);
            }
        };


        this.onTextInput = function(text, composition) {
            if (!composition)
                return this.keyBinding.onTextInput(text);
            
            this.startOperation({command: { name: "insertstring" }});
            var applyComposition = this.applyComposition.bind(this, text, composition);
            if (this.selection.rangeCount)
                this.forEachSelection(applyComposition);
            else
                applyComposition();
            this.endOperation();
        };
        
        this.applyComposition = function(text, composition) {
            if (composition.extendLeft || composition.extendRight) {
                var r = this.selection.getRange();
                r.start.column -= composition.extendLeft;
                r.end.column += composition.extendRight;
                if (r.start.column < 0) {
                    r.start.row--;
                    r.start.column += this.session.getLine(r.start.row).length + 1;
                }
                this.selection.setRange(r);
                if (!text && !r.isEmpty())
                    this.remove();
            }
            if (text || !this.selection.isEmpty())
                this.insert(text, true);
            if (composition.restoreStart || composition.restoreEnd) {
                var r = this.selection.getRange();
                r.start.column -= composition.restoreStart;
                r.end.column -= composition.restoreEnd;
                this.selection.setRange(r);
            }
        };

        this.onCommandKey = function(e, hashId, keyCode) {
            return this.keyBinding.onCommandKey(e, hashId, keyCode);
        };
        this.setOverwrite = function(overwrite) {
            this.session.setOverwrite(overwrite);
        };
        this.getOverwrite = function() {
            return this.session.getOverwrite();
        };
        this.toggleOverwrite = function() {
            this.session.toggleOverwrite();
        };
        this.setScrollSpeed = function(speed) {
            this.setOption("scrollSpeed", speed);
        };
        this.getScrollSpeed = function() {
            return this.getOption("scrollSpeed");
        };
        this.setDragDelay = function(dragDelay) {
            this.setOption("dragDelay", dragDelay);
        };
        this.getDragDelay = function() {
            return this.getOption("dragDelay");
        };
        this.setSelectionStyle = function(val) {
            this.setOption("selectionStyle", val);
        };
        this.getSelectionStyle = function() {
            return this.getOption("selectionStyle");
        };
        this.setHighlightActiveLine = function(shouldHighlight) {
            this.setOption("highlightActiveLine", shouldHighlight);
        };
        this.getHighlightActiveLine = function() {
            return this.getOption("highlightActiveLine");
        };
        this.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
        };

        this.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
        };
        this.setHighlightSelectedWord = function(shouldHighlight) {
            this.setOption("highlightSelectedWord", shouldHighlight);
        };
        this.getHighlightSelectedWord = function() {
            return this.$highlightSelectedWord;
        };

        this.setAnimatedScroll = function(shouldAnimate){
            this.renderer.setAnimatedScroll(shouldAnimate);
        };

        this.getAnimatedScroll = function(){
            return this.renderer.getAnimatedScroll();
        };
        this.setShowInvisibles = function(showInvisibles) {
            this.renderer.setShowInvisibles(showInvisibles);
        };
        this.getShowInvisibles = function() {
            return this.renderer.getShowInvisibles();
        };

        this.setDisplayIndentGuides = function(display) {
            this.renderer.setDisplayIndentGuides(display);
        };

        this.getDisplayIndentGuides = function() {
            return this.renderer.getDisplayIndentGuides();
        };
        this.setShowPrintMargin = function(showPrintMargin) {
            this.renderer.setShowPrintMargin(showPrintMargin);
        };
        this.getShowPrintMargin = function() {
            return this.renderer.getShowPrintMargin();
        };
        this.setPrintMarginColumn = function(showPrintMargin) {
            this.renderer.setPrintMarginColumn(showPrintMargin);
        };
        this.getPrintMarginColumn = function() {
            return this.renderer.getPrintMarginColumn();
        };
        this.setReadOnly = function(readOnly) {
            this.setOption("readOnly", readOnly);
        };
        this.getReadOnly = function() {
            return this.getOption("readOnly");
        };
        this.setBehavioursEnabled = function (enabled) {
            this.setOption("behavioursEnabled", enabled);
        };
        this.getBehavioursEnabled = function () {
            return this.getOption("behavioursEnabled");
        };
        this.setWrapBehavioursEnabled = function (enabled) {
            this.setOption("wrapBehavioursEnabled", enabled);
        };
        this.getWrapBehavioursEnabled = function () {
            return this.getOption("wrapBehavioursEnabled");
        };
        this.setShowFoldWidgets = function(show) {
            this.setOption("showFoldWidgets", show);

        };
        this.getShowFoldWidgets = function() {
            return this.getOption("showFoldWidgets");
        };

        this.setFadeFoldWidgets = function(fade) {
            this.setOption("fadeFoldWidgets", fade);
        };

        this.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
        };
        this.remove = function(dir) {
            if (this.selection.isEmpty()){
                if (dir == "left")
                    this.selection.selectLeft();
                else
                    this.selection.selectRight();
            }

            var range = this.getSelectionRange();
            if (this.getBehavioursEnabled()) {
                var session = this.session;
                var state = session.getState(range.start.row);
                var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);

                if (range.end.column === 0) {
                    var text = session.getTextRange(range);
                    if (text[text.length - 1] == "\n") {
                        var line = session.getLine(range.end.row);
                        if (/^\s+$/.test(line)) {
                            range.end.column = line.length;
                        }
                    }
                }
                if (new_range)
                    range = new_range;
            }

            this.session.remove(range);
            this.clearSelection();
        };
        this.removeWordRight = function() {
            if (this.selection.isEmpty())
                this.selection.selectWordRight();

            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        };
        this.removeWordLeft = function() {
            if (this.selection.isEmpty())
                this.selection.selectWordLeft();

            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        };
        this.removeToLineStart = function() {
            if (this.selection.isEmpty())
                this.selection.selectLineStart();
            if (this.selection.isEmpty())
                this.selection.selectLeft();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        };
        this.removeToLineEnd = function() {
            if (this.selection.isEmpty())
                this.selection.selectLineEnd();

            var range = this.getSelectionRange();
            if (range.start.column == range.end.column && range.start.row == range.end.row) {
                range.end.column = 0;
                range.end.row++;
            }

            this.session.remove(range);
            this.clearSelection();
        };
        this.splitLine = function() {
            if (!this.selection.isEmpty()) {
                this.session.remove(this.getSelectionRange());
                this.clearSelection();
            }

            var cursor = this.getCursorPosition();
            this.insert("\n");
            this.moveCursorToPosition(cursor);
        };
        this.transposeLetters = function() {
            if (!this.selection.isEmpty()) {
                return;
            }

            var cursor = this.getCursorPosition();
            var column = cursor.column;
            if (column === 0)
                return;

            var line = this.session.getLine(cursor.row);
            var swap, range;
            if (column < line.length) {
                swap = line.charAt(column) + line.charAt(column-1);
                range = new Range(cursor.row, column-1, cursor.row, column+1);
            }
            else {
                swap = line.charAt(column-1) + line.charAt(column-2);
                range = new Range(cursor.row, column-2, cursor.row, column);
            }
            this.session.replace(range, swap);
            this.session.selection.moveToPosition(range.end);
        };
        this.toLowerCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) {
                this.selection.selectWord();
            }

            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toLowerCase());
            this.selection.setSelectionRange(originalRange);
        };
        this.toUpperCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) {
                this.selection.selectWord();
            }

            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toUpperCase());
            this.selection.setSelectionRange(originalRange);
        };
        this.indent = function() {
            var session = this.session;
            var range = this.getSelectionRange();

            if (range.start.row < range.end.row) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "\t");
                return;
            } else if (range.start.column < range.end.column) {
                var text = session.getTextRange(range);
                if (!/^\s+$/.test(text)) {
                    var rows = this.$getSelectedRows();
                    session.indentRows(rows.first, rows.last, "\t");
                    return;
                }
            }
            
            var line = session.getLine(range.start.row);
            var position = range.start;
            var size = session.getTabSize();
            var column = session.documentToScreenColumn(position.row, position.column);

            if (this.session.getUseSoftTabs()) {
                var count = (size - column % size);
                var indentString = lang.stringRepeat(" ", count);
            } else {
                var count = column % size;
                while (line[range.start.column - 1] == " " && count) {
                    range.start.column--;
                    count--;
                }
                this.selection.setSelectionRange(range);
                indentString = "\t";
            }
            return this.insert(indentString);
        };
        this.blockIndent = function() {
            var rows = this.$getSelectedRows();
            this.session.indentRows(rows.first, rows.last, "\t");
        };
        this.blockOutdent = function() {
            var selection = this.session.getSelection();
            this.session.outdentRows(selection.getRange());
        };
        this.sortLines = function() {
            var rows = this.$getSelectedRows();
            var session = this.session;

            var lines = [];
            for (var i = rows.first; i <= rows.last; i++)
                lines.push(session.getLine(i));

            lines.sort(function(a, b) {
                if (a.toLowerCase() < b.toLowerCase()) return -1;
                if (a.toLowerCase() > b.toLowerCase()) return 1;
                return 0;
            });

            var deleteRange = new Range(0, 0, 0, 0);
            for (var i = rows.first; i <= rows.last; i++) {
                var line = session.getLine(i);
                deleteRange.start.row = i;
                deleteRange.end.row = i;
                deleteRange.end.column = line.length;
                session.replace(deleteRange, lines[i-rows.first]);
            }
        };
        this.toggleCommentLines = function() {
            var state = this.session.getState(this.getCursorPosition().row);
            var rows = this.$getSelectedRows();
            this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
        };

        this.toggleBlockComment = function() {
            var cursor = this.getCursorPosition();
            var state = this.session.getState(cursor.row);
            var range = this.getSelectionRange();
            this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
        };
        this.getNumberAt = function(row, column) {
            var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
            _numberRx.lastIndex = 0;

            var s = this.session.getLine(row);
            while (_numberRx.lastIndex < column) {
                var m = _numberRx.exec(s);
                if(m.index <= column && m.index+m[0].length >= column){
                    var number = {
                        value: m[0],
                        start: m.index,
                        end: m.index+m[0].length
                    };
                    return number;
                }
            }
            return null;
        };
        this.modifyNumber = function(amount) {
            var row = this.selection.getCursor().row;
            var column = this.selection.getCursor().column;
            var charRange = new Range(row, column-1, row, column);

            var c = this.session.getTextRange(charRange);
            if (!isNaN(parseFloat(c)) && isFinite(c)) {
                var nr = this.getNumberAt(row, column);
                if (nr) {
                    var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                    var decimals = nr.start + nr.value.length - fp;

                    var t = parseFloat(nr.value);
                    t *= Math.pow(10, decimals);


                    if(fp !== nr.end && column < fp){
                        amount *= Math.pow(10, nr.end - column - 1);
                    } else {
                        amount *= Math.pow(10, nr.end - column);
                    }

                    t += amount;
                    t /= Math.pow(10, decimals);
                    var nnr = t.toFixed(decimals);
                    var replaceRange = new Range(row, nr.start, row, nr.end);
                    this.session.replace(replaceRange, nnr);
                    this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));

                }
            } else {
                this.toggleWord();
            }
        };

        this.$toggleWordPairs = [
            ["first", "last"],
            ["true", "false"],
            ["yes", "no"],
            ["width", "height"],
            ["top", "bottom"],
            ["right", "left"],
            ["on", "off"],
            ["x", "y"],
            ["get", "set"],
            ["max", "min"],
            ["horizontal", "vertical"],
            ["show", "hide"],
            ["add", "remove"],
            ["up", "down"],
            ["before", "after"],
            ["even", "odd"],
            ["in", "out"],
            ["inside", "outside"],
            ["next", "previous"],
            ["increase", "decrease"],
            ["attach", "detach"],
            ["&&", "||"],
            ["==", "!="]
        ];

        this.toggleWord = function () {
            var row = this.selection.getCursor().row;
            var column = this.selection.getCursor().column;
            this.selection.selectWord();
            var currentState = this.getSelectedText();
            var currWordStart = this.selection.getWordRange().start.column;
            var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, '$1 ').split(/\s/);
            var delta = column - currWordStart - 1;
            if (delta < 0) delta = 0;
            var curLength = 0, itLength = 0;
            var that = this;
            if (currentState.match(/[A-Za-z0-9_]+/)) {
                wordParts.forEach(function (item, i) {
                    itLength = curLength + item.length;
                    if (delta >= curLength && delta <= itLength) {
                        currentState = item;
                        that.selection.clearSelection();
                        that.moveCursorTo(row, curLength + currWordStart);
                        that.selection.selectTo(row, itLength + currWordStart);
                    }
                    curLength = itLength;
                });
            }

            var wordPairs = this.$toggleWordPairs;
            var reg;
            for (var i = 0; i < wordPairs.length; i++) {
                var item = wordPairs[i];
                for (var j = 0; j <= 1; j++) {
                    var negate = +!j;
                    var firstCondition = currentState.match(new RegExp('^\\s?_?(' + lang.escapeRegExp(item[j]) + ')\\s?$', 'i'));
                    if (firstCondition) {
                        var secondCondition = currentState.match(new RegExp('([_]|^|\\s)(' + lang.escapeRegExp(firstCondition[1]) + ')($|\\s)', 'g'));
                        if (secondCondition) {
                            reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), 'i'), function (result) {
                                var res = item[negate];
                                if (result.toUpperCase() == result) {
                                    res = res.toUpperCase();
                                } else if (result.charAt(0).toUpperCase() == result.charAt(0)) {
                                    res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);
                                }
                                return res;
                            });
                            this.insert(reg);
                            reg = "";
                        }
                    }
                }
            }
        };
        this.removeLines = function() {
            var rows = this.$getSelectedRows();
            this.session.removeFullLines(rows.first, rows.last);
            this.clearSelection();
        };

        this.duplicateSelection = function() {
            var sel = this.selection;
            var doc = this.session;
            var range = sel.getRange();
            var reverse = sel.isBackwards();
            if (range.isEmpty()) {
                var row = range.start.row;
                doc.duplicateLines(row, row);
            } else {
                var point = reverse ? range.start : range.end;
                var endPoint = doc.insert(point, doc.getTextRange(range), false);
                range.start = point;
                range.end = endPoint;

                sel.setSelectionRange(range, reverse);
            }
        };
        this.moveLinesDown = function() {
            this.$moveLines(1, false);
        };
        this.moveLinesUp = function() {
            this.$moveLines(-1, false);
        };
        this.moveText = function(range, toPosition, copy) {
            return this.session.moveText(range, toPosition, copy);
        };
        this.copyLinesUp = function() {
            this.$moveLines(-1, true);
        };
        this.copyLinesDown = function() {
            this.$moveLines(1, true);
        };
        this.$moveLines = function(dir, copy) {
            var rows, moved;
            var selection = this.selection;
            if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
                var range = selection.toOrientedRange();
                rows = this.$getSelectedRows(range);
                moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
                if (copy && dir == -1) moved = 0;
                range.moveBy(moved, 0);
                selection.fromOrientedRange(range);
            } else {
                var ranges = selection.rangeList.ranges;
                selection.rangeList.detach(this.session);
                this.inVirtualSelectionMode = true;
                
                var diff = 0;
                var totalDiff = 0;
                var l = ranges.length;
                for (var i = 0; i < l; i++) {
                    var rangeIndex = i;
                    ranges[i].moveBy(diff, 0);
                    rows = this.$getSelectedRows(ranges[i]);
                    var first = rows.first;
                    var last = rows.last;
                    while (++i < l) {
                        if (totalDiff) ranges[i].moveBy(totalDiff, 0);
                        var subRows = this.$getSelectedRows(ranges[i]);
                        if (copy && subRows.first != last)
                            break;
                        else if (!copy && subRows.first > last + 1)
                            break;
                        last = subRows.last;
                    }
                    i--;
                    diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                    if (copy && dir == -1) rangeIndex = i + 1;
                    while (rangeIndex <= i) {
                        ranges[rangeIndex].moveBy(diff, 0);
                        rangeIndex++;
                    }
                    if (!copy) diff = 0;
                    totalDiff += diff;
                }
                
                selection.fromOrientedRange(selection.ranges[0]);
                selection.rangeList.attach(this.session);
                this.inVirtualSelectionMode = false;
            }
        };
        this.$getSelectedRows = function(range) {
            range = (range || this.getSelectionRange()).collapseRows();

            return {
                first: this.session.getRowFoldStart(range.start.row),
                last: this.session.getRowFoldEnd(range.end.row)
            };
        };

        this.onCompositionStart = function(compositionState) {
            this.renderer.showComposition(compositionState);
        };

        this.onCompositionUpdate = function(text) {
            this.renderer.setCompositionText(text);
        };

        this.onCompositionEnd = function() {
            this.renderer.hideComposition();
        };
        this.getFirstVisibleRow = function() {
            return this.renderer.getFirstVisibleRow();
        };
        this.getLastVisibleRow = function() {
            return this.renderer.getLastVisibleRow();
        };
        this.isRowVisible = function(row) {
            return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
        };
        this.isRowFullyVisible = function(row) {
            return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
        };
        this.$getVisibleRowCount = function() {
            return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
        };

        this.$moveByPage = function(dir, select) {
            var renderer = this.renderer;
            var config = this.renderer.layerConfig;
            var rows = dir * Math.floor(config.height / config.lineHeight);

            if (select === true) {
                this.selection.$moveSelection(function(){
                    this.moveCursorBy(rows, 0);
                });
            } else if (select === false) {
                this.selection.moveCursorBy(rows, 0);
                this.selection.clearSelection();
            }

            var scrollTop = renderer.scrollTop;

            renderer.scrollBy(0, rows * config.lineHeight);
            if (select != null)
                renderer.scrollCursorIntoView(null, 0.5);

            renderer.animateScrolling(scrollTop);
        };
        this.selectPageDown = function() {
            this.$moveByPage(1, true);
        };
        this.selectPageUp = function() {
            this.$moveByPage(-1, true);
        };
        this.gotoPageDown = function() {
           this.$moveByPage(1, false);
        };
        this.gotoPageUp = function() {
            this.$moveByPage(-1, false);
        };
        this.scrollPageDown = function() {
            this.$moveByPage(1);
        };
        this.scrollPageUp = function() {
            this.$moveByPage(-1);
        };
        this.scrollToRow = function(row) {
            this.renderer.scrollToRow(row);
        };
        this.scrollToLine = function(line, center, animate, callback) {
            this.renderer.scrollToLine(line, center, animate, callback);
        };
        this.centerSelection = function() {
            var range = this.getSelectionRange();
            var pos = {
                row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
                column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
            };
            this.renderer.alignCursor(pos, 0.5);
        };
        this.getCursorPosition = function() {
            return this.selection.getCursor();
        };
        this.getCursorPositionScreen = function() {
            return this.session.documentToScreenPosition(this.getCursorPosition());
        };
        this.getSelectionRange = function() {
            return this.selection.getRange();
        };
        this.selectAll = function() {
            this.selection.selectAll();
        };
        this.clearSelection = function() {
            this.selection.clearSelection();
        };
        this.moveCursorTo = function(row, column) {
            this.selection.moveCursorTo(row, column);
        };
        this.moveCursorToPosition = function(pos) {
            this.selection.moveCursorToPosition(pos);
        };
        this.jumpToMatching = function(select, expand) {
            var cursor = this.getCursorPosition();
            var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
            var prevToken = iterator.getCurrentToken();
            var token = prevToken || iterator.stepForward();

            if (!token) return;
            var matchType;
            var found = false;
            var depth = {};
            var i = cursor.column - token.start;
            var bracketType;
            var brackets = {
                ")": "(",
                "(": "(",
                "]": "[",
                "[": "[",
                "{": "{",
                "}": "{"
            };
            
            do {
                if (token.value.match(/[{}()\[\]]/g)) {
                    for (; i < token.value.length && !found; i++) {
                        if (!brackets[token.value[i]]) {
                            continue;
                        }

                        bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");

                        if (isNaN(depth[bracketType])) {
                            depth[bracketType] = 0;
                        }

                        switch (token.value[i]) {
                            case '(':
                            case '[':
                            case '{':
                                depth[bracketType]++;
                                break;
                            case ')':
                            case ']':
                            case '}':
                                depth[bracketType]--;

                                if (depth[bracketType] === -1) {
                                    matchType = 'bracket';
                                    found = true;
                                }
                            break;
                        }
                    }
                }
                else if (token.type.indexOf('tag-name') !== -1) {
                    if (isNaN(depth[token.value])) {
                        depth[token.value] = 0;
                    }
                    
                    if (prevToken.value === '<') {
                        depth[token.value]++;
                    }
                    else if (prevToken.value === '</') {
                        depth[token.value]--;
                    }
                    
                    if (depth[token.value] === -1) {
                        matchType = 'tag';
                        found = true;
                    }
                }

                if (!found) {
                    prevToken = token;
                    token = iterator.stepForward();
                    i = 0;
                }
            } while (token && !found);
            if (!matchType)
                return;

            var range, pos;
            if (matchType === 'bracket') {
                range = this.session.getBracketRange(cursor);
                if (!range) {
                    range = new Range(
                        iterator.getCurrentTokenRow(),
                        iterator.getCurrentTokenColumn() + i - 1,
                        iterator.getCurrentTokenRow(),
                        iterator.getCurrentTokenColumn() + i - 1
                    );
                    pos = range.start;
                    if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
                        range = this.session.getBracketRange(pos);
                }
            }
            else if (matchType === 'tag') {
                if (token && token.type.indexOf('tag-name') !== -1) 
                    var tag = token.value;
                else
                    return;

                range = new Range(
                    iterator.getCurrentTokenRow(),
                    iterator.getCurrentTokenColumn() - 2,
                    iterator.getCurrentTokenRow(),
                    iterator.getCurrentTokenColumn() - 2
                );
                if (range.compare(cursor.row, cursor.column) === 0) {
                    found = false;
                    do {
                        token = prevToken;
                        prevToken = iterator.stepBackward();
                        
                        if (prevToken) {
                            if (prevToken.type.indexOf('tag-close') !== -1) {
                                range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                            }

                            if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
                                if (prevToken.value === '<') {
                                    depth[tag]++;
                                }
                                else if (prevToken.value === '</') {
                                    depth[tag]--;
                                }
                                
                                if (depth[tag] === 0)
                                    found = true;
                            }
                        }
                    } while (prevToken && !found);
                }
                if (token && token.type.indexOf('tag-name')) {
                    pos = range.start;
                    if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
                        pos = range.end;
                }
            }

            pos = range && range.cursor || pos;
            if (pos) {
                if (select) {
                    if (range && expand) {
                        this.selection.setRange(range);
                    } else if (range && range.isEqual(this.getSelectionRange())) {
                        this.clearSelection();
                    } else {
                        this.selection.selectTo(pos.row, pos.column);
                    }
                } else {
                    this.selection.moveTo(pos.row, pos.column);
                }
            }
        };
        this.gotoLine = function(lineNumber, column, animate) {
            this.selection.clearSelection();
            this.session.unfold({row: lineNumber - 1, column: column || 0});
            this.exitMultiSelectMode && this.exitMultiSelectMode();
            this.moveCursorTo(lineNumber - 1, column || 0);

            if (!this.isRowFullyVisible(lineNumber - 1))
                this.scrollToLine(lineNumber - 1, true, animate);
        };
        this.navigateTo = function(row, column) {
            this.selection.moveTo(row, column);
        };
        this.navigateUp = function(times) {
            if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
                var selectionStart = this.selection.anchor.getPosition();
                return this.moveCursorToPosition(selectionStart);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(-times || -1, 0);
        };
        this.navigateDown = function(times) {
            if (this.selection.isMultiLine() && this.selection.isBackwards()) {
                var selectionEnd = this.selection.anchor.getPosition();
                return this.moveCursorToPosition(selectionEnd);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(times || 1, 0);
        };
        this.navigateLeft = function(times) {
            if (!this.selection.isEmpty()) {
                var selectionStart = this.getSelectionRange().start;
                this.moveCursorToPosition(selectionStart);
            }
            else {
                times = times || 1;
                while (times--) {
                    this.selection.moveCursorLeft();
                }
            }
            this.clearSelection();
        };
        this.navigateRight = function(times) {
            if (!this.selection.isEmpty()) {
                var selectionEnd = this.getSelectionRange().end;
                this.moveCursorToPosition(selectionEnd);
            }
            else {
                times = times || 1;
                while (times--) {
                    this.selection.moveCursorRight();
                }
            }
            this.clearSelection();
        };
        this.navigateLineStart = function() {
            this.selection.moveCursorLineStart();
            this.clearSelection();
        };
        this.navigateLineEnd = function() {
            this.selection.moveCursorLineEnd();
            this.clearSelection();
        };
        this.navigateFileEnd = function() {
            this.selection.moveCursorFileEnd();
            this.clearSelection();
        };
        this.navigateFileStart = function() {
            this.selection.moveCursorFileStart();
            this.clearSelection();
        };
        this.navigateWordRight = function() {
            this.selection.moveCursorWordRight();
            this.clearSelection();
        };
        this.navigateWordLeft = function() {
            this.selection.moveCursorWordLeft();
            this.clearSelection();
        };
        this.replace = function(replacement, options) {
            if (options)
                this.$search.set(options);

            var range = this.$search.find(this.session);
            var replaced = 0;
            if (!range)
                return replaced;

            if (this.$tryReplace(range, replacement)) {
                replaced = 1;
            }

            this.selection.setSelectionRange(range);
            this.renderer.scrollSelectionIntoView(range.start, range.end);

            return replaced;
        };
        this.replaceAll = function(replacement, options) {
            if (options) {
                this.$search.set(options);
            }

            var ranges = this.$search.findAll(this.session);
            var replaced = 0;
            if (!ranges.length)
                return replaced;

            var selection = this.getSelectionRange();
            this.selection.moveTo(0, 0);

            for (var i = ranges.length - 1; i >= 0; --i) {
                if(this.$tryReplace(ranges[i], replacement)) {
                    replaced++;
                }
            }

            this.selection.setSelectionRange(selection);

            return replaced;
        };

        this.$tryReplace = function(range, replacement) {
            var input = this.session.getTextRange(range);
            replacement = this.$search.replace(input, replacement);
            if (replacement !== null) {
                range.end = this.session.replace(range, replacement);
                return range;
            } else {
                return null;
            }
        };
        this.getLastSearchOptions = function() {
            return this.$search.getOptions();
        };
        this.find = function(needle, options, animate) {
            if (!options)
                options = {};

            if (typeof needle == "string" || needle instanceof RegExp)
                options.needle = needle;
            else if (typeof needle == "object")
                oop.mixin(options, needle);

            var range = this.selection.getRange();
            if (options.needle == null) {
                needle = this.session.getTextRange(range)
                    || this.$search.$options.needle;
                if (!needle) {
                    range = this.session.getWordRange(range.start.row, range.start.column);
                    needle = this.session.getTextRange(range);
                }
                this.$search.set({needle: needle});
            }

            this.$search.set(options);
            if (!options.start)
                this.$search.set({start: range});

            var newRange = this.$search.find(this.session);
            if (options.preventScroll)
                return newRange;
            if (newRange) {
                this.revealRange(newRange, animate);
                return newRange;
            }
            if (options.backwards)
                range.start = range.end;
            else
                range.end = range.start;
            this.selection.setRange(range);
        };
        this.findNext = function(options, animate) {
            this.find({skipCurrent: true, backwards: false}, options, animate);
        };
        this.findPrevious = function(options, animate) {
            this.find(options, {skipCurrent: true, backwards: true}, animate);
        };

        this.revealRange = function(range, animate) {
            this.session.unfold(range);
            this.selection.setSelectionRange(range);

            var scrollTop = this.renderer.scrollTop;
            this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
            if (animate !== false)
                this.renderer.animateScrolling(scrollTop);
        };
        this.undo = function() {
            this.session.getUndoManager().undo(this.session);
            this.renderer.scrollCursorIntoView(null, 0.5);
        };
        this.redo = function() {
            this.session.getUndoManager().redo(this.session);
            this.renderer.scrollCursorIntoView(null, 0.5);
        };
        this.destroy = function() {
            if (this.$toDestroy) {
                this.$toDestroy.forEach(function(el) {
                    el.destroy();
                });
                this.$toDestroy = null;
            }
            if (this.$mouseHandler)
                this.$mouseHandler.destroy();
            this.renderer.destroy();
            this._signal("destroy", this);
            if (this.session)
                this.session.destroy();
            if (this._$emitInputEvent)
                this._$emitInputEvent.cancel();
            this.removeAllListeners();
        };
        this.setAutoScrollEditorIntoView = function(enable) {
            if (!enable)
                return;
            var rect;
            var self = this;
            var shouldScroll = false;
            if (!this.$scrollAnchor)
                this.$scrollAnchor = document.createElement("div");
            var scrollAnchor = this.$scrollAnchor;
            scrollAnchor.style.cssText = "position:absolute";
            this.container.insertBefore(scrollAnchor, this.container.firstChild);
            var onChangeSelection = this.on("changeSelection", function() {
                shouldScroll = true;
            });
            var onBeforeRender = this.renderer.on("beforeRender", function() {
                if (shouldScroll)
                    rect = self.renderer.container.getBoundingClientRect();
            });
            var onAfterRender = this.renderer.on("afterRender", function() {
                if (shouldScroll && rect && (self.isFocused()
                    || self.searchBox && self.searchBox.isFocused())
                ) {
                    var renderer = self.renderer;
                    var pos = renderer.$cursorLayer.$pixelPos;
                    var config = renderer.layerConfig;
                    var top = pos.top - config.offset;
                    if (pos.top >= 0 && top + rect.top < 0) {
                        shouldScroll = true;
                    } else if (pos.top < config.height &&
                        pos.top + rect.top + config.lineHeight > window.innerHeight) {
                        shouldScroll = false;
                    } else {
                        shouldScroll = null;
                    }
                    if (shouldScroll != null) {
                        scrollAnchor.style.top = top + "px";
                        scrollAnchor.style.left = pos.left + "px";
                        scrollAnchor.style.height = config.lineHeight + "px";
                        scrollAnchor.scrollIntoView(shouldScroll);
                    }
                    shouldScroll = rect = null;
                }
            });
            this.setAutoScrollEditorIntoView = function(enable) {
                if (enable)
                    return;
                delete this.setAutoScrollEditorIntoView;
                this.off("changeSelection", onChangeSelection);
                this.renderer.off("afterRender", onAfterRender);
                this.renderer.off("beforeRender", onBeforeRender);
            };
        };


        this.$resetCursorStyle = function() {
            var style = this.$cursorStyle || "ace";
            var cursorLayer = this.renderer.$cursorLayer;
            if (!cursorLayer)
                return;
            cursorLayer.setSmoothBlinking(/smooth/.test(style));
            cursorLayer.isBlinking = !this.$readOnly && style != "wide";
            dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
        };
        this.prompt = function(message, options, callback) {
            var editor = this;
            config.loadModule("./ext/prompt", function (module) {
                module.prompt(editor, message, options, callback);
            });
        };

    }).call(Editor.prototype);



    config.defineOptions(Editor.prototype, "editor", {
        selectionStyle: {
            set: function(style) {
                this.onSelectionChange();
                this._signal("changeSelectionStyle", {data: style});
            },
            initialValue: "line"
        },
        highlightActiveLine: {
            set: function() {this.$updateHighlightActiveLine();},
            initialValue: true
        },
        highlightSelectedWord: {
            set: function(shouldHighlight) {this.$onSelectionChange();},
            initialValue: true
        },
        readOnly: {
            set: function(readOnly) {
                this.textInput.setReadOnly(readOnly);
                this.$resetCursorStyle(); 
            },
            initialValue: false
        },
        copyWithEmptySelection: {
            set: function(value) {
                this.textInput.setCopyWithEmptySelection(value);
            },
            initialValue: false
        },
        cursorStyle: {
            set: function(val) { this.$resetCursorStyle(); },
            values: ["ace", "slim", "smooth", "wide"],
            initialValue: "ace"
        },
        mergeUndoDeltas: {
            values: [false, true, "always"],
            initialValue: true
        },
        behavioursEnabled: {initialValue: true},
        wrapBehavioursEnabled: {initialValue: true},
        enableAutoIndent: {initialValue: true},
        autoScrollEditorIntoView: {
            set: function(val) {this.setAutoScrollEditorIntoView(val);}
        },
        keyboardHandler: {
            set: function(val) { this.setKeyboardHandler(val); },
            get: function() { return this.$keybindingId; },
            handlesSet: true
        },
        value: {
            set: function(val) { this.session.setValue(val); },
            get: function() { return this.getValue(); },
            handlesSet: true,
            hidden: true
        },
        session: {
            set: function(val) { this.setSession(val); },
            get: function() { return this.session; },
            handlesSet: true,
            hidden: true
        },
        
        showLineNumbers: {
            set: function(show) {
                this.renderer.$gutterLayer.setShowLineNumbers(show);
                this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);
                if (show && this.$relativeLineNumbers)
                    relativeNumberRenderer.attach(this);
                else
                    relativeNumberRenderer.detach(this);
            },
            initialValue: true
        },
        relativeLineNumbers: {
            set: function(value) {
                if (this.$showLineNumbers && value)
                    relativeNumberRenderer.attach(this);
                else
                    relativeNumberRenderer.detach(this);
            }
        },
        placeholder: {
            set: function(message) {
                if (!this.$updatePlaceholder) {
                    this.$updatePlaceholder = function() {
                        var value = this.session && (this.renderer.$composition || this.getValue());
                        if (value && this.renderer.placeholderNode) {
                            this.renderer.off("afterRender", this.$updatePlaceholder);
                            dom.removeCssClass(this.container, "ace_hasPlaceholder");
                            this.renderer.placeholderNode.remove();
                            this.renderer.placeholderNode = null;
                        } else if (!value && !this.renderer.placeholderNode) {
                            this.renderer.on("afterRender", this.$updatePlaceholder);
                            dom.addCssClass(this.container, "ace_hasPlaceholder");
                            var el = dom.createElement("div");
                            el.className = "ace_placeholder";
                            el.textContent = this.$placeholder || "";
                            this.renderer.placeholderNode = el;
                            this.renderer.content.appendChild(this.renderer.placeholderNode);
                        } else if (!value && this.renderer.placeholderNode) {
                            this.renderer.placeholderNode.textContent = this.$placeholder || "";
                        }
                    }.bind(this);
                    this.on("input", this.$updatePlaceholder);
                }
                this.$updatePlaceholder();
            }
        },

        hScrollBarAlwaysVisible: "renderer",
        vScrollBarAlwaysVisible: "renderer",
        highlightGutterLine: "renderer",
        animatedScroll: "renderer",
        showInvisibles: "renderer",
        showPrintMargin: "renderer",
        printMarginColumn: "renderer",
        printMargin: "renderer",
        fadeFoldWidgets: "renderer",
        showFoldWidgets: "renderer",
        displayIndentGuides: "renderer",
        showGutter: "renderer",
        fontSize: "renderer",
        fontFamily: "renderer",
        maxLines: "renderer",
        minLines: "renderer",
        scrollPastEnd: "renderer",
        fixedWidthGutter: "renderer",
        theme: "renderer",
        hasCssTransforms: "renderer",
        maxPixelHeight: "renderer",
        useTextareaForIME: "renderer",

        scrollSpeed: "$mouseHandler",
        dragDelay: "$mouseHandler",
        dragEnabled: "$mouseHandler",
        focusTimeout: "$mouseHandler",
        tooltipFollowsMouse: "$mouseHandler",

        firstLineNumber: "session",
        overwrite: "session",
        newLineMode: "session",
        useWorker: "session",
        useSoftTabs: "session",
        navigateWithinSoftTabs: "session",
        tabSize: "session",
        wrap: "session",
        indentedSoftWrap: "session",
        foldStyle: "session",
        mode: "session"
    });


    var relativeNumberRenderer = {
        getText: function(session, row) {
            return (Math.abs(session.selection.lead.row - row) || (row + 1 + (row < 9 ? "\xb7" : ""))) + "";
        },
        getWidth: function(session, lastLineNumber, config) {
            return Math.max(
                lastLineNumber.toString().length,
                (config.lastRow + 1).toString().length,
                2
            ) * config.characterWidth;
        },
        update: function(e, editor) {
            editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);
        },
        attach: function(editor) {
            editor.renderer.$gutterLayer.$renderer = this;
            editor.on("changeSelection", this.update);
            this.update(null, editor);
        },
        detach: function(editor) {
            if (editor.renderer.$gutterLayer.$renderer == this)
                editor.renderer.$gutterLayer.$renderer = null;
            editor.off("changeSelection", this.update);
            this.update(null, editor);
        }
    };

    exports.Editor = Editor;
    });

    ace.define("ace/undomanager",["require","exports","module","ace/range"], function(require, exports, module) {
    var UndoManager = function() {
        this.$maxRev = 0;
        this.$fromUndo = false;
        this.reset();
    };

    (function() {
        
        this.addSession = function(session) {
            this.$session = session;
        };
        this.add = function(delta, allowMerge, session) {
            if (this.$fromUndo) return;
            if (delta == this.$lastDelta) return;
            if (!this.$keepRedoStack) this.$redoStack.length = 0;
            if (allowMerge === false || !this.lastDeltas) {
                this.lastDeltas = [];
                this.$undoStack.push(this.lastDeltas);
                delta.id = this.$rev = ++this.$maxRev;
            }
            if (delta.action == "remove" || delta.action == "insert")
                this.$lastDelta = delta;
            this.lastDeltas.push(delta);
        };
        
        this.addSelection = function(selection, rev) {
            this.selections.push({
                value: selection,
                rev: rev || this.$rev
            });
        };
        
        this.startNewGroup = function() {
            this.lastDeltas = null;
            return this.$rev;
        };
        
        this.markIgnored = function(from, to) {
            if (to == null) to = this.$rev + 1;
            var stack = this.$undoStack;
            for (var i = stack.length; i--;) {
                var delta = stack[i][0];
                if (delta.id <= from)
                    break;
                if (delta.id < to)
                    delta.ignore = true;
            }
            this.lastDeltas = null;
        };
        
        this.getSelection = function(rev, after) {
            var stack = this.selections;
            for (var i = stack.length; i--;) {
                var selection = stack[i];
                if (selection.rev < rev) {
                    if (after)
                        selection = stack[i + 1];
                    return selection;
                }
            }
        };
        
        this.getRevision = function() {
            return this.$rev;
        };
        
        this.getDeltas = function(from, to) {
            if (to == null) to = this.$rev + 1;
            var stack = this.$undoStack;
            var end = null, start = 0;
            for (var i = stack.length; i--;) {
                var delta = stack[i][0];
                if (delta.id < to && !end)
                    end = i+1;
                if (delta.id <= from) {
                    start = i + 1;
                    break;
                }
            }
            return stack.slice(start, end);
        };
        
        this.getChangedRanges = function(from, to) {
            if (to == null) to = this.$rev + 1;
            
        };
        
        this.getChangedLines = function(from, to) {
            if (to == null) to = this.$rev + 1;
            
        };
        this.undo = function(session, dontSelect) {
            this.lastDeltas = null;
            var stack = this.$undoStack;
            
            if (!rearrangeUndoStack(stack, stack.length))
                return;
            
            if (!session)
                session = this.$session;
            
            if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)
                this.$redoStack = [];
            
            this.$fromUndo = true;
            
            var deltaSet = stack.pop();
            var undoSelectionRange = null;
            if (deltaSet) {
                undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
                this.$redoStack.push(deltaSet);
                this.$syncRev();
            }
            
            this.$fromUndo = false;

            return undoSelectionRange;
        };
        this.redo = function(session, dontSelect) {
            this.lastDeltas = null;
            
            if (!session)
                session = this.$session;
            
            this.$fromUndo = true;
            if (this.$redoStackBaseRev != this.$rev) {
                var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
                rebaseRedoStack(this.$redoStack, diff);
                this.$redoStackBaseRev = this.$rev;
                this.$redoStack.forEach(function(x) {
                    x[0].id = ++this.$maxRev;
                }, this);
            }
            var deltaSet = this.$redoStack.pop();
            var redoSelectionRange = null;
            
            if (deltaSet) {
                redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
                this.$undoStack.push(deltaSet);
                this.$syncRev();
            }
            this.$fromUndo = false;
            
            return redoSelectionRange;
        };
        
        this.$syncRev = function() {
            var stack = this.$undoStack;
            var nextDelta = stack[stack.length - 1];
            var id = nextDelta && nextDelta[0].id || 0;
            this.$redoStackBaseRev = id;
            this.$rev = id;
        };
        this.reset = function() {
            this.lastDeltas = null;
            this.$lastDelta = null;
            this.$undoStack = [];
            this.$redoStack = [];
            this.$rev = 0;
            this.mark = 0;
            this.$redoStackBaseRev = this.$rev;
            this.selections = [];
        };
        this.canUndo = function() {
            return this.$undoStack.length > 0;
        };
        this.canRedo = function() {
            return this.$redoStack.length > 0;
        };
        this.bookmark = function(rev) {
            if (rev == undefined)
                rev = this.$rev;
            this.mark = rev;
        };
        this.isAtBookmark = function() {
            return this.$rev === this.mark;
        };
        
        this.toJSON = function() {
            
        };
        
        this.fromJSON = function() {
            
        };
        
        this.hasUndo = this.canUndo;
        this.hasRedo = this.canRedo;
        this.isClean = this.isAtBookmark;
        this.markClean = this.bookmark;
        
        this.$prettyPrint = function(delta) {
            if (delta) return stringifyDelta(delta);
            return stringifyDelta(this.$undoStack) + "\n---\n" + stringifyDelta(this.$redoStack);
        };
    }).call(UndoManager.prototype);

    function rearrangeUndoStack(stack, pos) {
        for (var i = pos; i--; ) {
            var deltaSet = stack[i];
            if (deltaSet && !deltaSet[0].ignore) {
                while(i < pos - 1) {
                    var swapped = swapGroups(stack[i], stack[i + 1]);
                    stack[i] = swapped[0];
                    stack[i + 1] = swapped[1];
                    i++;
                }
                return true;
            }
        }
    }

    var Range = require("./range").Range;
    var cmp = Range.comparePoints;
    Range.comparePoints;



    function clonePos(pos) {
        return {row: pos.row,column: pos.column};
    }
    function cloneDelta(d) {
        return {
            start: clonePos(d.start),
            end: clonePos(d.end),
            action: d.action,
            lines: d.lines.slice()
        };
    }
    function stringifyDelta(d) {
        d = d || this;
        if (Array.isArray(d)) {
            return d.map(stringifyDelta).join("\n");
        }
        var type = "";
        if (d.action) {
            type = d.action == "insert" ? "+" : "-";
            type += "[" + d.lines + "]";
        } else if (d.value) {
            if (Array.isArray(d.value)) {
                type = d.value.map(stringifyRange).join("\n");
            } else {
                type = stringifyRange(d.value);
            }
        }
        if (d.start) {
            type += stringifyRange(d);
        }
        if (d.id || d.rev) {
            type += "\t(" + (d.id || d.rev) + ")";
        }
        return type;
    }
    function stringifyRange(r) {
        return r.start.row + ":" + r.start.column 
            + "=>" + r.end.row + ":" + r.end.column;
    }

    function swap(d1, d2) {
        var i1 = d1.action == "insert";
        var i2 = d2.action == "insert";
        
        if (i1 && i2) {
            if (cmp(d2.start, d1.end) >= 0) {
                shift(d2, d1, -1);
            } else if (cmp(d2.start, d1.start) <= 0) {
                shift(d1, d2, +1);
            } else {
                return null;
            }
        } else if (i1 && !i2) {
            if (cmp(d2.start, d1.end) >= 0) {
                shift(d2, d1, -1);
            } else if (cmp(d2.end, d1.start) <= 0) {
                shift(d1, d2, -1);
            } else {
                return null;
            }
        } else if (!i1 && i2) {
            if (cmp(d2.start, d1.start) >= 0) {
                shift(d2, d1, +1);
            } else if (cmp(d2.start, d1.start) <= 0) {
                shift(d1, d2, +1);
            } else {
                return null;
            }
        } else if (!i1 && !i2) {
            if (cmp(d2.start, d1.start) >= 0) {
                shift(d2, d1, +1);
            } else if (cmp(d2.end, d1.start) <= 0) {
                shift(d1, d2, -1);
            } else {
                return null;
            }
        }
        return [d2, d1];
    }
    function swapGroups(ds1, ds2) {
        for (var i = ds1.length; i--; ) {
            for (var j = 0; j < ds2.length; j++) {
                if (!swap(ds1[i], ds2[j])) {
                    while (i < ds1.length) {
                        while (j--) {
                            swap(ds2[j], ds1[i]);
                        }
                        j = ds2.length;
                        i++;
                    }                
                    return [ds1, ds2];
                }
            }
        }
        ds1.selectionBefore = ds2.selectionBefore = 
        ds1.selectionAfter = ds2.selectionAfter = null;
        return [ds2, ds1];
    }
    function xform(d1, c1) {
        var i1 = d1.action == "insert";
        var i2 = c1.action == "insert";
        
        if (i1 && i2) {
            if (cmp(d1.start, c1.start) < 0) {
                shift(c1, d1, 1);
            } else {
                shift(d1, c1, 1);
            }
        } else if (i1 && !i2) {
            if (cmp(d1.start, c1.end) >= 0) {
                shift(d1, c1, -1);
            } else if (cmp(d1.start, c1.start) <= 0) {
                shift(c1, d1, +1);
            } else {
                shift(d1, Range.fromPoints(c1.start, d1.start), -1);
                shift(c1, d1, +1);
            }
        } else if (!i1 && i2) {
            if (cmp(c1.start, d1.end) >= 0) {
                shift(c1, d1, -1);
            } else if (cmp(c1.start, d1.start) <= 0) {
                shift(d1, c1, +1);
            } else {
                shift(c1, Range.fromPoints(d1.start, c1.start), -1);
                shift(d1, c1, +1);
            }
        } else if (!i1 && !i2) {
            if (cmp(c1.start, d1.end) >= 0) {
                shift(c1, d1, -1);
            } else if (cmp(c1.end, d1.start) <= 0) {
                shift(d1, c1, -1);
            } else {
                var before, after;
                if (cmp(d1.start, c1.start) < 0) {
                    before = d1;
                    d1 = splitDelta(d1, c1.start);
                }
                if (cmp(d1.end, c1.end) > 0) {
                    after = splitDelta(d1, c1.end);
                }

                shiftPos(c1.end, d1.start, d1.end, -1);
                if (after && !before) {
                    d1.lines = after.lines;
                    d1.start = after.start;
                    d1.end = after.end;
                    after = d1;
                }

                return [c1, before, after].filter(Boolean);
            }
        }
        return [c1, d1];
    }
        
    function shift(d1, d2, dir) {
        shiftPos(d1.start, d2.start, d2.end, dir);
        shiftPos(d1.end, d2.start, d2.end, dir);
    }
    function shiftPos(pos, start, end, dir) {
        if (pos.row == (dir == 1 ? start : end).row) {
            pos.column += dir * (end.column - start.column);
        }
        pos.row += dir * (end.row - start.row);
    }
    function splitDelta(c, pos) {
        var lines = c.lines;
        var end = c.end;
        c.end = clonePos(pos);    
        var rowsBefore = c.end.row - c.start.row;
        var otherLines = lines.splice(rowsBefore, lines.length);
        
        var col = rowsBefore ? pos.column : pos.column - c.start.column;
        lines.push(otherLines[0].substring(0, col));
        otherLines[0] = otherLines[0].substr(col)   ; 
        var rest = {
            start: clonePos(pos),
            end: end,
            lines: otherLines,
            action: c.action
        };
        return rest;
    }

    function moveDeltasByOne(redoStack, d) {
        d = cloneDelta(d);
        for (var j = redoStack.length; j--;) {
            var deltaSet = redoStack[j];
            for (var i = 0; i < deltaSet.length; i++) {
                var x = deltaSet[i];
                var xformed = xform(x, d);
                d = xformed[0];
                if (xformed.length != 2) {
                    if (xformed[2]) {
                        deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);
                        i++;
                    } else if (!xformed[1]) {
                        deltaSet.splice(i, 1);
                        i--;
                    }
                }
            }
            if (!deltaSet.length) {
                redoStack.splice(j, 1); 
            }
        }
        return redoStack;
    }
    function rebaseRedoStack(redoStack, deltaSets) {
        for (var i = 0; i < deltaSets.length; i++) {
            var deltas = deltaSets[i];
            for (var j = 0; j < deltas.length; j++) {
                moveDeltasByOne(redoStack, deltas[j]);
            }
        }
    }

    exports.UndoManager = UndoManager;

    });

    ace.define("ace/layer/lines",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

    var dom = require("../lib/dom");

    var Lines = function(element, canvasHeight) {
        this.element = element;
        this.canvasHeight = canvasHeight || 500000;
        this.element.style.height = (this.canvasHeight * 2) + "px";
        
        this.cells = [];
        this.cellCache = [];
        this.$offsetCoefficient = 0;
    };

    (function() {
        
        this.moveContainer = function(config) {
            dom.translate(this.element, 0, -((config.firstRowScreen * config.lineHeight) % this.canvasHeight) - config.offset * this.$offsetCoefficient);
        };    
        
        this.pageChanged = function(oldConfig, newConfig) {
            return (
                Math.floor((oldConfig.firstRowScreen * oldConfig.lineHeight) / this.canvasHeight) !==
                Math.floor((newConfig.firstRowScreen * newConfig.lineHeight) / this.canvasHeight)
            );
        };
        
        this.computeLineTop = function(row, config, session) {
            var screenTop = config.firstRowScreen * config.lineHeight;
            var screenPage = Math.floor(screenTop / this.canvasHeight);
            var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;
            return lineTop - (screenPage * this.canvasHeight);
        };
        
        this.computeLineHeight = function(row, config, session) {
            return config.lineHeight * session.getRowLineCount(row);
        };
        
        this.getLength = function() {
            return this.cells.length;
        };
        
        this.get = function(index) {
            return this.cells[index];
        };
        
        this.shift = function() {
            this.$cacheCell(this.cells.shift());
        };
        
        this.pop = function() {
            this.$cacheCell(this.cells.pop());
        };
        
        this.push = function(cell) {
            if (Array.isArray(cell)) {
                this.cells.push.apply(this.cells, cell);
                var fragment = dom.createFragment(this.element);
                for (var i=0; i<cell.length; i++) {
                    fragment.appendChild(cell[i].element);
                }
                this.element.appendChild(fragment);
            } else {
                this.cells.push(cell);
                this.element.appendChild(cell.element);
            }
        };
        
        this.unshift = function(cell) {
            if (Array.isArray(cell)) {
                this.cells.unshift.apply(this.cells, cell);
                var fragment = dom.createFragment(this.element);
                for (var i=0; i<cell.length; i++) {
                    fragment.appendChild(cell[i].element);
                }
                if (this.element.firstChild)
                    this.element.insertBefore(fragment, this.element.firstChild);
                else
                    this.element.appendChild(fragment);
            } else {
                this.cells.unshift(cell);
                this.element.insertAdjacentElement("afterbegin", cell.element);
            }
        };
        
        this.last = function() {
            if (this.cells.length)
                return this.cells[this.cells.length-1];
            else
                return null;
        };
        
        this.$cacheCell = function(cell) {
            if (!cell)
                return;
                
            cell.element.remove();
            this.cellCache.push(cell);
        };
        
        this.createCell = function(row, config, session, initElement) {
            var cell = this.cellCache.pop();
            if (!cell) {
                var element = dom.createElement("div");
                if (initElement)
                    initElement(element);
                
                this.element.appendChild(element);
                
                cell = {
                    element: element,
                    text: "",
                    row: row
                };
            }
            cell.row = row;
            
            return cell;
        };
        
    }).call(Lines.prototype);

    exports.Lines = Lines;

    });

    ace.define("ace/layer/gutter",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/layer/lines"], function(require, exports, module) {

    var dom = require("../lib/dom");
    var oop = require("../lib/oop");
    var lang = require("../lib/lang");
    var EventEmitter = require("../lib/event_emitter").EventEmitter;
    var Lines = require("./lines").Lines;

    var Gutter = function(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_gutter-layer";
        parentEl.appendChild(this.element);
        this.setShowFoldWidgets(this.$showFoldWidgets);
        
        this.gutterWidth = 0;

        this.$annotations = [];
        this.$updateAnnotations = this.$updateAnnotations.bind(this);
        
        this.$lines = new Lines(this.element);
        this.$lines.$offsetCoefficient = 1;
    };

    (function() {

        oop.implement(this, EventEmitter);

        this.setSession = function(session) {
            if (this.session)
                this.session.off("change", this.$updateAnnotations);
            this.session = session;
            if (session)
                session.on("change", this.$updateAnnotations);
        };

        this.addGutterDecoration = function(row, className) {
            if (window.console)
                console.warn && console.warn("deprecated use session.addGutterDecoration");
            this.session.addGutterDecoration(row, className);
        };

        this.removeGutterDecoration = function(row, className) {
            if (window.console)
                console.warn && console.warn("deprecated use session.removeGutterDecoration");
            this.session.removeGutterDecoration(row, className);
        };

        this.setAnnotations = function(annotations) {
            this.$annotations = [];
            for (var i = 0; i < annotations.length; i++) {
                var annotation = annotations[i];
                var row = annotation.row;
                var rowInfo = this.$annotations[row];
                if (!rowInfo)
                    rowInfo = this.$annotations[row] = {text: []};
               
                var annoText = annotation.text;
                annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";

                if (rowInfo.text.indexOf(annoText) === -1)
                    rowInfo.text.push(annoText);

                var type = annotation.type;
                if (type == "error")
                    rowInfo.className = " ace_error";
                else if (type == "warning" && rowInfo.className != " ace_error")
                    rowInfo.className = " ace_warning";
                else if (type == "info" && (!rowInfo.className))
                    rowInfo.className = " ace_info";
            }
        };

        this.$updateAnnotations = function (delta) {
            if (!this.$annotations.length)
                return;
            var firstRow = delta.start.row;
            var len = delta.end.row - firstRow;
            if (len === 0) ; else if (delta.action == 'remove') {
                this.$annotations.splice(firstRow, len + 1, null);
            } else {
                var args = new Array(len + 1);
                args.unshift(firstRow, 1);
                this.$annotations.splice.apply(this.$annotations, args);
            }
        };

        this.update = function(config) {
            this.config = config;
            
            var session = this.session;
            var firstRow = config.firstRow;
            var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
                session.getLength() - 1);
                
            this.oldLastRow = lastRow;
            this.config = config;
            
            this.$lines.moveContainer(config);
            this.$updateCursorRow();
                
            var fold = session.getNextFoldLine(firstRow);
            var foldStart = fold ? fold.start.row : Infinity;

            var cell = null;
            var index = -1;
            var row = firstRow;
            
            while (true) {
                if (row > foldStart) {
                    row = fold.end.row + 1;
                    fold = session.getNextFoldLine(row, fold);
                    foldStart = fold ? fold.start.row : Infinity;
                }
                if (row > lastRow) {
                    while (this.$lines.getLength() > index + 1)
                        this.$lines.pop();
                        
                    break;
                }

                cell = this.$lines.get(++index);
                if (cell) {
                    cell.row = row;
                } else {
                    cell = this.$lines.createCell(row, config, this.session, onCreateCell);
                    this.$lines.push(cell);
                }

                this.$renderCell(cell, config, fold, row);
                row++;
            }
            
            this._signal("afterRender");
            this.$updateGutterWidth(config);
        };

        this.$updateGutterWidth = function(config) {
            var session = this.session;
            
            var gutterRenderer = session.gutterRenderer || this.$renderer;
            
            var firstLineNumber = session.$firstLineNumber;
            var lastLineText = this.$lines.last() ? this.$lines.last().text : "";
            
            if (this.$fixedWidth || session.$useWrapMode)
                lastLineText = session.getLength() + firstLineNumber - 1;

            var gutterWidth = gutterRenderer 
                ? gutterRenderer.getWidth(session, lastLineText, config)
                : lastLineText.toString().length * config.characterWidth;
            
            var padding = this.$padding || this.$computePadding();
            gutterWidth += padding.left + padding.right;
            if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
                this.gutterWidth = gutterWidth;
                this.element.parentNode.style.width = 
                this.element.style.width = Math.ceil(this.gutterWidth) + "px";
                this._signal("changeGutterWidth", gutterWidth);
            }
        };
        
        this.$updateCursorRow = function() {
            if (!this.$highlightGutterLine)
                return;
                
            var position = this.session.selection.getCursor();
            if (this.$cursorRow === position.row)
                return;
            
            this.$cursorRow = position.row;
        };
        
        this.updateLineHighlight = function() {
            if (!this.$highlightGutterLine)
                return;
            var row = this.session.selection.cursor.row;
            this.$cursorRow = row;

            if (this.$cursorCell && this.$cursorCell.row == row)
                return;
            if (this.$cursorCell)
                this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
            var cells = this.$lines.cells;
            this.$cursorCell = null;
            for (var i = 0; i < cells.length; i++) {
                var cell = cells[i];
                if (cell.row >= this.$cursorRow) {
                    if (cell.row > this.$cursorRow) {
                        var fold = this.session.getFoldLine(this.$cursorRow);
                        if (i > 0 && fold && fold.start.row == cells[i - 1].row)
                            cell = cells[i - 1];
                        else
                            break;
                    }
                    cell.element.className = "ace_gutter-active-line " + cell.element.className;
                    this.$cursorCell = cell;
                    break;
                }
            }
        };
        
        this.scrollLines = function(config) {
            var oldConfig = this.config;
            this.config = config;
            
            this.$updateCursorRow();
            if (this.$lines.pageChanged(oldConfig, config))
                return this.update(config);
            
            this.$lines.moveContainer(config);

            var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
                this.session.getLength() - 1);
            var oldLastRow = this.oldLastRow;
            this.oldLastRow = lastRow;
            
            if (!oldConfig || oldLastRow < config.firstRow)
                return this.update(config);

            if (lastRow < oldConfig.firstRow)
                return this.update(config);

            if (oldConfig.firstRow < config.firstRow)
                for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
                    this.$lines.shift();

            if (oldLastRow > lastRow)
                for (var row=this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row>0; row--)
                    this.$lines.pop();

            if (config.firstRow < oldConfig.firstRow) {
                this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));
            }

            if (lastRow > oldLastRow) {
                this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));
            }
            
            this.updateLineHighlight();
            
            this._signal("afterRender");
            this.$updateGutterWidth(config);
        };

        this.$renderLines = function(config, firstRow, lastRow) {
            var fragment = [];
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;

            while (true) {
                if (row > foldStart) {
                    row = foldLine.end.row+1;
                    foldLine = this.session.getNextFoldLine(row, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
                if (row > lastRow)
                    break;

                var cell = this.$lines.createCell(row, config, this.session, onCreateCell);
                this.$renderCell(cell, config, foldLine, row);
                fragment.push(cell);

                row++;
            }
            return fragment;
        };
        
        this.$renderCell = function(cell, config, fold, row) {
            var element = cell.element;
            
            var session = this.session;
            
            var textNode = element.childNodes[0];
            var foldWidget = element.childNodes[1];

            var firstLineNumber = session.$firstLineNumber;
            
            var breakpoints = session.$breakpoints;
            var decorations = session.$decorations;
            var gutterRenderer = session.gutterRenderer || this.$renderer;
            var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
            var foldStart = fold ? fold.start.row : Number.MAX_VALUE;
            
            var className = "ace_gutter-cell ";
            if (this.$highlightGutterLine) {
                if (row == this.$cursorRow || (fold && row < this.$cursorRow && row >= foldStart &&  this.$cursorRow <= fold.end.row)) {
                    className += "ace_gutter-active-line ";
                    if (this.$cursorCell != cell) {
                        if (this.$cursorCell)
                            this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
                        this.$cursorCell = cell;
                    }
                }
            }
            
            if (breakpoints[row])
                className += breakpoints[row];
            if (decorations[row])
                className += decorations[row];
            if (this.$annotations[row])
                className += this.$annotations[row].className;
            if (element.className != className)
                element.className = className;

            if (foldWidgets) {
                var c = foldWidgets[row];
                if (c == null)
                    c = foldWidgets[row] = session.getFoldWidget(row);
            }

            if (c) {
                var className = "ace_fold-widget ace_" + c;
                if (c == "start" && row == foldStart && row < fold.end.row)
                    className += " ace_closed";
                else
                    className += " ace_open";
                if (foldWidget.className != className)
                    foldWidget.className = className;

                var foldHeight = config.lineHeight + "px";
                dom.setStyle(foldWidget.style, "height", foldHeight);
                dom.setStyle(foldWidget.style, "display", "inline-block");
            } else {
                if (foldWidget) {
                    dom.setStyle(foldWidget.style, "display", "none");
                }
            }
            
            var text = (gutterRenderer
                ? gutterRenderer.getText(session, row)
                : row + firstLineNumber).toString();
                
            if (text !== textNode.data) {
                textNode.data = text;
            }
            
            dom.setStyle(cell.element.style, "height", this.$lines.computeLineHeight(row, config, session) + "px");
            dom.setStyle(cell.element.style, "top", this.$lines.computeLineTop(row, config, session) + "px");
            
            cell.text = text;
            return cell;
        };

        this.$fixedWidth = false;
        
        this.$highlightGutterLine = true;
        this.$renderer = "";
        this.setHighlightGutterLine = function(highlightGutterLine) {
            this.$highlightGutterLine = highlightGutterLine;
        };
        
        this.$showLineNumbers = true;
        this.$renderer = "";
        this.setShowLineNumbers = function(show) {
            this.$renderer = !show && {
                getWidth: function() {return 0;},
                getText: function() {return "";}
            };
        };
        
        this.getShowLineNumbers = function() {
            return this.$showLineNumbers;
        };
        
        this.$showFoldWidgets = true;
        this.setShowFoldWidgets = function(show) {
            if (show)
                dom.addCssClass(this.element, "ace_folding-enabled");
            else
                dom.removeCssClass(this.element, "ace_folding-enabled");

            this.$showFoldWidgets = show;
            this.$padding = null;
        };
        
        this.getShowFoldWidgets = function() {
            return this.$showFoldWidgets;
        };

        this.$computePadding = function() {
            if (!this.element.firstChild)
                return {left: 0, right: 0};
            var style = dom.computedStyle(this.element.firstChild);
            this.$padding = {};
            this.$padding.left = (parseInt(style.borderLeftWidth) || 0)
                + (parseInt(style.paddingLeft) || 0) + 1;
            this.$padding.right = (parseInt(style.borderRightWidth) || 0)
                + (parseInt(style.paddingRight) || 0);
            return this.$padding;
        };

        this.getRegion = function(point) {
            var padding = this.$padding || this.$computePadding();
            var rect = this.element.getBoundingClientRect();
            if (point.x < padding.left + rect.left)
                return "markers";
            if (this.$showFoldWidgets && point.x > rect.right - padding.right)
                return "foldWidgets";
        };

    }).call(Gutter.prototype);

    function onCreateCell(element) {
        var textNode = document.createTextNode('');
        element.appendChild(textNode);
        
        var foldWidget = dom.createElement("span");
        element.appendChild(foldWidget);
        
        return element;
    }

    exports.Gutter = Gutter;

    });

    ace.define("ace/layer/marker",["require","exports","module","ace/range","ace/lib/dom"], function(require, exports, module) {

    var Range = require("../range").Range;
    var dom = require("../lib/dom");

    var Marker = function(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_marker-layer";
        parentEl.appendChild(this.element);
    };

    (function() {

        this.$padding = 0;

        this.setPadding = function(padding) {
            this.$padding = padding;
        };
        this.setSession = function(session) {
            this.session = session;
        };
        
        this.setMarkers = function(markers) {
            this.markers = markers;
        };
        
        this.elt = function(className, css) {
            var x = this.i != -1 && this.element.childNodes[this.i];
            if (!x) {
                x = document.createElement("div");
                this.element.appendChild(x);
                this.i = -1;
            } else {
                this.i++;
            }
            x.style.cssText = css;
            x.className = className;
        };

        this.update = function(config) {
            if (!config) return;

            this.config = config;

            this.i = 0;
            var html;
            for (var key in this.markers) {
                var marker = this.markers[key];

                if (!marker.range) {
                    marker.update(html, this, this.session, config);
                    continue;
                }

                var range = marker.range.clipRows(config.firstRow, config.lastRow);
                if (range.isEmpty()) continue;

                range = range.toScreenRange(this.session);
                if (marker.renderer) {
                    var top = this.$getTop(range.start.row, config);
                    var left = this.$padding + range.start.column * config.characterWidth;
                    marker.renderer(html, range, left, top, config);
                } else if (marker.type == "fullLine") {
                    this.drawFullLineMarker(html, range, marker.clazz, config);
                } else if (marker.type == "screenLine") {
                    this.drawScreenLineMarker(html, range, marker.clazz, config);
                } else if (range.isMultiLine()) {
                    if (marker.type == "text")
                        this.drawTextMarker(html, range, marker.clazz, config);
                    else
                        this.drawMultiLineMarker(html, range, marker.clazz, config);
                } else {
                    this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
                }
            }
            if (this.i !=-1) {
                while (this.i < this.element.childElementCount)
                    this.element.removeChild(this.element.lastChild);
            }
        };

        this.$getTop = function(row, layerConfig) {
            return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
        };

        function getBorderClass(tl, tr, br, bl) {
            return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
        }
        this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
            var session = this.session;
            var start = range.start.row;
            var end = range.end.row;
            var row = start;
            var prev = 0; 
            var curr = 0;
            var next = session.getScreenLastRowColumn(row);
            var lineRange = new Range(row, range.start.column, row, curr);
            for (; row <= end; row++) {
                lineRange.start.row = lineRange.end.row = row;
                lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
                lineRange.end.column = next;
                prev = curr;
                curr = next;
                next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
                this.drawSingleLineMarker(stringBuilder, lineRange, 
                    clazz + (row == start  ? " ace_start" : "") + " ace_br"
                        + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end),
                    layerConfig, row == end ? 0 : 1, extraStyle);
            }
        };
        this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var padding = this.$padding;
            var height = config.lineHeight;
            var top = this.$getTop(range.start.row, config);
            var left = padding + range.start.column * config.characterWidth;
            extraStyle = extraStyle || "";

            if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
               var range1 = range.clone();
               range1.end.row = range1.start.row;
               range1.end.column = this.session.getLine(range1.start.row).length;
               this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
            } else {
                this.elt(
                    clazz + " ace_br1 ace_start",
                    "height:"+ height+ "px;"+ "right:0;"+ "top:"+top+ "px;left:"+ left+ "px;" + (extraStyle || "")
                );
            }
            if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
               var range1 = range.clone();
               range1.start.row = range1.end.row;
               range1.start.column = 0;
               this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
            } else {
                top = this.$getTop(range.end.row, config);
                var width = range.end.column * config.characterWidth;

                this.elt(
                    clazz + " ace_br12",
                    "height:"+ height+ "px;"+
                    "width:"+ width+ "px;"+
                    "top:"+ top+ "px;"+
                    "left:"+ padding+ "px;"+ (extraStyle || "")
                );
            }
            height = (range.end.row - range.start.row - 1) * config.lineHeight;
            if (height <= 0)
                return;
            top = this.$getTop(range.start.row + 1, config);
            
            var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);

            this.elt(
                clazz + (radiusClass ? " ace_br" + radiusClass : ""),
                "height:"+ height+ "px;"+
                "right:0;"+
                "top:"+ top+ "px;"+
                "left:"+ padding+ "px;"+ (extraStyle || "")
            );
        };
        this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
            if (this.session.$bidiHandler.isBidiRow(range.start.row))
                return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);
            var height = config.lineHeight;
            var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;

            var top = this.$getTop(range.start.row, config);
            var left = this.$padding + range.start.column * config.characterWidth;

            this.elt(
                clazz,
                "height:"+ height+ "px;"+
                "width:"+ width+ "px;"+
                "top:"+ top+ "px;"+
                "left:"+ left+ "px;"+ (extraStyle || "")
            );
        };
        this.drawBidiSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
            var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
            var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);

            selections.forEach(function(selection) {
                this.elt(
                    clazz,
                    "height:" + height + "px;" +
                    "width:" + selection.width + (extraLength || 0) + "px;" +
                    "top:" + top + "px;" +
                    "left:" + (padding + selection.left) + "px;" + (extraStyle || "")
                );
            }, this);
        };

        this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var top = this.$getTop(range.start.row, config);
            var height = config.lineHeight;
            if (range.start.row != range.end.row)
                height += this.$getTop(range.end.row, config) - top;

            this.elt(
                clazz,
                "height:"+ height+ "px;"+
                "top:"+ top+ "px;"+
                "left:0;right:0;"+ (extraStyle || "")
            );
        };
        
        this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var top = this.$getTop(range.start.row, config);
            var height = config.lineHeight;

            this.elt(
                clazz,
                "height:"+ height+ "px;"+
                "top:"+ top+ "px;"+
                "left:0;right:0;"+ (extraStyle || "")
            );
        };

    }).call(Marker.prototype);

    exports.Marker = Marker;

    });

    ace.define("ace/layer/text",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/layer/lines","ace/lib/event_emitter"], function(require, exports, module) {

    var oop = require("../lib/oop");
    var dom = require("../lib/dom");
    var lang = require("../lib/lang");
    var Lines = require("./lines").Lines;
    var EventEmitter = require("../lib/event_emitter").EventEmitter;

    var Text = function(parentEl) {
        this.dom = dom; 
        this.element = this.dom.createElement("div");
        this.element.className = "ace_layer ace_text-layer";
        parentEl.appendChild(this.element);
        this.$updateEolChar = this.$updateEolChar.bind(this);
        this.$lines = new Lines(this.element);
    };

    (function() {

        oop.implement(this, EventEmitter);

        this.EOF_CHAR = "\xB6";
        this.EOL_CHAR_LF = "\xAC";
        this.EOL_CHAR_CRLF = "\xa4";
        this.EOL_CHAR = this.EOL_CHAR_LF;
        this.TAB_CHAR = "\u2014"; //"\u21E5";
        this.SPACE_CHAR = "\xB7";
        this.$padding = 0;
        this.MAX_LINE_LENGTH = 10000;

        this.$updateEolChar = function() {
            var doc = this.session.doc;
            var unixMode = doc.getNewLineCharacter() == "\n" && doc.getNewLineMode() != "windows";
            var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
            if (this.EOL_CHAR != EOL_CHAR) {
                this.EOL_CHAR = EOL_CHAR;
                return true;
            }
        };

        this.setPadding = function(padding) {
            this.$padding = padding;
            this.element.style.margin = "0 " + padding + "px";
        };

        this.getLineHeight = function() {
            return this.$fontMetrics.$characterSize.height || 0;
        };

        this.getCharacterWidth = function() {
            return this.$fontMetrics.$characterSize.width || 0;
        };
        
        this.$setFontMetrics = function(measure) {
            this.$fontMetrics = measure;
            this.$fontMetrics.on("changeCharacterSize", function(e) {
                this._signal("changeCharacterSize", e);
            }.bind(this));
            this.$pollSizeChanges();
        };

        this.checkForSizeChanges = function() {
            this.$fontMetrics.checkForSizeChanges();
        };
        this.$pollSizeChanges = function() {
            return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
        };
        this.setSession = function(session) {
            this.session = session;
            if (session)
                this.$computeTabString();
        };

        this.showInvisibles = false;
        this.showSpaces = false;
        this.showTabs = false;
        this.showEOL = false;
        this.setShowInvisibles = function(showInvisibles) {
            if (this.showInvisibles == showInvisibles)
                return false;

            this.showInvisibles = showInvisibles;
            if (typeof showInvisibles == "string") {
                this.showSpaces = /tab/i.test(showInvisibles);
                this.showTabs = /space/i.test(showInvisibles);
                this.showEOL = /eol/i.test(showInvisibles);
            } else {
                this.showSpaces = this.showTabs = this.showEOL = showInvisibles;
            }
            this.$computeTabString();
            return true;
        };

        this.displayIndentGuides = true;
        this.setDisplayIndentGuides = function(display) {
            if (this.displayIndentGuides == display)
                return false;

            this.displayIndentGuides = display;
            this.$computeTabString();
            return true;
        };

        this.$tabStrings = [];
        this.onChangeTabSize =
        this.$computeTabString = function() {
            var tabSize = this.session.getTabSize();
            this.tabSize = tabSize;
            var tabStr = this.$tabStrings = [0];
            for (var i = 1; i < tabSize + 1; i++) {
                if (this.showTabs) {
                    var span = this.dom.createElement("span");
                    span.className = "ace_invisible ace_invisible_tab";
                    span.textContent = lang.stringRepeat(this.TAB_CHAR, i);
                    tabStr.push(span);
                } else {
                    tabStr.push(this.dom.createTextNode(lang.stringRepeat(" ", i), this.element));
                }
            }
            if (this.displayIndentGuides) {
                this.$indentGuideRe =  /\s\S| \t|\t |\s$/;
                var className = "ace_indent-guide";
                var spaceClass = this.showSpaces ? " ace_invisible ace_invisible_space" : "";
                var spaceContent = this.showSpaces
                    ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize)
                    : lang.stringRepeat(" ", this.tabSize);

                var tabClass = this.showTabs ? " ace_invisible ace_invisible_tab" : "";
                var tabContent = this.showTabs 
                    ? lang.stringRepeat(this.TAB_CHAR, this.tabSize)
                    : spaceContent;

                var span = this.dom.createElement("span");
                span.className = className + spaceClass;
                span.textContent = spaceContent;
                this.$tabStrings[" "] = span;
                
                var span = this.dom.createElement("span");
                span.className = className + tabClass;
                span.textContent = tabContent;
                this.$tabStrings["\t"] = span;
            }
        };

        this.updateLines = function(config, firstRow, lastRow) {
            if (this.config.lastRow != config.lastRow ||
                this.config.firstRow != config.firstRow) {
                return this.update(config);
            }
            
            this.config = config;

            var first = Math.max(firstRow, config.firstRow);
            var last = Math.min(lastRow, config.lastRow);

            var lineElements = this.element.childNodes;
            var lineElementsIdx = 0;

            for (var row = config.firstRow; row < first; row++) {
                var foldLine = this.session.getFoldLine(row);
                if (foldLine) {
                    if (foldLine.containsRow(first)) {
                        first = foldLine.start.row;
                        break;
                    } else {
                        row = foldLine.end.row;
                    }
                }
                lineElementsIdx ++;
            }

            var heightChanged = false;
            var row = first;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;

            while (true) {
                if (row > foldStart) {
                    row = foldLine.end.row+1;
                    foldLine = this.session.getNextFoldLine(row, foldLine);
                    foldStart = foldLine ? foldLine.start.row :Infinity;
                }
                if (row > last)
                    break;

                var lineElement = lineElements[lineElementsIdx++];
                if (lineElement) {
                    this.dom.removeChildren(lineElement);
                    this.$renderLine(
                        lineElement, row, row == foldStart ? foldLine : false
                    );

                    if (heightChanged)
                        lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + "px";

                    var height = (config.lineHeight * this.session.getRowLength(row)) + "px";
                    if (lineElement.style.height != height) {
                        heightChanged = true;
                        lineElement.style.height = height;
                    }
                }
                row++;
            }
            if (heightChanged) {
                while (lineElementsIdx < this.$lines.cells.length) {
                    var cell = this.$lines.cells[lineElementsIdx++];
                    cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + "px";
                }
            }
        };

        this.scrollLines = function(config) {
            var oldConfig = this.config;
            this.config = config;

            if (this.$lines.pageChanged(oldConfig, config))
                return this.update(config);
                
            this.$lines.moveContainer(config);
            
            var lastRow = config.lastRow;
            var oldLastRow = oldConfig ? oldConfig.lastRow : -1;

            if (!oldConfig || oldLastRow < config.firstRow)
                return this.update(config);

            if (lastRow < oldConfig.firstRow)
                return this.update(config);

            if (!oldConfig || oldConfig.lastRow < config.firstRow)
                return this.update(config);

            if (config.lastRow < oldConfig.firstRow)
                return this.update(config);

            if (oldConfig.firstRow < config.firstRow)
                for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
                    this.$lines.shift();

            if (oldConfig.lastRow > config.lastRow)
                for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)
                    this.$lines.pop();

            if (config.firstRow < oldConfig.firstRow) {
                this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));
            }

            if (config.lastRow > oldConfig.lastRow) {
                this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));
            }
        };

        this.$renderLinesFragment = function(config, firstRow, lastRow) {
            var fragment = [];
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;

            while (true) {
                if (row > foldStart) {
                    row = foldLine.end.row+1;
                    foldLine = this.session.getNextFoldLine(row, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
                if (row > lastRow)
                    break;

                var line = this.$lines.createCell(row, config, this.session);
                
                var lineEl = line.element;
                this.dom.removeChildren(lineEl);
                dom.setStyle(lineEl.style, "height", this.$lines.computeLineHeight(row, config, this.session) + "px");
                dom.setStyle(lineEl.style, "top", this.$lines.computeLineTop(row, config, this.session) + "px");
                this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);

                if (this.$useLineGroups()) {
                    lineEl.className = "ace_line_group";
                } else {
                    lineEl.className = "ace_line";
                }
                fragment.push(line);

                row++;
            }
            return fragment;
        };

        this.update = function(config) {
            this.$lines.moveContainer(config);
            
            this.config = config;

            var firstRow = config.firstRow;
            var lastRow = config.lastRow;

            var lines = this.$lines;
            while (lines.getLength())
                lines.pop();
                
            lines.push(this.$renderLinesFragment(config, firstRow, lastRow));
        };

        this.$textToken = {
            "text": true,
            "rparen": true,
            "lparen": true
        };

        this.$renderToken = function(parent, screenColumn, token, value) {
            var self = this;
            var re = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g;
            
            var valueFragment = this.dom.createFragment(this.element);

            var m;
            var i = 0;
            while (m = re.exec(value)) {
                var tab = m[1];
                var simpleSpace = m[2];
                var controlCharacter = m[3];
                var cjkSpace = m[4];
                var cjk = m[5];
                
                if (!self.showSpaces && simpleSpace)
                    continue;

                var before = i != m.index ? value.slice(i, m.index) : "";

                i = m.index + m[0].length;
                
                if (before) {
                    valueFragment.appendChild(this.dom.createTextNode(before, this.element));
                }
                    
                if (tab) {
                    var tabSize = self.session.getScreenTabSize(screenColumn + m.index);
                    valueFragment.appendChild(self.$tabStrings[tabSize].cloneNode(true));
                    screenColumn += tabSize - 1;
                } else if (simpleSpace) {
                    if (self.showSpaces) {
                        var span = this.dom.createElement("span");
                        span.className = "ace_invisible ace_invisible_space";
                        span.textContent = lang.stringRepeat(self.SPACE_CHAR, simpleSpace.length);
                        valueFragment.appendChild(span);
                    } else {
                        valueFragment.appendChild(this.com.createTextNode(simpleSpace, this.element));
                    }
                } else if (controlCharacter) {
                    var span = this.dom.createElement("span");
                    span.className = "ace_invisible ace_invisible_space ace_invalid";
                    span.textContent = lang.stringRepeat(self.SPACE_CHAR, controlCharacter.length);
                    valueFragment.appendChild(span);
                } else if (cjkSpace) {
                    screenColumn += 1;
                    
                    var span = this.dom.createElement("span");
                    span.style.width = (self.config.characterWidth * 2) + "px";
                    span.className = self.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                    span.textContent = self.showSpaces ? self.SPACE_CHAR : cjkSpace;
                    valueFragment.appendChild(span);
                } else if (cjk) {
                    screenColumn += 1;
                    var span = this.dom.createElement("span");
                    span.style.width = (self.config.characterWidth * 2) + "px";
                    span.className = "ace_cjk";
                    span.textContent = cjk;
                    valueFragment.appendChild(span);
                }
            }
            
            valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));

            if (!this.$textToken[token.type]) {
                var classes = "ace_" + token.type.replace(/\./g, " ace_");
                var span = this.dom.createElement("span");
                if (token.type == "fold")
                    span.style.width = (token.value.length * this.config.characterWidth) + "px";
                    
                span.className = classes;
                span.appendChild(valueFragment);
                
                parent.appendChild(span);
            }
            else {
                parent.appendChild(valueFragment);
            }
            
            return screenColumn + value.length;
        };

        this.renderIndentGuide = function(parent, value, max) {
            var cols = value.search(this.$indentGuideRe);
            if (cols <= 0 || cols >= max)
                return value;
            if (value[0] == " ") {
                cols -= cols % this.tabSize;
                var count = cols/this.tabSize;
                for (var i=0; i<count; i++) {
                    parent.appendChild(this.$tabStrings[" "].cloneNode(true));
                }
                return value.substr(cols);
            } else if (value[0] == "\t") {
                for (var i=0; i<cols; i++) {
                    parent.appendChild(this.$tabStrings["\t"].cloneNode(true));
                }
                return value.substr(cols);
            }
            return value;
        };

        this.$createLineElement = function(parent) {
            var lineEl = this.dom.createElement("div");
            lineEl.className = "ace_line";
            lineEl.style.height = this.config.lineHeight + "px";
            
            return lineEl;
        };

        this.$renderWrappedLine = function(parent, tokens, splits) {
            var chars = 0;
            var split = 0;
            var splitChars = splits[0];
            var screenColumn = 0;

            var lineEl = this.$createLineElement();
            parent.appendChild(lineEl);
            
            for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                var value = token.value;
                if (i == 0 && this.displayIndentGuides) {
                    chars = value.length;
                    value = this.renderIndentGuide(lineEl, value, splitChars);
                    if (!value)
                        continue;
                    chars -= value.length;
                }

                if (chars + value.length < splitChars) {
                    screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                    chars += value.length;
                } else {
                    while (chars + value.length >= splitChars) {
                        screenColumn = this.$renderToken(
                            lineEl, screenColumn,
                            token, value.substring(0, splitChars - chars)
                        );
                        value = value.substring(splitChars - chars);
                        chars = splitChars;

                        lineEl = this.$createLineElement();
                        parent.appendChild(lineEl);

                        lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat("\xa0", splits.indent), this.element));

                        split ++;
                        screenColumn = 0;
                        splitChars = splits[split] || Number.MAX_VALUE;
                    }
                    if (value.length != 0) {
                        chars += value.length;
                        screenColumn = this.$renderToken(
                            lineEl, screenColumn, token, value
                        );
                    }
                }
            }
            
            if (splits[splits.length - 1] > this.MAX_LINE_LENGTH)
                this.$renderOverflowMessage(lineEl, screenColumn, null, "", true);
        };

        this.$renderSimpleLine = function(parent, tokens) {
            var screenColumn = 0;
            var token = tokens[0];
            var value = token.value;
            if (this.displayIndentGuides)
                value = this.renderIndentGuide(parent, value);
            if (value)
                screenColumn = this.$renderToken(parent, screenColumn, token, value);
            for (var i = 1; i < tokens.length; i++) {
                token = tokens[i];
                value = token.value;
                if (screenColumn + value.length > this.MAX_LINE_LENGTH)
                    return this.$renderOverflowMessage(parent, screenColumn, token, value);
                screenColumn = this.$renderToken(parent, screenColumn, token, value);
            }
        };
        
        this.$renderOverflowMessage = function(parent, screenColumn, token, value, hide) {
            token && this.$renderToken(parent, screenColumn, token,
                value.slice(0, this.MAX_LINE_LENGTH - screenColumn));
                
            var overflowEl = this.dom.createElement("span");
            overflowEl.className = "ace_inline_button ace_keyword ace_toggle_wrap";
            overflowEl.textContent = hide ? "<hide>" : "<click to see more...>";
            
            parent.appendChild(overflowEl);        
        };
        this.$renderLine = function(parent, row, foldLine) {
            if (!foldLine && foldLine != false)
                foldLine = this.session.getFoldLine(row);

            if (foldLine)
                var tokens = this.$getFoldLineTokens(row, foldLine);
            else
                var tokens = this.session.getTokens(row);

            var lastLineEl = parent;
            if (tokens.length) {
                var splits = this.session.getRowSplitData(row);
                if (splits && splits.length) {
                    this.$renderWrappedLine(parent, tokens, splits);
                    var lastLineEl = parent.lastChild;
                } else {
                    var lastLineEl = parent;
                    if (this.$useLineGroups()) {
                        lastLineEl = this.$createLineElement();
                        parent.appendChild(lastLineEl);
                    }
                    this.$renderSimpleLine(lastLineEl, tokens);
                }
            } else if (this.$useLineGroups()) {
                lastLineEl = this.$createLineElement();
                parent.appendChild(lastLineEl);
            }

            if (this.showEOL && lastLineEl) {
                if (foldLine)
                    row = foldLine.end.row;

                var invisibleEl = this.dom.createElement("span");
                invisibleEl.className = "ace_invisible ace_invisible_eol";
                invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;
                
                lastLineEl.appendChild(invisibleEl);
            }
        };

        this.$getFoldLineTokens = function(row, foldLine) {
            var session = this.session;
            var renderTokens = [];

            function addTokens(tokens, from, to) {
                var idx = 0, col = 0;
                while ((col + tokens[idx].value.length) < from) {
                    col += tokens[idx].value.length;
                    idx++;

                    if (idx == tokens.length)
                        return;
                }
                if (col != from) {
                    var value = tokens[idx].value.substring(from - col);
                    if (value.length > (to - from))
                        value = value.substring(0, to - from);

                    renderTokens.push({
                        type: tokens[idx].type,
                        value: value
                    });

                    col = from + value.length;
                    idx += 1;
                }

                while (col < to && idx < tokens.length) {
                    var value = tokens[idx].value;
                    if (value.length + col > to) {
                        renderTokens.push({
                            type: tokens[idx].type,
                            value: value.substring(0, to - col)
                        });
                    } else
                        renderTokens.push(tokens[idx]);
                    col += value.length;
                    idx += 1;
                }
            }

            var tokens = session.getTokens(row);
            foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
                if (placeholder != null) {
                    renderTokens.push({
                        type: "fold",
                        value: placeholder
                    });
                } else {
                    if (isNewRow)
                        tokens = session.getTokens(row);

                    if (tokens.length)
                        addTokens(tokens, lastColumn, column);
                }
            }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);

            return renderTokens;
        };

        this.$useLineGroups = function() {
            return this.session.getUseWrapMode();
        };

        this.destroy = function() {};
    }).call(Text.prototype);

    exports.Text = Text;

    });

    ace.define("ace/layer/cursor",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

    var dom = require("../lib/dom");

    var Cursor = function(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_cursor-layer";
        parentEl.appendChild(this.element);
        
        this.isVisible = false;
        this.isBlinking = true;
        this.blinkInterval = 1000;
        this.smoothBlinking = false;

        this.cursors = [];
        this.cursor = this.addCursor();
        dom.addCssClass(this.element, "ace_hidden-cursors");
        this.$updateCursors = this.$updateOpacity.bind(this);
    };

    (function() {
        
        this.$updateOpacity = function(val) {
            var cursors = this.cursors;
            for (var i = cursors.length; i--; )
                dom.setStyle(cursors[i].style, "opacity", val ? "" : "0");
        };

        this.$startCssAnimation = function() {
            var cursors = this.cursors;
            for (var i = cursors.length; i--; )
                cursors[i].style.animationDuration = this.blinkInterval + "ms";

            setTimeout(function() {
                dom.addCssClass(this.element, "ace_animate-blinking");
            }.bind(this));
        };
        
        this.$stopCssAnimation = function() {
            dom.removeCssClass(this.element, "ace_animate-blinking");
        };

        this.$padding = 0;
        this.setPadding = function(padding) {
            this.$padding = padding;
        };

        this.setSession = function(session) {
            this.session = session;
        };

        this.setBlinking = function(blinking) {
            if (blinking != this.isBlinking) {
                this.isBlinking = blinking;
                this.restartTimer();
            }
        };

        this.setBlinkInterval = function(blinkInterval) {
            if (blinkInterval != this.blinkInterval) {
                this.blinkInterval = blinkInterval;
                this.restartTimer();
            }
        };

        this.setSmoothBlinking = function(smoothBlinking) {
            if (smoothBlinking != this.smoothBlinking) {
                this.smoothBlinking = smoothBlinking;
                dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
                this.$updateCursors(true);
                this.restartTimer();
            }
        };

        this.addCursor = function() {
            var el = dom.createElement("div");
            el.className = "ace_cursor";
            this.element.appendChild(el);
            this.cursors.push(el);
            return el;
        };

        this.removeCursor = function() {
            if (this.cursors.length > 1) {
                var el = this.cursors.pop();
                el.parentNode.removeChild(el);
                return el;
            }
        };

        this.hideCursor = function() {
            this.isVisible = false;
            dom.addCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
        };

        this.showCursor = function() {
            this.isVisible = true;
            dom.removeCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
        };

        this.restartTimer = function() {
            var update = this.$updateCursors;
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
            this.$stopCssAnimation();

            if (this.smoothBlinking) {
                dom.removeCssClass(this.element, "ace_smooth-blinking");
            }
            
            update(true);

            if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
                this.$stopCssAnimation();
                return;
            }

            if (this.smoothBlinking) {
                setTimeout(function(){
                    dom.addCssClass(this.element, "ace_smooth-blinking");
                }.bind(this));
            }
            
            if (dom.HAS_CSS_ANIMATION) {
                this.$startCssAnimation();
            } else {
                var blink = function(){
                    this.timeoutId = setTimeout(function() {
                        update(false);
                    }, 0.6 * this.blinkInterval);
                }.bind(this);
        
                this.intervalId = setInterval(function() {
                    update(true);
                    blink();
                }, this.blinkInterval);
                blink();
            }
        };

        this.getPixelPosition = function(position, onScreen) {
            if (!this.config || !this.session)
                return {left : 0, top : 0};

            if (!position)
                position = this.session.selection.getCursor();
            var pos = this.session.documentToScreenPosition(position);
            var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row)
                ? this.session.$bidiHandler.getPosLeft(pos.column)
                : pos.column * this.config.characterWidth);

            var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
                this.config.lineHeight;

            return {left : cursorLeft, top : cursorTop};
        };

        this.isCursorInView = function(pixelPos, config) {
            return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;
        };

        this.update = function(config) {
            this.config = config;

            var selections = this.session.$selectionMarkers;
            var i = 0, cursorIndex = 0;

            if (selections === undefined || selections.length === 0){
                selections = [{cursor: null}];
            }

            for (var i = 0, n = selections.length; i < n; i++) {
                var pixelPos = this.getPixelPosition(selections[i].cursor, true);
                if ((pixelPos.top > config.height + config.offset ||
                     pixelPos.top < 0) && i > 1) {
                    continue;
                }

                var element = this.cursors[cursorIndex++] || this.addCursor();
                var style = element.style;
                
                if (!this.drawCursor) {
                    if (!this.isCursorInView(pixelPos, config)) {
                        dom.setStyle(style, "display", "none");
                    } else {
                        dom.setStyle(style, "display", "block");
                        dom.translate(element, pixelPos.left, pixelPos.top);
                        dom.setStyle(style, "width", Math.round(config.characterWidth) + "px");
                        dom.setStyle(style, "height", config.lineHeight + "px");
                    }
                } else {
                    this.drawCursor(element, pixelPos, config, selections[i], this.session);
                }
            }
            while (this.cursors.length > cursorIndex)
                this.removeCursor();

            var overwrite = this.session.getOverwrite();
            this.$setOverwrite(overwrite);
            this.$pixelPos = pixelPos;
            this.restartTimer();
        };
        
        this.drawCursor = null;

        this.$setOverwrite = function(overwrite) {
            if (overwrite != this.overwrite) {
                this.overwrite = overwrite;
                if (overwrite)
                    dom.addCssClass(this.element, "ace_overwrite-cursors");
                else
                    dom.removeCssClass(this.element, "ace_overwrite-cursors");
            }
        };

        this.destroy = function() {
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
        };

    }).call(Cursor.prototype);

    exports.Cursor = Cursor;

    });

    ace.define("ace/scrollbar",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/event","ace/lib/event_emitter"], function(require, exports, module) {

    var oop = require("./lib/oop");
    var dom = require("./lib/dom");
    var event = require("./lib/event");
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var MAX_SCROLL_H = 0x8000;
    var ScrollBar = function(parent) {
        this.element = dom.createElement("div");
        this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;

        this.inner = dom.createElement("div");
        this.inner.className = "ace_scrollbar-inner";
        this.inner.textContent = "\xa0";
        this.element.appendChild(this.inner);

        parent.appendChild(this.element);

        this.setVisible(false);
        this.skipEvent = false;

        event.addListener(this.element, "scroll", this.onScroll.bind(this));
        event.addListener(this.element, "mousedown", event.preventDefault);
    };

    (function() {
        oop.implement(this, EventEmitter);

        this.setVisible = function(isVisible) {
            this.element.style.display = isVisible ? "" : "none";
            this.isVisible = isVisible;
            this.coeff = 1;
        };
    }).call(ScrollBar.prototype);
    var VScrollBar = function(parent, renderer) {
        ScrollBar.call(this, parent);
        this.scrollTop = 0;
        this.scrollHeight = 0;
        renderer.$scrollbarWidth = 
        this.width = dom.scrollbarWidth(parent.ownerDocument);
        this.inner.style.width =
        this.element.style.width = (this.width || 15) + 5 + "px";
        this.$minWidth = 0;
    };

    oop.inherits(VScrollBar, ScrollBar);

    (function() {

        this.classSuffix = '-v';
        this.onScroll = function() {
            if (!this.skipEvent) {
                this.scrollTop = this.element.scrollTop;
                if (this.coeff != 1) {
                    var h = this.element.clientHeight / this.scrollHeight;
                    this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
                }
                this._emit("scroll", {data: this.scrollTop});
            }
            this.skipEvent = false;
        };
        this.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
        };
        this.setHeight = function(height) {
            this.element.style.height = height + "px";
        };
        this.setInnerHeight = 
        this.setScrollHeight = function(height) {
            this.scrollHeight = height;
            if (height > MAX_SCROLL_H) {
                this.coeff = MAX_SCROLL_H / height;
                height = MAX_SCROLL_H;
            } else if (this.coeff != 1) {
                this.coeff = 1;
            }
            this.inner.style.height = height + "px";
        };
        this.setScrollTop = function(scrollTop) {
            if (this.scrollTop != scrollTop) {
                this.skipEvent = true;
                this.scrollTop = scrollTop;
                this.element.scrollTop = scrollTop * this.coeff;
            }
        };

    }).call(VScrollBar.prototype);
    var HScrollBar = function(parent, renderer) {
        ScrollBar.call(this, parent);
        this.scrollLeft = 0;
        this.height = renderer.$scrollbarWidth;
        this.inner.style.height =
        this.element.style.height = (this.height || 15) + 5 + "px";
    };

    oop.inherits(HScrollBar, ScrollBar);

    (function() {

        this.classSuffix = '-h';
        this.onScroll = function() {
            if (!this.skipEvent) {
                this.scrollLeft = this.element.scrollLeft;
                this._emit("scroll", {data: this.scrollLeft});
            }
            this.skipEvent = false;
        };
        this.getHeight = function() {
            return this.isVisible ? this.height : 0;
        };
        this.setWidth = function(width) {
            this.element.style.width = width + "px";
        };
        this.setInnerWidth = function(width) {
            this.inner.style.width = width + "px";
        };
        this.setScrollWidth = function(width) {
            this.inner.style.width = width + "px";
        };
        this.setScrollLeft = function(scrollLeft) {
            if (this.scrollLeft != scrollLeft) {
                this.skipEvent = true;
                this.scrollLeft = this.element.scrollLeft = scrollLeft;
            }
        };

    }).call(HScrollBar.prototype);


    exports.ScrollBar = VScrollBar; // backward compatibility
    exports.ScrollBarV = VScrollBar; // backward compatibility
    exports.ScrollBarH = HScrollBar; // backward compatibility

    exports.VScrollBar = VScrollBar;
    exports.HScrollBar = HScrollBar;
    });

    ace.define("ace/renderloop",["require","exports","module","ace/lib/event"], function(require, exports, module) {

    var event = require("./lib/event");


    var RenderLoop = function(onRender, win) {
        this.onRender = onRender;
        this.pending = false;
        this.changes = 0;
        this.$recursionLimit = 2;
        this.window = win || window;
        var _self = this;
        this._flush = function(ts) {
            _self.pending = false;
            var changes = _self.changes;

            if (changes) {
                event.blockIdle(100);
                _self.changes = 0;
                _self.onRender(changes);
            }
            
            if (_self.changes) {
                if (_self.$recursionLimit-- < 0) return;
                _self.schedule();
            } else {
                _self.$recursionLimit = 2;
            }
        };
    };

    (function() {

        this.schedule = function(change) {
            this.changes = this.changes | change;
            if (this.changes && !this.pending) {
                event.nextFrame(this._flush);
                this.pending = true;
            }
        };

        this.clear = function(change) {
            var changes = this.changes;
            this.changes = 0;
            return changes;
        };

    }).call(RenderLoop.prototype);

    exports.RenderLoop = RenderLoop;
    });

    ace.define("ace/layer/font_metrics",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/event","ace/lib/useragent","ace/lib/event_emitter"], function(require, exports, module) {

    var oop = require("../lib/oop");
    var dom = require("../lib/dom");
    var lang = require("../lib/lang");
    var event = require("../lib/event");
    var useragent = require("../lib/useragent");
    var EventEmitter = require("../lib/event_emitter").EventEmitter;

    var CHAR_COUNT = 256;
    var USE_OBSERVER = typeof ResizeObserver == "function";
    var L = 200;

    var FontMetrics = exports.FontMetrics = function(parentEl) {
        this.el = dom.createElement("div");
        this.$setMeasureNodeStyles(this.el.style, true);
        
        this.$main = dom.createElement("div");
        this.$setMeasureNodeStyles(this.$main.style);
        
        this.$measureNode = dom.createElement("div");
        this.$setMeasureNodeStyles(this.$measureNode.style);
        
        
        this.el.appendChild(this.$main);
        this.el.appendChild(this.$measureNode);
        parentEl.appendChild(this.el);
        
        this.$measureNode.textContent = lang.stringRepeat("X", CHAR_COUNT);
        
        this.$characterSize = {width: 0, height: 0};
        
        
        if (USE_OBSERVER)
            this.$addObserver();
        else
            this.checkForSizeChanges();
    };

    (function() {

        oop.implement(this, EventEmitter);
            
        this.$characterSize = {width: 0, height: 0};
        
        this.$setMeasureNodeStyles = function(style, isRoot) {
            style.width = style.height = "auto";
            style.left = style.top = "0px";
            style.visibility = "hidden";
            style.position = "absolute";
            style.whiteSpace = "pre";

            if (useragent.isIE < 8) {
                style["font-family"] = "inherit";
            } else {
                style.font = "inherit";
            }
            style.overflow = isRoot ? "hidden" : "visible";
        };

        this.checkForSizeChanges = function(size) {
            if (size === undefined)
                size = this.$measureSizes();
            if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
                this.$measureNode.style.fontWeight = "bold";
                var boldSize = this.$measureSizes();
                this.$measureNode.style.fontWeight = "";
                this.$characterSize = size;
                this.charSizes = Object.create(null);
                this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
                this._emit("changeCharacterSize", {data: size});
            }
        };
        
        this.$addObserver = function() {
            var self = this;
            this.$observer = new window.ResizeObserver(function(e) {
                self.checkForSizeChanges();
            });
            this.$observer.observe(this.$measureNode);
        };

        this.$pollSizeChanges = function() {
            if (this.$pollSizeChangesTimer || this.$observer)
                return this.$pollSizeChangesTimer;
            var self = this;
            
            return this.$pollSizeChangesTimer = event.onIdle(function cb() {
                self.checkForSizeChanges();
                event.onIdle(cb, 500);
            }, 500);
        };
        
        this.setPolling = function(val) {
            if (val) {
                this.$pollSizeChanges();
            } else if (this.$pollSizeChangesTimer) {
                clearInterval(this.$pollSizeChangesTimer);
                this.$pollSizeChangesTimer = 0;
            }
        };

        this.$measureSizes = function(node) {
            var size = {
                height: (node || this.$measureNode).clientHeight,
                width: (node || this.$measureNode).clientWidth / CHAR_COUNT
            };
            if (size.width === 0 || size.height === 0)
                return null;
            return size;
        };

        this.$measureCharWidth = function(ch) {
            this.$main.textContent = lang.stringRepeat(ch, CHAR_COUNT);
            var rect = this.$main.getBoundingClientRect();
            return rect.width / CHAR_COUNT;
        };
        
        this.getCharacterWidth = function(ch) {
            var w = this.charSizes[ch];
            if (w === undefined) {
                w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
            }
            return w;
        };

        this.destroy = function() {
            clearInterval(this.$pollSizeChangesTimer);
            if (this.$observer)
                this.$observer.disconnect();
            if (this.el && this.el.parentNode)
                this.el.parentNode.removeChild(this.el);
        };

        
        this.$getZoom = function getZoom(element) {
            if (!element || !element.parentElement) return 1;
            return (window.getComputedStyle(element).zoom || 1) * getZoom(element.parentElement);
        };
        this.$initTransformMeasureNodes = function() {
            var t = function(t, l) {
                return ["div", {
                    style: "position: absolute;top:" + t + "px;left:" + l + "px;"
                }];
            };
            this.els = dom.buildDom([t(0, 0), t(L, 0), t(0, L), t(L, L)], this.el);
        };
        this.transformCoordinates = function(clientPos, elPos) {
            if (clientPos) {
                var zoom = this.$getZoom(this.el);
                clientPos = mul(1 / zoom, clientPos);
            }
            function solve(l1, l2, r) {
                var det = l1[1] * l2[0] - l1[0] * l2[1];
                return [
                    (-l2[1] * r[0] + l2[0] * r[1]) / det,
                    (+l1[1] * r[0] - l1[0] * r[1]) / det
                ];
            }
            function sub(a, b) { return [a[0] - b[0], a[1] - b[1]]; }
            function add(a, b) { return [a[0] + b[0], a[1] + b[1]]; }
            function mul(a, b) { return [a * b[0], a * b[1]]; }

            if (!this.els)
                this.$initTransformMeasureNodes();
            
            function p(el) {
                var r = el.getBoundingClientRect();
                return [r.left, r.top];
            }

            var a = p(this.els[0]);
            var b = p(this.els[1]);
            var c = p(this.els[2]);
            var d = p(this.els[3]);

            var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));

            var m1 = mul(1 + h[0], sub(b, a));
            var m2 = mul(1 + h[1], sub(c, a));
            
            if (elPos) {
                var x = elPos;
                var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;
                var ut = add(mul(x[0], m1), mul(x[1], m2));
                return  add(mul(1 / k / L, ut), a);
            }
            var u = sub(clientPos, a);
            var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);
            return mul(L, f);
        };
        
    }).call(FontMetrics.prototype);

    });

    ace.define("ace/virtual_renderer",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/config","ace/layer/gutter","ace/layer/marker","ace/layer/text","ace/layer/cursor","ace/scrollbar","ace/scrollbar","ace/renderloop","ace/layer/font_metrics","ace/lib/event_emitter","ace/lib/useragent"], function(require, exports, module) {

    var oop = require("./lib/oop");
    var dom = require("./lib/dom");
    var config = require("./config");
    var GutterLayer = require("./layer/gutter").Gutter;
    var MarkerLayer = require("./layer/marker").Marker;
    var TextLayer = require("./layer/text").Text;
    var CursorLayer = require("./layer/cursor").Cursor;
    var HScrollBar = require("./scrollbar").HScrollBar;
    var VScrollBar = require("./scrollbar").VScrollBar;
    var RenderLoop = require("./renderloop").RenderLoop;
    var FontMetrics = require("./layer/font_metrics").FontMetrics;
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var editorCss = "\
.ace_br1 {border-top-left-radius    : 3px;}\
.ace_br2 {border-top-right-radius   : 3px;}\
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\
.ace_br4 {border-bottom-right-radius: 3px;}\
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\
.ace_br8 {border-bottom-left-radius : 3px;}\
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\
.ace_editor {\
position: relative;\
overflow: hidden;\
padding: 0;\
font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
direction: ltr;\
text-align: left;\
-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\
}\
.ace_scroller {\
position: absolute;\
overflow: hidden;\
top: 0;\
bottom: 0;\
background-color: inherit;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
cursor: text;\
}\
.ace_content {\
position: absolute;\
box-sizing: border-box;\
min-width: 100%;\
contain: style size layout;\
font-variant-ligatures: no-common-ligatures;\
}\
.ace_dragging .ace_scroller:before{\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
bottom: 0;\
content: '';\
background: rgba(250, 250, 250, 0.01);\
z-index: 1000;\
}\
.ace_dragging.ace_dark .ace_scroller:before{\
background: rgba(0, 0, 0, 0.01);\
}\
.ace_selecting, .ace_selecting * {\
cursor: text !important;\
}\
.ace_gutter {\
position: absolute;\
overflow : hidden;\
width: auto;\
top: 0;\
bottom: 0;\
left: 0;\
cursor: default;\
z-index: 4;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
contain: style size layout;\
}\
.ace_gutter-active-line {\
position: absolute;\
left: 0;\
right: 0;\
}\
.ace_scroller.ace_scroll-left {\
box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
}\
.ace_gutter-cell {\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
padding-left: 19px;\
padding-right: 6px;\
background-repeat: no-repeat;\
}\
.ace_gutter-cell.ace_error {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_warning {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\
background-position: 2px center;\
}\
.ace_dark .ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\
}\
.ace_scrollbar {\
contain: strict;\
position: absolute;\
right: 0;\
bottom: 0;\
z-index: 6;\
}\
.ace_scrollbar-inner {\
position: absolute;\
cursor: text;\
left: 0;\
top: 0;\
}\
.ace_scrollbar-v{\
overflow-x: hidden;\
overflow-y: scroll;\
top: 0;\
}\
.ace_scrollbar-h {\
overflow-x: scroll;\
overflow-y: hidden;\
left: 0;\
}\
.ace_print-margin {\
position: absolute;\
height: 100%;\
}\
.ace_text-input {\
position: absolute;\
z-index: 0;\
width: 0.5em;\
height: 1em;\
opacity: 0;\
background: transparent;\
-moz-appearance: none;\
appearance: none;\
border: none;\
resize: none;\
outline: none;\
overflow: hidden;\
font: inherit;\
padding: 0 1px;\
margin: 0 -1px;\
contain: strict;\
-ms-user-select: text;\
-moz-user-select: text;\
-webkit-user-select: text;\
user-select: text;\
white-space: pre!important;\
}\
.ace_text-input.ace_composition {\
background: transparent;\
color: inherit;\
z-index: 1000;\
opacity: 1;\
}\
.ace_composition_placeholder { color: transparent }\
.ace_composition_marker { \
border-bottom: 1px solid;\
position: absolute;\
border-radius: 0;\
margin-top: 1px;\
}\
[ace_nocontext=true] {\
transform: none!important;\
filter: none!important;\
clip-path: none!important;\
mask : none!important;\
contain: none!important;\
perspective: none!important;\
mix-blend-mode: initial!important;\
z-index: auto;\
}\
.ace_layer {\
z-index: 1;\
position: absolute;\
overflow: hidden;\
word-wrap: normal;\
white-space: pre;\
height: 100%;\
width: 100%;\
box-sizing: border-box;\
pointer-events: none;\
}\
.ace_gutter-layer {\
position: relative;\
width: auto;\
text-align: right;\
pointer-events: auto;\
height: 1000000px;\
contain: style size layout;\
}\
.ace_text-layer {\
font: inherit !important;\
position: absolute;\
height: 1000000px;\
width: 1000000px;\
contain: style size layout;\
}\
.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {\
contain: style size layout;\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
}\
.ace_hidpi .ace_text-layer,\
.ace_hidpi .ace_gutter-layer,\
.ace_hidpi .ace_content,\
.ace_hidpi .ace_gutter {\
contain: strict;\
will-change: transform;\
}\
.ace_hidpi .ace_text-layer > .ace_line, \
.ace_hidpi .ace_text-layer > .ace_line_group {\
contain: strict;\
}\
.ace_cjk {\
display: inline-block;\
text-align: center;\
}\
.ace_cursor-layer {\
z-index: 4;\
}\
.ace_cursor {\
z-index: 4;\
position: absolute;\
box-sizing: border-box;\
border-left: 2px solid;\
transform: translatez(0);\
}\
.ace_multiselect .ace_cursor {\
border-left-width: 1px;\
}\
.ace_slim-cursors .ace_cursor {\
border-left-width: 1px;\
}\
.ace_overwrite-cursors .ace_cursor {\
border-left-width: 0;\
border-bottom: 1px solid;\
}\
.ace_hidden-cursors .ace_cursor {\
opacity: 0.2;\
}\
.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {\
opacity: 0;\
}\
.ace_smooth-blinking .ace_cursor {\
transition: opacity 0.18s;\
}\
.ace_animate-blinking .ace_cursor {\
animation-duration: 1000ms;\
animation-timing-function: step-end;\
animation-name: blink-ace-animate;\
animation-iteration-count: infinite;\
}\
.ace_animate-blinking.ace_smooth-blinking .ace_cursor {\
animation-duration: 1000ms;\
animation-timing-function: ease-in-out;\
animation-name: blink-ace-animate-smooth;\
}\
@keyframes blink-ace-animate {\
from, to { opacity: 1; }\
60% { opacity: 0; }\
}\
@keyframes blink-ace-animate-smooth {\
from, to { opacity: 1; }\
45% { opacity: 1; }\
60% { opacity: 0; }\
85% { opacity: 0; }\
}\
.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
position: absolute;\
z-index: 3;\
}\
.ace_marker-layer .ace_selection {\
position: absolute;\
z-index: 5;\
}\
.ace_marker-layer .ace_bracket {\
position: absolute;\
z-index: 6;\
}\
.ace_marker-layer .ace_error_bracket {\
position: absolute;\
border-bottom: 1px solid #DE5555;\
border-radius: 0;\
}\
.ace_marker-layer .ace_active-line {\
position: absolute;\
z-index: 2;\
}\
.ace_marker-layer .ace_selected-word {\
position: absolute;\
z-index: 4;\
box-sizing: border-box;\
}\
.ace_line .ace_fold {\
box-sizing: border-box;\
display: inline-block;\
height: 11px;\
margin-top: -2px;\
vertical-align: middle;\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\
background-repeat: no-repeat, repeat-x;\
background-position: center center, top left;\
color: transparent;\
border: 1px solid black;\
border-radius: 2px;\
cursor: pointer;\
pointer-events: auto;\
}\
.ace_dark .ace_fold {\
}\
.ace_fold:hover{\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\
}\
.ace_tooltip {\
background-color: #FFF;\
background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
border: 1px solid gray;\
border-radius: 1px;\
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
color: black;\
max-width: 100%;\
padding: 3px 4px;\
position: fixed;\
z-index: 999999;\
box-sizing: border-box;\
cursor: default;\
white-space: pre;\
word-wrap: break-word;\
line-height: normal;\
font-style: normal;\
font-weight: normal;\
letter-spacing: normal;\
pointer-events: none;\
}\
.ace_folding-enabled > .ace_gutter-cell {\
padding-right: 13px;\
}\
.ace_fold-widget {\
box-sizing: border-box;\
margin: 0 -12px 0 1px;\
display: none;\
width: 11px;\
vertical-align: top;\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: center;\
border-radius: 3px;\
border: 1px solid transparent;\
cursor: pointer;\
}\
.ace_folding-enabled .ace_fold-widget {\
display: inline-block;   \
}\
.ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\
}\
.ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\
}\
.ace_fold-widget:hover {\
border: 1px solid rgba(0, 0, 0, 0.3);\
background-color: rgba(255, 255, 255, 0.2);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
}\
.ace_fold-widget:active {\
border: 1px solid rgba(0, 0, 0, 0.4);\
background-color: rgba(0, 0, 0, 0.05);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
}\
.ace_dark .ace_fold-widget {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
}\
.ace_dark .ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget:hover {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
background-color: rgba(255, 255, 255, 0.1);\
}\
.ace_dark .ace_fold-widget:active {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
}\
.ace_inline_button {\
border: 1px solid lightgray;\
display: inline-block;\
margin: -1px 8px;\
padding: 0 5px;\
pointer-events: auto;\
cursor: pointer;\
}\
.ace_inline_button:hover {\
border-color: gray;\
background: rgba(200,200,200,0.2);\
display: inline-block;\
pointer-events: auto;\
}\
.ace_fold-widget.ace_invalid {\
background-color: #FFB4B4;\
border-color: #DE5555;\
}\
.ace_fade-fold-widgets .ace_fold-widget {\
transition: opacity 0.4s ease 0.05s;\
opacity: 0;\
}\
.ace_fade-fold-widgets:hover .ace_fold-widget {\
transition: opacity 0.05s ease 0.05s;\
opacity:1;\
}\
.ace_underline {\
text-decoration: underline;\
}\
.ace_bold {\
font-weight: bold;\
}\
.ace_nobold .ace_bold {\
font-weight: normal;\
}\
.ace_italic {\
font-style: italic;\
}\
.ace_error-marker {\
background-color: rgba(255, 0, 0,0.2);\
position: absolute;\
z-index: 9;\
}\
.ace_highlight-marker {\
background-color: rgba(255, 255, 0,0.2);\
position: absolute;\
z-index: 8;\
}\
.ace_mobile-menu {\
position: absolute;\
line-height: 1.5;\
border-radius: 4px;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
background: white;\
box-shadow: 1px 3px 2px grey;\
border: 1px solid #dcdcdc;\
color: black;\
}\
.ace_dark > .ace_mobile-menu {\
background: #333;\
color: #ccc;\
box-shadow: 1px 3px 2px grey;\
border: 1px solid #444;\
}\
.ace_mobile-button {\
padding: 2px;\
cursor: pointer;\
overflow: hidden;\
}\
.ace_mobile-button:hover {\
background-color: #eee;\
opacity:1;\
}\
.ace_mobile-button:active {\
background-color: #ddd;\
}\
.ace_placeholder {\
font-family: arial;\
transform: scale(0.9);\
transform-origin: left;\
white-space: pre;\
opacity: 0.7;\
margin: 0 10px;\
}";

    var useragent = require("./lib/useragent");
    var HIDE_TEXTAREA = useragent.isIE;

    dom.importCssString(editorCss, "ace_editor.css");

    var VirtualRenderer = function(container, theme) {
        var _self = this;

        this.container = container || dom.createElement("div");

        dom.addCssClass(this.container, "ace_editor");
        if (dom.HI_DPI) dom.addCssClass(this.container, "ace_hidpi");

        this.setTheme(theme);

        this.$gutter = dom.createElement("div");
        this.$gutter.className = "ace_gutter";
        this.container.appendChild(this.$gutter);
        this.$gutter.setAttribute("aria-hidden", true);

        this.scroller = dom.createElement("div");
        this.scroller.className = "ace_scroller";
        
        this.container.appendChild(this.scroller);

        this.content = dom.createElement("div");
        this.content.className = "ace_content";
        this.scroller.appendChild(this.content);

        this.$gutterLayer = new GutterLayer(this.$gutter);
        this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));

        this.$markerBack = new MarkerLayer(this.content);

        var textLayer = this.$textLayer = new TextLayer(this.content);
        this.canvas = textLayer.element;

        this.$markerFront = new MarkerLayer(this.content);

        this.$cursorLayer = new CursorLayer(this.content);
        this.$horizScroll = false;
        this.$vScroll = false;

        this.scrollBar = 
        this.scrollBarV = new VScrollBar(this.container, this);
        this.scrollBarH = new HScrollBar(this.container, this);
        this.scrollBarV.on("scroll", function(e) {
            if (!_self.$scrollAnimation)
                _self.session.setScrollTop(e.data - _self.scrollMargin.top);
        });
        this.scrollBarH.on("scroll", function(e) {
            if (!_self.$scrollAnimation)
                _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
        });

        this.scrollTop = 0;
        this.scrollLeft = 0;

        this.cursorPos = {
            row : 0,
            column : 0
        };

        this.$fontMetrics = new FontMetrics(this.container);
        this.$textLayer.$setFontMetrics(this.$fontMetrics);
        this.$textLayer.on("changeCharacterSize", function(e) {
            _self.updateCharacterSize();
            _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
            _self._signal("changeCharacterSize", e);
        });

        this.$size = {
            width: 0,
            height: 0,
            scrollerHeight: 0,
            scrollerWidth: 0,
            $dirty: true
        };

        this.layerConfig = {
            width : 1,
            padding : 0,
            firstRow : 0,
            firstRowScreen: 0,
            lastRow : 0,
            lineHeight : 0,
            characterWidth : 0,
            minHeight : 1,
            maxHeight : 1,
            offset : 0,
            height : 1,
            gutterOffset: 1
        };
        
        this.scrollMargin = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            v: 0,
            h: 0
        };
        
        this.margin = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            v: 0,
            h: 0
        };
        
        this.$keepTextAreaAtCursor = !useragent.isIOS;

        this.$loop = new RenderLoop(
            this.$renderChanges.bind(this),
            this.container.ownerDocument.defaultView
        );
        this.$loop.schedule(this.CHANGE_FULL);

        this.updateCharacterSize();
        this.setPadding(4);
        config.resetOptions(this);
        config._signal("renderer", this);
    };

    (function() {

        this.CHANGE_CURSOR = 1;
        this.CHANGE_MARKER = 2;
        this.CHANGE_GUTTER = 4;
        this.CHANGE_SCROLL = 8;
        this.CHANGE_LINES = 16;
        this.CHANGE_TEXT = 32;
        this.CHANGE_SIZE = 64;
        this.CHANGE_MARKER_BACK = 128;
        this.CHANGE_MARKER_FRONT = 256;
        this.CHANGE_FULL = 512;
        this.CHANGE_H_SCROLL = 1024;

        oop.implement(this, EventEmitter);

        this.updateCharacterSize = function() {
            if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
                this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
                this.setStyle("ace_nobold", !this.$allowBoldFonts);
            }

            this.layerConfig.characterWidth =
            this.characterWidth = this.$textLayer.getCharacterWidth();
            this.layerConfig.lineHeight =
            this.lineHeight = this.$textLayer.getLineHeight();
            this.$updatePrintMargin();
            dom.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
        };
        this.setSession = function(session) {
            if (this.session)
                this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
                
            this.session = session;
            if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
                session.setScrollTop(-this.scrollMargin.top);

            this.$cursorLayer.setSession(session);
            this.$markerBack.setSession(session);
            this.$markerFront.setSession(session);
            this.$gutterLayer.setSession(session);
            this.$textLayer.setSession(session);
            if (!session)
                return;
            
            this.$loop.schedule(this.CHANGE_FULL);
            this.session.$setFontMetrics(this.$fontMetrics);
            this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
            
            this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
            this.onChangeNewLineMode();
            this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
        };
        this.updateLines = function(firstRow, lastRow, force) {
            if (lastRow === undefined)
                lastRow = Infinity;

            if (!this.$changedLines) {
                this.$changedLines = {
                    firstRow: firstRow,
                    lastRow: lastRow
                };
            }
            else {
                if (this.$changedLines.firstRow > firstRow)
                    this.$changedLines.firstRow = firstRow;

                if (this.$changedLines.lastRow < lastRow)
                    this.$changedLines.lastRow = lastRow;
            }
            if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
                if (force)
                    this.$changedLines.lastRow = this.layerConfig.lastRow;
                else
                    return;
            }
            if (this.$changedLines.firstRow > this.layerConfig.lastRow)
                return;
            this.$loop.schedule(this.CHANGE_LINES);
        };

        this.onChangeNewLineMode = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
            this.$textLayer.$updateEolChar();
            this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
        };
        
        this.onChangeTabSize = function() {
            this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
            this.$textLayer.onChangeTabSize();
        };
        this.updateText = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
        };
        this.updateFull = function(force) {
            if (force)
                this.$renderChanges(this.CHANGE_FULL, true);
            else
                this.$loop.schedule(this.CHANGE_FULL);
        };
        this.updateFontSize = function() {
            this.$textLayer.checkForSizeChanges();
        };

        this.$changes = 0;
        this.$updateSizeAsync = function() {
            if (this.$loop.pending)
                this.$size.$dirty = true;
            else
                this.onResize();
        };
        this.onResize = function(force, gutterWidth, width, height) {
            if (this.resizing > 2)
                return;
            else if (this.resizing > 0)
                this.resizing++;
            else
                this.resizing = force ? 1 : 0;
            var el = this.container;
            if (!height)
                height = el.clientHeight || el.scrollHeight;
            if (!width)
                width = el.clientWidth || el.scrollWidth;
            var changes = this.$updateCachedSize(force, gutterWidth, width, height);

            
            if (!this.$size.scrollerHeight || (!width && !height))
                return this.resizing = 0;

            if (force)
                this.$gutterLayer.$padding = null;

            if (force)
                this.$renderChanges(changes | this.$changes, true);
            else
                this.$loop.schedule(changes | this.$changes);

            if (this.resizing)
                this.resizing = 0;
            this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
        };
        
        this.$updateCachedSize = function(force, gutterWidth, width, height) {
            height -= (this.$extraHeight || 0);
            var changes = 0;
            var size = this.$size;
            var oldSize = {
                width: size.width,
                height: size.height,
                scrollerHeight: size.scrollerHeight,
                scrollerWidth: size.scrollerWidth
            };
            if (height && (force || size.height != height)) {
                size.height = height;
                changes |= this.CHANGE_SIZE;

                size.scrollerHeight = size.height;
                if (this.$horizScroll)
                    size.scrollerHeight -= this.scrollBarH.getHeight();
                this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";

                changes = changes | this.CHANGE_SCROLL;
            }

            if (width && (force || size.width != width)) {
                changes |= this.CHANGE_SIZE;
                size.width = width;
                
                if (gutterWidth == null)
                    gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
                
                this.gutterWidth = gutterWidth;
                
                dom.setStyle(this.scrollBarH.element.style, "left", gutterWidth + "px");
                dom.setStyle(this.scroller.style, "left", gutterWidth + this.margin.left + "px");
                size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);
                dom.setStyle(this.$gutter.style, "left", this.margin.left + "px");
                
                var right = this.scrollBarV.getWidth() + "px";
                dom.setStyle(this.scrollBarH.element.style, "right", right);
                dom.setStyle(this.scroller.style, "right", right);
                dom.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight());

                if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {
                    changes |= this.CHANGE_FULL;
                }
            }
            
            size.$dirty = !width || !height;

            if (changes)
                this._signal("resize", oldSize);

            return changes;
        };

        this.onGutterResize = function(width) {
            var gutterWidth = this.$showGutter ? width : 0;
            if (gutterWidth != this.gutterWidth)
                this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);

            if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
                this.$loop.schedule(this.CHANGE_FULL);
            } else if (this.$size.$dirty) {
                this.$loop.schedule(this.CHANGE_FULL);
            } else {
                this.$computeLayerConfig();
            }
        };
        this.adjustWrapLimit = function() {
            var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
            var limit = Math.floor(availableWidth / this.characterWidth);
            return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
        };
        this.setAnimatedScroll = function(shouldAnimate){
            this.setOption("animatedScroll", shouldAnimate);
        };
        this.getAnimatedScroll = function() {
            return this.$animatedScroll;
        };
        this.setShowInvisibles = function(showInvisibles) {
            this.setOption("showInvisibles", showInvisibles);
            this.session.$bidiHandler.setShowInvisibles(showInvisibles);
        };
        this.getShowInvisibles = function() {
            return this.getOption("showInvisibles");
        };
        this.getDisplayIndentGuides = function() {
            return this.getOption("displayIndentGuides");
        };

        this.setDisplayIndentGuides = function(display) {
            this.setOption("displayIndentGuides", display);
        };
        this.setShowPrintMargin = function(showPrintMargin) {
            this.setOption("showPrintMargin", showPrintMargin);
        };
        this.getShowPrintMargin = function() {
            return this.getOption("showPrintMargin");
        };
        this.setPrintMarginColumn = function(showPrintMargin) {
            this.setOption("printMarginColumn", showPrintMargin);
        };
        this.getPrintMarginColumn = function() {
            return this.getOption("printMarginColumn");
        };
        this.getShowGutter = function(){
            return this.getOption("showGutter");
        };
        this.setShowGutter = function(show){
            return this.setOption("showGutter", show);
        };

        this.getFadeFoldWidgets = function(){
            return this.getOption("fadeFoldWidgets");
        };

        this.setFadeFoldWidgets = function(show) {
            this.setOption("fadeFoldWidgets", show);
        };

        this.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
        };

        this.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
        };

        this.$updatePrintMargin = function() {
            if (!this.$showPrintMargin && !this.$printMarginEl)
                return;

            if (!this.$printMarginEl) {
                var containerEl = dom.createElement("div");
                containerEl.className = "ace_layer ace_print-margin-layer";
                this.$printMarginEl = dom.createElement("div");
                this.$printMarginEl.className = "ace_print-margin";
                containerEl.appendChild(this.$printMarginEl);
                this.content.insertBefore(containerEl, this.content.firstChild);
            }

            var style = this.$printMarginEl.style;
            style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px";
            style.visibility = this.$showPrintMargin ? "visible" : "hidden";
            
            if (this.session && this.session.$wrap == -1)
                this.adjustWrapLimit();
        };
        this.getContainerElement = function() {
            return this.container;
        };
        this.getMouseEventTarget = function() {
            return this.scroller;
        };
        this.getTextAreaContainer = function() {
            return this.container;
        };
        this.$moveTextAreaToCursor = function() {
            if (this.$isMousePressed) return;
            var style = this.textarea.style;
            var composition = this.$composition;
            if (!this.$keepTextAreaAtCursor && !composition) {
                dom.translate(this.textarea, -100, 0);
                return;
            }
            var pixelPos = this.$cursorLayer.$pixelPos;
            if (!pixelPos)
                return;
            if (composition && composition.markerRange)
                pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);
            
            var config = this.layerConfig;
            var posTop = pixelPos.top;
            var posLeft = pixelPos.left;
            posTop -= config.offset;

            var h = composition && composition.useTextareaForIME ? this.lineHeight : HIDE_TEXTAREA ? 0 : 1;
            if (posTop < 0 || posTop > config.height - h) {
                dom.translate(this.textarea, 0, 0);
                return;
            }

            var w = 1;
            var maxTop = this.$size.height - h;
            if (!composition) {
                posTop += this.lineHeight;
            }
            else {
                if (composition.useTextareaForIME) {
                    var val = this.textarea.value;
                    w = this.characterWidth * (this.session.$getStringScreenWidth(val)[0]);
                }
                else {
                    posTop += this.lineHeight + 2;
                }
            }
            
            posLeft -= this.scrollLeft;
            if (posLeft > this.$size.scrollerWidth - w)
                posLeft = this.$size.scrollerWidth - w;

            posLeft += this.gutterWidth + this.margin.left;

            dom.setStyle(style, "height", h + "px");
            dom.setStyle(style, "width", w + "px");
            dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, maxTop));
        };
        this.getFirstVisibleRow = function() {
            return this.layerConfig.firstRow;
        };
        this.getFirstFullyVisibleRow = function() {
            return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
        };
        this.getLastFullyVisibleRow = function() {
            var config = this.layerConfig;
            var lastRow = config.lastRow;
            var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
            if (top - this.session.getScrollTop() > config.height - config.lineHeight)
                return lastRow - 1;
            return lastRow;
        };
        this.getLastVisibleRow = function() {
            return this.layerConfig.lastRow;
        };

        this.$padding = null;
        this.setPadding = function(padding) {
            this.$padding = padding;
            this.$textLayer.setPadding(padding);
            this.$cursorLayer.setPadding(padding);
            this.$markerFront.setPadding(padding);
            this.$markerBack.setPadding(padding);
            this.$loop.schedule(this.CHANGE_FULL);
            this.$updatePrintMargin();
        };
        
        this.setScrollMargin = function(top, bottom, left, right) {
            var sm = this.scrollMargin;
            sm.top = top|0;
            sm.bottom = bottom|0;
            sm.right = right|0;
            sm.left = left|0;
            sm.v = sm.top + sm.bottom;
            sm.h = sm.left + sm.right;
            if (sm.top && this.scrollTop <= 0 && this.session)
                this.session.setScrollTop(-sm.top);
            this.updateFull();
        };
        
        this.setMargin = function(top, bottom, left, right) {
            var sm = this.margin;
            sm.top = top|0;
            sm.bottom = bottom|0;
            sm.right = right|0;
            sm.left = left|0;
            sm.v = sm.top + sm.bottom;
            sm.h = sm.left + sm.right;
            this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
            this.updateFull();
        };
        this.getHScrollBarAlwaysVisible = function() {
            return this.$hScrollBarAlwaysVisible;
        };
        this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
        };
        this.getVScrollBarAlwaysVisible = function() {
            return this.$vScrollBarAlwaysVisible;
        };
        this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
        };

        this.$updateScrollBarV = function() {
            var scrollHeight = this.layerConfig.maxHeight;
            var scrollerHeight = this.$size.scrollerHeight;
            if (!this.$maxLines && this.$scrollPastEnd) {
                scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
                if (this.scrollTop > scrollHeight - scrollerHeight) {
                    scrollHeight = this.scrollTop + scrollerHeight;
                    this.scrollBarV.scrollTop = null;
                }
            }
            this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
            this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
        };
        this.$updateScrollBarH = function() {
            this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
            this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
        };
        
        this.$frozen = false;
        this.freeze = function() {
            this.$frozen = true;
        };
        
        this.unfreeze = function() {
            this.$frozen = false;
        };

        this.$renderChanges = function(changes, force) {
            if (this.$changes) {
                changes |= this.$changes;
                this.$changes = 0;
            }
            if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
                this.$changes |= changes;
                return; 
            } 
            if (this.$size.$dirty) {
                this.$changes |= changes;
                return this.onResize(true);
            }
            if (!this.lineHeight) {
                this.$textLayer.checkForSizeChanges();
            }
            
            this._signal("beforeRender", changes);
            
            if (this.session && this.session.$bidiHandler)
                this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);

            var config = this.layerConfig;
            if (changes & this.CHANGE_FULL ||
                changes & this.CHANGE_SIZE ||
                changes & this.CHANGE_TEXT ||
                changes & this.CHANGE_LINES ||
                changes & this.CHANGE_SCROLL ||
                changes & this.CHANGE_H_SCROLL
            ) {
                changes |= this.$computeLayerConfig() | this.$loop.clear();
                if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
                    var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
                    if (st > 0) {
                        this.scrollTop = st;
                        changes = changes | this.CHANGE_SCROLL;
                        changes |= this.$computeLayerConfig() | this.$loop.clear();
                    }
                }
                config = this.layerConfig;
                this.$updateScrollBarV();
                if (changes & this.CHANGE_H_SCROLL)
                    this.$updateScrollBarH();
                
                dom.translate(this.content, -this.scrollLeft, -config.offset);
                
                var width = config.width + 2 * this.$padding + "px";
                var height = config.minHeight + "px";
                
                dom.setStyle(this.content.style, "width", width);
                dom.setStyle(this.content.style, "height", height);
            }
            if (changes & this.CHANGE_H_SCROLL) {
                dom.translate(this.content, -this.scrollLeft, -config.offset);
                this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
            }
            if (changes & this.CHANGE_FULL) {
                this.$changedLines = null;
                this.$textLayer.update(config);
                if (this.$showGutter)
                    this.$gutterLayer.update(config);
                this.$markerBack.update(config);
                this.$markerFront.update(config);
                this.$cursorLayer.update(config);
                this.$moveTextAreaToCursor();
                this._signal("afterRender", changes);
                return;
            }
            if (changes & this.CHANGE_SCROLL) {
                this.$changedLines = null;
                if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                    this.$textLayer.update(config);
                else
                    this.$textLayer.scrollLines(config);

                if (this.$showGutter) {
                    if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)
                        this.$gutterLayer.update(config);
                    else
                        this.$gutterLayer.scrollLines(config);
                }
                this.$markerBack.update(config);
                this.$markerFront.update(config);
                this.$cursorLayer.update(config);
                this.$moveTextAreaToCursor();
                this._signal("afterRender", changes);
                return;
            }

            if (changes & this.CHANGE_TEXT) {
                this.$changedLines = null;
                this.$textLayer.update(config);
                if (this.$showGutter)
                    this.$gutterLayer.update(config);
            }
            else if (changes & this.CHANGE_LINES) {
                if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
                    this.$gutterLayer.update(config);
            }
            else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
                if (this.$showGutter)
                    this.$gutterLayer.update(config);
            }
            else if (changes & this.CHANGE_CURSOR) {
                if (this.$highlightGutterLine)
                    this.$gutterLayer.updateLineHighlight(config);
            }

            if (changes & this.CHANGE_CURSOR) {
                this.$cursorLayer.update(config);
                this.$moveTextAreaToCursor();
            }

            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
                this.$markerFront.update(config);
            }

            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
                this.$markerBack.update(config);
            }

            this._signal("afterRender", changes);
        };

        
        this.$autosize = function() {
            var height = this.session.getScreenLength() * this.lineHeight;
            var maxHeight = this.$maxLines * this.lineHeight;
            var desiredHeight = Math.min(maxHeight, 
                Math.max((this.$minLines || 1) * this.lineHeight, height)
            ) + this.scrollMargin.v + (this.$extraHeight || 0);
            if (this.$horizScroll)
                desiredHeight += this.scrollBarH.getHeight();
            if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
                desiredHeight = this.$maxPixelHeight;
            
            var hideScrollbars = desiredHeight <= 2 * this.lineHeight;
            var vScroll = !hideScrollbars && height > maxHeight;
            
            if (desiredHeight != this.desiredHeight ||
                this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
                if (vScroll != this.$vScroll) {
                    this.$vScroll = vScroll;
                    this.scrollBarV.setVisible(vScroll);
                }
                
                var w = this.container.clientWidth;
                this.container.style.height = desiredHeight + "px";
                this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
                this.desiredHeight = desiredHeight;
                
                this._signal("autosize");
            }
        };
        
        this.$computeLayerConfig = function() {
            var session = this.session;
            var size = this.$size;
            
            var hideScrollbars = size.height <= 2 * this.lineHeight;
            var screenLines = this.session.getScreenLength();
            var maxHeight = screenLines * this.lineHeight;

            var longestLine = this.$getLongestLine();
            
            var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
                size.scrollerWidth - longestLine - 2 * this.$padding < 0);

            var hScrollChanged = this.$horizScroll !== horizScroll;
            if (hScrollChanged) {
                this.$horizScroll = horizScroll;
                this.scrollBarH.setVisible(horizScroll);
            }
            var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
            if (this.$maxLines && this.lineHeight > 1)
                this.$autosize();

            var minHeight = size.scrollerHeight + this.lineHeight;
            
            var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd
                ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
                : 0;
            maxHeight += scrollPastEnd;
            
            var sm = this.scrollMargin;
            this.session.setScrollTop(Math.max(-sm.top,
                Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));

            this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, 
                longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
            
            var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
                size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
            var vScrollChanged = vScrollBefore !== vScroll;
            if (vScrollChanged) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
            }

            var offset = this.scrollTop % this.lineHeight;
            var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
            var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
            var lastRow = firstRow + lineCount;
            var firstRowScreen, firstRowHeight;
            var lineHeight = this.lineHeight;
            firstRow = session.screenToDocumentRow(firstRow, 0);
            var foldLine = session.getFoldLine(firstRow);
            if (foldLine) {
                firstRow = foldLine.start.row;
            }

            firstRowScreen = session.documentToScreenRow(firstRow, 0);
            firstRowHeight = session.getRowLength(firstRow) * lineHeight;

            lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
            minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
                                                    firstRowHeight;

            offset = this.scrollTop - firstRowScreen * lineHeight;

            var changes = 0;
            if (this.layerConfig.width != longestLine || hScrollChanged) 
                changes = this.CHANGE_H_SCROLL;
            if (hScrollChanged || vScrollChanged) {
                changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
                this._signal("scrollbarVisibilityChanged");
                if (vScrollChanged)
                    longestLine = this.$getLongestLine();
            }
            
            this.layerConfig = {
                width : longestLine,
                padding : this.$padding,
                firstRow : firstRow,
                firstRowScreen: firstRowScreen,
                lastRow : lastRow,
                lineHeight : lineHeight,
                characterWidth : this.characterWidth,
                minHeight : minHeight,
                maxHeight : maxHeight,
                offset : offset,
                gutterOffset : lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
                height : this.$size.scrollerHeight
            };

            if (this.session.$bidiHandler)
                this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);

            return changes;
        };

        this.$updateLines = function() {
            if (!this.$changedLines) return;
            var firstRow = this.$changedLines.firstRow;
            var lastRow = this.$changedLines.lastRow;
            this.$changedLines = null;

            var layerConfig = this.layerConfig;

            if (firstRow > layerConfig.lastRow + 1) { return; }
            if (lastRow < layerConfig.firstRow) { return; }
            if (lastRow === Infinity) {
                if (this.$showGutter)
                    this.$gutterLayer.update(layerConfig);
                this.$textLayer.update(layerConfig);
                return;
            }
            this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
            return true;
        };

        this.$getLongestLine = function() {
            var charCount = this.session.getScreenWidth();
            if (this.showInvisibles && !this.session.$useWrapMode)
                charCount += 1;
                
            if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)
                charCount = this.$textLayer.MAX_LINE_LENGTH + 30;

            return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
        };
        this.updateFrontMarkers = function() {
            this.$markerFront.setMarkers(this.session.getMarkers(true));
            this.$loop.schedule(this.CHANGE_MARKER_FRONT);
        };
        this.updateBackMarkers = function() {
            this.$markerBack.setMarkers(this.session.getMarkers());
            this.$loop.schedule(this.CHANGE_MARKER_BACK);
        };
        this.addGutterDecoration = function(row, className){
            this.$gutterLayer.addGutterDecoration(row, className);
        };
        this.removeGutterDecoration = function(row, className){
            this.$gutterLayer.removeGutterDecoration(row, className);
        };
        this.updateBreakpoints = function(rows) {
            this.$loop.schedule(this.CHANGE_GUTTER);
        };
        this.setAnnotations = function(annotations) {
            this.$gutterLayer.setAnnotations(annotations);
            this.$loop.schedule(this.CHANGE_GUTTER);
        };
        this.updateCursor = function() {
            this.$loop.schedule(this.CHANGE_CURSOR);
        };
        this.hideCursor = function() {
            this.$cursorLayer.hideCursor();
        };
        this.showCursor = function() {
            this.$cursorLayer.showCursor();
        };

        this.scrollSelectionIntoView = function(anchor, lead, offset) {
            this.scrollCursorIntoView(anchor, offset);
            this.scrollCursorIntoView(lead, offset);
        };
        this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
            if (this.$size.scrollerHeight === 0)
                return;

            var pos = this.$cursorLayer.getPixelPosition(cursor);

            var left = pos.left;
            var top = pos.top;
            
            var topMargin = $viewMargin && $viewMargin.top || 0;
            var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
            
            var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
            
            if (scrollTop + topMargin > top) {
                if (offset && scrollTop + topMargin > top + this.lineHeight)
                    top -= offset * this.$size.scrollerHeight;
                if (top === 0)
                    top = -this.scrollMargin.top;
                this.session.setScrollTop(top);
            } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
                if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top -  this.lineHeight)
                    top += offset * this.$size.scrollerHeight;
                this.session.setScrollTop(top + this.lineHeight + bottomMargin - this.$size.scrollerHeight);
            }

            var scrollLeft = this.scrollLeft;

            if (scrollLeft > left) {
                if (left < this.$padding + 2 * this.layerConfig.characterWidth)
                    left = -this.scrollMargin.left;
                this.session.setScrollLeft(left);
            } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
                this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
            } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
                this.session.setScrollLeft(0);
            }
        };
        this.getScrollTop = function() {
            return this.session.getScrollTop();
        };
        this.getScrollLeft = function() {
            return this.session.getScrollLeft();
        };
        this.getScrollTopRow = function() {
            return this.scrollTop / this.lineHeight;
        };
        this.getScrollBottomRow = function() {
            return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
        };
        this.scrollToRow = function(row) {
            this.session.setScrollTop(row * this.lineHeight);
        };

        this.alignCursor = function(cursor, alignment) {
            if (typeof cursor == "number")
                cursor = {row: cursor, column: 0};

            var pos = this.$cursorLayer.getPixelPosition(cursor);
            var h = this.$size.scrollerHeight - this.lineHeight;
            var offset = pos.top - h * (alignment || 0);

            this.session.setScrollTop(offset);
            return offset;
        };

        this.STEPS = 8;
        this.$calcSteps = function(fromValue, toValue){
            var i = 0;
            var l = this.STEPS;
            var steps = [];

            var func  = function(t, x_min, dx) {
                return dx * (Math.pow(t - 1, 3) + 1) + x_min;
            };

            for (i = 0; i < l; ++i)
                steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

            return steps;
        };
        this.scrollToLine = function(line, center, animate, callback) {
            var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
            var offset = pos.top;
            if (center)
                offset -= this.$size.scrollerHeight / 2;

            var initialScroll = this.scrollTop;
            this.session.setScrollTop(offset);
            if (animate !== false)
                this.animateScrolling(initialScroll, callback);
        };

        this.animateScrolling = function(fromValue, callback) {
            var toValue = this.scrollTop;
            if (!this.$animatedScroll)
                return;
            var _self = this;
            
            if (fromValue == toValue)
                return;
            
            if (this.$scrollAnimation) {
                var oldSteps = this.$scrollAnimation.steps;
                if (oldSteps.length) {
                    fromValue = oldSteps[0];
                    if (fromValue == toValue)
                        return;
                }
            }
            
            var steps = _self.$calcSteps(fromValue, toValue);
            this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};

            clearInterval(this.$timer);

            _self.session.setScrollTop(steps.shift());
            _self.session.$scrollTop = toValue;
            this.$timer = setInterval(function() {
                if (!_self.session) 
                    return clearInterval(_self.$timer);
                if (steps.length) {
                    _self.session.setScrollTop(steps.shift());
                    _self.session.$scrollTop = toValue;
                } else if (toValue != null) {
                    _self.session.$scrollTop = -1;
                    _self.session.setScrollTop(toValue);
                    toValue = null;
                } else {
                    _self.$timer = clearInterval(_self.$timer);
                    _self.$scrollAnimation = null;
                    callback && callback();
                }
            }, 10);
        };
        this.scrollToY = function(scrollTop) {
            if (this.scrollTop !== scrollTop) {
                this.$loop.schedule(this.CHANGE_SCROLL);
                this.scrollTop = scrollTop;
            }
        };
        this.scrollToX = function(scrollLeft) {
            if (this.scrollLeft !== scrollLeft)
                this.scrollLeft = scrollLeft;
            this.$loop.schedule(this.CHANGE_H_SCROLL);
        };
        this.scrollTo = function(x, y) {
            this.session.setScrollTop(y);
            this.session.setScrollLeft(y);
        };
        this.scrollBy = function(deltaX, deltaY) {
            deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
            deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
        };
        this.isScrollableBy = function(deltaX, deltaY) {
            if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
               return true;
            if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
                - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
               return true;
            if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
                return true;
            if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
                - this.layerConfig.width < -1 + this.scrollMargin.right)
               return true;
        };

        this.pixelToScreenCoordinates = function(x, y) {
            var canvasPos;
            if (this.$hasCssTransforms) {
                canvasPos = {top:0, left: 0};
                var p = this.$fontMetrics.transformCoordinates([x, y]);
                x = p[1] - this.gutterWidth - this.margin.left;
                y = p[0];
            } else {
                canvasPos = this.scroller.getBoundingClientRect();
            }
            
            var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
            var offset = offsetX / this.characterWidth;
            var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
            var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);

            return {row: row, column: col, side: offset - col > 0 ? 1 : -1, offsetX:  offsetX};
        };

        this.screenToTextCoordinates = function(x, y) {
            var canvasPos;
            if (this.$hasCssTransforms) {
                canvasPos = {top:0, left: 0};
                var p = this.$fontMetrics.transformCoordinates([x, y]);
                x = p[1] - this.gutterWidth - this.margin.left;
                y = p[0];
            } else {
                canvasPos = this.scroller.getBoundingClientRect();
            }

            var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
            var offset = offsetX / this.characterWidth;
            var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);

            var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);

            return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
        };
        this.textToScreenCoordinates = function(row, column) {
            var canvasPos = this.scroller.getBoundingClientRect();
            var pos = this.session.documentToScreenPosition(row, column);

            var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row)
                 ? this.session.$bidiHandler.getPosLeft(pos.column)
                 : Math.round(pos.column * this.characterWidth));
            
            var y = pos.row * this.lineHeight;

            return {
                pageX: canvasPos.left + x - this.scrollLeft,
                pageY: canvasPos.top + y - this.scrollTop
            };
        };
        this.visualizeFocus = function() {
            dom.addCssClass(this.container, "ace_focus");
        };
        this.visualizeBlur = function() {
            dom.removeCssClass(this.container, "ace_focus");
        };
        this.showComposition = function(composition) {
            this.$composition = composition;
            if (!composition.cssText) {
                composition.cssText = this.textarea.style.cssText;
            }
            if (composition.useTextareaForIME == undefined)
                composition.useTextareaForIME = this.$useTextareaForIME;
            
            if (this.$useTextareaForIME) {
                dom.addCssClass(this.textarea, "ace_composition");
                this.textarea.style.cssText = "";
                this.$moveTextAreaToCursor();
                this.$cursorLayer.element.style.display = "none";
            }
            else {
                composition.markerId = this.session.addMarker(composition.markerRange, "ace_composition_marker", "text");
            }
        };
        this.setCompositionText = function(text) {
            var cursor = this.session.selection.cursor;
            this.addToken(text, "composition_placeholder", cursor.row, cursor.column);
            this.$moveTextAreaToCursor();
        };
        this.hideComposition = function() {
            if (!this.$composition)
                return;
            
            if (this.$composition.markerId)
                this.session.removeMarker(this.$composition.markerId);

            dom.removeCssClass(this.textarea, "ace_composition");
            this.textarea.style.cssText = this.$composition.cssText;
            var cursor = this.session.selection.cursor;
            this.removeExtraToken(cursor.row, cursor.column);
            this.$composition = null;
            this.$cursorLayer.element.style.display = "";
        };
        
        this.addToken = function(text, type, row, column) {
            var session = this.session;
            session.bgTokenizer.lines[row] = null;
            var newToken = {type: type, value: text};
            var tokens = session.getTokens(row);
            if (column == null) {
                tokens.push(newToken);
            } else {
                var l = 0;
                for (var i =0; i < tokens.length; i++) {
                    var token = tokens[i];
                    l += token.value.length;
                    if (column <= l) {
                        var diff = token.value.length - (l - column);
                        var before = token.value.slice(0, diff);
                        var after = token.value.slice(diff);
        
                        tokens.splice(i, 1, {type: token.type, value: before},  newToken,  {type: token.type, value: after});
                        break;
                    }
                }
            }
            this.updateLines(row, row);
        };

        this.removeExtraToken = function(row, column) {
            this.updateLines(row, row);
        };
        this.setTheme = function(theme, cb) {
            var _self = this;
            this.$themeId = theme;
            _self._dispatchEvent('themeChange',{theme:theme});

            if (!theme || typeof theme == "string") {
                var moduleName = theme || this.$options.theme.initialValue;
                config.loadModule(["theme", moduleName], afterLoad);
            } else {
                afterLoad(theme);
            }

            function afterLoad(module) {
                if (_self.$themeId != theme)
                    return cb && cb();
                if (!module || !module.cssClass)
                    throw new Error("couldn't load module " + theme + " or it didn't call define");
                if (module.$id)
                    _self.$themeId = module.$id;
                dom.importCssString(
                    module.cssText,
                    module.cssClass,
                    _self.container
                );

                if (_self.theme)
                    dom.removeCssClass(_self.container, _self.theme.cssClass);

                var padding = "padding" in module ? module.padding 
                    : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
                if (_self.$padding && padding != _self.$padding)
                    _self.setPadding(padding);
                _self.$theme = module.cssClass;

                _self.theme = module;
                dom.addCssClass(_self.container, module.cssClass);
                dom.setCssClass(_self.container, "ace_dark", module.isDark);
                if (_self.$size) {
                    _self.$size.width = 0;
                    _self.$updateSizeAsync();
                }

                _self._dispatchEvent('themeLoaded', {theme:module});
                cb && cb();
            }
        };
        this.getTheme = function() {
            return this.$themeId;
        };
        this.setStyle = function(style, include) {
            dom.setCssClass(this.container, style, include !== false);
        };
        this.unsetStyle = function(style) {
            dom.removeCssClass(this.container, style);
        };
        
        this.setCursorStyle = function(style) {
            dom.setStyle(this.scroller.style, "cursor", style);
        };
        this.setMouseCursor = function(cursorStyle) {
            dom.setStyle(this.scroller.style, "cursor", cursorStyle);
        };
        
        this.attachToShadowRoot = function() {
            dom.importCssString(editorCss, "ace_editor.css", this.container);
        };
        this.destroy = function() {
            this.freeze();
            this.$fontMetrics.destroy();
            this.$cursorLayer.destroy();
            this.removeAllListeners();
            this.container.textContent = "";
        };

    }).call(VirtualRenderer.prototype);


    config.defineOptions(VirtualRenderer.prototype, "renderer", {
        animatedScroll: {initialValue: false},
        showInvisibles: {
            set: function(value) {
                if (this.$textLayer.setShowInvisibles(value))
                    this.$loop.schedule(this.CHANGE_TEXT);
            },
            initialValue: false
        },
        showPrintMargin: {
            set: function() { this.$updatePrintMargin(); },
            initialValue: true
        },
        printMarginColumn: {
            set: function() { this.$updatePrintMargin(); },
            initialValue: 80
        },
        printMargin: {
            set: function(val) {
                if (typeof val == "number")
                    this.$printMarginColumn = val;
                this.$showPrintMargin = !!val;
                this.$updatePrintMargin();
            },
            get: function() {
                return this.$showPrintMargin && this.$printMarginColumn; 
            }
        },
        showGutter: {
            set: function(show){
                this.$gutter.style.display = show ? "block" : "none";
                this.$loop.schedule(this.CHANGE_FULL);
                this.onGutterResize();
            },
            initialValue: true
        },
        fadeFoldWidgets: {
            set: function(show) {
                dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
            },
            initialValue: false
        },
        showFoldWidgets: {
            set: function(show) {
                this.$gutterLayer.setShowFoldWidgets(show);
                this.$loop.schedule(this.CHANGE_GUTTER);
            },
            initialValue: true
        },
        displayIndentGuides: {
            set: function(show) {
                if (this.$textLayer.setDisplayIndentGuides(show))
                    this.$loop.schedule(this.CHANGE_TEXT);
            },
            initialValue: true
        },
        highlightGutterLine: {
            set: function(shouldHighlight) {
                this.$gutterLayer.setHighlightGutterLine(shouldHighlight);
                this.$loop.schedule(this.CHANGE_GUTTER);
            },
            initialValue: true
        },
        hScrollBarAlwaysVisible: {
            set: function(val) {
                if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                    this.$loop.schedule(this.CHANGE_SCROLL);
            },
            initialValue: false
        },
        vScrollBarAlwaysVisible: {
            set: function(val) {
                if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                    this.$loop.schedule(this.CHANGE_SCROLL);
            },
            initialValue: false
        },
        fontSize: {
            set: function(size) {
                if (typeof size == "number")
                    size = size + "px";
                this.container.style.fontSize = size;
                this.updateFontSize();
            },
            initialValue: 12
        },
        fontFamily: {
            set: function(name) {
                this.container.style.fontFamily = name;
                this.updateFontSize();
            }
        },
        maxLines: {
            set: function(val) {
                this.updateFull();
            }
        },
        minLines: {
            set: function(val) {
                if (!(this.$minLines < 0x1ffffffffffff))
                    this.$minLines = 0;
                this.updateFull();
            }
        },
        maxPixelHeight: {
            set: function(val) {
                this.updateFull();
            },
            initialValue: 0
        },
        scrollPastEnd: {
            set: function(val) {
                val = +val || 0;
                if (this.$scrollPastEnd == val)
                    return;
                this.$scrollPastEnd = val;
                this.$loop.schedule(this.CHANGE_SCROLL);
            },
            initialValue: 0,
            handlesSet: true
        },
        fixedWidthGutter: {
            set: function(val) {
                this.$gutterLayer.$fixedWidth = !!val;
                this.$loop.schedule(this.CHANGE_GUTTER);
            }
        },
        theme: {
            set: function(val) { this.setTheme(val); },
            get: function() { return this.$themeId || this.theme; },
            initialValue: "./theme/textmate",
            handlesSet: true
        },
        hasCssTransforms: {
        },
        useTextareaForIME: {
            initialValue: !useragent.isMobile && !useragent.isIE
        }
    });

    exports.VirtualRenderer = VirtualRenderer;
    });

    ace.define("ace/worker/worker_client",["require","exports","module","ace/lib/oop","ace/lib/net","ace/lib/event_emitter","ace/config"], function(require, exports, module) {

    var oop = require("../lib/oop");
    var net = require("../lib/net");
    var EventEmitter = require("../lib/event_emitter").EventEmitter;
    var config = require("../config");

    function $workerBlob(workerUrl) {
        var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
        try {
            return new Blob([script], {"type": "application/javascript"});
        } catch (e) { // Backwards-compatibility
            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
            var blobBuilder = new BlobBuilder();
            blobBuilder.append(script);
            return blobBuilder.getBlob("application/javascript");
        }
    }

    function createWorker(workerUrl) {
        if (typeof Worker == "undefined")
            return { postMessage: function() {}, terminate: function() {} };
        if (config.get("loadWorkerFromBlob")) {
            var blob = $workerBlob(workerUrl);
            var URL = window.URL || window.webkitURL;
            var blobURL = URL.createObjectURL(blob);
            return new Worker(blobURL);
        }
        return new Worker(workerUrl);
    }

    var WorkerClient = function(worker) {
        if (!worker.postMessage)
            worker = this.$createWorkerFromOldConfig.apply(this, arguments);

        this.$worker = worker;
        this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.onMessage = this.onMessage.bind(this);

        this.callbackId = 1;
        this.callbacks = {};

        this.$worker.onmessage = this.onMessage;
    };

    (function(){

        oop.implement(this, EventEmitter);

        this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {
            if (require.nameToUrl && !require.toUrl)
                require.toUrl = require.nameToUrl;

            if (config.get("packaged") || !require.toUrl) {
                workerUrl = workerUrl || config.moduleUrl(mod, "worker");
            } else {
                var normalizePath = this.$normalizePath;
                workerUrl = workerUrl || normalizePath(require.toUrl("ace/worker/worker.js", null, "_"));

                var tlns = {};
                topLevelNamespaces.forEach(function(ns) {
                    tlns[ns] = normalizePath(require.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
                });
            }

            this.$worker = createWorker(workerUrl);
            if (importScripts) {
                this.send("importScripts", importScripts);
            }
            this.$worker.postMessage({
                init : true,
                tlns : tlns,
                module : mod,
                classname : classname
            });
            return this.$worker;
        };

        this.onMessage = function(e) {
            var msg = e.data;
            switch (msg.type) {
                case "event":
                    this._signal(msg.name, {data: msg.data});
                    break;
                case "call":
                    var callback = this.callbacks[msg.id];
                    if (callback) {
                        callback(msg.data);
                        delete this.callbacks[msg.id];
                    }
                    break;
                case "error":
                    this.reportError(msg.data);
                    break;
                case "log":
                    window.console && console.log && console.log.apply(console, msg.data);
                    break;
            }
        };
        
        this.reportError = function(err) {
            window.console && console.error && console.error(err);
        };

        this.$normalizePath = function(path) {
            return net.qualifyURL(path);
        };

        this.terminate = function() {
            this._signal("terminate", {});
            this.deltaQueue = null;
            this.$worker.terminate();
            this.$worker = null;
            if (this.$doc)
                this.$doc.off("change", this.changeListener);
            this.$doc = null;
        };

        this.send = function(cmd, args) {
            this.$worker.postMessage({command: cmd, args: args});
        };

        this.call = function(cmd, args, callback) {
            if (callback) {
                var id = this.callbackId++;
                this.callbacks[id] = callback;
                args.push(id);
            }
            this.send(cmd, args);
        };

        this.emit = function(event, data) {
            try {
                if (data.data && data.data.err)
                    data.data.err = {message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code};
                this.$worker.postMessage({event: event, data: {data: data.data}});
            }
            catch(ex) {
                console.error(ex.stack);
            }
        };

        this.attachToDocument = function(doc) {
            if (this.$doc)
                this.terminate();

            this.$doc = doc;
            this.call("setValue", [doc.getValue()]);
            doc.on("change", this.changeListener);
        };

        this.changeListener = function(delta) {
            if (!this.deltaQueue) {
                this.deltaQueue = [];
                setTimeout(this.$sendDeltaQueue, 0);
            }
            if (delta.action == "insert")
                this.deltaQueue.push(delta.start, delta.lines);
            else
                this.deltaQueue.push(delta.start, delta.end);
        };

        this.$sendDeltaQueue = function() {
            var q = this.deltaQueue;
            if (!q) return;
            this.deltaQueue = null;
            if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
                this.call("setValue", [this.$doc.getValue()]);
            } else
                this.emit("change", {data: q});
        };

    }).call(WorkerClient.prototype);


    var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
        var main = null;
        var emitSync = false;
        var sender = Object.create(EventEmitter);

        var messageBuffer = [];
        var workerClient = new WorkerClient({
            messageBuffer: messageBuffer,
            terminate: function() {},
            postMessage: function(e) {
                messageBuffer.push(e);
                if (!main) return;
                if (emitSync)
                    setTimeout(processNext);
                else
                    processNext();
            }
        });

        workerClient.setEmitSync = function(val) { emitSync = val; };

        var processNext = function() {
            var msg = messageBuffer.shift();
            if (msg.command)
                main[msg.command].apply(main, msg.args);
            else if (msg.event)
                sender._signal(msg.event, msg.data);
        };

        sender.postMessage = function(msg) {
            workerClient.onMessage({data: msg});
        };
        sender.callback = function(data, callbackId) {
            this.postMessage({type: "call", id: callbackId, data: data});
        };
        sender.emit = function(name, data) {
            this.postMessage({type: "event", name: name, data: data});
        };

        config.loadModule(["worker", mod], function(Main) {
            main = new Main[classname](sender);
            while (messageBuffer.length)
                processNext();
        });

        return workerClient;
    };

    exports.UIWorkerClient = UIWorkerClient;
    exports.WorkerClient = WorkerClient;
    exports.createWorker = createWorker;


    });

    ace.define("ace/placeholder",["require","exports","module","ace/range","ace/lib/event_emitter","ace/lib/oop"], function(require, exports, module) {

    var Range = require("./range").Range;
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var oop = require("./lib/oop");

    var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
        var _self = this;
        this.length = length;
        this.session = session;
        this.doc = session.getDocument();
        this.mainClass = mainClass;
        this.othersClass = othersClass;
        this.$onUpdate = this.onUpdate.bind(this);
        this.doc.on("change", this.$onUpdate);
        this.$others = others;
        
        this.$onCursorChange = function() {
            setTimeout(function() {
                _self.onCursorChange();
            });
        };
        
        this.$pos = pos;
        var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
        this.$undoStackDepth = undoStack.length;
        this.setup();

        session.selection.on("changeCursor", this.$onCursorChange);
    };

    (function() {

        oop.implement(this, EventEmitter);
        this.setup = function() {
            var _self = this;
            var doc = this.doc;
            var session = this.session;
            
            this.selectionBefore = session.selection.toJSON();
            if (session.selection.inMultiSelectMode)
                session.selection.toSingleRange();

            this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
            var pos = this.pos;
            pos.$insertRight = true;
            pos.detach();
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
            this.others = [];
            this.$others.forEach(function(other) {
                var anchor = doc.createAnchor(other.row, other.column);
                anchor.$insertRight = true;
                anchor.detach();
                _self.others.push(anchor);
            });
            session.setUndoSelect(false);
        };
        this.showOtherMarkers = function() {
            if (this.othersActive) return;
            var session = this.session;
            var _self = this;
            this.othersActive = true;
            this.others.forEach(function(anchor) {
                anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);
            });
        };
        this.hideOtherMarkers = function() {
            if (!this.othersActive) return;
            this.othersActive = false;
            for (var i = 0; i < this.others.length; i++) {
                this.session.removeMarker(this.others[i].markerId);
            }
        };
        this.onUpdate = function(delta) {
            if (this.$updating)
                return this.updateAnchors(delta);
                
            var range = delta;
            if (range.start.row !== range.end.row) return;
            if (range.start.row !== this.pos.row) return;
            this.$updating = true;
            var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
            var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
            var distanceFromStart = range.start.column - this.pos.column;
            
            this.updateAnchors(delta);
            
            if (inMainRange)
                this.length += lengthDiff;

            if (inMainRange && !this.session.$fromUndo) {
                if (delta.action === 'insert') {
                    for (var i = this.others.length - 1; i >= 0; i--) {
                        var otherPos = this.others[i];
                        var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                        this.doc.insertMergedLines(newPos, delta.lines);
                    }
                } else if (delta.action === 'remove') {
                    for (var i = this.others.length - 1; i >= 0; i--) {
                        var otherPos = this.others[i];
                        var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                        this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                    }
                }
            }
            
            this.$updating = false;
            this.updateMarkers();
        };
        
        this.updateAnchors = function(delta) {
            this.pos.onChange(delta);
            for (var i = this.others.length; i--;)
                this.others[i].onChange(delta);
            this.updateMarkers();
        };
        
        this.updateMarkers = function() {
            if (this.$updating)
                return;
            var _self = this;
            var session = this.session;
            var updateMarker = function(pos, className) {
                session.removeMarker(pos.markerId);
                pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column+_self.length), className, null, false);
            };
            updateMarker(this.pos, this.mainClass);
            for (var i = this.others.length; i--;)
                updateMarker(this.others[i], this.othersClass);
        };

        this.onCursorChange = function(event) {
            if (this.$updating || !this.session) return;
            var pos = this.session.selection.getCursor();
            if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
                this.showOtherMarkers();
                this._emit("cursorEnter", event);
            } else {
                this.hideOtherMarkers();
                this._emit("cursorLeave", event);
            }
        };    
        this.detach = function() {
            this.session.removeMarker(this.pos && this.pos.markerId);
            this.hideOtherMarkers();
            this.doc.off("change", this.$onUpdate);
            this.session.selection.off("changeCursor", this.$onCursorChange);
            this.session.setUndoSelect(true);
            this.session = null;
        };
        this.cancel = function() {
            if (this.$undoStackDepth === -1)
                return;
            var undoManager = this.session.getUndoManager();
            var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
            for (var i = 0; i < undosRequired; i++) {
                undoManager.undo(this.session, true);
            }
            if (this.selectionBefore)
                this.session.selection.fromJSON(this.selectionBefore);
        };
    }).call(PlaceHolder.prototype);


    exports.PlaceHolder = PlaceHolder;
    });

    ace.define("ace/mouse/multi_select_handler",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(require, exports, module) {

    var event = require("../lib/event");
    var useragent = require("../lib/useragent");
    function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
    }

    function onMouseDown(e) {
        var ev = e.domEvent;
        var alt = ev.altKey;
        var shift = ev.shiftKey;
        var ctrl = ev.ctrlKey;
        var accel = e.getAccelKey();
        var button = e.getButton();
        
        if (ctrl && useragent.isMac)
            button = ev.button;

        if (e.editor.inMultiSelectMode && button == 2) {
            e.editor.textInput.onContextMenu(e.domEvent);
            return;
        }
        
        if (!ctrl && !alt && !accel) {
            if (button === 0 && e.editor.inMultiSelectMode)
                e.editor.exitMultiSelectMode();
            return;
        }
        
        if (button !== 0)
            return;

        var editor = e.editor;
        var selection = editor.selection;
        var isMultiSelect = editor.inMultiSelectMode;
        var pos = e.getDocumentPosition();
        var cursor = selection.getCursor();
        var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));

        var mouseX = e.x, mouseY = e.y;
        var onMouseSelection = function(e) {
            mouseX = e.clientX;
            mouseY = e.clientY;
        };
        
        var session = editor.session;
        var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
        var screenCursor = screenAnchor;
        
        var selectionMode;
        if (editor.$mouseHandler.$enableJumpToDef) {
            if (ctrl && alt || accel && alt)
                selectionMode = shift ? "block" : "add";
            else if (alt && editor.$blockSelectEnabled)
                selectionMode = "block";
        } else {
            if (accel && !alt) {
                selectionMode = "add";
                if (!isMultiSelect && shift)
                    return;
            } else if (alt && editor.$blockSelectEnabled) {
                selectionMode = "block";
            }
        }
        
        if (selectionMode && useragent.isMac && ev.ctrlKey) {
            editor.$mouseHandler.cancelContextMenu();
        }

        if (selectionMode == "add") {
            if (!isMultiSelect && inSelection)
                return; // dragging

            if (!isMultiSelect) {
                var range = selection.toOrientedRange();
                editor.addSelectionMarker(range);
            }

            var oldRange = selection.rangeList.rangeAtPoint(pos);
            
            editor.inVirtualSelectionMode = true;
            
            if (shift) {
                oldRange = null;
                range = selection.ranges[0] || range;
                editor.removeSelectionMarker(range);
            }
            editor.once("mouseup", function() {
                var tmpSel = selection.toOrientedRange();

                if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
                    selection.substractPoint(tmpSel.cursor);
                else {
                    if (shift) {
                        selection.substractPoint(range.cursor);
                    } else if (range) {
                        editor.removeSelectionMarker(range);
                        selection.addRange(range);
                    }
                    selection.addRange(tmpSel);
                }
                editor.inVirtualSelectionMode = false;
            });

        } else if (selectionMode == "block") {
            e.stop();
            editor.inVirtualSelectionMode = true;        
            var initialRange;
            var rectSel = [];
            var blockSelect = function() {
                var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
                var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);

                if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
                    return;
                screenCursor = newCursor;
                
                editor.selection.moveToPosition(cursor);
                editor.renderer.scrollCursorIntoView();

                editor.removeSelectionMarkers(rectSel);
                rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
                if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
                    rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
                rectSel.forEach(editor.addSelectionMarker, editor);
                editor.updateSelectionMarkers();
            };
            if (isMultiSelect && !accel) {
                selection.toSingleRange();
            } else if (!isMultiSelect && accel) {
                initialRange = selection.toOrientedRange();
                editor.addSelectionMarker(initialRange);
            }
            
            if (shift)
                screenAnchor = session.documentToScreenPosition(selection.lead);            
            else
                selection.moveToPosition(pos);
            
            screenCursor = {row: -1, column: -1};

            var onMouseSelectionEnd = function(e) {
                blockSelect();
                clearInterval(timerId);
                editor.removeSelectionMarkers(rectSel);
                if (!rectSel.length)
                    rectSel = [selection.toOrientedRange()];
                if (initialRange) {
                    editor.removeSelectionMarker(initialRange);
                    selection.toSingleRange(initialRange);
                }
                for (var i = 0; i < rectSel.length; i++)
                    selection.addRange(rectSel[i]);
                editor.inVirtualSelectionMode = false;
                editor.$mouseHandler.$clickSelection = null;
            };

            var onSelectionInterval = blockSelect;

            event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
            var timerId = setInterval(function() {onSelectionInterval();}, 20);

            return e.preventDefault();
        }
    }


    exports.onMouseDown = onMouseDown;

    });

    ace.define("ace/commands/multi_select_commands",["require","exports","module","ace/keyboard/hash_handler"], function(require, exports, module) {
    exports.defaultCommands = [{
        name: "addCursorAbove",
        description: "Add cursor above",
        exec: function(editor) { editor.selectMoreLines(-1); },
        bindKey: {win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up"},
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "addCursorBelow",
        description: "Add cursor below",
        exec: function(editor) { editor.selectMoreLines(1); },
        bindKey: {win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down"},
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "addCursorAboveSkipCurrent",
        description: "Add cursor above (skip current)",
        exec: function(editor) { editor.selectMoreLines(-1, true); },
        bindKey: {win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up"},
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "addCursorBelowSkipCurrent",
        description: "Add cursor below (skip current)",
        exec: function(editor) { editor.selectMoreLines(1, true); },
        bindKey: {win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down"},
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectMoreBefore",
        description: "Select more before",
        exec: function(editor) { editor.selectMore(-1); },
        bindKey: {win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left"},
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectMoreAfter",
        description: "Select more after",
        exec: function(editor) { editor.selectMore(1); },
        bindKey: {win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right"},
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectNextBefore",
        description: "Select next before",
        exec: function(editor) { editor.selectMore(-1, true); },
        bindKey: {win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left"},
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectNextAfter",
        description: "Select next after",
        exec: function(editor) { editor.selectMore(1, true); },
        bindKey: {win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right"},
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "toggleSplitSelectionIntoLines",
        description: "Split into lines",
        exec: function(editor) {
            if (editor.multiSelect.rangeCount > 1)
                editor.multiSelect.joinSelections();
            else
                editor.multiSelect.splitIntoLines();
        },
        bindKey: {win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L"},
        readOnly: true
    }, {
        name: "splitSelectionIntoLines",
        description: "Split into lines",
        exec: function(editor) { editor.multiSelect.splitIntoLines(); },
        readOnly: true
    }, {
        name: "alignCursors",
        description: "Align cursors",
        exec: function(editor) { editor.alignCursors(); },
        bindKey: {win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A"},
        scrollIntoView: "cursor"
    }, {
        name: "findAll",
        description: "Find all",
        exec: function(editor) { editor.findAll(); },
        bindKey: {win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G"},
        scrollIntoView: "cursor",
        readOnly: true
    }];
    exports.multiSelectCommands = [{
        name: "singleSelection",
        description: "Single selection",
        bindKey: "esc",
        exec: function(editor) { editor.exitMultiSelectMode(); },
        scrollIntoView: "cursor",
        readOnly: true,
        isAvailable: function(editor) {return editor && editor.inMultiSelectMode;}
    }];

    var HashHandler = require("../keyboard/hash_handler").HashHandler;
    exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);

    });

    ace.define("ace/multi_select",["require","exports","module","ace/range_list","ace/range","ace/selection","ace/mouse/multi_select_handler","ace/lib/event","ace/lib/lang","ace/commands/multi_select_commands","ace/search","ace/edit_session","ace/editor","ace/config"], function(require, exports, module) {

    var RangeList = require("./range_list").RangeList;
    var Range = require("./range").Range;
    var Selection = require("./selection").Selection;
    var onMouseDown = require("./mouse/multi_select_handler").onMouseDown;
    var event = require("./lib/event");
    var lang = require("./lib/lang");
    var commands = require("./commands/multi_select_commands");
    exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
    var Search = require("./search").Search;
    var search = new Search();

    function find(session, needle, dir) {
        search.$options.wrap = true;
        search.$options.needle = needle;
        search.$options.backwards = dir == -1;
        return search.find(session);
    }
    var EditSession = require("./edit_session").EditSession;
    (function() {
        this.getSelectionMarkers = function() {
            return this.$selectionMarkers;
        };
    }).call(EditSession.prototype);
    (function() {
        this.ranges = null;
        this.rangeList = null;
        this.addRange = function(range, $blockChangeEvents) {
            if (!range)
                return;

            if (!this.inMultiSelectMode && this.rangeCount === 0) {
                var oldRange = this.toOrientedRange();
                this.rangeList.add(oldRange);
                this.rangeList.add(range);
                if (this.rangeList.ranges.length != 2) {
                    this.rangeList.removeAll();
                    return $blockChangeEvents || this.fromOrientedRange(range);
                }
                this.rangeList.removeAll();
                this.rangeList.add(oldRange);
                this.$onAddRange(oldRange);
            }

            if (!range.cursor)
                range.cursor = range.end;

            var removed = this.rangeList.add(range);

            this.$onAddRange(range);

            if (removed.length)
                this.$onRemoveRange(removed);

            if (this.rangeCount > 1 && !this.inMultiSelectMode) {
                this._signal("multiSelect");
                this.inMultiSelectMode = true;
                this.session.$undoSelect = false;
                this.rangeList.attach(this.session);
            }

            return $blockChangeEvents || this.fromOrientedRange(range);
        };
        this.toSingleRange = function(range) {
            range = range || this.ranges[0];
            var removed = this.rangeList.removeAll();
            if (removed.length)
                this.$onRemoveRange(removed);

            range && this.fromOrientedRange(range);
        };
        this.substractPoint = function(pos) {
            var removed = this.rangeList.substractPoint(pos);
            if (removed) {
                this.$onRemoveRange(removed);
                return removed[0];
            }
        };
        this.mergeOverlappingRanges = function() {
            var removed = this.rangeList.merge();
            if (removed.length)
                this.$onRemoveRange(removed);
        };

        this.$onAddRange = function(range) {
            this.rangeCount = this.rangeList.ranges.length;
            this.ranges.unshift(range);
            this._signal("addRange", {range: range});
        };

        this.$onRemoveRange = function(removed) {
            this.rangeCount = this.rangeList.ranges.length;
            if (this.rangeCount == 1 && this.inMultiSelectMode) {
                var lastRange = this.rangeList.ranges.pop();
                removed.push(lastRange);
                this.rangeCount = 0;
            }

            for (var i = removed.length; i--; ) {
                var index = this.ranges.indexOf(removed[i]);
                this.ranges.splice(index, 1);
            }

            this._signal("removeRange", {ranges: removed});

            if (this.rangeCount === 0 && this.inMultiSelectMode) {
                this.inMultiSelectMode = false;
                this._signal("singleSelect");
                this.session.$undoSelect = true;
                this.rangeList.detach(this.session);
            }

            lastRange = lastRange || this.ranges[0];
            if (lastRange && !lastRange.isEqual(this.getRange()))
                this.fromOrientedRange(lastRange);
        };
        this.$initRangeList = function() {
            if (this.rangeList)
                return;

            this.rangeList = new RangeList();
            this.ranges = [];
            this.rangeCount = 0;
        };
        this.getAllRanges = function() {
            return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
        };
        this.splitIntoLines = function () {
            var ranges = this.ranges.length ? this.ranges : [this.getRange()];
            var newRanges = [];
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                var row = range.start.row;
                var endRow = range.end.row;
                if (row === endRow) {
                    newRanges.push(range.clone());
                } else {
                    newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));
                    while (++row < endRow)
                        newRanges.push(this.getLineRange(row, true));
                    newRanges.push(new Range(endRow, 0, endRow, range.end.column));
                }
                if (i == 0 && !this.isBackwards())
                    newRanges = newRanges.reverse();
            }
            this.toSingleRange();
            for (var i = newRanges.length; i--;)
                this.addRange(newRanges[i]);
        };
        
        this.joinSelections = function () {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);

            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        };
        this.toggleBlockSelection = function () {
            if (this.rangeCount > 1) {
                var ranges = this.rangeList.ranges;
                var lastRange = ranges[ranges.length - 1];
                var range = Range.fromPoints(ranges[0].start, lastRange.end);

                this.toSingleRange();
                this.setSelectionRange(range, lastRange.cursor == lastRange.start);
            } else {
                var cursor = this.session.documentToScreenPosition(this.cursor);
                var anchor = this.session.documentToScreenPosition(this.anchor);

                var rectSel = this.rectangularRangeBlock(cursor, anchor);
                rectSel.forEach(this.addRange, this);
            }
        };
        this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
            var rectSel = [];

            var xBackwards = screenCursor.column < screenAnchor.column;
            if (xBackwards) {
                var startColumn = screenCursor.column;
                var endColumn = screenAnchor.column;
                var startOffsetX = screenCursor.offsetX;
                var endOffsetX = screenAnchor.offsetX;
            } else {
                var startColumn = screenAnchor.column;
                var endColumn = screenCursor.column;
                var startOffsetX = screenAnchor.offsetX;
                var endOffsetX = screenCursor.offsetX;
            }

            var yBackwards = screenCursor.row < screenAnchor.row;
            if (yBackwards) {
                var startRow = screenCursor.row;
                var endRow = screenAnchor.row;
            } else {
                var startRow = screenAnchor.row;
                var endRow = screenCursor.row;
            }

            if (startColumn < 0)
                startColumn = 0;
            if (startRow < 0)
                startRow = 0;

            if (startRow == endRow)
                includeEmptyLines = true;

            var docEnd;
            for (var row = startRow; row <= endRow; row++) {
                var range = Range.fromPoints(
                    this.session.screenToDocumentPosition(row, startColumn, startOffsetX),
                    this.session.screenToDocumentPosition(row, endColumn, endOffsetX)
                );
                if (range.isEmpty()) {
                    if (docEnd && isSamePoint(range.end, docEnd))
                        break;
                    docEnd = range.end;
                }
                range.cursor = xBackwards ? range.start : range.end;
                rectSel.push(range);
            }

            if (yBackwards)
                rectSel.reverse();

            if (!includeEmptyLines) {
                var end = rectSel.length - 1;
                while (rectSel[end].isEmpty() && end > 0)
                    end--;
                if (end > 0) {
                    var start = 0;
                    while (rectSel[start].isEmpty())
                        start++;
                }
                for (var i = end; i >= start; i--) {
                    if (rectSel[i].isEmpty())
                        rectSel.splice(i, 1);
                }
            }

            return rectSel;
        };
    }).call(Selection.prototype);
    var Editor = require("./editor").Editor;
    (function() {
        this.updateSelectionMarkers = function() {
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        };
        this.addSelectionMarker = function(orientedRange) {
            if (!orientedRange.cursor)
                orientedRange.cursor = orientedRange.end;

            var style = this.getSelectionStyle();
            orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);

            this.session.$selectionMarkers.push(orientedRange);
            this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
            return orientedRange;
        };
        this.removeSelectionMarker = function(range) {
            if (!range.marker)
                return;
            this.session.removeMarker(range.marker);
            var index = this.session.$selectionMarkers.indexOf(range);
            if (index != -1)
                this.session.$selectionMarkers.splice(index, 1);
            this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        };

        this.removeSelectionMarkers = function(ranges) {
            var markerList = this.session.$selectionMarkers;
            for (var i = ranges.length; i--; ) {
                var range = ranges[i];
                if (!range.marker)
                    continue;
                this.session.removeMarker(range.marker);
                var index = markerList.indexOf(range);
                if (index != -1)
                    markerList.splice(index, 1);
            }
            this.session.selectionMarkerCount = markerList.length;
        };

        this.$onAddRange = function(e) {
            this.addSelectionMarker(e.range);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        };

        this.$onRemoveRange = function(e) {
            this.removeSelectionMarkers(e.ranges);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        };

        this.$onMultiSelect = function(e) {
            if (this.inMultiSelectMode)
                return;
            this.inMultiSelectMode = true;

            this.setStyle("ace_multiselect");
            this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
            this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);

            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        };

        this.$onSingleSelect = function(e) {
            if (this.session.multiSelect.inVirtualMode)
                return;
            this.inMultiSelectMode = false;

            this.unsetStyle("ace_multiselect");
            this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);

            this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
            this._emit("changeSelection");
        };

        this.$onMultiSelectExec = function(e) {
            var command = e.command;
            var editor = e.editor;
            if (!editor.multiSelect)
                return;
            if (!command.multiSelectAction) {
                var result = command.exec(editor, e.args || {});
                editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
                editor.multiSelect.mergeOverlappingRanges();
            } else if (command.multiSelectAction == "forEach") {
                result = editor.forEachSelection(command, e.args);
            } else if (command.multiSelectAction == "forEachLine") {
                result = editor.forEachSelection(command, e.args, true);
            } else if (command.multiSelectAction == "single") {
                editor.exitMultiSelectMode();
                result = command.exec(editor, e.args || {});
            } else {
                result = command.multiSelectAction(editor, e.args || {});
            }
            return result;
        }; 
        this.forEachSelection = function(cmd, args, options) {
            if (this.inVirtualSelectionMode)
                return;
            var keepOrder = options && options.keepOrder;
            var $byLines = options == true || options && options.$byLines;
            var session = this.session;
            var selection = this.selection;
            var rangeList = selection.rangeList;
            var ranges = (keepOrder ? selection : rangeList).ranges;
            var result;
            
            if (!ranges.length)
                return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            
            var reg = selection._eventRegistry;
            selection._eventRegistry = {};

            var tmpSel = new Selection(session);
            this.inVirtualSelectionMode = true;
            for (var i = ranges.length; i--;) {
                if ($byLines) {
                    while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
                        i--;
                }
                tmpSel.fromOrientedRange(ranges[i]);
                tmpSel.index = i;
                this.selection = session.selection = tmpSel;
                var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
                if (!result && cmdResult !== undefined)
                    result = cmdResult;
                tmpSel.toOrientedRange(ranges[i]);
            }
            tmpSel.detach();

            this.selection = session.selection = selection;
            this.inVirtualSelectionMode = false;
            selection._eventRegistry = reg;
            selection.mergeOverlappingRanges();
            if (selection.ranges[0])
                selection.fromOrientedRange(selection.ranges[0]);
            
            var anim = this.renderer.$scrollAnimation;
            this.onCursorChange();
            this.onSelectionChange();
            if (anim && anim.from == anim.to)
                this.renderer.animateScrolling(anim.from);
            
            return result;
        };
        this.exitMultiSelectMode = function() {
            if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
                return;
            this.multiSelect.toSingleRange();
        };

        this.getSelectedText = function() {
            var text = "";
            if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                var ranges = this.multiSelect.rangeList.ranges;
                var buf = [];
                for (var i = 0; i < ranges.length; i++) {
                    buf.push(this.session.getTextRange(ranges[i]));
                }
                var nl = this.session.getDocument().getNewLineCharacter();
                text = buf.join(nl);
                if (text.length == (buf.length - 1) * nl.length)
                    text = "";
            } else if (!this.selection.isEmpty()) {
                text = this.session.getTextRange(this.getSelectionRange());
            }
            return text;
        };
        
        this.$checkMultiselectChange = function(e, anchor) {
            if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                var range = this.multiSelect.ranges[0];
                if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
                    return;
                var pos = anchor == this.multiSelect.anchor
                    ? range.cursor == range.start ? range.end : range.start
                    : range.cursor;
                if (pos.row != anchor.row 
                    || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
                    this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
                else
                    this.multiSelect.mergeOverlappingRanges();
            }
        };
        this.findAll = function(needle, options, additive) {
            options = options || {};
            options.needle = needle || options.needle;
            if (options.needle == undefined) {
                var range = this.selection.isEmpty()
                    ? this.selection.getWordRange()
                    : this.selection.getRange();
                options.needle = this.session.getTextRange(range);
            }    
            this.$search.set(options);
            
            var ranges = this.$search.findAll(this.session);
            if (!ranges.length)
                return 0;

            var selection = this.multiSelect;

            if (!additive)
                selection.toSingleRange(ranges[0]);

            for (var i = ranges.length; i--; )
                selection.addRange(ranges[i], true);
            if (range && selection.rangeList.rangeAtPoint(range.start))
                selection.addRange(range, true);
            
            return ranges.length;
        };
        this.selectMoreLines = function(dir, skip) {
            var range = this.selection.toOrientedRange();
            var isBackwards = range.cursor == range.end;

            var screenLead = this.session.documentToScreenPosition(range.cursor);
            if (this.selection.$desiredColumn)
                screenLead.column = this.selection.$desiredColumn;

            var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);

            if (!range.isEmpty()) {
                var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
                var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
            } else {
                var anchor = lead;
            }

            if (isBackwards) {
                var newRange = Range.fromPoints(lead, anchor);
                newRange.cursor = newRange.start;
            } else {
                var newRange = Range.fromPoints(anchor, lead);
                newRange.cursor = newRange.end;
            }

            newRange.desiredColumn = screenLead.column;
            if (!this.selection.inMultiSelectMode) {
                this.selection.addRange(range);
            } else {
                if (skip)
                    var toRemove = range.cursor;
            }

            this.selection.addRange(newRange);
            if (toRemove)
                this.selection.substractPoint(toRemove);
        };
        this.transposeSelections = function(dir) {
            var session = this.session;
            var sel = session.multiSelect;
            var all = sel.ranges;

            for (var i = all.length; i--; ) {
                var range = all[i];
                if (range.isEmpty()) {
                    var tmp = session.getWordRange(range.start.row, range.start.column);
                    range.start.row = tmp.start.row;
                    range.start.column = tmp.start.column;
                    range.end.row = tmp.end.row;
                    range.end.column = tmp.end.column;
                }
            }
            sel.mergeOverlappingRanges();

            var words = [];
            for (var i = all.length; i--; ) {
                var range = all[i];
                words.unshift(session.getTextRange(range));
            }

            if (dir < 0)
                words.unshift(words.pop());
            else
                words.push(words.shift());

            for (var i = all.length; i--; ) {
                var range = all[i];
                var tmp = range.clone();
                session.replace(range, words[i]);
                range.start.row = tmp.start.row;
                range.start.column = tmp.start.column;
            }
            sel.fromOrientedRange(sel.ranges[0]);
        };
        this.selectMore = function(dir, skip, stopAtFirst) {
            var session = this.session;
            var sel = session.multiSelect;

            var range = sel.toOrientedRange();
            if (range.isEmpty()) {
                range = session.getWordRange(range.start.row, range.start.column);
                range.cursor = dir == -1 ? range.start : range.end;
                this.multiSelect.addRange(range);
                if (stopAtFirst)
                    return;
            }
            var needle = session.getTextRange(range);

            var newRange = find(session, needle, dir);
            if (newRange) {
                newRange.cursor = dir == -1 ? newRange.start : newRange.end;
                this.session.unfold(newRange);
                this.multiSelect.addRange(newRange);
                this.renderer.scrollCursorIntoView(null, 0.5);
            }
            if (skip)
                this.multiSelect.substractPoint(range.cursor);
        };
        this.alignCursors = function() {
            var session = this.session;
            var sel = session.multiSelect;
            var ranges = sel.ranges;
            var row = -1;
            var sameRowRanges = ranges.filter(function(r) {
                if (r.cursor.row == row)
                    return true;
                row = r.cursor.row;
            });
            
            if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
                var range = this.selection.getRange();
                var fr = range.start.row, lr = range.end.row;
                var guessRange = fr == lr;
                if (guessRange) {
                    var max = this.session.getLength();
                    var line;
                    do {
                        line = this.session.getLine(lr);
                    } while (/[=:]/.test(line) && ++lr < max);
                    do {
                        line = this.session.getLine(fr);
                    } while (/[=:]/.test(line) && --fr > 0);
                    
                    if (fr < 0) fr = 0;
                    if (lr >= max) lr = max - 1;
                }
                var lines = this.session.removeFullLines(fr, lr);
                lines = this.$reAlignText(lines, guessRange);
                this.session.insert({row: fr, column: 0}, lines.join("\n") + "\n");
                if (!guessRange) {
                    range.start.column = 0;
                    range.end.column = lines[lines.length - 1].length;
                }
                this.selection.setRange(range);
            } else {
                sameRowRanges.forEach(function(r) {
                    sel.substractPoint(r.cursor);
                });

                var maxCol = 0;
                var minSpace = Infinity;
                var spaceOffsets = ranges.map(function(r) {
                    var p = r.cursor;
                    var line = session.getLine(p.row);
                    var spaceOffset = line.substr(p.column).search(/\S/g);
                    if (spaceOffset == -1)
                        spaceOffset = 0;

                    if (p.column > maxCol)
                        maxCol = p.column;
                    if (spaceOffset < minSpace)
                        minSpace = spaceOffset;
                    return spaceOffset;
                });
                ranges.forEach(function(r, i) {
                    var p = r.cursor;
                    var l = maxCol - p.column;
                    var d = spaceOffsets[i] - minSpace;
                    if (l > d)
                        session.insert(p, lang.stringRepeat(" ", l - d));
                    else
                        session.remove(new Range(p.row, p.column, p.row, p.column - l + d));

                    r.start.column = r.end.column = maxCol;
                    r.start.row = r.end.row = p.row;
                    r.cursor = r.end;
                });
                sel.fromOrientedRange(ranges[0]);
                this.renderer.updateCursor();
                this.renderer.updateBackMarkers();
            }
        };

        this.$reAlignText = function(lines, forceLeft) {
            var isLeftAligned = true, isRightAligned = true;
            var startW, textW, endW;

            return lines.map(function(line) {
                var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
                if (!m)
                    return [line];

                if (startW == null) {
                    startW = m[1].length;
                    textW = m[2].length;
                    endW = m[3].length;
                    return m;
                }

                if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
                    isRightAligned = false;
                if (startW != m[1].length)
                    isLeftAligned = false;

                if (startW > m[1].length)
                    startW = m[1].length;
                if (textW < m[2].length)
                    textW = m[2].length;
                if (endW > m[3].length)
                    endW = m[3].length;

                return m;
            }).map(forceLeft ? alignLeft :
                isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);

            function spaces(n) {
                return lang.stringRepeat(" ", n);
            }

            function alignLeft(m) {
                return !m[2] ? m[0] : spaces(startW) + m[2]
                    + spaces(textW - m[2].length + endW)
                    + m[4].replace(/^([=:])\s+/, "$1 ");
            }
            function alignRight(m) {
                return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
                    + spaces(endW)
                    + m[4].replace(/^([=:])\s+/, "$1 ");
            }
            function unAlign(m) {
                return !m[2] ? m[0] : spaces(startW) + m[2]
                    + spaces(endW)
                    + m[4].replace(/^([=:])\s+/, "$1 ");
            }
        };
    }).call(Editor.prototype);


    function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
    }
    exports.onSessionChange = function(e) {
        var session = e.session;
        if (session && !session.multiSelect) {
            session.$selectionMarkers = [];
            session.selection.$initRangeList();
            session.multiSelect = session.selection;
        }
        this.multiSelect = session && session.multiSelect;

        var oldSession = e.oldSession;
        if (oldSession) {
            oldSession.multiSelect.off("addRange", this.$onAddRange);
            oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
            oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
            oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
            oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
            oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
        }

        if (session) {
            session.multiSelect.on("addRange", this.$onAddRange);
            session.multiSelect.on("removeRange", this.$onRemoveRange);
            session.multiSelect.on("multiSelect", this.$onMultiSelect);
            session.multiSelect.on("singleSelect", this.$onSingleSelect);
            session.multiSelect.lead.on("change", this.$checkMultiselectChange);
            session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
        }

        if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
            if (session.selection.inMultiSelectMode)
                this.$onMultiSelect();
            else
                this.$onSingleSelect();
        }
    };
    function MultiSelect(editor) {
        if (editor.$multiselectOnSessionChange)
            return;
        editor.$onAddRange = editor.$onAddRange.bind(editor);
        editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
        editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
        editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
        editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
        editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);

        editor.$multiselectOnSessionChange(editor);
        editor.on("changeSession", editor.$multiselectOnSessionChange);

        editor.on("mousedown", onMouseDown);
        editor.commands.addCommands(commands.defaultCommands);

        addAltCursorListeners(editor);
    }

    function addAltCursorListeners(editor){
        if (!editor.textInput) return;
        var el = editor.textInput.getElement();
        var altCursor = false;
        event.addListener(el, "keydown", function(e) {
            var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
            if (editor.$blockSelectEnabled && altDown) {
                if (!altCursor) {
                    editor.renderer.setMouseCursor("crosshair");
                    altCursor = true;
                }
            } else if (altCursor) {
                reset();
            }
        }, editor);

        event.addListener(el, "keyup", reset, editor);
        event.addListener(el, "blur", reset, editor);
        function reset(e) {
            if (altCursor) {
                editor.renderer.setMouseCursor("");
                altCursor = false;
            }
        }
    }

    exports.MultiSelect = MultiSelect;


    require("./config").defineOptions(Editor.prototype, "editor", {
        enableMultiselect: {
            set: function(val) {
                MultiSelect(this);
                if (val) {
                    this.on("changeSession", this.$multiselectOnSessionChange);
                    this.on("mousedown", onMouseDown);
                } else {
                    this.off("changeSession", this.$multiselectOnSessionChange);
                    this.off("mousedown", onMouseDown);
                }
            },
            value: true
        },
        enableBlockSelect: {
            set: function(val) {
                this.$blockSelectEnabled = val;
            },
            value: true
        }
    });



    });

    ace.define("ace/mode/folding/fold_mode",["require","exports","module","ace/range"], function(require, exports, module) {

    var Range = require("../../range").Range;

    var FoldMode = exports.FoldMode = function() {};

    (function() {

        this.foldingStartMarker = null;
        this.foldingStopMarker = null;
        this.getFoldWidget = function(session, foldStyle, row) {
            var line = session.getLine(row);
            if (this.foldingStartMarker.test(line))
                return "start";
            if (foldStyle == "markbeginend"
                    && this.foldingStopMarker
                    && this.foldingStopMarker.test(line))
                return "end";
            return "";
        };

        this.getFoldWidgetRange = function(session, foldStyle, row) {
            return null;
        };

        this.indentationBlock = function(session, row, column) {
            var re = /\S/;
            var line = session.getLine(row);
            var startLevel = line.search(re);
            if (startLevel == -1)
                return;

            var startColumn = column || line.length;
            var maxRow = session.getLength();
            var startRow = row;
            var endRow = row;

            while (++row < maxRow) {
                var level = session.getLine(row).search(re);

                if (level == -1)
                    continue;

                if (level <= startLevel) {
                    var token = session.getTokenAt(row, 0);
                    if (!token || token.type !== "string")
                        break;
                }

                endRow = row;
            }

            if (endRow > startRow) {
                var endColumn = session.getLine(endRow).length;
                return new Range(startRow, startColumn, endRow, endColumn);
            }
        };

        this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
            var start = {row: row, column: column + 1};
            var end = session.$findClosingBracket(bracket, start, typeRe);
            if (!end)
                return;

            var fw = session.foldWidgets[end.row];
            if (fw == null)
                fw = session.getFoldWidget(end.row);

            if (fw == "start" && end.row > start.row) {
                end.row --;
                end.column = session.getLine(end.row).length;
            }
            return Range.fromPoints(start, end);
        };

        this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
            var end = {row: row, column: column};
            var start = session.$findOpeningBracket(bracket, end);

            if (!start)
                return;

            start.column++;
            end.column--;

            return  Range.fromPoints(start, end);
        };
    }).call(FoldMode.prototype);

    });

    ace.define("ace/theme/textmate",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

    exports.isDark = false;
    exports.cssClass = "ace-tm";
    exports.cssText = ".ace-tm .ace_gutter {\
background: #f0f0f0;\
color: #333;\
}\
.ace-tm .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-tm .ace_fold {\
background-color: #6B72E6;\
}\
.ace-tm {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-tm .ace_cursor {\
color: black;\
}\
.ace-tm .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-tm .ace_storage,\
.ace-tm .ace_keyword {\
color: blue;\
}\
.ace-tm .ace_constant {\
color: rgb(197, 6, 11);\
}\
.ace-tm .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-tm .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-tm .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_invalid {\
background-color: rgba(255, 0, 0, 0.1);\
color: red;\
}\
.ace-tm .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-tm .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_support.ace_type,\
.ace-tm .ace_support.ace_class {\
color: rgb(109, 121, 222);\
}\
.ace-tm .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-tm .ace_string {\
color: rgb(3, 106, 7);\
}\
.ace-tm .ace_comment {\
color: rgb(76, 136, 107);\
}\
.ace-tm .ace_comment.ace_doc {\
color: rgb(0, 102, 255);\
}\
.ace-tm .ace_comment.ace_doc.ace_tag {\
color: rgb(128, 159, 191);\
}\
.ace-tm .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-tm .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-tm .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-tm .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-tm .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-tm .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-tm .ace_meta.ace_tag {\
color:rgb(0, 22, 142);\
}\
.ace-tm .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-tm .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-tm.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px white;\
}\
.ace-tm .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-tm .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-tm .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-tm .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-tm .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-tm .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-tm .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";
    exports.$id = "ace/theme/textmate";

    var dom = require("../lib/dom");
    dom.importCssString(exports.cssText, exports.cssClass);
    });

    ace.define("ace/line_widgets",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

    var dom = require("./lib/dom");

    function LineWidgets(session) {
        this.session = session;
        this.session.widgetManager = this;
        this.session.getRowLength = this.getRowLength;
        this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
        this.updateOnChange = this.updateOnChange.bind(this);
        this.renderWidgets = this.renderWidgets.bind(this);
        this.measureWidgets = this.measureWidgets.bind(this);
        this.session._changedWidgets = [];
        this.$onChangeEditor = this.$onChangeEditor.bind(this);
        
        this.session.on("change", this.updateOnChange);
        this.session.on("changeFold", this.updateOnFold);
        this.session.on("changeEditor", this.$onChangeEditor);
    }

    (function() {
        this.getRowLength = function(row) {
            var h;
            if (this.lineWidgets)
                h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            else 
                h = 0;
            if (!this.$useWrapMode || !this.$wrapData[row]) {
                return 1 + h;
            } else {
                return this.$wrapData[row].length + 1 + h;
            }
        };

        this.$getWidgetScreenLength = function() {
            var screenRows = 0;
            this.lineWidgets.forEach(function(w){
                if (w && w.rowCount && !w.hidden)
                    screenRows += w.rowCount;
            });
            return screenRows;
        };    
        
        this.$onChangeEditor = function(e) {
            this.attach(e.editor);
        };
        
        this.attach = function(editor) {
            if (editor  && editor.widgetManager && editor.widgetManager != this)
                editor.widgetManager.detach();

            if (this.editor == editor)
                return;

            this.detach();
            this.editor = editor;
            
            if (editor) {
                editor.widgetManager = this;
                editor.renderer.on("beforeRender", this.measureWidgets);
                editor.renderer.on("afterRender", this.renderWidgets);
            }
        };
        this.detach = function(e) {
            var editor = this.editor;
            if (!editor)
                return;
            
            this.editor = null;
            editor.widgetManager = null;
            
            editor.renderer.off("beforeRender", this.measureWidgets);
            editor.renderer.off("afterRender", this.renderWidgets);
            var lineWidgets = this.session.lineWidgets;
            lineWidgets && lineWidgets.forEach(function(w) {
                if (w && w.el && w.el.parentNode) {
                    w._inDocument = false;
                    w.el.parentNode.removeChild(w.el);
                }
            });
        };

        this.updateOnFold = function(e, session) {
            var lineWidgets = session.lineWidgets;
            if (!lineWidgets || !e.action)
                return;
            var fold = e.data;
            var start = fold.start.row;
            var end = fold.end.row;
            var hide = e.action == "add";
            for (var i = start + 1; i < end; i++) {
                if (lineWidgets[i])
                    lineWidgets[i].hidden = hide;
            }
            if (lineWidgets[end]) {
                if (hide) {
                    if (!lineWidgets[start])
                        lineWidgets[start] = lineWidgets[end];
                    else
                        lineWidgets[end].hidden = hide;
                } else {
                    if (lineWidgets[start] == lineWidgets[end])
                        lineWidgets[start] = undefined;
                    lineWidgets[end].hidden = hide;
                }
            }
        };
        
        this.updateOnChange = function(delta) {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets) return;
            
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;

            if (len === 0) ; else if (delta.action == "remove") {
                var removed = lineWidgets.splice(startRow + 1, len);
                if (!lineWidgets[startRow] && removed[removed.length - 1]) {
                    lineWidgets[startRow] = removed.pop();
                }
                removed.forEach(function(w) {
                    w && this.removeLineWidget(w);
                }, this);
                this.$updateRows();
            } else {
                var args = new Array(len);
                if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {
                    if (delta.start.column > lineWidgets[startRow].column)
                        startRow++;
                }
                args.unshift(startRow, 0);
                lineWidgets.splice.apply(lineWidgets, args);
                this.$updateRows();
            }
        };
        
        this.$updateRows = function() {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets) return;
            var noWidgets = true;
            lineWidgets.forEach(function(w, i) {
                if (w) {
                    noWidgets = false;
                    w.row = i;
                    while (w.$oldWidget) {
                        w.$oldWidget.row = i;
                        w = w.$oldWidget;
                    }
                }
            });
            if (noWidgets)
                this.session.lineWidgets = null;
        };

        this.$registerLineWidget = function(w) {
            if (!this.session.lineWidgets)
                this.session.lineWidgets = new Array(this.session.getLength());
            
            var old = this.session.lineWidgets[w.row];
            if (old) {
                w.$oldWidget = old;
                if (old.el && old.el.parentNode) {
                    old.el.parentNode.removeChild(old.el);
                    old._inDocument = false;
                }
            }
                
            this.session.lineWidgets[w.row] = w;
            return w;
        };
        
        this.addLineWidget = function(w) {
            this.$registerLineWidget(w);
            w.session = this.session;
            
            if (!this.editor) return w;
            
            var renderer = this.editor.renderer;
            if (w.html && !w.el) {
                w.el = dom.createElement("div");
                w.el.innerHTML = w.html;
            }
            if (w.el) {
                dom.addCssClass(w.el, "ace_lineWidgetContainer");
                w.el.style.position = "absolute";
                w.el.style.zIndex = 5;
                renderer.container.appendChild(w.el);
                w._inDocument = true;
                
                if (!w.coverGutter) {
                    w.el.style.zIndex = 3;
                }
                if (w.pixelHeight == null) {
                    w.pixelHeight = w.el.offsetHeight;
                }
            }
            if (w.rowCount == null) {
                w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
            }
            
            var fold = this.session.getFoldAt(w.row, 0);
            w.$fold = fold;
            if (fold) {
                var lineWidgets = this.session.lineWidgets;
                if (w.row == fold.end.row && !lineWidgets[fold.start.row])
                    lineWidgets[fold.start.row] = w;
                else
                    w.hidden = true;
            }
                
            this.session._emit("changeFold", {data:{start:{row: w.row}}});
            
            this.$updateRows();
            this.renderWidgets(null, renderer);
            this.onWidgetChanged(w);
            return w;
        };
        
        this.removeLineWidget = function(w) {
            w._inDocument = false;
            w.session = null;
            if (w.el && w.el.parentNode)
                w.el.parentNode.removeChild(w.el);
            if (w.editor && w.editor.destroy) try {
                w.editor.destroy();
            } catch(e){}
            if (this.session.lineWidgets) {
                var w1 = this.session.lineWidgets[w.row];
                if (w1 == w) {
                    this.session.lineWidgets[w.row] = w.$oldWidget;
                    if (w.$oldWidget)
                        this.onWidgetChanged(w.$oldWidget);
                } else {
                    while (w1) {
                        if (w1.$oldWidget == w) {
                            w1.$oldWidget = w.$oldWidget;
                            break;
                        }
                        w1 = w1.$oldWidget;
                    }
                }
            }
            this.session._emit("changeFold", {data:{start:{row: w.row}}});
            this.$updateRows();
        };
        
        this.getWidgetsAtRow = function(row) {
            var lineWidgets = this.session.lineWidgets;
            var w = lineWidgets && lineWidgets[row];
            var list = [];
            while (w) {
                list.push(w);
                w = w.$oldWidget;
            }
            return list;
        };
        
        this.onWidgetChanged = function(w) {
            this.session._changedWidgets.push(w);
            this.editor && this.editor.renderer.updateFull();
        };
        
        this.measureWidgets = function(e, renderer) {
            var changedWidgets = this.session._changedWidgets;
            var config = renderer.layerConfig;
            
            if (!changedWidgets || !changedWidgets.length) return;
            var min = Infinity;
            for (var i = 0; i < changedWidgets.length; i++) {
                var w = changedWidgets[i];
                if (!w || !w.el) continue;
                if (w.session != this.session) continue;
                if (!w._inDocument) {
                    if (this.session.lineWidgets[w.row] != w)
                        continue;
                    w._inDocument = true;
                    renderer.container.appendChild(w.el);
                }
                
                w.h = w.el.offsetHeight;
                
                if (!w.fixedWidth) {
                    w.w = w.el.offsetWidth;
                    w.screenWidth = Math.ceil(w.w / config.characterWidth);
                }
                
                var rowCount = w.h / config.lineHeight;
                if (w.coverLine) {
                    rowCount -= this.session.getRowLineCount(w.row);
                    if (rowCount < 0)
                        rowCount = 0;
                }
                if (w.rowCount != rowCount) {
                    w.rowCount = rowCount;
                    if (w.row < min)
                        min = w.row;
                }
            }
            if (min != Infinity) {
                this.session._emit("changeFold", {data:{start:{row: min}}});
                this.session.lineWidgetWidth = null;
            }
            this.session._changedWidgets = [];
        };
        
        this.renderWidgets = function(e, renderer) {
            var config = renderer.layerConfig;
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
                return;
            var first = Math.min(this.firstRow, config.firstRow);
            var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
            
            while (first > 0 && !lineWidgets[first])
                first--;
            
            this.firstRow = config.firstRow;
            this.lastRow = config.lastRow;

            renderer.$cursorLayer.config = config;
            for (var i = first; i <= last; i++) {
                var w = lineWidgets[i];
                if (!w || !w.el) continue;
                if (w.hidden) {
                    w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
                    continue;
                }
                if (!w._inDocument) {
                    w._inDocument = true;
                    renderer.container.appendChild(w.el);
                }
                var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;
                if (!w.coverLine)
                    top += config.lineHeight * this.session.getRowLineCount(w.row);
                w.el.style.top = top - config.offset + "px";
                
                var left = w.coverGutter ? 0 : renderer.gutterWidth;
                if (!w.fixedWidth)
                    left -= renderer.scrollLeft;
                w.el.style.left = left + "px";
                
                if (w.fullWidth && w.screenWidth) {
                    w.el.style.minWidth = config.width + 2 * config.padding + "px";
                }
                
                if (w.fixedWidth) {
                    w.el.style.right = renderer.scrollBar.getWidth() + "px";
                } else {
                    w.el.style.right = "";
                }
            }
        };
        
    }).call(LineWidgets.prototype);


    exports.LineWidgets = LineWidgets;

    });

    ace.define("ace/ext/error_marker",["require","exports","module","ace/line_widgets","ace/lib/dom","ace/range"], function(require, exports, module) {
    var LineWidgets = require("../line_widgets").LineWidgets;
    var dom = require("../lib/dom");
    var Range = require("../range").Range;

    function binarySearch(array, needle, comparator) {
        var first = 0;
        var last = array.length - 1;

        while (first <= last) {
            var mid = (first + last) >> 1;
            var c = comparator(needle, array[mid]);
            if (c > 0)
                first = mid + 1;
            else if (c < 0)
                last = mid - 1;
            else
                return mid;
        }
        return -(first + 1);
    }

    function findAnnotations(session, row, dir) {
        var annotations = session.getAnnotations().sort(Range.comparePoints);
        if (!annotations.length)
            return;
        
        var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);
        if (i < 0)
            i = -i - 1;
        
        if (i >= annotations.length)
            i = dir > 0 ? 0 : annotations.length - 1;
        else if (i === 0 && dir < 0)
            i = annotations.length - 1;
        
        var annotation = annotations[i];
        if (!annotation || !dir)
            return;

        if (annotation.row === row) {
            do {
                annotation = annotations[i += dir];
            } while (annotation && annotation.row === row);
            if (!annotation)
                return annotations.slice();
        }
        
        
        var matched = [];
        row = annotation.row;
        do {
            matched[dir < 0 ? "unshift" : "push"](annotation);
            annotation = annotations[i += dir];
        } while (annotation && annotation.row == row);
        return matched.length && matched;
    }

    exports.showErrorMarker = function(editor, dir) {
        var session = editor.session;
        if (!session.widgetManager) {
            session.widgetManager = new LineWidgets(session);
            session.widgetManager.attach(editor);
        }
        
        var pos = editor.getCursorPosition();
        var row = pos.row;
        var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w) {
            return w.type == "errorMarker";
        })[0];
        if (oldWidget) {
            oldWidget.destroy();
        } else {
            row -= dir;
        }
        var annotations = findAnnotations(session, row, dir);
        var gutterAnno;
        if (annotations) {
            var annotation = annotations[0];
            pos.column = (annotation.pos && typeof annotation.column != "number"
                ? annotation.pos.sc
                : annotation.column) || 0;
            pos.row = annotation.row;
            gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
        } else if (oldWidget) {
            return;
        } else {
            gutterAnno = {
                text: ["Looks good!"],
                className: "ace_ok"
            };
        }
        editor.session.unfold(pos.row);
        editor.selection.moveToPosition(pos);
        
        var w = {
            row: pos.row, 
            fixedWidth: true,
            coverGutter: true,
            el: dom.createElement("div"),
            type: "errorMarker"
        };
        var el = w.el.appendChild(dom.createElement("div"));
        var arrow = w.el.appendChild(dom.createElement("div"));
        arrow.className = "error_widget_arrow " + gutterAnno.className;
        
        var left = editor.renderer.$cursorLayer
            .getPixelPosition(pos).left;
        arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
        
        w.el.className = "error_widget_wrapper";
        el.className = "error_widget " + gutterAnno.className;
        el.innerHTML = gutterAnno.text.join("<br>");
        
        el.appendChild(dom.createElement("div"));
        
        var kb = function(_, hashId, keyString) {
            if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
                w.destroy();
                return {command: "null"};
            }
        };
        
        w.destroy = function() {
            if (editor.$mouseHandler.isMousePressed)
                return;
            editor.keyBinding.removeKeyboardHandler(kb);
            session.widgetManager.removeLineWidget(w);
            editor.off("changeSelection", w.destroy);
            editor.off("changeSession", w.destroy);
            editor.off("mouseup", w.destroy);
            editor.off("change", w.destroy);
        };
        
        editor.keyBinding.addKeyboardHandler(kb);
        editor.on("changeSelection", w.destroy);
        editor.on("changeSession", w.destroy);
        editor.on("mouseup", w.destroy);
        editor.on("change", w.destroy);
        
        editor.session.widgetManager.addLineWidget(w);
        
        w.el.onmousedown = editor.focus.bind(editor);
        
        editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});
    };


    dom.importCssString("\
    .error_widget_wrapper {\
        background: inherit;\
        color: inherit;\
        border:none\
    }\
    .error_widget {\
        border-top: solid 2px;\
        border-bottom: solid 2px;\
        margin: 5px 0;\
        padding: 10px 40px;\
        white-space: pre-wrap;\
    }\
    .error_widget.ace_error, .error_widget_arrow.ace_error{\
        border-color: #ff5a5a\
    }\
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
        border-color: #F1D817\
    }\
    .error_widget.ace_info, .error_widget_arrow.ace_info{\
        border-color: #5a5a5a\
    }\
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
        border-color: #5aaa5a\
    }\
    .error_widget_arrow {\
        position: absolute;\
        border: solid 5px;\
        border-top-color: transparent!important;\
        border-right-color: transparent!important;\
        border-left-color: transparent!important;\
        top: -5px;\
    }\
", "");

    });

    ace.define("ace/ace",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/dom","ace/lib/event","ace/range","ace/editor","ace/edit_session","ace/undomanager","ace/virtual_renderer","ace/worker/worker_client","ace/keyboard/hash_handler","ace/placeholder","ace/multi_select","ace/mode/folding/fold_mode","ace/theme/textmate","ace/ext/error_marker","ace/config"], function(require, exports, module) {

    require("./lib/fixoldbrowsers");

    var dom = require("./lib/dom");
    var event = require("./lib/event");

    var Range = require("./range").Range;
    var Editor = require("./editor").Editor;
    var EditSession = require("./edit_session").EditSession;
    var UndoManager = require("./undomanager").UndoManager;
    var Renderer = require("./virtual_renderer").VirtualRenderer;
    require("./worker/worker_client");
    require("./keyboard/hash_handler");
    require("./placeholder");
    require("./multi_select");
    require("./mode/folding/fold_mode");
    require("./theme/textmate");
    require("./ext/error_marker");

    exports.config = require("./config");
    exports.require = require;
    exports.edit = function(el, options) {
        if (typeof el == "string") {
            var _id = el;
            el = document.getElementById(_id);
            if (!el)
                throw new Error("ace.edit can't find div #" + _id);
        }

        if (el && el.env && el.env.editor instanceof Editor)
            return el.env.editor;

        var value = "";
        if (el && /input|textarea/i.test(el.tagName)) {
            var oldNode = el;
            value = oldNode.value;
            el = dom.createElement("pre");
            oldNode.parentNode.replaceChild(el, oldNode);
        } else if (el) {
            value = el.textContent;
            el.innerHTML = "";
        }

        var doc = exports.createEditSession(value);

        var editor = new Editor(new Renderer(el), doc, options);

        var env = {
            document: doc,
            editor: editor,
            onResize: editor.resize.bind(editor, null)
        };
        if (oldNode) env.textarea = oldNode;
        event.addListener(window, "resize", env.onResize);
        editor.on("destroy", function() {
            event.removeListener(window, "resize", env.onResize);
            env.editor.container.env = null; // prevent memory leak on old ie
        });
        editor.container.env = editor.env = env;
        return editor;
    };
    exports.createEditSession = function(text, mode) {
        var doc = new EditSession(text, mode);
        doc.setUndoManager(new UndoManager());
        return doc;
    };
    exports.Range = Range;
    exports.Editor = Editor;
    exports.EditSession = EditSession;
    exports.UndoManager = UndoManager;
    exports.VirtualRenderer = Renderer;
    exports.version = exports.config.version;
    });            (function() {
                    ace.require(["ace/ace"], function(a) {
                        if (a) {
                            a.config.init(true);
                            a.define = ace.define;
                        }
                        if (!window.ace)
                            window.ace = a;
                        for (var key in a) if (a.hasOwnProperty(key))
                            window.ace[key] = a[key];
                        window.ace["default"] = window.ace;
                        if (module) {
                            module.exports = window.ace;
                        }
                    });
                })();
    });

    createCommonjsModule(function (module, exports) {
    ace.define("ace/mode/json_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(require, exports, module) {

    var oop = require("../lib/oop");
    var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

    var JsonHighlightRules = function() {
        this.$rules = {
            "start" : [
                {
                    token : "variable", // single line
                    regex : '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]\\s*(?=:)'
                }, {
                    token : "string", // single line
                    regex : '"',
                    next  : "string"
                }, {
                    token : "constant.numeric", // hex
                    regex : "0[xX][0-9a-fA-F]+\\b"
                }, {
                    token : "constant.numeric", // float
                    regex : "[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"
                }, {
                    token : "constant.language.boolean",
                    regex : "(?:true|false)\\b"
                }, {
                    token : "text", // single quoted strings are not allowed
                    regex : "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
                }, {
                    token : "comment", // comments are not allowed, but who cares?
                    regex : "\\/\\/.*$"
                }, {
                    token : "comment.start", // comments are not allowed, but who cares?
                    regex : "\\/\\*",
                    next  : "comment"
                }, {
                    token : "paren.lparen",
                    regex : "[[({]"
                }, {
                    token : "paren.rparen",
                    regex : "[\\])}]"
                }, {
                    token : "text",
                    regex : "\\s+"
                }
            ],
            "string" : [
                {
                    token : "constant.language.escape",
                    regex : /\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|["\\\/bfnrt])/
                }, {
                    token : "string",
                    regex : '"|$',
                    next  : "start"
                }, {
                    defaultToken : "string"
                }
            ],
            "comment" : [
                {
                    token : "comment.end", // comments are not allowed, but who cares?
                    regex : "\\*\\/",
                    next  : "start"
                }, {
                    defaultToken: "comment"
                }
            ]
        };
        
    };

    oop.inherits(JsonHighlightRules, TextHighlightRules);

    exports.JsonHighlightRules = JsonHighlightRules;
    });

    ace.define("ace/mode/matching_brace_outdent",["require","exports","module","ace/range"], function(require, exports, module) {

    var Range = require("../range").Range;

    var MatchingBraceOutdent = function() {};

    (function() {

        this.checkOutdent = function(line, input) {
            if (! /^\s+$/.test(line))
                return false;

            return /^\s*\}/.test(input);
        };

        this.autoOutdent = function(doc, row) {
            var line = doc.getLine(row);
            var match = line.match(/^(\s*\})/);

            if (!match) return 0;

            var column = match[1].length;
            var openBracePos = doc.findMatchingBracket({row: row, column: column});

            if (!openBracePos || openBracePos.row == row) return 0;

            var indent = this.$getIndent(doc.getLine(openBracePos.row));
            doc.replace(new Range(row, 0, row, column-1), indent);
        };

        this.$getIndent = function(line) {
            return line.match(/^\s*/)[0];
        };

    }).call(MatchingBraceOutdent.prototype);

    exports.MatchingBraceOutdent = MatchingBraceOutdent;
    });

    ace.define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"], function(require, exports, module) {

    var oop = require("../../lib/oop");
    var Range = require("../../range").Range;
    var BaseFoldMode = require("./fold_mode").FoldMode;

    var FoldMode = exports.FoldMode = function(commentRegex) {
        if (commentRegex) {
            this.foldingStartMarker = new RegExp(
                this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
            );
            this.foldingStopMarker = new RegExp(
                this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
            );
        }
    };
    oop.inherits(FoldMode, BaseFoldMode);

    (function() {
        
        this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/;
        this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/;
        this.singleLineBlockCommentRe= /^\s*(\/\*).*\*\/\s*$/;
        this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
        this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
        this._getFoldWidgetBase = this.getFoldWidget;
        this.getFoldWidget = function(session, foldStyle, row) {
            var line = session.getLine(row);
        
            if (this.singleLineBlockCommentRe.test(line)) {
                if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
                    return "";
            }
        
            var fw = this._getFoldWidgetBase(session, foldStyle, row);
        
            if (!fw && this.startRegionRe.test(line))
                return "start"; // lineCommentRegionStart
        
            return fw;
        };

        this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
            var line = session.getLine(row);
            
            if (this.startRegionRe.test(line))
                return this.getCommentRegionBlock(session, line, row);
            
            var match = line.match(this.foldingStartMarker);
            if (match) {
                var i = match.index;

                if (match[1])
                    return this.openingBracketBlock(session, match[1], row, i);
                    
                var range = session.getCommentFoldRange(row, i + match[0].length, 1);
                
                if (range && !range.isMultiLine()) {
                    if (forceMultiline) {
                        range = this.getSectionRange(session, row);
                    } else if (foldStyle != "all")
                        range = null;
                }
                
                return range;
            }

            if (foldStyle === "markbegin")
                return;

            var match = line.match(this.foldingStopMarker);
            if (match) {
                var i = match.index + match[0].length;

                if (match[1])
                    return this.closingBracketBlock(session, match[1], row, i);

                return session.getCommentFoldRange(row, i, -1);
            }
        };
        
        this.getSectionRange = function(session, row) {
            var line = session.getLine(row);
            var startIndent = line.search(/\S/);
            var startRow = row;
            var startColumn = line.length;
            row = row + 1;
            var endRow = row;
            var maxRow = session.getLength();
            while (++row < maxRow) {
                line = session.getLine(row);
                var indent = line.search(/\S/);
                if (indent === -1)
                    continue;
                if  (startIndent > indent)
                    break;
                var subRange = this.getFoldWidgetRange(session, "all", row);
                
                if (subRange) {
                    if (subRange.start.row <= startRow) {
                        break;
                    } else if (subRange.isMultiLine()) {
                        row = subRange.end.row;
                    } else if (startIndent == indent) {
                        break;
                    }
                }
                endRow = row;
            }
            
            return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
        };
        this.getCommentRegionBlock = function(session, line, row) {
            var startColumn = line.search(/\s*$/);
            var maxRow = session.getLength();
            var startRow = row;
            
            var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
            var depth = 1;
            while (++row < maxRow) {
                line = session.getLine(row);
                var m = re.exec(line);
                if (!m) continue;
                if (m[1]) depth--;
                else depth++;

                if (!depth) break;
            }

            var endRow = row;
            if (endRow > startRow) {
                return new Range(startRow, startColumn, endRow, line.length);
            }
        };

    }).call(FoldMode.prototype);

    });

    ace.define("ace/mode/json",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/json_highlight_rules","ace/mode/matching_brace_outdent","ace/mode/behaviour/cstyle","ace/mode/folding/cstyle","ace/worker/worker_client"], function(require, exports, module) {

    var oop = require("../lib/oop");
    var TextMode = require("./text").Mode;
    var HighlightRules = require("./json_highlight_rules").JsonHighlightRules;
    var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
    var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
    var CStyleFoldMode = require("./folding/cstyle").FoldMode;
    var WorkerClient = require("../worker/worker_client").WorkerClient;

    var Mode = function() {
        this.HighlightRules = HighlightRules;
        this.$outdent = new MatchingBraceOutdent();
        this.$behaviour = new CstyleBehaviour();
        this.foldingRules = new CStyleFoldMode();
    };
    oop.inherits(Mode, TextMode);

    (function() {

        this.lineCommentStart = "//";
        this.blockComment = {start: "/*", end: "*/"};
        
        this.getNextLineIndent = function(state, line, tab) {
            var indent = this.$getIndent(line);

            if (state == "start") {
                var match = line.match(/^.*[\{\(\[]\s*$/);
                if (match) {
                    indent += tab;
                }
            }

            return indent;
        };

        this.checkOutdent = function(state, line, input) {
            return this.$outdent.checkOutdent(line, input);
        };

        this.autoOutdent = function(state, doc, row) {
            this.$outdent.autoOutdent(doc, row);
        };

        this.createWorker = function(session) {
            var worker = new WorkerClient(["ace"], "ace/mode/json_worker", "JsonWorker");
            worker.attachToDocument(session.getDocument());

            worker.on("annotate", function(e) {
                session.setAnnotations(e.data);
            });

            worker.on("terminate", function() {
                session.clearAnnotations();
            });

            return worker;
        };


        this.$id = "ace/mode/json";
    }).call(Mode.prototype);

    exports.Mode = Mode;
    });                (function() {
                        ace.require(["ace/mode/json"], function(m) {
                            if (module) {
                                module.exports = m;
                            }
                        });
                    })();
    });

    createCommonjsModule(function (module, exports) {
    ace.define("ace/ext/searchbox",["require","exports","module","ace/lib/dom","ace/lib/lang","ace/lib/event","ace/keyboard/hash_handler","ace/lib/keys"], function(require, exports, module) {

    var dom = require("../lib/dom");
    var lang = require("../lib/lang");
    var event = require("../lib/event");
    var searchboxCss = "\
.ace_search {\
background-color: #ddd;\
color: #666;\
border: 1px solid #cbcbcb;\
border-top: 0 none;\
overflow: hidden;\
margin: 0;\
padding: 4px 6px 0 4px;\
position: absolute;\
top: 0;\
z-index: 99;\
white-space: normal;\
}\
.ace_search.left {\
border-left: 0 none;\
border-radius: 0px 0px 5px 0px;\
left: 0;\
}\
.ace_search.right {\
border-radius: 0px 0px 0px 5px;\
border-right: 0 none;\
right: 0;\
}\
.ace_search_form, .ace_replace_form {\
margin: 0 20px 4px 0;\
overflow: hidden;\
line-height: 1.9;\
}\
.ace_replace_form {\
margin-right: 0;\
}\
.ace_search_form.ace_nomatch {\
outline: 1px solid red;\
}\
.ace_search_field {\
border-radius: 3px 0 0 3px;\
background-color: white;\
color: black;\
border: 1px solid #cbcbcb;\
border-right: 0 none;\
outline: 0;\
padding: 0;\
font-size: inherit;\
margin: 0;\
line-height: inherit;\
padding: 0 6px;\
min-width: 17em;\
vertical-align: top;\
min-height: 1.8em;\
box-sizing: content-box;\
}\
.ace_searchbtn {\
border: 1px solid #cbcbcb;\
line-height: inherit;\
display: inline-block;\
padding: 0 6px;\
background: #fff;\
border-right: 0 none;\
border-left: 1px solid #dcdcdc;\
cursor: pointer;\
margin: 0;\
position: relative;\
color: #666;\
}\
.ace_searchbtn:last-child {\
border-radius: 0 3px 3px 0;\
border-right: 1px solid #cbcbcb;\
}\
.ace_searchbtn:disabled {\
background: none;\
cursor: default;\
}\
.ace_searchbtn:hover {\
background-color: #eef1f6;\
}\
.ace_searchbtn.prev, .ace_searchbtn.next {\
padding: 0px 0.7em\
}\
.ace_searchbtn.prev:after, .ace_searchbtn.next:after {\
content: \"\";\
border: solid 2px #888;\
width: 0.5em;\
height: 0.5em;\
border-width:  2px 0 0 2px;\
display:inline-block;\
transform: rotate(-45deg);\
}\
.ace_searchbtn.next:after {\
border-width: 0 2px 2px 0 ;\
}\
.ace_searchbtn_close {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAcCAYAAABRVo5BAAAAZ0lEQVR42u2SUQrAMAhDvazn8OjZBilCkYVVxiis8H4CT0VrAJb4WHT3C5xU2a2IQZXJjiQIRMdkEoJ5Q2yMqpfDIo+XY4k6h+YXOyKqTIj5REaxloNAd0xiKmAtsTHqW8sR2W5f7gCu5nWFUpVjZwAAAABJRU5ErkJggg==) no-repeat 50% 0;\
border-radius: 50%;\
border: 0 none;\
color: #656565;\
cursor: pointer;\
font: 16px/16px Arial;\
padding: 0;\
height: 14px;\
width: 14px;\
top: 9px;\
right: 7px;\
position: absolute;\
}\
.ace_searchbtn_close:hover {\
background-color: #656565;\
background-position: 50% 100%;\
color: white;\
}\
.ace_button {\
margin-left: 2px;\
cursor: pointer;\
-webkit-user-select: none;\
-moz-user-select: none;\
-o-user-select: none;\
-ms-user-select: none;\
user-select: none;\
overflow: hidden;\
opacity: 0.7;\
border: 1px solid rgba(100,100,100,0.23);\
padding: 1px;\
box-sizing:    border-box!important;\
color: black;\
}\
.ace_button:hover {\
background-color: #eee;\
opacity:1;\
}\
.ace_button:active {\
background-color: #ddd;\
}\
.ace_button.checked {\
border-color: #3399ff;\
opacity:1;\
}\
.ace_search_options{\
margin-bottom: 3px;\
text-align: right;\
-webkit-user-select: none;\
-moz-user-select: none;\
-o-user-select: none;\
-ms-user-select: none;\
user-select: none;\
clear: both;\
}\
.ace_search_counter {\
float: left;\
font-family: arial;\
padding: 0 8px;\
}";
    var HashHandler = require("../keyboard/hash_handler").HashHandler;
    var keyUtil = require("../lib/keys");

    var MAX_COUNT = 999;

    dom.importCssString(searchboxCss, "ace_searchbox");

    var SearchBox = function(editor, range, showReplaceForm) {
        var div = dom.createElement("div");
        dom.buildDom(["div", {class:"ace_search right"},
            ["span", {action: "hide", class: "ace_searchbtn_close"}],
            ["div", {class: "ace_search_form"},
                ["input", {class: "ace_search_field", placeholder: "Search for", spellcheck: "false"}],
                ["span", {action: "findPrev", class: "ace_searchbtn prev"}, "\u200b"],
                ["span", {action: "findNext", class: "ace_searchbtn next"}, "\u200b"],
                ["span", {action: "findAll", class: "ace_searchbtn", title: "Alt-Enter"}, "All"]
            ],
            ["div", {class: "ace_replace_form"},
                ["input", {class: "ace_search_field", placeholder: "Replace with", spellcheck: "false"}],
                ["span", {action: "replaceAndFindNext", class: "ace_searchbtn"}, "Replace"],
                ["span", {action: "replaceAll", class: "ace_searchbtn"}, "All"]
            ],
            ["div", {class: "ace_search_options"},
                ["span", {action: "toggleReplace", class: "ace_button", title: "Toggle Replace mode",
                    style: "float:left;margin-top:-2px;padding:0 5px;"}, "+"],
                ["span", {class: "ace_search_counter"}],
                ["span", {action: "toggleRegexpMode", class: "ace_button", title: "RegExp Search"}, ".*"],
                ["span", {action: "toggleCaseSensitive", class: "ace_button", title: "CaseSensitive Search"}, "Aa"],
                ["span", {action: "toggleWholeWords", class: "ace_button", title: "Whole Word Search"}, "\\b"],
                ["span", {action: "searchInSelection", class: "ace_button", title: "Search In Selection"}, "S"]
            ]
        ], div);
        this.element = div.firstChild;
        
        this.setSession = this.setSession.bind(this);

        this.$init();
        this.setEditor(editor);
        dom.importCssString(searchboxCss, "ace_searchbox", editor.container);
    };

    (function() {
        this.setEditor = function(editor) {
            editor.searchBox = this;
            editor.renderer.scroller.appendChild(this.element);
            this.editor = editor;
        };
        
        this.setSession = function(e) {
            this.searchRange = null;
            this.$syncOptions(true);
        };

        this.$initElements = function(sb) {
            this.searchBox = sb.querySelector(".ace_search_form");
            this.replaceBox = sb.querySelector(".ace_replace_form");
            this.searchOption = sb.querySelector("[action=searchInSelection]");
            this.replaceOption = sb.querySelector("[action=toggleReplace]");
            this.regExpOption = sb.querySelector("[action=toggleRegexpMode]");
            this.caseSensitiveOption = sb.querySelector("[action=toggleCaseSensitive]");
            this.wholeWordOption = sb.querySelector("[action=toggleWholeWords]");
            this.searchInput = this.searchBox.querySelector(".ace_search_field");
            this.replaceInput = this.replaceBox.querySelector(".ace_search_field");
            this.searchCounter = sb.querySelector(".ace_search_counter");
        };
        
        this.$init = function() {
            var sb = this.element;
            
            this.$initElements(sb);
            
            var _this = this;
            event.addListener(sb, "mousedown", function(e) {
                setTimeout(function(){
                    _this.activeInput.focus();
                }, 0);
                event.stopPropagation(e);
            });
            event.addListener(sb, "click", function(e) {
                var t = e.target || e.srcElement;
                var action = t.getAttribute("action");
                if (action && _this[action])
                    _this[action]();
                else if (_this.$searchBarKb.commands[action])
                    _this.$searchBarKb.commands[action].exec(_this);
                event.stopPropagation(e);
            });

            event.addCommandKeyListener(sb, function(e, hashId, keyCode) {
                var keyString = keyUtil.keyCodeToString(keyCode);
                var command = _this.$searchBarKb.findKeyCommand(hashId, keyString);
                if (command && command.exec) {
                    command.exec(_this);
                    event.stopEvent(e);
                }
            });

            this.$onChange = lang.delayedCall(function() {
                _this.find(false, false);
            });

            event.addListener(this.searchInput, "input", function() {
                _this.$onChange.schedule(20);
            });
            event.addListener(this.searchInput, "focus", function() {
                _this.activeInput = _this.searchInput;
                _this.searchInput.value && _this.highlight();
            });
            event.addListener(this.replaceInput, "focus", function() {
                _this.activeInput = _this.replaceInput;
                _this.searchInput.value && _this.highlight();
            });
        };
        this.$closeSearchBarKb = new HashHandler([{
            bindKey: "Esc",
            name: "closeSearchBar",
            exec: function(editor) {
                editor.searchBox.hide();
            }
        }]);
        this.$searchBarKb = new HashHandler();
        this.$searchBarKb.bindKeys({
            "Ctrl-f|Command-f": function(sb) {
                var isReplace = sb.isReplace = !sb.isReplace;
                sb.replaceBox.style.display = isReplace ? "" : "none";
                sb.replaceOption.checked = false;
                sb.$syncOptions();
                sb.searchInput.focus();
            },
            "Ctrl-H|Command-Option-F": function(sb) {
                if (sb.editor.getReadOnly())
                    return;
                sb.replaceOption.checked = true;
                sb.$syncOptions();
                sb.replaceInput.focus();
            },
            "Ctrl-G|Command-G": function(sb) {
                sb.findNext();
            },
            "Ctrl-Shift-G|Command-Shift-G": function(sb) {
                sb.findPrev();
            },
            "esc": function(sb) {
                setTimeout(function() { sb.hide();});
            },
            "Return": function(sb) {
                if (sb.activeInput == sb.replaceInput)
                    sb.replace();
                sb.findNext();
            },
            "Shift-Return": function(sb) {
                if (sb.activeInput == sb.replaceInput)
                    sb.replace();
                sb.findPrev();
            },
            "Alt-Return": function(sb) {
                if (sb.activeInput == sb.replaceInput)
                    sb.replaceAll();
                sb.findAll();
            },
            "Tab": function(sb) {
                (sb.activeInput == sb.replaceInput ? sb.searchInput : sb.replaceInput).focus();
            }
        });

        this.$searchBarKb.addCommands([{
            name: "toggleRegexpMode",
            bindKey: {win: "Alt-R|Alt-/", mac: "Ctrl-Alt-R|Ctrl-Alt-/"},
            exec: function(sb) {
                sb.regExpOption.checked = !sb.regExpOption.checked;
                sb.$syncOptions();
            }
        }, {
            name: "toggleCaseSensitive",
            bindKey: {win: "Alt-C|Alt-I", mac: "Ctrl-Alt-R|Ctrl-Alt-I"},
            exec: function(sb) {
                sb.caseSensitiveOption.checked = !sb.caseSensitiveOption.checked;
                sb.$syncOptions();
            }
        }, {
            name: "toggleWholeWords",
            bindKey: {win: "Alt-B|Alt-W", mac: "Ctrl-Alt-B|Ctrl-Alt-W"},
            exec: function(sb) {
                sb.wholeWordOption.checked = !sb.wholeWordOption.checked;
                sb.$syncOptions();
            }
        }, {
            name: "toggleReplace",
            exec: function(sb) {
                sb.replaceOption.checked = !sb.replaceOption.checked;
                sb.$syncOptions();
            }
        }, {
            name: "searchInSelection",
            exec: function(sb) {
                sb.searchOption.checked = !sb.searchRange;
                sb.setSearchRange(sb.searchOption.checked && sb.editor.getSelectionRange());
                sb.$syncOptions();
            }
        }]);
        
        this.setSearchRange = function(range) {
            this.searchRange = range;
            if (range) {
                this.searchRangeMarker = this.editor.session.addMarker(range, "ace_active-line");
            } else if (this.searchRangeMarker) {
                this.editor.session.removeMarker(this.searchRangeMarker);
                this.searchRangeMarker = null;
            }
        };

        this.$syncOptions = function(preventScroll) {
            dom.setCssClass(this.replaceOption, "checked", this.searchRange);
            dom.setCssClass(this.searchOption, "checked", this.searchOption.checked);
            this.replaceOption.textContent = this.replaceOption.checked ? "-" : "+";
            dom.setCssClass(this.regExpOption, "checked", this.regExpOption.checked);
            dom.setCssClass(this.wholeWordOption, "checked", this.wholeWordOption.checked);
            dom.setCssClass(this.caseSensitiveOption, "checked", this.caseSensitiveOption.checked);
            var readOnly = this.editor.getReadOnly();
            this.replaceOption.style.display = readOnly ? "none" : "";
            this.replaceBox.style.display = this.replaceOption.checked && !readOnly ? "" : "none";
            this.find(false, false, preventScroll);
        };

        this.highlight = function(re) {
            this.editor.session.highlight(re || this.editor.$search.$options.re);
            this.editor.renderer.updateBackMarkers();
        };
        this.find = function(skipCurrent, backwards, preventScroll) {
            var range = this.editor.find(this.searchInput.value, {
                skipCurrent: skipCurrent,
                backwards: backwards,
                wrap: true,
                regExp: this.regExpOption.checked,
                caseSensitive: this.caseSensitiveOption.checked,
                wholeWord: this.wholeWordOption.checked,
                preventScroll: preventScroll,
                range: this.searchRange
            });
            var noMatch = !range && this.searchInput.value;
            dom.setCssClass(this.searchBox, "ace_nomatch", noMatch);
            this.editor._emit("findSearchBox", { match: !noMatch });
            this.highlight();
            this.updateCounter();
        };
        this.updateCounter = function() {
            var editor = this.editor;
            var regex = editor.$search.$options.re;
            var all = 0;
            var before = 0;
            if (regex) {
                var value = this.searchRange
                    ? editor.session.getTextRange(this.searchRange)
                    : editor.getValue();
                
                var offset = editor.session.doc.positionToIndex(editor.selection.anchor);
                if (this.searchRange)
                    offset -= editor.session.doc.positionToIndex(this.searchRange.start);
                    
                var last = regex.lastIndex = 0;
                var m;
                while ((m = regex.exec(value))) {
                    all++;
                    last = m.index;
                    if (last <= offset)
                        before++;
                    if (all > MAX_COUNT)
                        break;
                    if (!m[0]) {
                        regex.lastIndex = last += 1;
                        if (last >= value.length)
                            break;
                    }
                }
            }
            this.searchCounter.textContent = before + " of " + (all > MAX_COUNT ? MAX_COUNT + "+" : all);
        };
        this.findNext = function() {
            this.find(true, false);
        };
        this.findPrev = function() {
            this.find(true, true);
        };
        this.findAll = function(){
            var range = this.editor.findAll(this.searchInput.value, {            
                regExp: this.regExpOption.checked,
                caseSensitive: this.caseSensitiveOption.checked,
                wholeWord: this.wholeWordOption.checked
            });
            var noMatch = !range && this.searchInput.value;
            dom.setCssClass(this.searchBox, "ace_nomatch", noMatch);
            this.editor._emit("findSearchBox", { match: !noMatch });
            this.highlight();
            this.hide();
        };
        this.replace = function() {
            if (!this.editor.getReadOnly())
                this.editor.replace(this.replaceInput.value);
        };    
        this.replaceAndFindNext = function() {
            if (!this.editor.getReadOnly()) {
                this.editor.replace(this.replaceInput.value);
                this.findNext();
            }
        };
        this.replaceAll = function() {
            if (!this.editor.getReadOnly())
                this.editor.replaceAll(this.replaceInput.value);
        };

        this.hide = function() {
            this.active = false;
            this.setSearchRange(null);
            this.editor.off("changeSession", this.setSession);
            
            this.element.style.display = "none";
            this.editor.keyBinding.removeKeyboardHandler(this.$closeSearchBarKb);
            this.editor.focus();
        };
        this.show = function(value, isReplace) {
            this.active = true;
            this.editor.on("changeSession", this.setSession);
            this.element.style.display = "";
            this.replaceOption.checked = isReplace;
            
            if (value)
                this.searchInput.value = value;
            
            this.searchInput.focus();
            this.searchInput.select();

            this.editor.keyBinding.addKeyboardHandler(this.$closeSearchBarKb);
            
            this.$syncOptions(true);
        };

        this.isFocused = function() {
            var el = document.activeElement;
            return el == this.searchInput || el == this.replaceInput;
        };
    }).call(SearchBox.prototype);

    exports.SearchBox = SearchBox;

    exports.Search = function(editor, isReplace) {
        var sb = editor.searchBox || new SearchBox(editor);
        sb.show(editor.session.getTextRange(), isReplace);
    };

    });                (function() {
                        ace.require(["ace/ext/searchbox"], function(m) {
                            if (module) {
                                module.exports = m;
                            }
                        });
                    })();
    });

    /* ***** BEGIN LICENSE BLOCK *****
     * Distributed under the BSD license:
     *
     * Copyright (c) 2010, Ajax.org B.V.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *     * Redistributions of source code must retain the above copyright
     *       notice, this list of conditions and the following disclaimer.
     *     * Redistributions in binary form must reproduce the above copyright
     *       notice, this list of conditions and the following disclaimer in the
     *       documentation and/or other materials provided with the distribution.
     *     * Neither the name of Ajax.org B.V. nor the
     *       names of its contributors may be used to endorse or promote products
     *       derived from this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
     * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
     * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     *
     * ***** END LICENSE BLOCK ***** */

    window.ace.define('ace/theme/jsoneditor', ['require', 'exports', 'module', 'ace/lib/dom'], (acequire, exports, module) => {
      exports.isDark = false;
      exports.cssClass = 'ace-jsoneditor';
      exports.cssText = `.ace-jsoneditor .ace_gutter {
background: #ebebeb;
color: #333
}

.ace-jsoneditor.ace_editor {
font-family: consolas, monaco, "lucida console", "dejavu sans mono", "droid sans mono", monospace, "courier new", courier;
line-height: 1.3;
background-color: #fff;
}
.ace-jsoneditor .ace_print-margin {
width: 1px;
background: #e8e8e8
}
.ace-jsoneditor .ace_scroller {
background-color: #FFFFFF
}
.ace-jsoneditor .ace_text-layer {
color: gray
}
.ace-jsoneditor .ace_variable {
color: #1a1a1a
}
.ace-jsoneditor .ace_cursor {
border-left: 2px solid #000000
}
.ace-jsoneditor .ace_overwrite-cursors .ace_cursor {
border-left: 0px;
border-bottom: 1px solid #000000
}
.ace-jsoneditor .ace_marker-layer .ace_selection {
background: lightgray
}
.ace-jsoneditor.ace_multiselect .ace_selection.ace_start {
box-shadow: 0 0 3px 0px #FFFFFF;
border-radius: 2px
}
.ace-jsoneditor .ace_marker-layer .ace_step {
background: rgb(255, 255, 0)
}
.ace-jsoneditor .ace_marker-layer .ace_bracket {
margin: -1px 0 0 -1px;
border: 1px solid #BFBFBF
}
.ace-jsoneditor .ace_marker-layer .ace_active-line {
background: #FFFBD1
}
.ace-jsoneditor .ace_gutter-active-line {
background-color : #dcdcdc
}
.ace-jsoneditor .ace_marker-layer .ace_selected-word {
border: 1px solid lightgray
}
.ace-jsoneditor .ace_invisible {
color: #BFBFBF
}
.ace-jsoneditor .ace_keyword,
.ace-jsoneditor .ace_meta,
.ace-jsoneditor .ace_support.ace_constant.ace_property-value {
color: #AF956F
}
.ace-jsoneditor .ace_keyword.ace_operator {
color: #484848
}
.ace-jsoneditor .ace_keyword.ace_other.ace_unit {
color: #96DC5F
}
.ace-jsoneditor .ace_constant.ace_language {
color: darkorange
}
.ace-jsoneditor .ace_constant.ace_numeric {
color: red
}
.ace-jsoneditor .ace_constant.ace_character.ace_entity {
color: #BF78CC
}
.ace-jsoneditor .ace_invalid {
color: #FFFFFF;
background-color: #FF002A;
}
.ace-jsoneditor .ace_fold {
background-color: #AF956F;
border-color: #000000
}
.ace-jsoneditor .ace_storage,
.ace-jsoneditor .ace_support.ace_class,
.ace-jsoneditor .ace_support.ace_function,
.ace-jsoneditor .ace_support.ace_other,
.ace-jsoneditor .ace_support.ace_type {
color: #C52727
}
.ace-jsoneditor .ace_string {
color: green
}
.ace-jsoneditor .ace_comment {
color: #BCC8BA
}
.ace-jsoneditor .ace_entity.ace_name.ace_tag,
.ace-jsoneditor .ace_entity.ace_other.ace_attribute-name {
color: #606060
}
.ace-jsoneditor .ace_markup.ace_underline {
text-decoration: underline
}
.ace-jsoneditor .ace_indent-guide {
background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y
}`;

      const dom = acequire('../lib/dom');
      dom.importCssString(exports.cssText, exports.cssClass);
    });

    var jsonWorkerDataUrl = 'data:application/javascript;base64,Im5vIHVzZSBzdHJpY3QiOwohKGZ1bmN0aW9uKHdpbmRvdykgewppZiAodHlwZW9mIHdpbmRvdy53aW5kb3cgIT0gInVuZGVmaW5lZCIgJiYgd2luZG93LmRvY3VtZW50KQogICAgcmV0dXJuOwppZiAod2luZG93LnJlcXVpcmUgJiYgd2luZG93LmRlZmluZSkKICAgIHJldHVybjsKCmlmICghd2luZG93LmNvbnNvbGUpIHsKICAgIHdpbmRvdy5jb25zb2xlID0gZnVuY3Rpb24oKSB7CiAgICAgICAgdmFyIG1zZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApOwogICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlOiAibG9nIiwgZGF0YTogbXNnc30pOwogICAgfTsKICAgIHdpbmRvdy5jb25zb2xlLmVycm9yID0KICAgIHdpbmRvdy5jb25zb2xlLndhcm4gPSAKICAgIHdpbmRvdy5jb25zb2xlLmxvZyA9CiAgICB3aW5kb3cuY29uc29sZS50cmFjZSA9IHdpbmRvdy5jb25zb2xlOwp9CndpbmRvdy53aW5kb3cgPSB3aW5kb3c7CndpbmRvdy5hY2UgPSB3aW5kb3c7Cgp3aW5kb3cub25lcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGZpbGUsIGxpbmUsIGNvbCwgZXJyKSB7CiAgICBwb3N0TWVzc2FnZSh7dHlwZTogImVycm9yIiwgZGF0YTogewogICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsCiAgICAgICAgZGF0YTogZXJyLmRhdGEsCiAgICAgICAgZmlsZTogZmlsZSwKICAgICAgICBsaW5lOiBsaW5lLCAKICAgICAgICBjb2w6IGNvbCwKICAgICAgICBzdGFjazogZXJyLnN0YWNrCiAgICB9fSk7Cn07Cgp3aW5kb3cubm9ybWFsaXplTW9kdWxlID0gZnVuY3Rpb24ocGFyZW50SWQsIG1vZHVsZU5hbWUpIHsKICAgIC8vIG5vcm1hbGl6ZSBwbHVnaW4gcmVxdWlyZXMKICAgIGlmIChtb2R1bGVOYW1lLmluZGV4T2YoIiEiKSAhPT0gLTEpIHsKICAgICAgICB2YXIgY2h1bmtzID0gbW9kdWxlTmFtZS5zcGxpdCgiISIpOwogICAgICAgIHJldHVybiB3aW5kb3cubm9ybWFsaXplTW9kdWxlKHBhcmVudElkLCBjaHVua3NbMF0pICsgIiEiICsgd2luZG93Lm5vcm1hbGl6ZU1vZHVsZShwYXJlbnRJZCwgY2h1bmtzWzFdKTsKICAgIH0KICAgIC8vIG5vcm1hbGl6ZSByZWxhdGl2ZSByZXF1aXJlcwogICAgaWYgKG1vZHVsZU5hbWUuY2hhckF0KDApID09ICIuIikgewogICAgICAgIHZhciBiYXNlID0gcGFyZW50SWQuc3BsaXQoIi8iKS5zbGljZSgwLCAtMSkuam9pbigiLyIpOwogICAgICAgIG1vZHVsZU5hbWUgPSAoYmFzZSA/IGJhc2UgKyAiLyIgOiAiIikgKyBtb2R1bGVOYW1lOwogICAgICAgIAogICAgICAgIHdoaWxlIChtb2R1bGVOYW1lLmluZGV4T2YoIi4iKSAhPT0gLTEgJiYgcHJldmlvdXMgIT0gbW9kdWxlTmFtZSkgewogICAgICAgICAgICB2YXIgcHJldmlvdXMgPSBtb2R1bGVOYW1lOwogICAgICAgICAgICBtb2R1bGVOYW1lID0gbW9kdWxlTmFtZS5yZXBsYWNlKC9eXC5cLy8sICIiKS5yZXBsYWNlKC9cL1wuXC8vLCAiLyIpLnJlcGxhY2UoL1teXC9dK1wvXC5cLlwvLywgIiIpOwogICAgICAgIH0KICAgIH0KICAgIAogICAgcmV0dXJuIG1vZHVsZU5hbWU7Cn07Cgp3aW5kb3cucmVxdWlyZSA9IGZ1bmN0aW9uIHJlcXVpcmUocGFyZW50SWQsIGlkKSB7CiAgICBpZiAoIWlkKSB7CiAgICAgICAgaWQgPSBwYXJlbnRJZDsKICAgICAgICBwYXJlbnRJZCA9IG51bGw7CiAgICB9CiAgICBpZiAoIWlkLmNoYXJBdCkKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIndvcmtlci5qcyByZXF1aXJlKCkgYWNjZXB0cyBvbmx5IChwYXJlbnRJZCwgaWQpIGFzIGFyZ3VtZW50cyIpOwoKICAgIGlkID0gd2luZG93Lm5vcm1hbGl6ZU1vZHVsZShwYXJlbnRJZCwgaWQpOwoKICAgIHZhciBtb2R1bGUgPSB3aW5kb3cucmVxdWlyZS5tb2R1bGVzW2lkXTsKICAgIGlmIChtb2R1bGUpIHsKICAgICAgICBpZiAoIW1vZHVsZS5pbml0aWFsaXplZCkgewogICAgICAgICAgICBtb2R1bGUuaW5pdGlhbGl6ZWQgPSB0cnVlOwogICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5mYWN0b3J5KCkuZXhwb3J0czsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzOwogICAgfQogICAKICAgIGlmICghd2luZG93LnJlcXVpcmUudGxucykKICAgICAgICByZXR1cm4gY29uc29sZS5sb2coInVuYWJsZSB0byBsb2FkICIgKyBpZCk7CiAgICAKICAgIHZhciBwYXRoID0gcmVzb2x2ZU1vZHVsZUlkKGlkLCB3aW5kb3cucmVxdWlyZS50bG5zKTsKICAgIGlmIChwYXRoLnNsaWNlKC0zKSAhPSAiLmpzIikgcGF0aCArPSAiLmpzIjsKICAgIAogICAgd2luZG93LnJlcXVpcmUuaWQgPSBpZDsKICAgIHdpbmRvdy5yZXF1aXJlLm1vZHVsZXNbaWRdID0ge307IC8vIHByZXZlbnQgaW5maW5pdGUgbG9vcCBvbiBicm9rZW4gbW9kdWxlcwogICAgaW1wb3J0U2NyaXB0cyhwYXRoKTsKICAgIHJldHVybiB3aW5kb3cucmVxdWlyZShwYXJlbnRJZCwgaWQpOwp9OwpmdW5jdGlvbiByZXNvbHZlTW9kdWxlSWQoaWQsIHBhdGhzKSB7CiAgICB2YXIgdGVzdFBhdGggPSBpZCwgdGFpbCA9ICIiOwogICAgd2hpbGUgKHRlc3RQYXRoKSB7CiAgICAgICAgdmFyIGFsaWFzID0gcGF0aHNbdGVzdFBhdGhdOwogICAgICAgIGlmICh0eXBlb2YgYWxpYXMgPT0gInN0cmluZyIpIHsKICAgICAgICAgICAgcmV0dXJuIGFsaWFzICsgdGFpbDsKICAgICAgICB9IGVsc2UgaWYgKGFsaWFzKSB7CiAgICAgICAgICAgIHJldHVybiAgYWxpYXMubG9jYXRpb24ucmVwbGFjZSgvXC8qJC8sICIvIikgKyAodGFpbCB8fCBhbGlhcy5tYWluIHx8IGFsaWFzLm5hbWUpOwogICAgICAgIH0gZWxzZSBpZiAoYWxpYXMgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB9CiAgICAgICAgdmFyIGkgPSB0ZXN0UGF0aC5sYXN0SW5kZXhPZigiLyIpOwogICAgICAgIGlmIChpID09PSAtMSkgYnJlYWs7CiAgICAgICAgdGFpbCA9IHRlc3RQYXRoLnN1YnN0cihpKSArIHRhaWw7CiAgICAgICAgdGVzdFBhdGggPSB0ZXN0UGF0aC5zbGljZSgwLCBpKTsKICAgIH0KICAgIHJldHVybiBpZDsKfQp3aW5kb3cucmVxdWlyZS5tb2R1bGVzID0ge307CndpbmRvdy5yZXF1aXJlLnRsbnMgPSB7fTsKCndpbmRvdy5kZWZpbmUgPSBmdW5jdGlvbihpZCwgZGVwcywgZmFjdG9yeSkgewogICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikgewogICAgICAgIGZhY3RvcnkgPSBkZXBzOwogICAgICAgIGlmICh0eXBlb2YgaWQgIT0gInN0cmluZyIpIHsKICAgICAgICAgICAgZGVwcyA9IGlkOwogICAgICAgICAgICBpZCA9IHdpbmRvdy5yZXF1aXJlLmlkOwogICAgICAgIH0KICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7CiAgICAgICAgZmFjdG9yeSA9IGlkOwogICAgICAgIGRlcHMgPSBbXTsKICAgICAgICBpZCA9IHdpbmRvdy5yZXF1aXJlLmlkOwogICAgfQogICAgCiAgICBpZiAodHlwZW9mIGZhY3RvcnkgIT0gImZ1bmN0aW9uIikgewogICAgICAgIHdpbmRvdy5yZXF1aXJlLm1vZHVsZXNbaWRdID0gewogICAgICAgICAgICBleHBvcnRzOiBmYWN0b3J5LAogICAgICAgICAgICBpbml0aWFsaXplZDogdHJ1ZQogICAgICAgIH07CiAgICAgICAgcmV0dXJuOwogICAgfQoKICAgIGlmICghZGVwcy5sZW5ndGgpCiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZGVwZW5kZW5jaWVzLCB3ZSBpbmplY3QgInJlcXVpcmUiLCAiZXhwb3J0cyIgYW5kCiAgICAgICAgLy8gIm1vZHVsZSIgYXMgZGVwZW5kZW5jaWVzLCB0byBwcm92aWRlIENvbW1vbkpTIGNvbXBhdGliaWxpdHkuCiAgICAgICAgZGVwcyA9IFsicmVxdWlyZSIsICJleHBvcnRzIiwgIm1vZHVsZSJdOwoKICAgIHZhciByZXEgPSBmdW5jdGlvbihjaGlsZElkKSB7CiAgICAgICAgcmV0dXJuIHdpbmRvdy5yZXF1aXJlKGlkLCBjaGlsZElkKTsKICAgIH07CgogICAgd2luZG93LnJlcXVpcmUubW9kdWxlc1tpZF0gPSB7CiAgICAgICAgZXhwb3J0czoge30sCiAgICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBtb2R1bGUgPSB0aGlzOwogICAgICAgICAgICB2YXIgcmV0dXJuRXhwb3J0cyA9IGZhY3RvcnkuYXBwbHkodGhpcywgZGVwcy5zbGljZSgwLCBmYWN0b3J5Lmxlbmd0aCkubWFwKGZ1bmN0aW9uKGRlcCkgewogICAgICAgICAgICAgICAgc3dpdGNoIChkZXApIHsKICAgICAgICAgICAgICAgICAgICAvLyBCZWNhdXNlICJyZXF1aXJlIiwgImV4cG9ydHMiIGFuZCAibW9kdWxlIiBhcmVuJ3QgYWN0dWFsCiAgICAgICAgICAgICAgICAgICAgLy8gZGVwZW5kZW5jaWVzLCB3ZSBtdXN0IGhhbmRsZSB0aGVtIHNlcGVyYXRlbHkuCiAgICAgICAgICAgICAgICAgICAgY2FzZSAicmVxdWlyZSI6IHJldHVybiByZXE7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZXhwb3J0cyI6IHJldHVybiBtb2R1bGUuZXhwb3J0czsKICAgICAgICAgICAgICAgICAgICBjYXNlICJtb2R1bGUiOiAgcmV0dXJuIG1vZHVsZTsKICAgICAgICAgICAgICAgICAgICAvLyBCdXQgZm9yIGFsbCBvdGhlciBkZXBlbmRlbmNpZXMsIHdlIGNhbiBqdXN0IGdvIGFoZWFkIGFuZAogICAgICAgICAgICAgICAgICAgIC8vIHJlcXVpcmUgdGhlbS4KICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiAgICAgICAgcmV0dXJuIHJlcShkZXApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KSk7CiAgICAgICAgICAgIGlmIChyZXR1cm5FeHBvcnRzKQogICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXR1cm5FeHBvcnRzOwogICAgICAgICAgICByZXR1cm4gbW9kdWxlOwogICAgICAgIH0KICAgIH07Cn07CndpbmRvdy5kZWZpbmUuYW1kID0ge307CnJlcXVpcmUudGxucyA9IHt9Owp3aW5kb3cuaW5pdEJhc2VVcmxzICA9IGZ1bmN0aW9uIGluaXRCYXNlVXJscyh0b3BMZXZlbE5hbWVzcGFjZXMpIHsKICAgIGZvciAodmFyIGkgaW4gdG9wTGV2ZWxOYW1lc3BhY2VzKQogICAgICAgIHJlcXVpcmUudGxuc1tpXSA9IHRvcExldmVsTmFtZXNwYWNlc1tpXTsKfTsKCndpbmRvdy5pbml0U2VuZGVyID0gZnVuY3Rpb24gaW5pdFNlbmRlcigpIHsKCiAgICB2YXIgRXZlbnRFbWl0dGVyID0gd2luZG93LnJlcXVpcmUoImFjZS9saWIvZXZlbnRfZW1pdHRlciIpLkV2ZW50RW1pdHRlcjsKICAgIHZhciBvb3AgPSB3aW5kb3cucmVxdWlyZSgiYWNlL2xpYi9vb3AiKTsKICAgIAogICAgdmFyIFNlbmRlciA9IGZ1bmN0aW9uKCkge307CiAgICAKICAgIChmdW5jdGlvbigpIHsKICAgICAgICAKICAgICAgICBvb3AuaW1wbGVtZW50KHRoaXMsIEV2ZW50RW1pdHRlcik7CiAgICAgICAgICAgICAgICAKICAgICAgICB0aGlzLmNhbGxiYWNrID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2tJZCkgewogICAgICAgICAgICBwb3N0TWVzc2FnZSh7CiAgICAgICAgICAgICAgICB0eXBlOiAiY2FsbCIsCiAgICAgICAgICAgICAgICBpZDogY2FsbGJhY2tJZCwKICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEKICAgICAgICAgICAgfSk7CiAgICAgICAgfTsKICAgIAogICAgICAgIHRoaXMuZW1pdCA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEpIHsKICAgICAgICAgICAgcG9zdE1lc3NhZ2UoewogICAgICAgICAgICAgICAgdHlwZTogImV2ZW50IiwKICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsCiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhCiAgICAgICAgICAgIH0pOwogICAgICAgIH07CiAgICAgICAgCiAgICB9KS5jYWxsKFNlbmRlci5wcm90b3R5cGUpOwogICAgCiAgICByZXR1cm4gbmV3IFNlbmRlcigpOwp9OwoKdmFyIG1haW4gPSB3aW5kb3cubWFpbiA9IG51bGw7CnZhciBzZW5kZXIgPSB3aW5kb3cuc2VuZGVyID0gbnVsbDsKCndpbmRvdy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7CiAgICB2YXIgbXNnID0gZS5kYXRhOwogICAgaWYgKG1zZy5ldmVudCAmJiBzZW5kZXIpIHsKICAgICAgICBzZW5kZXIuX3NpZ25hbChtc2cuZXZlbnQsIG1zZy5kYXRhKTsKICAgIH0KICAgIGVsc2UgaWYgKG1zZy5jb21tYW5kKSB7CiAgICAgICAgaWYgKG1haW5bbXNnLmNvbW1hbmRdKQogICAgICAgICAgICBtYWluW21zZy5jb21tYW5kXS5hcHBseShtYWluLCBtc2cuYXJncyk7CiAgICAgICAgZWxzZSBpZiAod2luZG93W21zZy5jb21tYW5kXSkKICAgICAgICAgICAgd2luZG93W21zZy5jb21tYW5kXS5hcHBseSh3aW5kb3csIG1zZy5hcmdzKTsKICAgICAgICBlbHNlCiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiVW5rbm93biBjb21tYW5kOiIgKyBtc2cuY29tbWFuZCk7CiAgICB9CiAgICBlbHNlIGlmIChtc2cuaW5pdCkgewogICAgICAgIHdpbmRvdy5pbml0QmFzZVVybHMobXNnLnRsbnMpOwogICAgICAgIHNlbmRlciA9IHdpbmRvdy5zZW5kZXIgPSB3aW5kb3cuaW5pdFNlbmRlcigpOwogICAgICAgIHZhciBjbGF6eiA9IHJlcXVpcmUobXNnLm1vZHVsZSlbbXNnLmNsYXNzbmFtZV07CiAgICAgICAgbWFpbiA9IHdpbmRvdy5tYWluID0gbmV3IGNsYXp6KHNlbmRlcik7CiAgICB9Cn07Cn0pKHRoaXMpOwoKYWNlLmRlZmluZSgiYWNlL2xpYi9vb3AiLFtdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHsKInVzZSBzdHJpY3QiOwoKZXhwb3J0cy5pbmhlcml0cyA9IGZ1bmN0aW9uKGN0b3IsIHN1cGVyQ3RvcikgewogICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7CiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwgewogICAgICAgIGNvbnN0cnVjdG9yOiB7CiAgICAgICAgICAgIHZhbHVlOiBjdG9yLAogICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgIH0KICAgIH0pOwp9OwoKZXhwb3J0cy5taXhpbiA9IGZ1bmN0aW9uKG9iaiwgbWl4aW4pIHsKICAgIGZvciAodmFyIGtleSBpbiBtaXhpbikgewogICAgICAgIG9ialtrZXldID0gbWl4aW5ba2V5XTsKICAgIH0KICAgIHJldHVybiBvYmo7Cn07CgpleHBvcnRzLmltcGxlbWVudCA9IGZ1bmN0aW9uKHByb3RvLCBtaXhpbikgewogICAgZXhwb3J0cy5taXhpbihwcm90bywgbWl4aW4pOwp9OwoKfSk7CgphY2UuZGVmaW5lKCJhY2UvcmFuZ2UiLFtdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHsKInVzZSBzdHJpY3QiOwp2YXIgY29tcGFyZVBvaW50cyA9IGZ1bmN0aW9uKHAxLCBwMikgewogICAgcmV0dXJuIHAxLnJvdyAtIHAyLnJvdyB8fCBwMS5jb2x1bW4gLSBwMi5jb2x1bW47Cn07CnZhciBSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0Um93LCBzdGFydENvbHVtbiwgZW5kUm93LCBlbmRDb2x1bW4pIHsKICAgIHRoaXMuc3RhcnQgPSB7CiAgICAgICAgcm93OiBzdGFydFJvdywKICAgICAgICBjb2x1bW46IHN0YXJ0Q29sdW1uCiAgICB9OwoKICAgIHRoaXMuZW5kID0gewogICAgICAgIHJvdzogZW5kUm93LAogICAgICAgIGNvbHVtbjogZW5kQ29sdW1uCiAgICB9Owp9OwoKKGZ1bmN0aW9uKCkgewogICAgdGhpcy5pc0VxdWFsID0gZnVuY3Rpb24ocmFuZ2UpIHsKICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5yb3cgPT09IHJhbmdlLnN0YXJ0LnJvdyAmJgogICAgICAgICAgICB0aGlzLmVuZC5yb3cgPT09IHJhbmdlLmVuZC5yb3cgJiYKICAgICAgICAgICAgdGhpcy5zdGFydC5jb2x1bW4gPT09IHJhbmdlLnN0YXJ0LmNvbHVtbiAmJgogICAgICAgICAgICB0aGlzLmVuZC5jb2x1bW4gPT09IHJhbmdlLmVuZC5jb2x1bW47CiAgICB9OwogICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiAoIlJhbmdlOiBbIiArIHRoaXMuc3RhcnQucm93ICsgIi8iICsgdGhpcy5zdGFydC5jb2x1bW4gKwogICAgICAgICAgICAiXSAtPiBbIiArIHRoaXMuZW5kLnJvdyArICIvIiArIHRoaXMuZW5kLmNvbHVtbiArICJdIik7CiAgICB9OwoKICAgIHRoaXMuY29udGFpbnMgPSBmdW5jdGlvbihyb3csIGNvbHVtbikgewogICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUocm93LCBjb2x1bW4pID09IDA7CiAgICB9OwogICAgdGhpcy5jb21wYXJlUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkgewogICAgICAgIHZhciBjbXAsCiAgICAgICAgICAgIGVuZCA9IHJhbmdlLmVuZCwKICAgICAgICAgICAgc3RhcnQgPSByYW5nZS5zdGFydDsKCiAgICAgICAgY21wID0gdGhpcy5jb21wYXJlKGVuZC5yb3csIGVuZC5jb2x1bW4pOwogICAgICAgIGlmIChjbXAgPT0gMSkgewogICAgICAgICAgICBjbXAgPSB0aGlzLmNvbXBhcmUoc3RhcnQucm93LCBzdGFydC5jb2x1bW4pOwogICAgICAgICAgICBpZiAoY21wID09IDEpIHsKICAgICAgICAgICAgICAgIHJldHVybiAyOwogICAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PSAwKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gMTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJldHVybiAwOwogICAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmIChjbXAgPT0gLTEpIHsKICAgICAgICAgICAgcmV0dXJuIC0yOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNtcCA9IHRoaXMuY29tcGFyZShzdGFydC5yb3csIHN0YXJ0LmNvbHVtbik7CiAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHsKICAgICAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT0gMSkgewogICAgICAgICAgICAgICAgcmV0dXJuIDQyOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9OwogICAgdGhpcy5jb21wYXJlUG9pbnQgPSBmdW5jdGlvbihwKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShwLnJvdywgcC5jb2x1bW4pOwogICAgfTsKICAgIHRoaXMuY29udGFpbnNSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVBvaW50KHJhbmdlLnN0YXJ0KSA9PSAwICYmIHRoaXMuY29tcGFyZVBvaW50KHJhbmdlLmVuZCkgPT0gMDsKICAgIH07CiAgICB0aGlzLmludGVyc2VjdHMgPSBmdW5jdGlvbihyYW5nZSkgewogICAgICAgIHZhciBjbXAgPSB0aGlzLmNvbXBhcmVSYW5nZShyYW5nZSk7CiAgICAgICAgcmV0dXJuIChjbXAgPT0gLTEgfHwgY21wID09IDAgfHwgY21wID09IDEpOwogICAgfTsKICAgIHRoaXMuaXNFbmQgPSBmdW5jdGlvbihyb3csIGNvbHVtbikgewogICAgICAgIHJldHVybiB0aGlzLmVuZC5yb3cgPT0gcm93ICYmIHRoaXMuZW5kLmNvbHVtbiA9PSBjb2x1bW47CiAgICB9OwogICAgdGhpcy5pc1N0YXJ0ID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHsKICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5yb3cgPT0gcm93ICYmIHRoaXMuc3RhcnQuY29sdW1uID09IGNvbHVtbjsKICAgIH07CiAgICB0aGlzLnNldFN0YXJ0ID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHsKICAgICAgICBpZiAodHlwZW9mIHJvdyA9PSAib2JqZWN0IikgewogICAgICAgICAgICB0aGlzLnN0YXJ0LmNvbHVtbiA9IHJvdy5jb2x1bW47CiAgICAgICAgICAgIHRoaXMuc3RhcnQucm93ID0gcm93LnJvdzsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aGlzLnN0YXJ0LnJvdyA9IHJvdzsKICAgICAgICAgICAgdGhpcy5zdGFydC5jb2x1bW4gPSBjb2x1bW47CiAgICAgICAgfQogICAgfTsKICAgIHRoaXMuc2V0RW5kID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHsKICAgICAgICBpZiAodHlwZW9mIHJvdyA9PSAib2JqZWN0IikgewogICAgICAgICAgICB0aGlzLmVuZC5jb2x1bW4gPSByb3cuY29sdW1uOwogICAgICAgICAgICB0aGlzLmVuZC5yb3cgPSByb3cucm93OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMuZW5kLnJvdyA9IHJvdzsKICAgICAgICAgICAgdGhpcy5lbmQuY29sdW1uID0gY29sdW1uOwogICAgICAgIH0KICAgIH07CiAgICB0aGlzLmluc2lkZSA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7CiAgICAgICAgaWYgKHRoaXMuY29tcGFyZShyb3csIGNvbHVtbikgPT0gMCkgewogICAgICAgICAgICBpZiAodGhpcy5pc0VuZChyb3csIGNvbHVtbikgfHwgdGhpcy5pc1N0YXJ0KHJvdywgY29sdW1uKSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgfTsKICAgIHRoaXMuaW5zaWRlU3RhcnQgPSBmdW5jdGlvbihyb3csIGNvbHVtbikgewogICAgICAgIGlmICh0aGlzLmNvbXBhcmUocm93LCBjb2x1bW4pID09IDApIHsKICAgICAgICAgICAgaWYgKHRoaXMuaXNFbmQocm93LCBjb2x1bW4pKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gZmFsc2U7CiAgICB9OwogICAgdGhpcy5pbnNpZGVFbmQgPSBmdW5jdGlvbihyb3csIGNvbHVtbikgewogICAgICAgIGlmICh0aGlzLmNvbXBhcmUocm93LCBjb2x1bW4pID09IDApIHsKICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFydChyb3csIGNvbHVtbikpIHsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBmYWxzZTsKICAgIH07CiAgICB0aGlzLmNvbXBhcmUgPSBmdW5jdGlvbihyb3csIGNvbHVtbikgewogICAgICAgIGlmICghdGhpcy5pc011bHRpTGluZSgpKSB7CiAgICAgICAgICAgIGlmIChyb3cgPT09IHRoaXMuc3RhcnQucm93KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uIDwgdGhpcy5zdGFydC5jb2x1bW4gPyAtMSA6IChjb2x1bW4gPiB0aGlzLmVuZC5jb2x1bW4gPyAxIDogMCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGlmIChyb3cgPCB0aGlzLnN0YXJ0LnJvdykKICAgICAgICAgICAgcmV0dXJuIC0xOwoKICAgICAgICBpZiAocm93ID4gdGhpcy5lbmQucm93KQogICAgICAgICAgICByZXR1cm4gMTsKCiAgICAgICAgaWYgKHRoaXMuc3RhcnQucm93ID09PSByb3cpCiAgICAgICAgICAgIHJldHVybiBjb2x1bW4gPj0gdGhpcy5zdGFydC5jb2x1bW4gPyAwIDogLTE7CgogICAgICAgIGlmICh0aGlzLmVuZC5yb3cgPT09IHJvdykKICAgICAgICAgICAgcmV0dXJuIGNvbHVtbiA8PSB0aGlzLmVuZC5jb2x1bW4gPyAwIDogMTsKCiAgICAgICAgcmV0dXJuIDA7CiAgICB9OwogICAgdGhpcy5jb21wYXJlU3RhcnQgPSBmdW5jdGlvbihyb3csIGNvbHVtbikgewogICAgICAgIGlmICh0aGlzLnN0YXJ0LnJvdyA9PSByb3cgJiYgdGhpcy5zdGFydC5jb2x1bW4gPT0gY29sdW1uKSB7CiAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHJvdywgY29sdW1uKTsKICAgICAgICB9CiAgICB9OwogICAgdGhpcy5jb21wYXJlRW5kID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHsKICAgICAgICBpZiAodGhpcy5lbmQucm93ID09IHJvdyAmJiB0aGlzLmVuZC5jb2x1bW4gPT0gY29sdW1uKSB7CiAgICAgICAgICAgIHJldHVybiAxOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUocm93LCBjb2x1bW4pOwogICAgICAgIH0KICAgIH07CiAgICB0aGlzLmNvbXBhcmVJbnNpZGUgPSBmdW5jdGlvbihyb3csIGNvbHVtbikgewogICAgICAgIGlmICh0aGlzLmVuZC5yb3cgPT0gcm93ICYmIHRoaXMuZW5kLmNvbHVtbiA9PSBjb2x1bW4pIHsKICAgICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXJ0LnJvdyA9PSByb3cgJiYgdGhpcy5zdGFydC5jb2x1bW4gPT0gY29sdW1uKSB7CiAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHJvdywgY29sdW1uKTsKICAgICAgICB9CiAgICB9OwogICAgdGhpcy5jbGlwUm93cyA9IGZ1bmN0aW9uKGZpcnN0Um93LCBsYXN0Um93KSB7CiAgICAgICAgaWYgKHRoaXMuZW5kLnJvdyA+IGxhc3RSb3cpCiAgICAgICAgICAgIHZhciBlbmQgPSB7cm93OiBsYXN0Um93ICsgMSwgY29sdW1uOiAwfTsKICAgICAgICBlbHNlIGlmICh0aGlzLmVuZC5yb3cgPCBmaXJzdFJvdykKICAgICAgICAgICAgdmFyIGVuZCA9IHtyb3c6IGZpcnN0Um93LCBjb2x1bW46IDB9OwoKICAgICAgICBpZiAodGhpcy5zdGFydC5yb3cgPiBsYXN0Um93KQogICAgICAgICAgICB2YXIgc3RhcnQgPSB7cm93OiBsYXN0Um93ICsgMSwgY29sdW1uOiAwfTsKICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXJ0LnJvdyA8IGZpcnN0Um93KQogICAgICAgICAgICB2YXIgc3RhcnQgPSB7cm93OiBmaXJzdFJvdywgY29sdW1uOiAwfTsKCiAgICAgICAgcmV0dXJuIFJhbmdlLmZyb21Qb2ludHMoc3RhcnQgfHwgdGhpcy5zdGFydCwgZW5kIHx8IHRoaXMuZW5kKTsKICAgIH07CiAgICB0aGlzLmV4dGVuZCA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7CiAgICAgICAgdmFyIGNtcCA9IHRoaXMuY29tcGFyZShyb3csIGNvbHVtbik7CgogICAgICAgIGlmIChjbXAgPT0gMCkKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgZWxzZSBpZiAoY21wID09IC0xKQogICAgICAgICAgICB2YXIgc3RhcnQgPSB7cm93OiByb3csIGNvbHVtbjogY29sdW1ufTsKICAgICAgICBlbHNlCiAgICAgICAgICAgIHZhciBlbmQgPSB7cm93OiByb3csIGNvbHVtbjogY29sdW1ufTsKCiAgICAgICAgcmV0dXJuIFJhbmdlLmZyb21Qb2ludHMoc3RhcnQgfHwgdGhpcy5zdGFydCwgZW5kIHx8IHRoaXMuZW5kKTsKICAgIH07CgogICAgdGhpcy5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXJ0LnJvdyA9PT0gdGhpcy5lbmQucm93ICYmIHRoaXMuc3RhcnQuY29sdW1uID09PSB0aGlzLmVuZC5jb2x1bW4pOwogICAgfTsKICAgIHRoaXMuaXNNdWx0aUxpbmUgPSBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gKHRoaXMuc3RhcnQucm93ICE9PSB0aGlzLmVuZC5yb3cpOwogICAgfTsKICAgIHRoaXMuY2xvbmUgPSBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gUmFuZ2UuZnJvbVBvaW50cyh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7CiAgICB9OwogICAgdGhpcy5jb2xsYXBzZVJvd3MgPSBmdW5jdGlvbigpIHsKICAgICAgICBpZiAodGhpcy5lbmQuY29sdW1uID09IDApCiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy5zdGFydC5yb3csIDAsIE1hdGgubWF4KHRoaXMuc3RhcnQucm93LCB0aGlzLmVuZC5yb3ctMSksIDApOwogICAgICAgIGVsc2UKICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnN0YXJ0LnJvdywgMCwgdGhpcy5lbmQucm93LCAwKTsKICAgIH07CiAgICB0aGlzLnRvU2NyZWVuUmFuZ2UgPSBmdW5jdGlvbihzZXNzaW9uKSB7CiAgICAgICAgdmFyIHNjcmVlblBvc1N0YXJ0ID0gc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24odGhpcy5zdGFydCk7CiAgICAgICAgdmFyIHNjcmVlblBvc0VuZCA9IHNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKHRoaXMuZW5kKTsKCiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZSgKICAgICAgICAgICAgc2NyZWVuUG9zU3RhcnQucm93LCBzY3JlZW5Qb3NTdGFydC5jb2x1bW4sCiAgICAgICAgICAgIHNjcmVlblBvc0VuZC5yb3csIHNjcmVlblBvc0VuZC5jb2x1bW4KICAgICAgICApOwogICAgfTsKICAgIHRoaXMubW92ZUJ5ID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHsKICAgICAgICB0aGlzLnN0YXJ0LnJvdyArPSByb3c7CiAgICAgICAgdGhpcy5zdGFydC5jb2x1bW4gKz0gY29sdW1uOwogICAgICAgIHRoaXMuZW5kLnJvdyArPSByb3c7CiAgICAgICAgdGhpcy5lbmQuY29sdW1uICs9IGNvbHVtbjsKICAgIH07Cgp9KS5jYWxsKFJhbmdlLnByb3RvdHlwZSk7ClJhbmdlLmZyb21Qb2ludHMgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7CiAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LnJvdywgc3RhcnQuY29sdW1uLCBlbmQucm93LCBlbmQuY29sdW1uKTsKfTsKUmFuZ2UuY29tcGFyZVBvaW50cyA9IGNvbXBhcmVQb2ludHM7CgpSYW5nZS5jb21wYXJlUG9pbnRzID0gZnVuY3Rpb24ocDEsIHAyKSB7CiAgICByZXR1cm4gcDEucm93IC0gcDIucm93IHx8IHAxLmNvbHVtbiAtIHAyLmNvbHVtbjsKfTsKCgpleHBvcnRzLlJhbmdlID0gUmFuZ2U7Cn0pOwoKYWNlLmRlZmluZSgiYWNlL2FwcGx5X2RlbHRhIixbXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7CiJ1c2Ugc3RyaWN0IjsKCmZ1bmN0aW9uIHRocm93RGVsdGFFcnJvcihkZWx0YSwgZXJyb3JUZXh0KXsKICAgIGNvbnNvbGUubG9nKCJJbnZhbGlkIERlbHRhOiIsIGRlbHRhKTsKICAgIHRocm93ICJJbnZhbGlkIERlbHRhOiAiICsgZXJyb3JUZXh0Owp9CgpmdW5jdGlvbiBwb3NpdGlvbkluRG9jdW1lbnQoZG9jTGluZXMsIHBvc2l0aW9uKSB7CiAgICByZXR1cm4gcG9zaXRpb24ucm93ICAgID49IDAgJiYgcG9zaXRpb24ucm93ICAgIDwgIGRvY0xpbmVzLmxlbmd0aCAmJgogICAgICAgICAgIHBvc2l0aW9uLmNvbHVtbiA+PSAwICYmIHBvc2l0aW9uLmNvbHVtbiA8PSBkb2NMaW5lc1twb3NpdGlvbi5yb3ddLmxlbmd0aDsKfQoKZnVuY3Rpb24gdmFsaWRhdGVEZWx0YShkb2NMaW5lcywgZGVsdGEpIHsKICAgIGlmIChkZWx0YS5hY3Rpb24gIT0gImluc2VydCIgJiYgZGVsdGEuYWN0aW9uICE9ICJyZW1vdmUiKQogICAgICAgIHRocm93RGVsdGFFcnJvcihkZWx0YSwgImRlbHRhLmFjdGlvbiBtdXN0IGJlICdpbnNlcnQnIG9yICdyZW1vdmUnIik7CiAgICBpZiAoIShkZWx0YS5saW5lcyBpbnN0YW5jZW9mIEFycmF5KSkKICAgICAgICB0aHJvd0RlbHRhRXJyb3IoZGVsdGEsICJkZWx0YS5saW5lcyBtdXN0IGJlIGFuIEFycmF5Iik7CiAgICBpZiAoIWRlbHRhLnN0YXJ0IHx8ICFkZWx0YS5lbmQpCiAgICAgICB0aHJvd0RlbHRhRXJyb3IoZGVsdGEsICJkZWx0YS5zdGFydC9lbmQgbXVzdCBiZSBhbiBwcmVzZW50Iik7CiAgICB2YXIgc3RhcnQgPSBkZWx0YS5zdGFydDsKICAgIGlmICghcG9zaXRpb25JbkRvY3VtZW50KGRvY0xpbmVzLCBkZWx0YS5zdGFydCkpCiAgICAgICAgdGhyb3dEZWx0YUVycm9yKGRlbHRhLCAiZGVsdGEuc3RhcnQgbXVzdCBiZSBjb250YWluZWQgaW4gZG9jdW1lbnQiKTsKICAgIHZhciBlbmQgPSBkZWx0YS5lbmQ7CiAgICBpZiAoZGVsdGEuYWN0aW9uID09ICJyZW1vdmUiICYmICFwb3NpdGlvbkluRG9jdW1lbnQoZG9jTGluZXMsIGVuZCkpCiAgICAgICAgdGhyb3dEZWx0YUVycm9yKGRlbHRhLCAiZGVsdGEuZW5kIG11c3QgY29udGFpbmVkIGluIGRvY3VtZW50IGZvciAncmVtb3ZlJyBhY3Rpb25zIik7CiAgICB2YXIgbnVtUmFuZ2VSb3dzID0gZW5kLnJvdyAtIHN0YXJ0LnJvdzsKICAgIHZhciBudW1SYW5nZUxhc3RMaW5lQ2hhcnMgPSAoZW5kLmNvbHVtbiAtIChudW1SYW5nZVJvd3MgPT0gMCA/IHN0YXJ0LmNvbHVtbiA6IDApKTsKICAgIGlmIChudW1SYW5nZVJvd3MgIT0gZGVsdGEubGluZXMubGVuZ3RoIC0gMSB8fCBkZWx0YS5saW5lc1tudW1SYW5nZVJvd3NdLmxlbmd0aCAhPSBudW1SYW5nZUxhc3RMaW5lQ2hhcnMpCiAgICAgICAgdGhyb3dEZWx0YUVycm9yKGRlbHRhLCAiZGVsdGEucmFuZ2UgbXVzdCBtYXRjaCBkZWx0YSBsaW5lcyIpOwp9CgpleHBvcnRzLmFwcGx5RGVsdGEgPSBmdW5jdGlvbihkb2NMaW5lcywgZGVsdGEsIGRvTm90VmFsaWRhdGUpIHsKICAgIAogICAgdmFyIHJvdyA9IGRlbHRhLnN0YXJ0LnJvdzsKICAgIHZhciBzdGFydENvbHVtbiA9IGRlbHRhLnN0YXJ0LmNvbHVtbjsKICAgIHZhciBsaW5lID0gZG9jTGluZXNbcm93XSB8fCAiIjsKICAgIHN3aXRjaCAoZGVsdGEuYWN0aW9uKSB7CiAgICAgICAgY2FzZSAiaW5zZXJ0IjoKICAgICAgICAgICAgdmFyIGxpbmVzID0gZGVsdGEubGluZXM7CiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDEpIHsKICAgICAgICAgICAgICAgIGRvY0xpbmVzW3Jvd10gPSBsaW5lLnN1YnN0cmluZygwLCBzdGFydENvbHVtbikgKyBkZWx0YS5saW5lc1swXSArIGxpbmUuc3Vic3RyaW5nKHN0YXJ0Q29sdW1uKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW3JvdywgMV0uY29uY2F0KGRlbHRhLmxpbmVzKTsKICAgICAgICAgICAgICAgIGRvY0xpbmVzLnNwbGljZS5hcHBseShkb2NMaW5lcywgYXJncyk7CiAgICAgICAgICAgICAgICBkb2NMaW5lc1tyb3ddID0gbGluZS5zdWJzdHJpbmcoMCwgc3RhcnRDb2x1bW4pICsgZG9jTGluZXNbcm93XTsKICAgICAgICAgICAgICAgIGRvY0xpbmVzW3JvdyArIGRlbHRhLmxpbmVzLmxlbmd0aCAtIDFdICs9IGxpbmUuc3Vic3RyaW5nKHN0YXJ0Q29sdW1uKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlICJyZW1vdmUiOgogICAgICAgICAgICB2YXIgZW5kQ29sdW1uID0gZGVsdGEuZW5kLmNvbHVtbjsKICAgICAgICAgICAgdmFyIGVuZFJvdyA9IGRlbHRhLmVuZC5yb3c7CiAgICAgICAgICAgIGlmIChyb3cgPT09IGVuZFJvdykgewogICAgICAgICAgICAgICAgZG9jTGluZXNbcm93XSA9IGxpbmUuc3Vic3RyaW5nKDAsIHN0YXJ0Q29sdW1uKSArIGxpbmUuc3Vic3RyaW5nKGVuZENvbHVtbik7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBkb2NMaW5lcy5zcGxpY2UoCiAgICAgICAgICAgICAgICAgICAgcm93LCBlbmRSb3cgLSByb3cgKyAxLAogICAgICAgICAgICAgICAgICAgIGxpbmUuc3Vic3RyaW5nKDAsIHN0YXJ0Q29sdW1uKSArIGRvY0xpbmVzW2VuZFJvd10uc3Vic3RyaW5nKGVuZENvbHVtbikKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYnJlYWs7CiAgICB9Cn07Cn0pOwoKYWNlLmRlZmluZSgiYWNlL2xpYi9ldmVudF9lbWl0dGVyIixbXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7CiJ1c2Ugc3RyaWN0IjsKCnZhciBFdmVudEVtaXR0ZXIgPSB7fTsKdmFyIHN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkgeyB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7IH07CnZhciBwcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkgeyB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlOyB9OwoKRXZlbnRFbWl0dGVyLl9lbWl0ID0KRXZlbnRFbWl0dGVyLl9kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnROYW1lLCBlKSB7CiAgICB0aGlzLl9ldmVudFJlZ2lzdHJ5IHx8ICh0aGlzLl9ldmVudFJlZ2lzdHJ5ID0ge30pOwogICAgdGhpcy5fZGVmYXVsdEhhbmRsZXJzIHx8ICh0aGlzLl9kZWZhdWx0SGFuZGxlcnMgPSB7fSk7CgogICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50UmVnaXN0cnlbZXZlbnROYW1lXSB8fCBbXTsKICAgIHZhciBkZWZhdWx0SGFuZGxlciA9IHRoaXMuX2RlZmF1bHRIYW5kbGVyc1tldmVudE5hbWVdOwogICAgaWYgKCFsaXN0ZW5lcnMubGVuZ3RoICYmICFkZWZhdWx0SGFuZGxlcikKICAgICAgICByZXR1cm47CgogICAgaWYgKHR5cGVvZiBlICE9ICJvYmplY3QiIHx8ICFlKQogICAgICAgIGUgPSB7fTsKCiAgICBpZiAoIWUudHlwZSkKICAgICAgICBlLnR5cGUgPSBldmVudE5hbWU7CiAgICBpZiAoIWUuc3RvcFByb3BhZ2F0aW9uKQogICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uID0gc3RvcFByb3BhZ2F0aW9uOwogICAgaWYgKCFlLnByZXZlbnREZWZhdWx0KQogICAgICAgIGUucHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdDsKCiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTsKICAgIGZvciAodmFyIGk9MDsgaTxsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHsKICAgICAgICBsaXN0ZW5lcnNbaV0oZSwgdGhpcyk7CiAgICAgICAgaWYgKGUucHJvcGFnYXRpb25TdG9wcGVkKQogICAgICAgICAgICBicmVhazsKICAgIH0KICAgIAogICAgaWYgKGRlZmF1bHRIYW5kbGVyICYmICFlLmRlZmF1bHRQcmV2ZW50ZWQpCiAgICAgICAgcmV0dXJuIGRlZmF1bHRIYW5kbGVyKGUsIHRoaXMpOwp9OwoKCkV2ZW50RW1pdHRlci5fc2lnbmFsID0gZnVuY3Rpb24oZXZlbnROYW1lLCBlKSB7CiAgICB2YXIgbGlzdGVuZXJzID0gKHRoaXMuX2V2ZW50UmVnaXN0cnkgfHwge30pW2V2ZW50TmFtZV07CiAgICBpZiAoIWxpc3RlbmVycykKICAgICAgICByZXR1cm47CiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTsKICAgIGZvciAodmFyIGk9MDsgaTxsaXN0ZW5lcnMubGVuZ3RoOyBpKyspCiAgICAgICAgbGlzdGVuZXJzW2ldKGUsIHRoaXMpOwp9OwoKRXZlbnRFbWl0dGVyLm9uY2UgPSBmdW5jdGlvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7CiAgICB2YXIgX3NlbGYgPSB0aGlzOwogICAgdGhpcy5vbihldmVudE5hbWUsIGZ1bmN0aW9uIG5ld0NhbGxiYWNrKCkgewogICAgICAgIF9zZWxmLm9mZihldmVudE5hbWUsIG5ld0NhbGxiYWNrKTsKICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpOwogICAgfSk7CiAgICBpZiAoIWNhbGxiYWNrKSB7CiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHsKICAgICAgICAgICAgY2FsbGJhY2sgPSByZXNvbHZlOwogICAgICAgIH0pOwogICAgfQp9OwoKCkV2ZW50RW1pdHRlci5zZXREZWZhdWx0SGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHsKICAgIHZhciBoYW5kbGVycyA9IHRoaXMuX2RlZmF1bHRIYW5kbGVyczsKICAgIGlmICghaGFuZGxlcnMpCiAgICAgICAgaGFuZGxlcnMgPSB0aGlzLl9kZWZhdWx0SGFuZGxlcnMgPSB7X2Rpc2FibGVkXzoge319OwogICAgCiAgICBpZiAoaGFuZGxlcnNbZXZlbnROYW1lXSkgewogICAgICAgIHZhciBvbGQgPSBoYW5kbGVyc1tldmVudE5hbWVdOwogICAgICAgIHZhciBkaXNhYmxlZCA9IGhhbmRsZXJzLl9kaXNhYmxlZF9bZXZlbnROYW1lXTsKICAgICAgICBpZiAoIWRpc2FibGVkKQogICAgICAgICAgICBoYW5kbGVycy5fZGlzYWJsZWRfW2V2ZW50TmFtZV0gPSBkaXNhYmxlZCA9IFtdOwogICAgICAgIGRpc2FibGVkLnB1c2gob2xkKTsKICAgICAgICB2YXIgaSA9IGRpc2FibGVkLmluZGV4T2YoY2FsbGJhY2spOwogICAgICAgIGlmIChpICE9IC0xKSAKICAgICAgICAgICAgZGlzYWJsZWQuc3BsaWNlKGksIDEpOwogICAgfQogICAgaGFuZGxlcnNbZXZlbnROYW1lXSA9IGNhbGxiYWNrOwp9OwpFdmVudEVtaXR0ZXIucmVtb3ZlRGVmYXVsdEhhbmRsZXIgPSBmdW5jdGlvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7CiAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLl9kZWZhdWx0SGFuZGxlcnM7CiAgICBpZiAoIWhhbmRsZXJzKQogICAgICAgIHJldHVybjsKICAgIHZhciBkaXNhYmxlZCA9IGhhbmRsZXJzLl9kaXNhYmxlZF9bZXZlbnROYW1lXTsKICAgIAogICAgaWYgKGhhbmRsZXJzW2V2ZW50TmFtZV0gPT0gY2FsbGJhY2spIHsKICAgICAgICBpZiAoZGlzYWJsZWQpCiAgICAgICAgICAgIHRoaXMuc2V0RGVmYXVsdEhhbmRsZXIoZXZlbnROYW1lLCBkaXNhYmxlZC5wb3AoKSk7CiAgICB9IGVsc2UgaWYgKGRpc2FibGVkKSB7CiAgICAgICAgdmFyIGkgPSBkaXNhYmxlZC5pbmRleE9mKGNhbGxiYWNrKTsKICAgICAgICBpZiAoaSAhPSAtMSkKICAgICAgICAgICAgZGlzYWJsZWQuc3BsaWNlKGksIDEpOwogICAgfQp9OwoKRXZlbnRFbWl0dGVyLm9uID0KRXZlbnRFbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudE5hbWUsIGNhbGxiYWNrLCBjYXB0dXJpbmcpIHsKICAgIHRoaXMuX2V2ZW50UmVnaXN0cnkgPSB0aGlzLl9ldmVudFJlZ2lzdHJ5IHx8IHt9OwoKICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudFJlZ2lzdHJ5W2V2ZW50TmFtZV07CiAgICBpZiAoIWxpc3RlbmVycykKICAgICAgICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudFJlZ2lzdHJ5W2V2ZW50TmFtZV0gPSBbXTsKCiAgICBpZiAobGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spID09IC0xKQogICAgICAgIGxpc3RlbmVyc1tjYXB0dXJpbmcgPyAidW5zaGlmdCIgOiAicHVzaCJdKGNhbGxiYWNrKTsKICAgIHJldHVybiBjYWxsYmFjazsKfTsKCkV2ZW50RW1pdHRlci5vZmYgPQpFdmVudEVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPQpFdmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHsKICAgIHRoaXMuX2V2ZW50UmVnaXN0cnkgPSB0aGlzLl9ldmVudFJlZ2lzdHJ5IHx8IHt9OwoKICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudFJlZ2lzdHJ5W2V2ZW50TmFtZV07CiAgICBpZiAoIWxpc3RlbmVycykKICAgICAgICByZXR1cm47CgogICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spOwogICAgaWYgKGluZGV4ICE9PSAtMSkKICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTsKfTsKCkV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudE5hbWUpIHsKICAgIGlmICghZXZlbnROYW1lKSB0aGlzLl9ldmVudFJlZ2lzdHJ5ID0gdGhpcy5fZGVmYXVsdEhhbmRsZXJzID0gdW5kZWZpbmVkOwogICAgaWYgKHRoaXMuX2V2ZW50UmVnaXN0cnkpIHRoaXMuX2V2ZW50UmVnaXN0cnlbZXZlbnROYW1lXSA9IHVuZGVmaW5lZDsKICAgIGlmICh0aGlzLl9kZWZhdWx0SGFuZGxlcnMpIHRoaXMuX2RlZmF1bHRIYW5kbGVyc1tldmVudE5hbWVdID0gdW5kZWZpbmVkOwp9OwoKZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7Cgp9KTsKCmFjZS5kZWZpbmUoImFjZS9hbmNob3IiLFtdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHsKInVzZSBzdHJpY3QiOwoKdmFyIG9vcCA9IHJlcXVpcmUoIi4vbGliL29vcCIpOwp2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgiLi9saWIvZXZlbnRfZW1pdHRlciIpLkV2ZW50RW1pdHRlcjsKCnZhciBBbmNob3IgPSBleHBvcnRzLkFuY2hvciA9IGZ1bmN0aW9uKGRvYywgcm93LCBjb2x1bW4pIHsKICAgIHRoaXMuJG9uQ2hhbmdlID0gdGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpOwogICAgdGhpcy5hdHRhY2goZG9jKTsKICAgIAogICAgaWYgKHR5cGVvZiBjb2x1bW4gPT0gInVuZGVmaW5lZCIpCiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihyb3cucm93LCByb3cuY29sdW1uKTsKICAgIGVsc2UKICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHJvdywgY29sdW1uKTsKfTsKCihmdW5jdGlvbigpIHsKCiAgICBvb3AuaW1wbGVtZW50KHRoaXMsIEV2ZW50RW1pdHRlcik7CiAgICB0aGlzLmdldFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuJGNsaXBQb3NpdGlvblRvRG9jdW1lbnQodGhpcy5yb3csIHRoaXMuY29sdW1uKTsKICAgIH07CiAgICB0aGlzLmdldERvY3VtZW50ID0gZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQ7CiAgICB9OwogICAgdGhpcy4kaW5zZXJ0UmlnaHQgPSBmYWxzZTsKICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbihkZWx0YSkgewogICAgICAgIGlmIChkZWx0YS5zdGFydC5yb3cgPT0gZGVsdGEuZW5kLnJvdyAmJiBkZWx0YS5zdGFydC5yb3cgIT0gdGhpcy5yb3cpCiAgICAgICAgICAgIHJldHVybjsKCiAgICAgICAgaWYgKGRlbHRhLnN0YXJ0LnJvdyA+IHRoaXMucm93KQogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIAogICAgICAgIHZhciBwb2ludCA9ICRnZXRUcmFuc2Zvcm1lZFBvaW50KGRlbHRhLCB7cm93OiB0aGlzLnJvdywgY29sdW1uOiB0aGlzLmNvbHVtbn0sIHRoaXMuJGluc2VydFJpZ2h0KTsKICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHBvaW50LnJvdywgcG9pbnQuY29sdW1uLCB0cnVlKTsKICAgIH07CiAgICAKICAgIGZ1bmN0aW9uICRwb2ludHNJbk9yZGVyKHBvaW50MSwgcG9pbnQyLCBlcXVhbFBvaW50c0luT3JkZXIpIHsKICAgICAgICB2YXIgYkNvbElzQWZ0ZXIgPSBlcXVhbFBvaW50c0luT3JkZXIgPyBwb2ludDEuY29sdW1uIDw9IHBvaW50Mi5jb2x1bW4gOiBwb2ludDEuY29sdW1uIDwgcG9pbnQyLmNvbHVtbjsKICAgICAgICByZXR1cm4gKHBvaW50MS5yb3cgPCBwb2ludDIucm93KSB8fCAocG9pbnQxLnJvdyA9PSBwb2ludDIucm93ICYmIGJDb2xJc0FmdGVyKTsKICAgIH0KICAgICAgICAgICAgCiAgICBmdW5jdGlvbiAkZ2V0VHJhbnNmb3JtZWRQb2ludChkZWx0YSwgcG9pbnQsIG1vdmVJZkVxdWFsKSB7CiAgICAgICAgdmFyIGRlbHRhSXNJbnNlcnQgPSBkZWx0YS5hY3Rpb24gPT0gImluc2VydCI7CiAgICAgICAgdmFyIGRlbHRhUm93U2hpZnQgPSAoZGVsdGFJc0luc2VydCA/IDEgOiAtMSkgKiAoZGVsdGEuZW5kLnJvdyAgICAtIGRlbHRhLnN0YXJ0LnJvdyk7CiAgICAgICAgdmFyIGRlbHRhQ29sU2hpZnQgPSAoZGVsdGFJc0luc2VydCA/IDEgOiAtMSkgKiAoZGVsdGEuZW5kLmNvbHVtbiAtIGRlbHRhLnN0YXJ0LmNvbHVtbik7CiAgICAgICAgdmFyIGRlbHRhU3RhcnQgPSBkZWx0YS5zdGFydDsKICAgICAgICB2YXIgZGVsdGFFbmQgPSBkZWx0YUlzSW5zZXJ0ID8gZGVsdGFTdGFydCA6IGRlbHRhLmVuZDsgLy8gQ29sbGFwc2UgaW5zZXJ0IHJhbmdlLgogICAgICAgIGlmICgkcG9pbnRzSW5PcmRlcihwb2ludCwgZGVsdGFTdGFydCwgbW92ZUlmRXF1YWwpKSB7CiAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICByb3c6IHBvaW50LnJvdywKICAgICAgICAgICAgICAgIGNvbHVtbjogcG9pbnQuY29sdW1uCiAgICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIGlmICgkcG9pbnRzSW5PcmRlcihkZWx0YUVuZCwgcG9pbnQsICFtb3ZlSWZFcXVhbCkpIHsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgIHJvdzogcG9pbnQucm93ICsgZGVsdGFSb3dTaGlmdCwKICAgICAgICAgICAgICAgIGNvbHVtbjogcG9pbnQuY29sdW1uICsgKHBvaW50LnJvdyA9PSBkZWx0YUVuZC5yb3cgPyBkZWx0YUNvbFNoaWZ0IDogMCkKICAgICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgcm93OiBkZWx0YVN0YXJ0LnJvdywKICAgICAgICAgICAgY29sdW1uOiBkZWx0YVN0YXJ0LmNvbHVtbgogICAgICAgIH07CiAgICB9CiAgICB0aGlzLnNldFBvc2l0aW9uID0gZnVuY3Rpb24ocm93LCBjb2x1bW4sIG5vQ2xpcCkgewogICAgICAgIHZhciBwb3M7CiAgICAgICAgaWYgKG5vQ2xpcCkgewogICAgICAgICAgICBwb3MgPSB7CiAgICAgICAgICAgICAgICByb3c6IHJvdywKICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uCiAgICAgICAgICAgIH07CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcG9zID0gdGhpcy4kY2xpcFBvc2l0aW9uVG9Eb2N1bWVudChyb3csIGNvbHVtbik7CiAgICAgICAgfQoKICAgICAgICBpZiAodGhpcy5yb3cgPT0gcG9zLnJvdyAmJiB0aGlzLmNvbHVtbiA9PSBwb3MuY29sdW1uKQogICAgICAgICAgICByZXR1cm47CgogICAgICAgIHZhciBvbGQgPSB7CiAgICAgICAgICAgIHJvdzogdGhpcy5yb3csCiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4KICAgICAgICB9OwoKICAgICAgICB0aGlzLnJvdyA9IHBvcy5yb3c7CiAgICAgICAgdGhpcy5jb2x1bW4gPSBwb3MuY29sdW1uOwogICAgICAgIHRoaXMuX3NpZ25hbCgiY2hhbmdlIiwgewogICAgICAgICAgICBvbGQ6IG9sZCwKICAgICAgICAgICAgdmFsdWU6IHBvcwogICAgICAgIH0pOwogICAgfTsKICAgIHRoaXMuZGV0YWNoID0gZnVuY3Rpb24oKSB7CiAgICAgICAgdGhpcy5kb2N1bWVudC5vZmYoImNoYW5nZSIsIHRoaXMuJG9uQ2hhbmdlKTsKICAgIH07CiAgICB0aGlzLmF0dGFjaCA9IGZ1bmN0aW9uKGRvYykgewogICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2MgfHwgdGhpcy5kb2N1bWVudDsKICAgICAgICB0aGlzLmRvY3VtZW50Lm9uKCJjaGFuZ2UiLCB0aGlzLiRvbkNoYW5nZSk7CiAgICB9OwogICAgdGhpcy4kY2xpcFBvc2l0aW9uVG9Eb2N1bWVudCA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7CiAgICAgICAgdmFyIHBvcyA9IHt9OwoKICAgICAgICBpZiAocm93ID49IHRoaXMuZG9jdW1lbnQuZ2V0TGVuZ3RoKCkpIHsKICAgICAgICAgICAgcG9zLnJvdyA9IE1hdGgubWF4KDAsIHRoaXMuZG9jdW1lbnQuZ2V0TGVuZ3RoKCkgLSAxKTsKICAgICAgICAgICAgcG9zLmNvbHVtbiA9IHRoaXMuZG9jdW1lbnQuZ2V0TGluZShwb3Mucm93KS5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIGVsc2UgaWYgKHJvdyA8IDApIHsKICAgICAgICAgICAgcG9zLnJvdyA9IDA7CiAgICAgICAgICAgIHBvcy5jb2x1bW4gPSAwOwogICAgICAgIH0KICAgICAgICBlbHNlIHsKICAgICAgICAgICAgcG9zLnJvdyA9IHJvdzsKICAgICAgICAgICAgcG9zLmNvbHVtbiA9IE1hdGgubWluKHRoaXMuZG9jdW1lbnQuZ2V0TGluZShwb3Mucm93KS5sZW5ndGgsIE1hdGgubWF4KDAsIGNvbHVtbikpOwogICAgICAgIH0KCiAgICAgICAgaWYgKGNvbHVtbiA8IDApCiAgICAgICAgICAgIHBvcy5jb2x1bW4gPSAwOwoKICAgICAgICByZXR1cm4gcG9zOwogICAgfTsKCn0pLmNhbGwoQW5jaG9yLnByb3RvdHlwZSk7Cgp9KTsKCmFjZS5kZWZpbmUoImFjZS9kb2N1bWVudCIsW10sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkgewoidXNlIHN0cmljdCI7Cgp2YXIgb29wID0gcmVxdWlyZSgiLi9saWIvb29wIik7CnZhciBhcHBseURlbHRhID0gcmVxdWlyZSgiLi9hcHBseV9kZWx0YSIpLmFwcGx5RGVsdGE7CnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCIuL2xpYi9ldmVudF9lbWl0dGVyIikuRXZlbnRFbWl0dGVyOwp2YXIgUmFuZ2UgPSByZXF1aXJlKCIuL3JhbmdlIikuUmFuZ2U7CnZhciBBbmNob3IgPSByZXF1aXJlKCIuL2FuY2hvciIpLkFuY2hvcjsKCnZhciBEb2N1bWVudCA9IGZ1bmN0aW9uKHRleHRPckxpbmVzKSB7CiAgICB0aGlzLiRsaW5lcyA9IFsiIl07CiAgICBpZiAodGV4dE9yTGluZXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgdGhpcy4kbGluZXMgPSBbIiJdOwogICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRleHRPckxpbmVzKSkgewogICAgICAgIHRoaXMuaW5zZXJ0TWVyZ2VkTGluZXMoe3JvdzogMCwgY29sdW1uOiAwfSwgdGV4dE9yTGluZXMpOwogICAgfSBlbHNlIHsKICAgICAgICB0aGlzLmluc2VydCh7cm93OiAwLCBjb2x1bW46MH0sIHRleHRPckxpbmVzKTsKICAgIH0KfTsKCihmdW5jdGlvbigpIHsKCiAgICBvb3AuaW1wbGVtZW50KHRoaXMsIEV2ZW50RW1pdHRlcik7CiAgICB0aGlzLnNldFZhbHVlID0gZnVuY3Rpb24odGV4dCkgewogICAgICAgIHZhciBsZW4gPSB0aGlzLmdldExlbmd0aCgpIC0gMTsKICAgICAgICB0aGlzLnJlbW92ZShuZXcgUmFuZ2UoMCwgMCwgbGVuLCB0aGlzLmdldExpbmUobGVuKS5sZW5ndGgpKTsKICAgICAgICB0aGlzLmluc2VydCh7cm93OiAwLCBjb2x1bW46IDB9LCB0ZXh0KTsKICAgIH07CiAgICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsTGluZXMoKS5qb2luKHRoaXMuZ2V0TmV3TGluZUNoYXJhY3RlcigpKTsKICAgIH07CiAgICB0aGlzLmNyZWF0ZUFuY2hvciA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7CiAgICAgICAgcmV0dXJuIG5ldyBBbmNob3IodGhpcywgcm93LCBjb2x1bW4pOwogICAgfTsKICAgIGlmICgiYWFhIi5zcGxpdCgvYS8pLmxlbmd0aCA9PT0gMCkgewogICAgICAgIHRoaXMuJHNwbGl0ID0gZnVuY3Rpb24odGV4dCkgewogICAgICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cclxufFxyL2csICJcbiIpLnNwbGl0KCJcbiIpOwogICAgICAgIH07CiAgICB9IGVsc2UgewogICAgICAgIHRoaXMuJHNwbGl0ID0gZnVuY3Rpb24odGV4dCkgewogICAgICAgICAgICByZXR1cm4gdGV4dC5zcGxpdCgvXHJcbnxccnxcbi8pOwogICAgICAgIH07CiAgICB9CgoKICAgIHRoaXMuJGRldGVjdE5ld0xpbmUgPSBmdW5jdGlvbih0ZXh0KSB7CiAgICAgICAgdmFyIG1hdGNoID0gdGV4dC5tYXRjaCgvXi4qPyhcclxufFxyfFxuKS9tKTsKICAgICAgICB0aGlzLiRhdXRvTmV3TGluZSA9IG1hdGNoID8gbWF0Y2hbMV0gOiAiXG4iOwogICAgICAgIHRoaXMuX3NpZ25hbCgiY2hhbmdlTmV3TGluZU1vZGUiKTsKICAgIH07CiAgICB0aGlzLmdldE5ld0xpbmVDaGFyYWN0ZXIgPSBmdW5jdGlvbigpIHsKICAgICAgICBzd2l0Y2ggKHRoaXMuJG5ld0xpbmVNb2RlKSB7CiAgICAgICAgICBjYXNlICJ3aW5kb3dzIjoKICAgICAgICAgICAgcmV0dXJuICJcclxuIjsKICAgICAgICAgIGNhc2UgInVuaXgiOgogICAgICAgICAgICByZXR1cm4gIlxuIjsKICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgIHJldHVybiB0aGlzLiRhdXRvTmV3TGluZSB8fCAiXG4iOwogICAgICAgIH0KICAgIH07CgogICAgdGhpcy4kYXV0b05ld0xpbmUgPSAiIjsKICAgIHRoaXMuJG5ld0xpbmVNb2RlID0gImF1dG8iOwogICAgdGhpcy5zZXROZXdMaW5lTW9kZSA9IGZ1bmN0aW9uKG5ld0xpbmVNb2RlKSB7CiAgICAgICAgaWYgKHRoaXMuJG5ld0xpbmVNb2RlID09PSBuZXdMaW5lTW9kZSkKICAgICAgICAgICAgcmV0dXJuOwoKICAgICAgICB0aGlzLiRuZXdMaW5lTW9kZSA9IG5ld0xpbmVNb2RlOwogICAgICAgIHRoaXMuX3NpZ25hbCgiY2hhbmdlTmV3TGluZU1vZGUiKTsKICAgIH07CiAgICB0aGlzLmdldE5ld0xpbmVNb2RlID0gZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuJG5ld0xpbmVNb2RlOwogICAgfTsKICAgIHRoaXMuaXNOZXdMaW5lID0gZnVuY3Rpb24odGV4dCkgewogICAgICAgIHJldHVybiAodGV4dCA9PSAiXHJcbiIgfHwgdGV4dCA9PSAiXHIiIHx8IHRleHQgPT0gIlxuIik7CiAgICB9OwogICAgdGhpcy5nZXRMaW5lID0gZnVuY3Rpb24ocm93KSB7CiAgICAgICAgcmV0dXJuIHRoaXMuJGxpbmVzW3Jvd10gfHwgIiI7CiAgICB9OwogICAgdGhpcy5nZXRMaW5lcyA9IGZ1bmN0aW9uKGZpcnN0Um93LCBsYXN0Um93KSB7CiAgICAgICAgcmV0dXJuIHRoaXMuJGxpbmVzLnNsaWNlKGZpcnN0Um93LCBsYXN0Um93ICsgMSk7CiAgICB9OwogICAgdGhpcy5nZXRBbGxMaW5lcyA9IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLmdldExpbmVzKDAsIHRoaXMuZ2V0TGVuZ3RoKCkpOwogICAgfTsKICAgIHRoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuJGxpbmVzLmxlbmd0aDsKICAgIH07CiAgICB0aGlzLmdldFRleHRSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZXNGb3JSYW5nZShyYW5nZSkuam9pbih0aGlzLmdldE5ld0xpbmVDaGFyYWN0ZXIoKSk7CiAgICB9OwogICAgdGhpcy5nZXRMaW5lc0ZvclJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHsKICAgICAgICB2YXIgbGluZXM7CiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LnJvdyA9PT0gcmFuZ2UuZW5kLnJvdykgewogICAgICAgICAgICBsaW5lcyA9IFt0aGlzLmdldExpbmUocmFuZ2Uuc3RhcnQucm93KS5zdWJzdHJpbmcocmFuZ2Uuc3RhcnQuY29sdW1uLCByYW5nZS5lbmQuY29sdW1uKV07CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgbGluZXMgPSB0aGlzLmdldExpbmVzKHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2UuZW5kLnJvdyk7CiAgICAgICAgICAgIGxpbmVzWzBdID0gKGxpbmVzWzBdIHx8ICIiKS5zdWJzdHJpbmcocmFuZ2Uuc3RhcnQuY29sdW1uKTsKICAgICAgICAgICAgdmFyIGwgPSBsaW5lcy5sZW5ndGggLSAxOwogICAgICAgICAgICBpZiAocmFuZ2UuZW5kLnJvdyAtIHJhbmdlLnN0YXJ0LnJvdyA9PSBsKQogICAgICAgICAgICAgICAgbGluZXNbbF0gPSBsaW5lc1tsXS5zdWJzdHJpbmcoMCwgcmFuZ2UuZW5kLmNvbHVtbik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBsaW5lczsKICAgIH07CiAgICB0aGlzLmluc2VydExpbmVzID0gZnVuY3Rpb24ocm93LCBsaW5lcykgewogICAgICAgIGNvbnNvbGUud2FybigiVXNlIG9mIGRvY3VtZW50Lmluc2VydExpbmVzIGlzIGRlcHJlY2F0ZWQuIFVzZSB0aGUgaW5zZXJ0RnVsbExpbmVzIG1ldGhvZCBpbnN0ZWFkLiIpOwogICAgICAgIHJldHVybiB0aGlzLmluc2VydEZ1bGxMaW5lcyhyb3csIGxpbmVzKTsKICAgIH07CiAgICB0aGlzLnJlbW92ZUxpbmVzID0gZnVuY3Rpb24oZmlyc3RSb3csIGxhc3RSb3cpIHsKICAgICAgICBjb25zb2xlLndhcm4oIlVzZSBvZiBkb2N1bWVudC5yZW1vdmVMaW5lcyBpcyBkZXByZWNhdGVkLiBVc2UgdGhlIHJlbW92ZUZ1bGxMaW5lcyBtZXRob2QgaW5zdGVhZC4iKTsKICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVGdWxsTGluZXMoZmlyc3RSb3csIGxhc3RSb3cpOwogICAgfTsKICAgIHRoaXMuaW5zZXJ0TmV3TGluZSA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7CiAgICAgICAgY29uc29sZS53YXJuKCJVc2Ugb2YgZG9jdW1lbnQuaW5zZXJ0TmV3TGluZSBpcyBkZXByZWNhdGVkLiBVc2UgaW5zZXJ0TWVyZ2VkTGluZXMocG9zaXRpb24sIFsnJywgJyddKSBpbnN0ZWFkLiIpOwogICAgICAgIHJldHVybiB0aGlzLmluc2VydE1lcmdlZExpbmVzKHBvc2l0aW9uLCBbIiIsICIiXSk7CiAgICB9OwogICAgdGhpcy5pbnNlcnQgPSBmdW5jdGlvbihwb3NpdGlvbiwgdGV4dCkgewogICAgICAgIGlmICh0aGlzLmdldExlbmd0aCgpIDw9IDEpCiAgICAgICAgICAgIHRoaXMuJGRldGVjdE5ld0xpbmUodGV4dCk7CiAgICAgICAgCiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0TWVyZ2VkTGluZXMocG9zaXRpb24sIHRoaXMuJHNwbGl0KHRleHQpKTsKICAgIH07CiAgICB0aGlzLmluc2VydEluTGluZSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCB0ZXh0KSB7CiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5jbGlwcGVkUG9zKHBvc2l0aW9uLnJvdywgcG9zaXRpb24uY29sdW1uKTsKICAgICAgICB2YXIgZW5kID0gdGhpcy5wb3MocG9zaXRpb24ucm93LCBwb3NpdGlvbi5jb2x1bW4gKyB0ZXh0Lmxlbmd0aCk7CiAgICAgICAgCiAgICAgICAgdGhpcy5hcHBseURlbHRhKHsKICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LAogICAgICAgICAgICBlbmQ6IGVuZCwKICAgICAgICAgICAgYWN0aW9uOiAiaW5zZXJ0IiwKICAgICAgICAgICAgbGluZXM6IFt0ZXh0XQogICAgICAgIH0sIHRydWUpOwogICAgICAgIAogICAgICAgIHJldHVybiB0aGlzLmNsb25lUG9zKGVuZCk7CiAgICB9OwogICAgCiAgICB0aGlzLmNsaXBwZWRQb3MgPSBmdW5jdGlvbihyb3csIGNvbHVtbikgewogICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmdldExlbmd0aCgpOwogICAgICAgIGlmIChyb3cgPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICByb3cgPSBsZW5ndGg7CiAgICAgICAgfSBlbHNlIGlmIChyb3cgPCAwKSB7CiAgICAgICAgICAgIHJvdyA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChyb3cgPj0gbGVuZ3RoKSB7CiAgICAgICAgICAgIHJvdyA9IGxlbmd0aCAtIDE7CiAgICAgICAgICAgIGNvbHVtbiA9IHVuZGVmaW5lZDsKICAgICAgICB9CiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmdldExpbmUocm93KTsKICAgICAgICBpZiAoY29sdW1uID09IHVuZGVmaW5lZCkKICAgICAgICAgICAgY29sdW1uID0gbGluZS5sZW5ndGg7CiAgICAgICAgY29sdW1uID0gTWF0aC5taW4oTWF0aC5tYXgoY29sdW1uLCAwKSwgbGluZS5sZW5ndGgpOwogICAgICAgIHJldHVybiB7cm93OiByb3csIGNvbHVtbjogY29sdW1ufTsKICAgIH07CiAgICAKICAgIHRoaXMuY2xvbmVQb3MgPSBmdW5jdGlvbihwb3MpIHsKICAgICAgICByZXR1cm4ge3JvdzogcG9zLnJvdywgY29sdW1uOiBwb3MuY29sdW1ufTsKICAgIH07CiAgICAKICAgIHRoaXMucG9zID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHsKICAgICAgICByZXR1cm4ge3Jvdzogcm93LCBjb2x1bW46IGNvbHVtbn07CiAgICB9OwogICAgCiAgICB0aGlzLiRjbGlwUG9zaXRpb24gPSBmdW5jdGlvbihwb3NpdGlvbikgewogICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmdldExlbmd0aCgpOwogICAgICAgIGlmIChwb3NpdGlvbi5yb3cgPj0gbGVuZ3RoKSB7CiAgICAgICAgICAgIHBvc2l0aW9uLnJvdyA9IE1hdGgubWF4KDAsIGxlbmd0aCAtIDEpOwogICAgICAgICAgICBwb3NpdGlvbi5jb2x1bW4gPSB0aGlzLmdldExpbmUobGVuZ3RoIC0gMSkubGVuZ3RoOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHBvc2l0aW9uLnJvdyA9IE1hdGgubWF4KDAsIHBvc2l0aW9uLnJvdyk7CiAgICAgICAgICAgIHBvc2l0aW9uLmNvbHVtbiA9IE1hdGgubWluKE1hdGgubWF4KHBvc2l0aW9uLmNvbHVtbiwgMCksIHRoaXMuZ2V0TGluZShwb3NpdGlvbi5yb3cpLmxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBwb3NpdGlvbjsKICAgIH07CiAgICB0aGlzLmluc2VydEZ1bGxMaW5lcyA9IGZ1bmN0aW9uKHJvdywgbGluZXMpIHsKICAgICAgICByb3cgPSBNYXRoLm1pbihNYXRoLm1heChyb3csIDApLCB0aGlzLmdldExlbmd0aCgpKTsKICAgICAgICB2YXIgY29sdW1uID0gMDsKICAgICAgICBpZiAocm93IDwgdGhpcy5nZXRMZW5ndGgoKSkgewogICAgICAgICAgICBsaW5lcyA9IGxpbmVzLmNvbmNhdChbIiJdKTsKICAgICAgICAgICAgY29sdW1uID0gMDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBsaW5lcyA9IFsiIl0uY29uY2F0KGxpbmVzKTsKICAgICAgICAgICAgcm93LS07CiAgICAgICAgICAgIGNvbHVtbiA9IHRoaXMuJGxpbmVzW3Jvd10ubGVuZ3RoOwogICAgICAgIH0KICAgICAgICB0aGlzLmluc2VydE1lcmdlZExpbmVzKHtyb3c6IHJvdywgY29sdW1uOiBjb2x1bW59LCBsaW5lcyk7CiAgICB9OyAgICAKICAgIHRoaXMuaW5zZXJ0TWVyZ2VkTGluZXMgPSBmdW5jdGlvbihwb3NpdGlvbiwgbGluZXMpIHsKICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmNsaXBwZWRQb3MocG9zaXRpb24ucm93LCBwb3NpdGlvbi5jb2x1bW4pOwogICAgICAgIHZhciBlbmQgPSB7CiAgICAgICAgICAgIHJvdzogc3RhcnQucm93ICsgbGluZXMubGVuZ3RoIC0gMSwKICAgICAgICAgICAgY29sdW1uOiAobGluZXMubGVuZ3RoID09IDEgPyBzdGFydC5jb2x1bW4gOiAwKSArIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aAogICAgICAgIH07CiAgICAgICAgCiAgICAgICAgdGhpcy5hcHBseURlbHRhKHsKICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LAogICAgICAgICAgICBlbmQ6IGVuZCwKICAgICAgICAgICAgYWN0aW9uOiAiaW5zZXJ0IiwKICAgICAgICAgICAgbGluZXM6IGxpbmVzCiAgICAgICAgfSk7CiAgICAgICAgCiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmVQb3MoZW5kKTsKICAgIH07CiAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uKHJhbmdlKSB7CiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5jbGlwcGVkUG9zKHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uKTsKICAgICAgICB2YXIgZW5kID0gdGhpcy5jbGlwcGVkUG9zKHJhbmdlLmVuZC5yb3csIHJhbmdlLmVuZC5jb2x1bW4pOwogICAgICAgIHRoaXMuYXBwbHlEZWx0YSh7CiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCwKICAgICAgICAgICAgZW5kOiBlbmQsCiAgICAgICAgICAgIGFjdGlvbjogInJlbW92ZSIsCiAgICAgICAgICAgIGxpbmVzOiB0aGlzLmdldExpbmVzRm9yUmFuZ2Uoe3N0YXJ0OiBzdGFydCwgZW5kOiBlbmR9KQogICAgICAgIH0pOwogICAgICAgIHJldHVybiB0aGlzLmNsb25lUG9zKHN0YXJ0KTsKICAgIH07CiAgICB0aGlzLnJlbW92ZUluTGluZSA9IGZ1bmN0aW9uKHJvdywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbikgewogICAgICAgIHZhciBzdGFydCA9IHRoaXMuY2xpcHBlZFBvcyhyb3csIHN0YXJ0Q29sdW1uKTsKICAgICAgICB2YXIgZW5kID0gdGhpcy5jbGlwcGVkUG9zKHJvdywgZW5kQ29sdW1uKTsKICAgICAgICAKICAgICAgICB0aGlzLmFwcGx5RGVsdGEoewogICAgICAgICAgICBzdGFydDogc3RhcnQsCiAgICAgICAgICAgIGVuZDogZW5kLAogICAgICAgICAgICBhY3Rpb246ICJyZW1vdmUiLAogICAgICAgICAgICBsaW5lczogdGhpcy5nZXRMaW5lc0ZvclJhbmdlKHtzdGFydDogc3RhcnQsIGVuZDogZW5kfSkKICAgICAgICB9LCB0cnVlKTsKICAgICAgICAKICAgICAgICByZXR1cm4gdGhpcy5jbG9uZVBvcyhzdGFydCk7CiAgICB9OwogICAgdGhpcy5yZW1vdmVGdWxsTGluZXMgPSBmdW5jdGlvbihmaXJzdFJvdywgbGFzdFJvdykgewogICAgICAgIGZpcnN0Um93ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZmlyc3RSb3cpLCB0aGlzLmdldExlbmd0aCgpIC0gMSk7CiAgICAgICAgbGFzdFJvdyAgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBsYXN0Um93ICksIHRoaXMuZ2V0TGVuZ3RoKCkgLSAxKTsKICAgICAgICB2YXIgZGVsZXRlRmlyc3ROZXdMaW5lID0gbGFzdFJvdyA9PSB0aGlzLmdldExlbmd0aCgpIC0gMSAmJiBmaXJzdFJvdyA+IDA7CiAgICAgICAgdmFyIGRlbGV0ZUxhc3ROZXdMaW5lICA9IGxhc3RSb3cgIDwgdGhpcy5nZXRMZW5ndGgoKSAtIDE7CiAgICAgICAgdmFyIHN0YXJ0Um93ID0gKCBkZWxldGVGaXJzdE5ld0xpbmUgPyBmaXJzdFJvdyAtIDEgICAgICAgICAgICAgICAgICA6IGZpcnN0Um93ICAgICAgICAgICAgICAgICAgICApOwogICAgICAgIHZhciBzdGFydENvbCA9ICggZGVsZXRlRmlyc3ROZXdMaW5lID8gdGhpcy5nZXRMaW5lKHN0YXJ0Um93KS5sZW5ndGggOiAwICAgICAgICAgICAgICAgICAgICAgICAgICAgKTsKICAgICAgICB2YXIgZW5kUm93ICAgPSAoIGRlbGV0ZUxhc3ROZXdMaW5lICA/IGxhc3RSb3cgKyAxICAgICAgICAgICAgICAgICAgIDogbGFzdFJvdyAgICAgICAgICAgICAgICAgICAgICk7CiAgICAgICAgdmFyIGVuZENvbCAgID0gKCBkZWxldGVMYXN0TmV3TGluZSAgPyAwICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuZ2V0TGluZShlbmRSb3cpLmxlbmd0aCApOyAKICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnRSb3csIHN0YXJ0Q29sLCBlbmRSb3csIGVuZENvbCk7CiAgICAgICAgdmFyIGRlbGV0ZWRMaW5lcyA9IHRoaXMuJGxpbmVzLnNsaWNlKGZpcnN0Um93LCBsYXN0Um93ICsgMSk7CiAgICAgICAgCiAgICAgICAgdGhpcy5hcHBseURlbHRhKHsKICAgICAgICAgICAgc3RhcnQ6IHJhbmdlLnN0YXJ0LAogICAgICAgICAgICBlbmQ6IHJhbmdlLmVuZCwKICAgICAgICAgICAgYWN0aW9uOiAicmVtb3ZlIiwKICAgICAgICAgICAgbGluZXM6IHRoaXMuZ2V0TGluZXNGb3JSYW5nZShyYW5nZSkKICAgICAgICB9KTsKICAgICAgICByZXR1cm4gZGVsZXRlZExpbmVzOwogICAgfTsKICAgIHRoaXMucmVtb3ZlTmV3TGluZSA9IGZ1bmN0aW9uKHJvdykgewogICAgICAgIGlmIChyb3cgPCB0aGlzLmdldExlbmd0aCgpIC0gMSAmJiByb3cgPj0gMCkgewogICAgICAgICAgICB0aGlzLmFwcGx5RGVsdGEoewogICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMucG9zKHJvdywgdGhpcy5nZXRMaW5lKHJvdykubGVuZ3RoKSwKICAgICAgICAgICAgICAgIGVuZDogdGhpcy5wb3Mocm93ICsgMSwgMCksCiAgICAgICAgICAgICAgICBhY3Rpb246ICJyZW1vdmUiLAogICAgICAgICAgICAgICAgbGluZXM6IFsiIiwgIiJdCiAgICAgICAgICAgIH0pOwogICAgICAgIH0KICAgIH07CiAgICB0aGlzLnJlcGxhY2UgPSBmdW5jdGlvbihyYW5nZSwgdGV4dCkgewogICAgICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKQogICAgICAgICAgICByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7CiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwICYmIHJhbmdlLmlzRW1wdHkoKSkKICAgICAgICAgICAgcmV0dXJuIHJhbmdlLnN0YXJ0OwogICAgICAgIGlmICh0ZXh0ID09IHRoaXMuZ2V0VGV4dFJhbmdlKHJhbmdlKSkKICAgICAgICAgICAgcmV0dXJuIHJhbmdlLmVuZDsKCiAgICAgICAgdGhpcy5yZW1vdmUocmFuZ2UpOwogICAgICAgIHZhciBlbmQ7CiAgICAgICAgaWYgKHRleHQpIHsKICAgICAgICAgICAgZW5kID0gdGhpcy5pbnNlcnQocmFuZ2Uuc3RhcnQsIHRleHQpOwogICAgICAgIH0KICAgICAgICBlbHNlIHsKICAgICAgICAgICAgZW5kID0gcmFuZ2Uuc3RhcnQ7CiAgICAgICAgfQogICAgICAgIAogICAgICAgIHJldHVybiBlbmQ7CiAgICB9OwogICAgdGhpcy5hcHBseURlbHRhcyA9IGZ1bmN0aW9uKGRlbHRhcykgewogICAgICAgIGZvciAodmFyIGk9MDsgaTxkZWx0YXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgdGhpcy5hcHBseURlbHRhKGRlbHRhc1tpXSk7CiAgICAgICAgfQogICAgfTsKICAgIHRoaXMucmV2ZXJ0RGVsdGFzID0gZnVuY3Rpb24oZGVsdGFzKSB7CiAgICAgICAgZm9yICh2YXIgaT1kZWx0YXMubGVuZ3RoLTE7IGk+PTA7IGktLSkgewogICAgICAgICAgICB0aGlzLnJldmVydERlbHRhKGRlbHRhc1tpXSk7CiAgICAgICAgfQogICAgfTsKICAgIHRoaXMuYXBwbHlEZWx0YSA9IGZ1bmN0aW9uKGRlbHRhLCBkb05vdFZhbGlkYXRlKSB7CiAgICAgICAgdmFyIGlzSW5zZXJ0ID0gZGVsdGEuYWN0aW9uID09ICJpbnNlcnQiOwogICAgICAgIGlmIChpc0luc2VydCA/IGRlbHRhLmxpbmVzLmxlbmd0aCA8PSAxICYmICFkZWx0YS5saW5lc1swXQogICAgICAgICAgICA6ICFSYW5nZS5jb21wYXJlUG9pbnRzKGRlbHRhLnN0YXJ0LCBkZWx0YS5lbmQpKSB7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgaWYgKGlzSW5zZXJ0ICYmIGRlbHRhLmxpbmVzLmxlbmd0aCA+IDIwMDAwKSB7CiAgICAgICAgICAgIHRoaXMuJHNwbGl0QW5kYXBwbHlMYXJnZURlbHRhKGRlbHRhLCAyMDAwMCk7CiAgICAgICAgfQogICAgICAgIGVsc2UgewogICAgICAgICAgICBhcHBseURlbHRhKHRoaXMuJGxpbmVzLCBkZWx0YSwgZG9Ob3RWYWxpZGF0ZSk7CiAgICAgICAgICAgIHRoaXMuX3NpZ25hbCgiY2hhbmdlIiwgZGVsdGEpOwogICAgICAgIH0KICAgIH07CiAgICAKICAgIHRoaXMuJHNhZmVBcHBseURlbHRhID0gZnVuY3Rpb24oZGVsdGEpIHsKICAgICAgICB2YXIgZG9jTGVuZ3RoID0gdGhpcy4kbGluZXMubGVuZ3RoOwogICAgICAgIGlmICgKICAgICAgICAgICAgZGVsdGEuYWN0aW9uID09ICJyZW1vdmUiICYmIGRlbHRhLnN0YXJ0LnJvdyA8IGRvY0xlbmd0aCAmJiBkZWx0YS5lbmQucm93IDwgZG9jTGVuZ3RoCiAgICAgICAgICAgIHx8IGRlbHRhLmFjdGlvbiA9PSAiaW5zZXJ0IiAmJiBkZWx0YS5zdGFydC5yb3cgPD0gZG9jTGVuZ3RoCiAgICAgICAgKSB7CiAgICAgICAgICAgIHRoaXMuYXBwbHlEZWx0YShkZWx0YSk7CiAgICAgICAgfQogICAgfTsKICAgIAogICAgdGhpcy4kc3BsaXRBbmRhcHBseUxhcmdlRGVsdGEgPSBmdW5jdGlvbihkZWx0YSwgTUFYKSB7CiAgICAgICAgdmFyIGxpbmVzID0gZGVsdGEubGluZXM7CiAgICAgICAgdmFyIGwgPSBsaW5lcy5sZW5ndGggLSBNQVggKyAxOwogICAgICAgIHZhciByb3cgPSBkZWx0YS5zdGFydC5yb3c7IAogICAgICAgIHZhciBjb2x1bW4gPSBkZWx0YS5zdGFydC5jb2x1bW47CiAgICAgICAgZm9yICh2YXIgZnJvbSA9IDAsIHRvID0gMDsgZnJvbSA8IGw7IGZyb20gPSB0bykgewogICAgICAgICAgICB0byArPSBNQVggLSAxOwogICAgICAgICAgICB2YXIgY2h1bmsgPSBsaW5lcy5zbGljZShmcm9tLCB0byk7CiAgICAgICAgICAgIGNodW5rLnB1c2goIiIpOwogICAgICAgICAgICB0aGlzLmFwcGx5RGVsdGEoewogICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMucG9zKHJvdyArIGZyb20sIGNvbHVtbiksCiAgICAgICAgICAgICAgICBlbmQ6IHRoaXMucG9zKHJvdyArIHRvLCBjb2x1bW4gPSAwKSwKICAgICAgICAgICAgICAgIGFjdGlvbjogZGVsdGEuYWN0aW9uLAogICAgICAgICAgICAgICAgbGluZXM6IGNodW5rCiAgICAgICAgICAgIH0sIHRydWUpOwogICAgICAgIH0KICAgICAgICBkZWx0YS5saW5lcyA9IGxpbmVzLnNsaWNlKGZyb20pOwogICAgICAgIGRlbHRhLnN0YXJ0LnJvdyA9IHJvdyArIGZyb207CiAgICAgICAgZGVsdGEuc3RhcnQuY29sdW1uID0gY29sdW1uOwogICAgICAgIHRoaXMuYXBwbHlEZWx0YShkZWx0YSwgdHJ1ZSk7CiAgICB9OwogICAgdGhpcy5yZXZlcnREZWx0YSA9IGZ1bmN0aW9uKGRlbHRhKSB7CiAgICAgICAgdGhpcy4kc2FmZUFwcGx5RGVsdGEoewogICAgICAgICAgICBzdGFydDogdGhpcy5jbG9uZVBvcyhkZWx0YS5zdGFydCksCiAgICAgICAgICAgIGVuZDogdGhpcy5jbG9uZVBvcyhkZWx0YS5lbmQpLAogICAgICAgICAgICBhY3Rpb246IChkZWx0YS5hY3Rpb24gPT0gImluc2VydCIgPyAicmVtb3ZlIiA6ICJpbnNlcnQiKSwKICAgICAgICAgICAgbGluZXM6IGRlbHRhLmxpbmVzLnNsaWNlKCkKICAgICAgICB9KTsKICAgIH07CiAgICB0aGlzLmluZGV4VG9Qb3NpdGlvbiA9IGZ1bmN0aW9uKGluZGV4LCBzdGFydFJvdykgewogICAgICAgIHZhciBsaW5lcyA9IHRoaXMuJGxpbmVzIHx8IHRoaXMuZ2V0QWxsTGluZXMoKTsKICAgICAgICB2YXIgbmV3bGluZUxlbmd0aCA9IHRoaXMuZ2V0TmV3TGluZUNoYXJhY3RlcigpLmxlbmd0aDsKICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRSb3cgfHwgMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICBpbmRleCAtPSBsaW5lc1tpXS5sZW5ndGggKyBuZXdsaW5lTGVuZ3RoOwogICAgICAgICAgICBpZiAoaW5kZXggPCAwKQogICAgICAgICAgICAgICAgcmV0dXJuIHtyb3c6IGksIGNvbHVtbjogaW5kZXggKyBsaW5lc1tpXS5sZW5ndGggKyBuZXdsaW5lTGVuZ3RofTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHtyb3c6IGwtMSwgY29sdW1uOiBpbmRleCArIGxpbmVzW2wtMV0ubGVuZ3RoICsgbmV3bGluZUxlbmd0aH07CiAgICB9OwogICAgdGhpcy5wb3NpdGlvblRvSW5kZXggPSBmdW5jdGlvbihwb3MsIHN0YXJ0Um93KSB7CiAgICAgICAgdmFyIGxpbmVzID0gdGhpcy4kbGluZXMgfHwgdGhpcy5nZXRBbGxMaW5lcygpOwogICAgICAgIHZhciBuZXdsaW5lTGVuZ3RoID0gdGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKCkubGVuZ3RoOwogICAgICAgIHZhciBpbmRleCA9IDA7CiAgICAgICAgdmFyIHJvdyA9IE1hdGgubWluKHBvcy5yb3csIGxpbmVzLmxlbmd0aCk7CiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0Um93IHx8IDA7IGkgPCByb3c7ICsraSkKICAgICAgICAgICAgaW5kZXggKz0gbGluZXNbaV0ubGVuZ3RoICsgbmV3bGluZUxlbmd0aDsKCiAgICAgICAgcmV0dXJuIGluZGV4ICsgcG9zLmNvbHVtbjsKICAgIH07Cgp9KS5jYWxsKERvY3VtZW50LnByb3RvdHlwZSk7CgpleHBvcnRzLkRvY3VtZW50ID0gRG9jdW1lbnQ7Cn0pOwoKYWNlLmRlZmluZSgiYWNlL2xpYi9sYW5nIixbXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7CiJ1c2Ugc3RyaWN0IjsKCmV4cG9ydHMubGFzdCA9IGZ1bmN0aW9uKGEpIHsKICAgIHJldHVybiBhW2EubGVuZ3RoIC0gMV07Cn07CgpleHBvcnRzLnN0cmluZ1JldmVyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHsKICAgIHJldHVybiBzdHJpbmcuc3BsaXQoIiIpLnJldmVyc2UoKS5qb2luKCIiKTsKfTsKCmV4cG9ydHMuc3RyaW5nUmVwZWF0ID0gZnVuY3Rpb24gKHN0cmluZywgY291bnQpIHsKICAgIHZhciByZXN1bHQgPSAnJzsKICAgIHdoaWxlIChjb3VudCA+IDApIHsKICAgICAgICBpZiAoY291bnQgJiAxKQogICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nOwoKICAgICAgICBpZiAoY291bnQgPj49IDEpCiAgICAgICAgICAgIHN0cmluZyArPSBzdHJpbmc7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0Owp9OwoKdmFyIHRyaW1CZWdpblJlZ2V4cCA9IC9eXHNccyovOwp2YXIgdHJpbUVuZFJlZ2V4cCA9IC9cc1xzKiQvOwoKZXhwb3J0cy5zdHJpbmdUcmltTGVmdCA9IGZ1bmN0aW9uIChzdHJpbmcpIHsKICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSh0cmltQmVnaW5SZWdleHAsICcnKTsKfTsKCmV4cG9ydHMuc3RyaW5nVHJpbVJpZ2h0ID0gZnVuY3Rpb24gKHN0cmluZykgewogICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHRyaW1FbmRSZWdleHAsICcnKTsKfTsKCmV4cG9ydHMuY29weU9iamVjdCA9IGZ1bmN0aW9uKG9iaikgewogICAgdmFyIGNvcHkgPSB7fTsKICAgIGZvciAodmFyIGtleSBpbiBvYmopIHsKICAgICAgICBjb3B5W2tleV0gPSBvYmpba2V5XTsKICAgIH0KICAgIHJldHVybiBjb3B5Owp9OwoKZXhwb3J0cy5jb3B5QXJyYXkgPSBmdW5jdGlvbihhcnJheSl7CiAgICB2YXIgY29weSA9IFtdOwogICAgZm9yICh2YXIgaT0wLCBsPWFycmF5Lmxlbmd0aDsgaTxsOyBpKyspIHsKICAgICAgICBpZiAoYXJyYXlbaV0gJiYgdHlwZW9mIGFycmF5W2ldID09ICJvYmplY3QiKQogICAgICAgICAgICBjb3B5W2ldID0gdGhpcy5jb3B5T2JqZWN0KGFycmF5W2ldKTsKICAgICAgICBlbHNlIAogICAgICAgICAgICBjb3B5W2ldID0gYXJyYXlbaV07CiAgICB9CiAgICByZXR1cm4gY29weTsKfTsKCmV4cG9ydHMuZGVlcENvcHkgPSBmdW5jdGlvbiBkZWVwQ29weShvYmopIHsKICAgIGlmICh0eXBlb2Ygb2JqICE9PSAib2JqZWN0IiB8fCAhb2JqKQogICAgICAgIHJldHVybiBvYmo7CiAgICB2YXIgY29weTsKICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHsKICAgICAgICBjb3B5ID0gW107CiAgICAgICAgZm9yICh2YXIga2V5ID0gMDsga2V5IDwgb2JqLmxlbmd0aDsga2V5KyspIHsKICAgICAgICAgICAgY29weVtrZXldID0gZGVlcENvcHkob2JqW2tleV0pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gY29weTsKICAgIH0KICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSAhPT0gIltvYmplY3QgT2JqZWN0XSIpCiAgICAgICAgcmV0dXJuIG9iajsKICAgIAogICAgY29weSA9IHt9OwogICAgZm9yICh2YXIga2V5IGluIG9iaikKICAgICAgICBjb3B5W2tleV0gPSBkZWVwQ29weShvYmpba2V5XSk7CiAgICByZXR1cm4gY29weTsKfTsKCmV4cG9ydHMuYXJyYXlUb01hcCA9IGZ1bmN0aW9uKGFycikgewogICAgdmFyIG1hcCA9IHt9OwogICAgZm9yICh2YXIgaT0wOyBpPGFyci5sZW5ndGg7IGkrKykgewogICAgICAgIG1hcFthcnJbaV1dID0gMTsKICAgIH0KICAgIHJldHVybiBtYXA7Cgp9OwoKZXhwb3J0cy5jcmVhdGVNYXAgPSBmdW5jdGlvbihwcm9wcykgewogICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7CiAgICBmb3IgKHZhciBpIGluIHByb3BzKSB7CiAgICAgICAgbWFwW2ldID0gcHJvcHNbaV07CiAgICB9CiAgICByZXR1cm4gbWFwOwp9OwpleHBvcnRzLmFycmF5UmVtb3ZlID0gZnVuY3Rpb24oYXJyYXksIHZhbHVlKSB7CiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gYXJyYXkubGVuZ3RoOyBpKyspIHsKICAgIGlmICh2YWx1ZSA9PT0gYXJyYXlbaV0pIHsKICAgICAgYXJyYXkuc3BsaWNlKGksIDEpOwogICAgfQogIH0KfTsKCmV4cG9ydHMuZXNjYXBlUmVnRXhwID0gZnVuY3Rpb24oc3RyKSB7CiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLiorP14ke30oKXxbXF1cL1xcXSkvZywgJ1xcJDEnKTsKfTsKCmV4cG9ydHMuZXNjYXBlSFRNTCA9IGZ1bmN0aW9uKHN0cikgewogICAgcmV0dXJuICgiIiArIHN0cikucmVwbGFjZSgvJi9nLCAiJiMzODsiKS5yZXBsYWNlKC8iL2csICImIzM0OyIpLnJlcGxhY2UoLycvZywgIiYjMzk7IikucmVwbGFjZSgvPC9nLCAiJiM2MDsiKTsKfTsKCmV4cG9ydHMuZ2V0TWF0Y2hPZmZzZXRzID0gZnVuY3Rpb24oc3RyaW5nLCByZWdFeHApIHsKICAgIHZhciBtYXRjaGVzID0gW107CgogICAgc3RyaW5nLnJlcGxhY2UocmVnRXhwLCBmdW5jdGlvbihzdHIpIHsKICAgICAgICBtYXRjaGVzLnB1c2goewogICAgICAgICAgICBvZmZzZXQ6IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTJdLAogICAgICAgICAgICBsZW5ndGg6IHN0ci5sZW5ndGgKICAgICAgICB9KTsKICAgIH0pOwoKICAgIHJldHVybiBtYXRjaGVzOwp9OwpleHBvcnRzLmRlZmVycmVkQ2FsbCA9IGZ1bmN0aW9uKGZjbikgewogICAgdmFyIHRpbWVyID0gbnVsbDsKICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKCkgewogICAgICAgIHRpbWVyID0gbnVsbDsKICAgICAgICBmY24oKTsKICAgIH07CgogICAgdmFyIGRlZmVycmVkID0gZnVuY3Rpb24odGltZW91dCkgewogICAgICAgIGRlZmVycmVkLmNhbmNlbCgpOwogICAgICAgIHRpbWVyID0gc2V0VGltZW91dChjYWxsYmFjaywgdGltZW91dCB8fCAwKTsKICAgICAgICByZXR1cm4gZGVmZXJyZWQ7CiAgICB9OwoKICAgIGRlZmVycmVkLnNjaGVkdWxlID0gZGVmZXJyZWQ7CgogICAgZGVmZXJyZWQuY2FsbCA9IGZ1bmN0aW9uKCkgewogICAgICAgIHRoaXMuY2FuY2VsKCk7CiAgICAgICAgZmNuKCk7CiAgICAgICAgcmV0dXJuIGRlZmVycmVkOwogICAgfTsKCiAgICBkZWZlcnJlZC5jYW5jZWwgPSBmdW5jdGlvbigpIHsKICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpOwogICAgICAgIHRpbWVyID0gbnVsbDsKICAgICAgICByZXR1cm4gZGVmZXJyZWQ7CiAgICB9OwogICAgCiAgICBkZWZlcnJlZC5pc1BlbmRpbmcgPSBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGltZXI7CiAgICB9OwoKICAgIHJldHVybiBkZWZlcnJlZDsKfTsKCgpleHBvcnRzLmRlbGF5ZWRDYWxsID0gZnVuY3Rpb24oZmNuLCBkZWZhdWx0VGltZW91dCkgewogICAgdmFyIHRpbWVyID0gbnVsbDsKICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKCkgewogICAgICAgIHRpbWVyID0gbnVsbDsKICAgICAgICBmY24oKTsKICAgIH07CgogICAgdmFyIF9zZWxmID0gZnVuY3Rpb24odGltZW91dCkgewogICAgICAgIGlmICh0aW1lciA9PSBudWxsKQogICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWVvdXQgfHwgZGVmYXVsdFRpbWVvdXQpOwogICAgfTsKCiAgICBfc2VsZi5kZWxheSA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsKICAgICAgICB0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpOwogICAgICAgIHRpbWVyID0gc2V0VGltZW91dChjYWxsYmFjaywgdGltZW91dCB8fCBkZWZhdWx0VGltZW91dCk7CiAgICB9OwogICAgX3NlbGYuc2NoZWR1bGUgPSBfc2VsZjsKCiAgICBfc2VsZi5jYWxsID0gZnVuY3Rpb24oKSB7CiAgICAgICAgdGhpcy5jYW5jZWwoKTsKICAgICAgICBmY24oKTsKICAgIH07CgogICAgX3NlbGYuY2FuY2VsID0gZnVuY3Rpb24oKSB7CiAgICAgICAgdGltZXIgJiYgY2xlYXJUaW1lb3V0KHRpbWVyKTsKICAgICAgICB0aW1lciA9IG51bGw7CiAgICB9OwoKICAgIF9zZWxmLmlzUGVuZGluZyA9IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aW1lcjsKICAgIH07CgogICAgcmV0dXJuIF9zZWxmOwp9Owp9KTsKCmFjZS5kZWZpbmUoImFjZS93b3JrZXIvbWlycm9yIixbXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7CiJ1c2Ugc3RyaWN0IjsKCnZhciBSYW5nZSA9IHJlcXVpcmUoIi4uL3JhbmdlIikuUmFuZ2U7CnZhciBEb2N1bWVudCA9IHJlcXVpcmUoIi4uL2RvY3VtZW50IikuRG9jdW1lbnQ7CnZhciBsYW5nID0gcmVxdWlyZSgiLi4vbGliL2xhbmciKTsKICAgIAp2YXIgTWlycm9yID0gZXhwb3J0cy5NaXJyb3IgPSBmdW5jdGlvbihzZW5kZXIpIHsKICAgIHRoaXMuc2VuZGVyID0gc2VuZGVyOwogICAgdmFyIGRvYyA9IHRoaXMuZG9jID0gbmV3IERvY3VtZW50KCIiKTsKICAgIAogICAgdmFyIGRlZmVycmVkVXBkYXRlID0gdGhpcy5kZWZlcnJlZFVwZGF0ZSA9IGxhbmcuZGVsYXllZENhbGwodGhpcy5vblVwZGF0ZS5iaW5kKHRoaXMpKTsKICAgIAogICAgdmFyIF9zZWxmID0gdGhpczsKICAgIHNlbmRlci5vbigiY2hhbmdlIiwgZnVuY3Rpb24oZSkgewogICAgICAgIHZhciBkYXRhID0gZS5kYXRhOwogICAgICAgIGlmIChkYXRhWzBdLnN0YXJ0KSB7CiAgICAgICAgICAgIGRvYy5hcHBseURlbHRhcyhkYXRhKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDIpIHsKICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFbaSsxXSkpIHsKICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHthY3Rpb246ICJpbnNlcnQiLCBzdGFydDogZGF0YVtpXSwgbGluZXM6IGRhdGFbaSsxXX07CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHZhciBkID0ge2FjdGlvbjogInJlbW92ZSIsIHN0YXJ0OiBkYXRhW2ldLCBlbmQ6IGRhdGFbaSsxXX07CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBkb2MuYXBwbHlEZWx0YShkLCB0cnVlKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoX3NlbGYuJHRpbWVvdXQpCiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZFVwZGF0ZS5zY2hlZHVsZShfc2VsZi4kdGltZW91dCk7CiAgICAgICAgX3NlbGYub25VcGRhdGUoKTsKICAgIH0pOwp9OwoKKGZ1bmN0aW9uKCkgewogICAgCiAgICB0aGlzLiR0aW1lb3V0ID0gNTAwOwogICAgCiAgICB0aGlzLnNldFRpbWVvdXQgPSBmdW5jdGlvbih0aW1lb3V0KSB7CiAgICAgICAgdGhpcy4kdGltZW91dCA9IHRpbWVvdXQ7CiAgICB9OwogICAgCiAgICB0aGlzLnNldFZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICB0aGlzLmRvYy5zZXRWYWx1ZSh2YWx1ZSk7CiAgICAgICAgdGhpcy5kZWZlcnJlZFVwZGF0ZS5zY2hlZHVsZSh0aGlzLiR0aW1lb3V0KTsKICAgIH07CiAgICAKICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbihjYWxsYmFja0lkKSB7CiAgICAgICAgdGhpcy5zZW5kZXIuY2FsbGJhY2sodGhpcy5kb2MuZ2V0VmFsdWUoKSwgY2FsbGJhY2tJZCk7CiAgICB9OwogICAgCiAgICB0aGlzLm9uVXBkYXRlID0gZnVuY3Rpb24oKSB7CiAgICB9OwogICAgCiAgICB0aGlzLmlzUGVuZGluZyA9IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLmRlZmVycmVkVXBkYXRlLmlzUGVuZGluZygpOwogICAgfTsKICAgIAp9KS5jYWxsKE1pcnJvci5wcm90b3R5cGUpOwoKfSk7CgphY2UuZGVmaW5lKCJhY2UvbW9kZS9qc29uL2pzb25fcGFyc2UiLFtdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHsKInVzZSBzdHJpY3QiOwoKICAgIHZhciBhdCwgICAgIC8vIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFyYWN0ZXIKICAgICAgICBjaCwgICAgIC8vIFRoZSBjdXJyZW50IGNoYXJhY3RlcgogICAgICAgIGVzY2FwZWUgPSB7CiAgICAgICAgICAgICciJzogICciJywKICAgICAgICAgICAgJ1xcJzogJ1xcJywKICAgICAgICAgICAgJy8nOiAgJy8nLAogICAgICAgICAgICBiOiAgICAnXGInLAogICAgICAgICAgICBmOiAgICAnXGYnLAogICAgICAgICAgICBuOiAgICAnXG4nLAogICAgICAgICAgICByOiAgICAnXHInLAogICAgICAgICAgICB0OiAgICAnXHQnCiAgICAgICAgfSwKICAgICAgICB0ZXh0LAoKICAgICAgICBlcnJvciA9IGZ1bmN0aW9uIChtKSB7CgogICAgICAgICAgICB0aHJvdyB7CiAgICAgICAgICAgICAgICBuYW1lOiAgICAnU3ludGF4RXJyb3InLAogICAgICAgICAgICAgICAgbWVzc2FnZTogbSwKICAgICAgICAgICAgICAgIGF0OiAgICAgIGF0LAogICAgICAgICAgICAgICAgdGV4dDogICAgdGV4dAogICAgICAgICAgICB9OwogICAgICAgIH0sCgogICAgICAgIG5leHQgPSBmdW5jdGlvbiAoYykgewoKICAgICAgICAgICAgaWYgKGMgJiYgYyAhPT0gY2gpIHsKICAgICAgICAgICAgICAgIGVycm9yKCJFeHBlY3RlZCAnIiArIGMgKyAiJyBpbnN0ZWFkIG9mICciICsgY2ggKyAiJyIpOwogICAgICAgICAgICB9CgogICAgICAgICAgICBjaCA9IHRleHQuY2hhckF0KGF0KTsKICAgICAgICAgICAgYXQgKz0gMTsKICAgICAgICAgICAgcmV0dXJuIGNoOwogICAgICAgIH0sCgogICAgICAgIG51bWJlciA9IGZ1bmN0aW9uICgpIHsKCiAgICAgICAgICAgIHZhciBudW1iZXIsCiAgICAgICAgICAgICAgICBzdHJpbmcgPSAnJzsKCiAgICAgICAgICAgIGlmIChjaCA9PT0gJy0nKSB7CiAgICAgICAgICAgICAgICBzdHJpbmcgPSAnLSc7CiAgICAgICAgICAgICAgICBuZXh0KCctJyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHsKICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDsKICAgICAgICAgICAgICAgIG5leHQoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoY2ggPT09ICcuJykgewogICAgICAgICAgICAgICAgc3RyaW5nICs9ICcuJzsKICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KCkgJiYgY2ggPj0gJzAnICYmIGNoIDw9ICc5JykgewogICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7CiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7CiAgICAgICAgICAgICAgICBuZXh0KCk7CiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7CiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoOwogICAgICAgICAgICAgICAgICAgIG5leHQoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7CiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoOwogICAgICAgICAgICAgICAgICAgIG5leHQoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBudW1iZXIgPSArc3RyaW5nOwogICAgICAgICAgICBpZiAoaXNOYU4obnVtYmVyKSkgewogICAgICAgICAgICAgICAgZXJyb3IoIkJhZCBudW1iZXIiKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7CiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBzdHJpbmcgPSBmdW5jdGlvbiAoKSB7CgogICAgICAgICAgICB2YXIgaGV4LAogICAgICAgICAgICAgICAgaSwKICAgICAgICAgICAgICAgIHN0cmluZyA9ICcnLAogICAgICAgICAgICAgICAgdWZmZmY7CgogICAgICAgICAgICBpZiAoY2ggPT09ICciJykgewogICAgICAgICAgICAgICAgd2hpbGUgKG5leHQoKSkgewogICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJyInKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZzsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFwnKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpICs9IDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZXggPSBwYXJzZUludChuZXh0KCksIDE2KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGhleCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gdWZmZmYgKiAxNiArIGhleDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVmZmZmKTsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXNjYXBlZVtjaF0gPT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gZXNjYXBlZVtjaF07CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gIlxuIiB8fCBjaCA9PSAiXHIiKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZXJyb3IoIkJhZCBzdHJpbmciKTsKICAgICAgICB9LAoKICAgICAgICB3aGl0ZSA9IGZ1bmN0aW9uICgpIHsKCiAgICAgICAgICAgIHdoaWxlIChjaCAmJiBjaCA8PSAnICcpIHsKICAgICAgICAgICAgICAgIG5leHQoKTsKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIHdvcmQgPSBmdW5jdGlvbiAoKSB7CgogICAgICAgICAgICBzd2l0Y2ggKGNoKSB7CiAgICAgICAgICAgIGNhc2UgJ3QnOgogICAgICAgICAgICAgICAgbmV4dCgndCcpOwogICAgICAgICAgICAgICAgbmV4dCgncicpOwogICAgICAgICAgICAgICAgbmV4dCgndScpOwogICAgICAgICAgICAgICAgbmV4dCgnZScpOwogICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIGNhc2UgJ2YnOgogICAgICAgICAgICAgICAgbmV4dCgnZicpOwogICAgICAgICAgICAgICAgbmV4dCgnYScpOwogICAgICAgICAgICAgICAgbmV4dCgnbCcpOwogICAgICAgICAgICAgICAgbmV4dCgncycpOwogICAgICAgICAgICAgICAgbmV4dCgnZScpOwogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICBjYXNlICduJzoKICAgICAgICAgICAgICAgIG5leHQoJ24nKTsKICAgICAgICAgICAgICAgIG5leHQoJ3UnKTsKICAgICAgICAgICAgICAgIG5leHQoJ2wnKTsKICAgICAgICAgICAgICAgIG5leHQoJ2wnKTsKICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVycm9yKCJVbmV4cGVjdGVkICciICsgY2ggKyAiJyIpOwogICAgICAgIH0sCgogICAgICAgIHZhbHVlLCAgLy8gUGxhY2UgaG9sZGVyIGZvciB0aGUgdmFsdWUgZnVuY3Rpb24uCgogICAgICAgIGFycmF5ID0gZnVuY3Rpb24gKCkgewoKICAgICAgICAgICAgdmFyIGFycmF5ID0gW107CgogICAgICAgICAgICBpZiAoY2ggPT09ICdbJykgewogICAgICAgICAgICAgICAgbmV4dCgnWycpOwogICAgICAgICAgICAgICAgd2hpdGUoKTsKICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7CiAgICAgICAgICAgICAgICAgICAgbmV4dCgnXScpOwogICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTsgICAvLyBlbXB0eSBhcnJheQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKGNoKSB7CiAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSgpKTsKICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpOwogICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoJ10nKTsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5OwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBuZXh0KCcsJyk7CiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBlcnJvcigiQmFkIGFycmF5Iik7CiAgICAgICAgfSwKCiAgICAgICAgb2JqZWN0ID0gZnVuY3Rpb24gKCkgewoKICAgICAgICAgICAgdmFyIGtleSwKICAgICAgICAgICAgICAgIG9iamVjdCA9IHt9OwoKICAgICAgICAgICAgaWYgKGNoID09PSAneycpIHsKICAgICAgICAgICAgICAgIG5leHQoJ3snKTsKICAgICAgICAgICAgICAgIHdoaXRlKCk7CiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd9JykgewogICAgICAgICAgICAgICAgICAgIG5leHQoJ30nKTsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0OyAgIC8vIGVtcHR5IG9iamVjdAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKGNoKSB7CiAgICAgICAgICAgICAgICAgICAga2V5ID0gc3RyaW5nKCk7CiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTsKICAgICAgICAgICAgICAgICAgICBuZXh0KCc6Jyk7CiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkgewogICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignRHVwbGljYXRlIGtleSAiJyArIGtleSArICciJyk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0gdmFsdWUoKTsKICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpOwogICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoJ30nKTsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgbmV4dCgnLCcpOwogICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZXJyb3IoIkJhZCBvYmplY3QiKTsKICAgICAgICB9OwoKICAgIHZhbHVlID0gZnVuY3Rpb24gKCkgewoKICAgICAgICB3aGl0ZSgpOwogICAgICAgIHN3aXRjaCAoY2gpIHsKICAgICAgICBjYXNlICd7JzoKICAgICAgICAgICAgcmV0dXJuIG9iamVjdCgpOwogICAgICAgIGNhc2UgJ1snOgogICAgICAgICAgICByZXR1cm4gYXJyYXkoKTsKICAgICAgICBjYXNlICciJzoKICAgICAgICAgICAgcmV0dXJuIHN0cmluZygpOwogICAgICAgIGNhc2UgJy0nOgogICAgICAgICAgICByZXR1cm4gbnVtYmVyKCk7CiAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgcmV0dXJuIGNoID49ICcwJyAmJiBjaCA8PSAnOScgPyBudW1iZXIoKSA6IHdvcmQoKTsKICAgICAgICB9CiAgICB9OwoKICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlLCByZXZpdmVyKSB7CiAgICAgICAgdmFyIHJlc3VsdDsKCiAgICAgICAgdGV4dCA9IHNvdXJjZTsKICAgICAgICBhdCA9IDA7CiAgICAgICAgY2ggPSAnICc7CiAgICAgICAgcmVzdWx0ID0gdmFsdWUoKTsKICAgICAgICB3aGl0ZSgpOwogICAgICAgIGlmIChjaCkgewogICAgICAgICAgICBlcnJvcigiU3ludGF4IGVycm9yIik7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbicgPyBmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7CiAgICAgICAgICAgIHZhciBrLCB2LCB2YWx1ZSA9IGhvbGRlcltrZXldOwogICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykgewogICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkgewogICAgICAgICAgICAgICAgICAgICAgICB2ID0gd2Fsayh2YWx1ZSwgayk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrXTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gcmV2aXZlci5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7CiAgICAgICAgfSh7Jyc6IHJlc3VsdH0sICcnKSA6IHJlc3VsdDsKICAgIH07Cn0pOwoKYWNlLmRlZmluZSgiYWNlL21vZGUvanNvbl93b3JrZXIiLFtdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHsKInVzZSBzdHJpY3QiOwoKdmFyIG9vcCA9IHJlcXVpcmUoIi4uL2xpYi9vb3AiKTsKdmFyIE1pcnJvciA9IHJlcXVpcmUoIi4uL3dvcmtlci9taXJyb3IiKS5NaXJyb3I7CnZhciBwYXJzZSA9IHJlcXVpcmUoIi4vanNvbi9qc29uX3BhcnNlIik7Cgp2YXIgSnNvbldvcmtlciA9IGV4cG9ydHMuSnNvbldvcmtlciA9IGZ1bmN0aW9uKHNlbmRlcikgewogICAgTWlycm9yLmNhbGwodGhpcywgc2VuZGVyKTsKICAgIHRoaXMuc2V0VGltZW91dCgyMDApOwp9OwoKb29wLmluaGVyaXRzKEpzb25Xb3JrZXIsIE1pcnJvcik7CgooZnVuY3Rpb24oKSB7CgogICAgdGhpcy5vblVwZGF0ZSA9IGZ1bmN0aW9uKCkgewogICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZG9jLmdldFZhbHVlKCk7CiAgICAgICAgdmFyIGVycm9ycyA9IFtdOwogICAgICAgIHRyeSB7CiAgICAgICAgICAgIGlmICh2YWx1ZSkKICAgICAgICAgICAgICAgIHBhcnNlKHZhbHVlKTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmRvYy5pbmRleFRvUG9zaXRpb24oZS5hdC0xKTsKICAgICAgICAgICAgZXJyb3JzLnB1c2goewogICAgICAgICAgICAgICAgcm93OiBwb3Mucm93LAogICAgICAgICAgICAgICAgY29sdW1uOiBwb3MuY29sdW1uLAogICAgICAgICAgICAgICAgdGV4dDogZS5tZXNzYWdlLAogICAgICAgICAgICAgICAgdHlwZTogImVycm9yIgogICAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgdGhpcy5zZW5kZXIuZW1pdCgiYW5ub3RhdGUiLCBlcnJvcnMpOwogICAgfTsKCn0pLmNhbGwoSnNvbldvcmtlci5wcm90b3R5cGUpOwoKfSk7Cg==';

    ace_1.config.setModuleUrl('ace/mode/json_worker', jsonWorkerDataUrl);

    const faJSONEditorExpand = {
      prefix: 'fas',
      iconName: 'jsoneditor-expand',
      icon: [512, 512, [], null,
        'M 0,448 V 512 h 512 v -64 z ' +
        'M 0,0 V 64 H 512 V 0 Z ' +
        'M 256,96 128,224 h 256 z ' +
        'M 256,416 384,288 H 128 Z'
      ]
    };

    const faJSONEditorCollapse = {
      prefix: 'fas',
      iconName: 'jsoneditor-collapse',
      icon: [512, 512, [], null,
        'm 0,224 v 64 h 512 v -64 z ' +
        'M 256,192 384,64 H 128 Z ' +
        'M 256,320 128,448 h 256 z'
      ]
    };

    const faJSONEditorFormat = {
      prefix: 'fas',
      iconName: 'jsoneditor-format',
      icon: [512, 512, [], null,
        'M 0,32 v 64 h 416 v -64 z ' +
        'M 160,160 v 64 h 352 v -64 z ' +
        'M 160,288 v 64 h 288 v -64 z ' +
        'M 0,416 v 64 h 320 v -64 z'
      ]
    };

    const faJSONEditorCompact = {
      prefix: 'fas',
      iconName: 'jsoneditor-compact',
      icon: [512, 512, [], null,
        'M 0,32 v 64 h 512 v -64 z ' +
        'M 0,160 v 64 h 512 v -64 z ' +
        'M 0,288 v 64 h 352 v -64 z'
      ]
    };

    /* node_modules\svelte-jsoneditor\src\components\modes\codemode\menu\CodeMenu.svelte generated by Svelte v3.38.2 */
    const file$h = "node_modules\\svelte-jsoneditor\\src\\components\\modes\\codemode\\menu\\CodeMenu.svelte";

    // (88:2) 
    function create_right_slot$1(ctx) {
    	let div;
    	let a;

    	const block = {
    		c: function create() {
    			div = element("div");
    			a = element("a");
    			a.textContent = "powered by ace";
    			attr_dev(a, "href", "https://ace.c9.io/");
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noopener noreferrer");
    			attr_dev(a, "title", "Code mode is powered by Ace editor");
    			attr_dev(a, "class", "svelte-1frror0");
    			add_location(a, file$h, 88, 4, 1978);
    			attr_dev(div, "slot", "right");
    			attr_dev(div, "class", "powered-by svelte-1frror0");
    			add_location(div, file$h, 87, 2, 1936);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, a);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_right_slot$1.name,
    		type: "slot",
    		source: "(88:2) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let menu;
    	let current;

    	menu = new Menu({
    			props: {
    				items: /*items*/ ctx[0],
    				$$slots: { right: [create_right_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const menu_changes = {};
    			if (dirty & /*items*/ 1) menu_changes.items = /*items*/ ctx[0];

    			if (dirty & /*$$scope*/ 65536) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let defaultItems;
    	let items;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CodeMenu", slots, []);
    	let { readOnly = false } = $$props;
    	let { onFormat } = $$props;
    	let { onCompact } = $$props;
    	let { onSort } = $$props;
    	let { onTransform } = $$props;
    	let { onUndo } = $$props;
    	let { onRedo } = $$props;
    	let { canUndo } = $$props;
    	let { canRedo } = $$props;
    	let { canFormat } = $$props;
    	let { canCompact } = $$props;
    	let { canSort } = $$props;
    	let { canTransform } = $$props;

    	let { onRenderMenu = () => {
    		
    	} } = $$props;

    	const writable_props = [
    		"readOnly",
    		"onFormat",
    		"onCompact",
    		"onSort",
    		"onTransform",
    		"onUndo",
    		"onRedo",
    		"canUndo",
    		"canRedo",
    		"canFormat",
    		"canCompact",
    		"canSort",
    		"canTransform",
    		"onRenderMenu"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CodeMenu> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("readOnly" in $$props) $$invalidate(1, readOnly = $$props.readOnly);
    		if ("onFormat" in $$props) $$invalidate(2, onFormat = $$props.onFormat);
    		if ("onCompact" in $$props) $$invalidate(3, onCompact = $$props.onCompact);
    		if ("onSort" in $$props) $$invalidate(4, onSort = $$props.onSort);
    		if ("onTransform" in $$props) $$invalidate(5, onTransform = $$props.onTransform);
    		if ("onUndo" in $$props) $$invalidate(6, onUndo = $$props.onUndo);
    		if ("onRedo" in $$props) $$invalidate(7, onRedo = $$props.onRedo);
    		if ("canUndo" in $$props) $$invalidate(8, canUndo = $$props.canUndo);
    		if ("canRedo" in $$props) $$invalidate(9, canRedo = $$props.canRedo);
    		if ("canFormat" in $$props) $$invalidate(10, canFormat = $$props.canFormat);
    		if ("canCompact" in $$props) $$invalidate(11, canCompact = $$props.canCompact);
    		if ("canSort" in $$props) $$invalidate(12, canSort = $$props.canSort);
    		if ("canTransform" in $$props) $$invalidate(13, canTransform = $$props.canTransform);
    		if ("onRenderMenu" in $$props) $$invalidate(14, onRenderMenu = $$props.onRenderMenu);
    	};

    	$$self.$capture_state = () => ({
    		faFilter,
    		faRedo,
    		faSortAmountDownAlt,
    		faUndo,
    		faJSONEditorCompact,
    		faJSONEditorFormat,
    		Menu,
    		readOnly,
    		onFormat,
    		onCompact,
    		onSort,
    		onTransform,
    		onUndo,
    		onRedo,
    		canUndo,
    		canRedo,
    		canFormat,
    		canCompact,
    		canSort,
    		canTransform,
    		onRenderMenu,
    		defaultItems,
    		items
    	});

    	$$self.$inject_state = $$props => {
    		if ("readOnly" in $$props) $$invalidate(1, readOnly = $$props.readOnly);
    		if ("onFormat" in $$props) $$invalidate(2, onFormat = $$props.onFormat);
    		if ("onCompact" in $$props) $$invalidate(3, onCompact = $$props.onCompact);
    		if ("onSort" in $$props) $$invalidate(4, onSort = $$props.onSort);
    		if ("onTransform" in $$props) $$invalidate(5, onTransform = $$props.onTransform);
    		if ("onUndo" in $$props) $$invalidate(6, onUndo = $$props.onUndo);
    		if ("onRedo" in $$props) $$invalidate(7, onRedo = $$props.onRedo);
    		if ("canUndo" in $$props) $$invalidate(8, canUndo = $$props.canUndo);
    		if ("canRedo" in $$props) $$invalidate(9, canRedo = $$props.canRedo);
    		if ("canFormat" in $$props) $$invalidate(10, canFormat = $$props.canFormat);
    		if ("canCompact" in $$props) $$invalidate(11, canCompact = $$props.canCompact);
    		if ("canSort" in $$props) $$invalidate(12, canSort = $$props.canSort);
    		if ("canTransform" in $$props) $$invalidate(13, canTransform = $$props.canTransform);
    		if ("onRenderMenu" in $$props) $$invalidate(14, onRenderMenu = $$props.onRenderMenu);
    		if ("defaultItems" in $$props) $$invalidate(15, defaultItems = $$props.defaultItems);
    		if ("items" in $$props) $$invalidate(0, items = $$props.items);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*onFormat, readOnly, canFormat, onCompact, canCompact, onSort, canSort, onTransform, canTransform, onUndo, canUndo, onRedo, canRedo*/ 16382) {
    			/* @type {MenuItem[]} */
    			$$invalidate(15, defaultItems = [
    				{
    					icon: faJSONEditorFormat,
    					title: "Format JSON: add proper indentation and new lines (Ctrl+I)",
    					className: "format",
    					onClick: onFormat,
    					disabled: readOnly || !canFormat
    				},
    				{
    					icon: faJSONEditorCompact,
    					title: "Compact JSON: remove all white spacing and new lines (Ctrl+Shift+I)",
    					className: "compact",
    					onClick: onCompact,
    					disabled: readOnly || !canCompact
    				},
    				{ separator: true },
    				{
    					icon: faSortAmountDownAlt,
    					title: "Sort",
    					className: "sort",
    					onClick: onSort,
    					disabled: readOnly || !canSort
    				},
    				{
    					icon: faFilter,
    					title: "Transform contents (filter, sort, project)",
    					className: "transform",
    					onClick: onTransform,
    					disabled: readOnly || !canTransform
    				},
    				{ separator: true },
    				{
    					icon: faUndo,
    					title: "Undo (Ctrl+Z)",
    					className: "undo",
    					onClick: onUndo,
    					disabled: !canUndo
    				},
    				{
    					icon: faRedo,
    					title: "Redo (Ctrl+Shift+Z)",
    					className: "redo",
    					onClick: onRedo,
    					disabled: !canRedo
    				},
    				{ space: true }
    			]);
    		}

    		if ($$self.$$.dirty & /*onRenderMenu, defaultItems*/ 49152) {
    			$$invalidate(0, items = onRenderMenu("code", defaultItems) || defaultItems);
    		}
    	};

    	return [
    		items,
    		readOnly,
    		onFormat,
    		onCompact,
    		onSort,
    		onTransform,
    		onUndo,
    		onRedo,
    		canUndo,
    		canRedo,
    		canFormat,
    		canCompact,
    		canSort,
    		canTransform,
    		onRenderMenu,
    		defaultItems
    	];
    }

    class CodeMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
    			readOnly: 1,
    			onFormat: 2,
    			onCompact: 3,
    			onSort: 4,
    			onTransform: 5,
    			onUndo: 6,
    			onRedo: 7,
    			canUndo: 8,
    			canRedo: 9,
    			canFormat: 10,
    			canCompact: 11,
    			canSort: 12,
    			canTransform: 13,
    			onRenderMenu: 14
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CodeMenu",
    			options,
    			id: create_fragment$j.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*onFormat*/ ctx[2] === undefined && !("onFormat" in props)) {
    			console.warn("<CodeMenu> was created without expected prop 'onFormat'");
    		}

    		if (/*onCompact*/ ctx[3] === undefined && !("onCompact" in props)) {
    			console.warn("<CodeMenu> was created without expected prop 'onCompact'");
    		}

    		if (/*onSort*/ ctx[4] === undefined && !("onSort" in props)) {
    			console.warn("<CodeMenu> was created without expected prop 'onSort'");
    		}

    		if (/*onTransform*/ ctx[5] === undefined && !("onTransform" in props)) {
    			console.warn("<CodeMenu> was created without expected prop 'onTransform'");
    		}

    		if (/*onUndo*/ ctx[6] === undefined && !("onUndo" in props)) {
    			console.warn("<CodeMenu> was created without expected prop 'onUndo'");
    		}

    		if (/*onRedo*/ ctx[7] === undefined && !("onRedo" in props)) {
    			console.warn("<CodeMenu> was created without expected prop 'onRedo'");
    		}

    		if (/*canUndo*/ ctx[8] === undefined && !("canUndo" in props)) {
    			console.warn("<CodeMenu> was created without expected prop 'canUndo'");
    		}

    		if (/*canRedo*/ ctx[9] === undefined && !("canRedo" in props)) {
    			console.warn("<CodeMenu> was created without expected prop 'canRedo'");
    		}

    		if (/*canFormat*/ ctx[10] === undefined && !("canFormat" in props)) {
    			console.warn("<CodeMenu> was created without expected prop 'canFormat'");
    		}

    		if (/*canCompact*/ ctx[11] === undefined && !("canCompact" in props)) {
    			console.warn("<CodeMenu> was created without expected prop 'canCompact'");
    		}

    		if (/*canSort*/ ctx[12] === undefined && !("canSort" in props)) {
    			console.warn("<CodeMenu> was created without expected prop 'canSort'");
    		}

    		if (/*canTransform*/ ctx[13] === undefined && !("canTransform" in props)) {
    			console.warn("<CodeMenu> was created without expected prop 'canTransform'");
    		}
    	}

    	get readOnly() {
    		throw new Error("<CodeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readOnly(value) {
    		throw new Error("<CodeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onFormat() {
    		throw new Error("<CodeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onFormat(value) {
    		throw new Error("<CodeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onCompact() {
    		throw new Error("<CodeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onCompact(value) {
    		throw new Error("<CodeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSort() {
    		throw new Error("<CodeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSort(value) {
    		throw new Error("<CodeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onTransform() {
    		throw new Error("<CodeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onTransform(value) {
    		throw new Error("<CodeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onUndo() {
    		throw new Error("<CodeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onUndo(value) {
    		throw new Error("<CodeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onRedo() {
    		throw new Error("<CodeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onRedo(value) {
    		throw new Error("<CodeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get canUndo() {
    		throw new Error("<CodeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set canUndo(value) {
    		throw new Error("<CodeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get canRedo() {
    		throw new Error("<CodeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set canRedo(value) {
    		throw new Error("<CodeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get canFormat() {
    		throw new Error("<CodeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set canFormat(value) {
    		throw new Error("<CodeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get canCompact() {
    		throw new Error("<CodeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set canCompact(value) {
    		throw new Error("<CodeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get canSort() {
    		throw new Error("<CodeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set canSort(value) {
    		throw new Error("<CodeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get canTransform() {
    		throw new Error("<CodeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set canTransform(value) {
    		throw new Error("<CodeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onRenderMenu() {
    		throw new Error("<CodeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onRenderMenu(value) {
    		throw new Error("<CodeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\modes\codemode\CodeMode.svelte generated by Svelte v3.38.2 */
    const file$g = "node_modules\\svelte-jsoneditor\\src\\components\\modes\\codemode\\CodeMode.svelte";

    // (504:2) {#if mainMenuBar}
    function create_if_block_2$2(ctx) {
    	let codemenu;
    	let current;

    	codemenu = new CodeMenu({
    			props: {
    				readOnly: /*readOnly*/ ctx[1],
    				onFormat: /*handleFormat*/ ctx[14],
    				onCompact: /*handleCompact*/ ctx[15],
    				onSort: /*handleSort*/ ctx[16],
    				onTransform: /*handleTransform*/ ctx[17],
    				onUndo: /*handleUndo*/ ctx[18],
    				onRedo: /*handleRedo*/ ctx[19],
    				canFormat: !/*isNewDocument*/ ctx[11],
    				canCompact: !/*isNewDocument*/ ctx[11],
    				canSort: !/*isNewDocument*/ ctx[11],
    				canTransform: !/*isNewDocument*/ ctx[11],
    				canUndo: /*canUndo*/ ctx[8],
    				canRedo: /*canRedo*/ ctx[9],
    				onRenderMenu: /*onRenderMenu*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(codemenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(codemenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const codemenu_changes = {};
    			if (dirty[0] & /*readOnly*/ 2) codemenu_changes.readOnly = /*readOnly*/ ctx[1];
    			if (dirty[0] & /*isNewDocument*/ 2048) codemenu_changes.canFormat = !/*isNewDocument*/ ctx[11];
    			if (dirty[0] & /*isNewDocument*/ 2048) codemenu_changes.canCompact = !/*isNewDocument*/ ctx[11];
    			if (dirty[0] & /*isNewDocument*/ 2048) codemenu_changes.canSort = !/*isNewDocument*/ ctx[11];
    			if (dirty[0] & /*isNewDocument*/ 2048) codemenu_changes.canTransform = !/*isNewDocument*/ ctx[11];
    			if (dirty[0] & /*canUndo*/ 256) codemenu_changes.canUndo = /*canUndo*/ ctx[8];
    			if (dirty[0] & /*canRedo*/ 512) codemenu_changes.canRedo = /*canRedo*/ ctx[9];
    			if (dirty[0] & /*onRenderMenu*/ 16) codemenu_changes.onRenderMenu = /*onRenderMenu*/ ctx[4];
    			codemenu.$set(codemenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(codemenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(codemenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(codemenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(504:2) {#if mainMenuBar}",
    		ctx
    	});

    	return block;
    }

    // (522:2) {#if aceEditorDisabled}
    function create_if_block_1$4(ctx) {
    	let message;
    	let current;

    	message = new Message({
    			props: {
    				icon: faExclamationTriangle,
    				type: "error",
    				message: `The JSON document is larger than ${formatSize(MAX_DOCUMENT_SIZE_CODE_MODE, 1024)}, ` + `and may crash your browser when loading it in code mode. Actual size: ${formatSize(/*text*/ ctx[0].length, 1024)}.`,
    				actions: [
    					{
    						text: "Open anyway",
    						title: "Open the document in code mode",
    						onClick: /*handleAcceptTooLarge*/ ctx[21]
    					},
    					{
    						text: "Open in tree mode",
    						title: "Open the document in tree mode",
    						onClick: /*onSwitchToTreeMode*/ ctx[3]
    					}
    				]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(message.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(message, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const message_changes = {};
    			if (dirty[0] & /*text*/ 1) message_changes.message = `The JSON document is larger than ${formatSize(MAX_DOCUMENT_SIZE_CODE_MODE, 1024)}, ` + `and may crash your browser when loading it in code mode. Actual size: ${formatSize(/*text*/ ctx[0].length, 1024)}.`;

    			if (dirty[0] & /*onSwitchToTreeMode*/ 8) message_changes.actions = [
    				{
    					text: "Open anyway",
    					title: "Open the document in code mode",
    					onClick: /*handleAcceptTooLarge*/ ctx[21]
    				},
    				{
    					text: "Open in tree mode",
    					title: "Open the document in tree mode",
    					onClick: /*onSwitchToTreeMode*/ ctx[3]
    				}
    			];

    			message.$set(message_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(message.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(message.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(message, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(522:2) {#if aceEditorDisabled}",
    		ctx
    	});

    	return block;
    }

    // (547:2) {#if jsonParseError}
    function create_if_block$8(ctx) {
    	let message;
    	let current;

    	message = new Message({
    			props: {
    				type: "error",
    				icon: faExclamationTriangle,
    				message: /*jsonParseError*/ ctx[10],
    				actions: /*repairActions*/ ctx[13]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(message.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(message, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const message_changes = {};
    			if (dirty[0] & /*jsonParseError*/ 1024) message_changes.message = /*jsonParseError*/ ctx[10];
    			if (dirty[0] & /*repairActions*/ 8192) message_changes.actions = /*repairActions*/ ctx[13];
    			message.$set(message_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(message.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(message.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(message, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(547:2) {#if jsonParseError}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let div1;
    	let t0;
    	let t1;
    	let div0;
    	let t2;
    	let t3;
    	let validationerrorsoverview;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*mainMenuBar*/ ctx[2] && create_if_block_2$2(ctx);
    	let if_block1 = /*aceEditorDisabled*/ ctx[12] && create_if_block_1$4(ctx);
    	let if_block2 = /*jsonParseError*/ ctx[10] && create_if_block$8(ctx);

    	validationerrorsoverview = new ValidationErrorsOverview({
    			props: {
    				validationErrorsList: /*validationErrorsList*/ ctx[7],
    				selectError: /*handleSelectValidationError*/ ctx[22]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			div0 = element("div");
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			create_component(validationerrorsoverview.$$.fragment);
    			attr_dev(div0, "class", "contents svelte-1eajo9u");
    			toggle_class(div0, "visible", !/*aceEditorDisabled*/ ctx[12]);
    			add_location(div0, file$g, 544, 2, 13841);
    			attr_dev(div1, "class", "code-mode svelte-1eajo9u");
    			add_location(div1, file$g, 498, 0, 12610);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t0);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			/*div0_binding*/ ctx[35](div0);
    			append_dev(div1, t2);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div1, t3);
    			mount_component(validationerrorsoverview, div1, null);
    			/*div1_binding*/ ctx[36](div1);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div1, "keydown", /*handleKeyDown*/ ctx[20], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*mainMenuBar*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*mainMenuBar*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*aceEditorDisabled*/ ctx[12]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*aceEditorDisabled*/ 4096) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*aceEditorDisabled*/ 4096) {
    				toggle_class(div0, "visible", !/*aceEditorDisabled*/ ctx[12]);
    			}

    			if (/*jsonParseError*/ ctx[10]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*jsonParseError*/ 1024) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$8(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div1, t3);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			const validationerrorsoverview_changes = {};
    			if (dirty[0] & /*validationErrorsList*/ 128) validationerrorsoverview_changes.validationErrorsList = /*validationErrorsList*/ ctx[7];
    			validationerrorsoverview.$set(validationerrorsoverview_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(validationerrorsoverview.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(validationerrorsoverview.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			/*div0_binding*/ ctx[35](null);
    			if (if_block2) if_block2.d();
    			destroy_component(validationerrorsoverview);
    			/*div1_binding*/ ctx[36](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let isNewDocument;
    	let tooLarge;
    	let aceEditorDisabled;
    	let repairActions;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CodeMode", slots, []);
    	let { readOnly = false } = $$props;
    	let { mainMenuBar = true } = $$props;
    	let { text = "" } = $$props;
    	let { indentation = 2 } = $$props; // TODO: make indentation configurable
    	let { aceTheme = "ace/theme/jsoneditor" } = $$props; // TODO: make aceTheme configurable
    	let { validator = null } = $$props;
    	let { onChange = null } = $$props;

    	let { onSwitchToTreeMode = () => {
    		
    	} } = $$props;

    	let { onError } = $$props;

    	let { onFocus = () => {
    		
    	} } = $$props;

    	let { onBlur = () => {
    		
    	} } = $$props;

    	let { onRenderMenu = () => {
    		
    	} } = $$props;

    	const debug = browser("jsoneditor:CodeMode");
    	let aceEditorRef;
    	let aceEditor;
    	let aceEditorText;
    	let domCodeMode;
    	let onChangeDisabled = false;
    	let acceptTooLarge = false;
    	let validationErrorsList = [];

    	onMount(() => {
    		aceEditor = createAceEditor({
    			target: aceEditorRef,
    			ace: ace_1,
    			readOnly,
    			indentation,
    			onChange: onChangeAceEditorValue
    		});

    		if (resizeObserver) {
    			resizeObserver.observe(aceEditorRef);
    		} else {
    			debug("WARNING: ResizeObserver is undefined. Code editor will not automatically be resized");
    		}

    		// load initial text
    		setAceEditorValue(text);

    		aceEditor.session.getUndoManager().reset();
    	});

    	onDestroy(() => {
    		checkValidJsonDebounced.cancel();
    		updateCancelUndoRedoDebounced.cancel();

    		if (resizeObserver) {
    			resizeObserver.unobserve(aceEditorRef);
    			resizeObserver = null;
    		}

    		debug("Destroy Ace editor");
    		aceEditor.destroy();
    		aceEditor = null;
    	});

    	let canUndo = false;
    	let canRedo = false;

    	let resizeObserver = window.ResizeObserver
    	? new window.ResizeObserver(resize)
    	: null;

    	const { open } = getContext("simple-modal");
    	const sortModalId = uniqueId$1();
    	const transformModalId = uniqueId$1();

    	function focus() {
    		aceEditor.focus();
    	}

    	createFocusTracker({
    		onMount,
    		onDestroy,
    		getWindow: () => getWindow(domCodeMode),
    		hasFocus: () => activeElementIsChildOf(domCodeMode),
    		onFocus,
    		onBlur
    	});

    	function patch(operations) {
    		debug("patch", operations);
    		const oldText = text;
    		const json = JSON.parse(text);
    		const updatedJson = immutableJSONPatch.immutableJSONPatch(json, operations);
    		const undo = immutableJSONPatch.revertJSONPatch(json, operations);
    		$$invalidate(0, text = JSON.stringify(updatedJson, null, indentation));

    		if (text !== oldText) {
    			emitOnChange();
    		}

    		return { json, undo, redo: operations };
    	}

    	function resize() {
    		const force = false;
    		aceEditor.resize(force);
    	}

    	function handleFormat() {
    		debug("format");

    		try {
    			const oldText = text;
    			const json = JSON.parse(text);
    			$$invalidate(0, text = JSON.stringify(json, null, indentation));

    			if (text !== oldText) {
    				emitOnChange();
    			}
    		} catch(err) {
    			onError(err);
    		}
    	}

    	function handleCompact() {
    		debug("compact");

    		try {
    			const oldText = text;
    			const json = JSON.parse(text);
    			$$invalidate(0, text = JSON.stringify(json));

    			if (text !== oldText) {
    				emitOnChange();
    			}
    		} catch(err) {
    			onError(err);
    		}
    	}

    	function handleRepair() {
    		debug("repair");

    		try {
    			const oldText = text;
    			$$invalidate(0, text = jsonrepair_min(text));
    			$$invalidate(33, jsonStatus = JSON_STATUS_VALID);
    			$$invalidate(10, jsonParseError = undefined);

    			if (text !== oldText) {
    				emitOnChange();
    			}
    		} catch(err) {
    			onError(err);
    		}
    	}

    	function handleSort() {
    		if (readOnly) {
    			return;
    		}

    		try {
    			const json = JSON.parse(text);

    			open(
    				SortModal,
    				{
    					id: sortModalId,
    					json,
    					selectedPath: [],
    					onSort: async operations => {
    						debug("onSort", operations);
    						patch(operations);
    					}
    				},
    				SORT_MODAL_OPTIONS,
    				{ onClose: focus }
    			);
    		} catch(err) {
    			onError(err);
    		}
    	}

    	function handleTransform() {
    		if (readOnly) {
    			return;
    		}

    		try {
    			const json = JSON.parse(text);

    			open(
    				TransformModal,
    				{
    					id: transformModalId,
    					json,
    					selectedPath: [],
    					indentation,
    					onTransform: async operations => {
    						debug("onTransform", operations);
    						patch(operations);
    					}
    				},
    				TRANSFORM_MODAL_OPTIONS,
    				{ onClose: focus }
    			);
    		} catch(err) {
    			onError(err);
    		}
    	}

    	function handleUndo() {
    		aceEditor.getSession().getUndoManager().undo(false);
    	}

    	function handleRedo() {
    		aceEditor.getSession().getUndoManager().redo(false);
    	}

    	function handleKeyDown(event) {
    		// get key combo, and normalize key combo from Mac: replace "Command+X" with "Ctrl+X" etc
    		const combo = keyComboFromEvent(event).replace(/^Command\+/, "Ctrl+");

    		debug("keydown", combo);

    		if (combo === "Ctrl+I" || combo === "Ctrl+\\") {
    			event.preventDefault(); // for backward compatibility
    			event.stopPropagation();
    			handleFormat();
    		}

    		if (combo === "Ctrl+Shift+I" || combo === "Ctrl+Shift+\\") {
    			event.preventDefault(); // for backward compatibility
    			event.stopPropagation();
    			handleCompact();
    		}
    	}

    	function handleAcceptTooLarge() {
    		$$invalidate(32, acceptTooLarge = true);
    		setAceEditorValue(text, true);
    	}

    	/**
     * @param {ValidationError} error
     **/
    	function handleSelectValidationError(error) {
    		debug("select validation error", error);
    		const annotation = validationErrorToAnnotation(error);

    		const location = {
    			row: annotation.row,
    			column: annotation.column
    		};

    		setSelection(location, location);
    		focus();
    	}

    	/**
     * @param {Point} start
     * @param {Point} end
     **/
    	function setSelection(start, end) {
    		aceEditor.selection.setRange({ start, end });
    		aceEditor.scrollToLine(start.row, true);
    	}

    	function createAceEditor({ target, ace, readOnly, indentation, onChange }) {
    		debug("create Ace editor");
    		const aceEditor = ace.edit(target);
    		const aceSession = aceEditor.getSession();
    		aceEditor.$blockScrolling = Infinity;
    		aceEditor.setTheme(aceTheme);
    		aceEditor.setOptions({ readOnly });
    		aceEditor.setShowPrintMargin(false);
    		aceEditor.setFontSize("14px"); // must correspond with CSS $font-size-mono
    		aceSession.setMode("ace/mode/json");
    		aceSession.setTabSize(indentation);
    		aceSession.setUseSoftTabs(true);
    		aceSession.setUseWrapMode(true);

    		// disable Ctrl+L quickkey of Ace (is used by the browser to select the address bar)
    		aceEditor.commands.bindKey("Ctrl-L", null);

    		aceEditor.commands.bindKey("Command-L", null);

    		// disable the quickkeys we want to use for Format and Compact
    		aceEditor.commands.bindKey("Ctrl-\\", null);

    		aceEditor.commands.bindKey("Command-\\", null);
    		aceEditor.commands.bindKey("Ctrl-Shift-\\", null);
    		aceEditor.commands.bindKey("Command-Shift-\\", null);

    		// replace ace setAnnotations with custom function that also covers jsoneditor annotations
    		const originalSetAnnotations = aceSession.setAnnotations;

    		aceSession.setAnnotations = function (annotations) {
    			const newAnnotations = annotations && annotations.length
    			? annotations
    			: validationErrorsList.map(validationErrorToAnnotation);

    			debug("setAnnotations", { annotations, newAnnotations });
    			originalSetAnnotations.call(this, newAnnotations);
    		};

    		// register onchange event
    		aceEditor.on("change", onChange);

    		return aceEditor;
    	}

    	function validationErrorToAnnotation(validationError) {
    		const location = findTextLocation(text, validationError.path);

    		return {
    			row: location ? location.row : 0,
    			column: location ? location.column : 0,
    			text: validationError.message,
    			type: "warning"
    		};
    	}

    	/**
     * refresh ERROR annotations state
     * error annotations are handled by the ace json mode (ace/mode/json)
     * validation annotations are handled by this mode
     * therefore in order to refresh we send only the annotations of error type in order to maintain its state
     * @private
     */
    	function refreshAnnotations() {
    		debug("refresh annotations");
    		const session = aceEditor && aceEditor.getSession();

    		if (session) {
    			const errorAnnotations = session.getAnnotations().filter(annotation => annotation.type === "error");
    			session.setAnnotations(errorAnnotations);
    		}
    	}

    	function setAceEditorValue(text, force = false) {
    		if (aceEditorDisabled && !force) {
    			debug("not applying text: editor is disabled");
    			return;
    		}

    		onChangeDisabled = true;

    		if (aceEditor && text !== aceEditorText) {
    			aceEditorText = text;
    			aceEditor.setValue(text, -1);
    			updateCancelUndoRedoDebounced();
    		}

    		onChangeDisabled = false;
    	}

    	function onChangeAceEditorValue() {
    		if (onChangeDisabled) {
    			return;
    		}

    		aceEditorText = aceEditor.getValue();

    		if (text !== aceEditorText) {
    			$$invalidate(0, text = aceEditorText);
    			updateCancelUndoRedoDebounced();
    			emitOnChange();
    		}
    	}

    	function updateIndentation(indentation) {
    		if (aceEditor) {
    			aceEditor.getSession().setTabSize(indentation);
    		}
    	}

    	function updateCanUndoRedo() {
    		const undoManager = aceEditor.getSession().getUndoManager();

    		if (undoManager && undoManager.hasUndo && undoManager.hasRedo) {
    			$$invalidate(8, canUndo = undoManager.hasUndo());
    			$$invalidate(9, canRedo = undoManager.hasRedo());
    		}
    	}

    	const updateCancelUndoRedoDebounced = debounce$1(updateCanUndoRedo, 0); // just on next tick

    	function emitOnChange() {
    		if (onChange) {
    			onChange(text);
    		}
    	}

    	let jsonStatus = JSON_STATUS_VALID;
    	let jsonParseError;

    	function checkValidJson() {
    		$$invalidate(33, jsonStatus = JSON_STATUS_VALID);
    		$$invalidate(10, jsonParseError = undefined);
    		$$invalidate(7, validationErrorsList = []);

    		// FIXME: utilize the parse errors coming from AceEditor worker, only try to repair then
    		if (text.length > MAX_AUTO_REPAIRABLE_SIZE) {
    			debug("checkValidJson: not validating, document too large");
    			return;
    		}

    		if (isNewDocument) {
    			// new, empty document, do not try to parse
    			return;
    		}

    		try {
    			// FIXME: instead of parsing the JSON here (which is expensive),
    			//  get the parse error from the Ace Editor worker instead
    			const json = JSON.parse(text);

    			if (validator) {
    				$$invalidate(7, validationErrorsList = validator(json));
    			}

    			refreshAnnotations();
    		} catch(err) {
    			$$invalidate(10, jsonParseError = err.toString());

    			try {
    				JSON.parse(jsonrepair_min(text));
    				$$invalidate(33, jsonStatus = JSON_STATUS_REPAIRABLE);
    			} catch(err) {
    				$$invalidate(33, jsonStatus = JSON_STATUS_INVALID);
    			}
    		}

    		debug("checked json status", jsonStatus);
    	}

    	const checkValidJsonDebounced = debounce$1(checkValidJson, CHECK_VALID_JSON_DELAY);

    	const writable_props = [
    		"readOnly",
    		"mainMenuBar",
    		"text",
    		"indentation",
    		"aceTheme",
    		"validator",
    		"onChange",
    		"onSwitchToTreeMode",
    		"onError",
    		"onFocus",
    		"onBlur",
    		"onRenderMenu"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CodeMode> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			aceEditorRef = $$value;
    			$$invalidate(5, aceEditorRef);
    		});
    	}

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			domCodeMode = $$value;
    			$$invalidate(6, domCodeMode);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("readOnly" in $$props) $$invalidate(1, readOnly = $$props.readOnly);
    		if ("mainMenuBar" in $$props) $$invalidate(2, mainMenuBar = $$props.mainMenuBar);
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("indentation" in $$props) $$invalidate(23, indentation = $$props.indentation);
    		if ("aceTheme" in $$props) $$invalidate(24, aceTheme = $$props.aceTheme);
    		if ("validator" in $$props) $$invalidate(25, validator = $$props.validator);
    		if ("onChange" in $$props) $$invalidate(26, onChange = $$props.onChange);
    		if ("onSwitchToTreeMode" in $$props) $$invalidate(3, onSwitchToTreeMode = $$props.onSwitchToTreeMode);
    		if ("onError" in $$props) $$invalidate(27, onError = $$props.onError);
    		if ("onFocus" in $$props) $$invalidate(28, onFocus = $$props.onFocus);
    		if ("onBlur" in $$props) $$invalidate(29, onBlur = $$props.onBlur);
    		if ("onRenderMenu" in $$props) $$invalidate(4, onRenderMenu = $$props.onRenderMenu);
    	};

    	$$self.$capture_state = () => ({
    		faExclamationTriangle,
    		faWrench,
    		createDebug: browser,
    		immutableJSONPatch: immutableJSONPatch.immutableJSONPatch,
    		revertJSONPatch: immutableJSONPatch.revertJSONPatch,
    		jsonrepair: jsonrepair_min,
    		debounce: debounce$1,
    		uniqueId: uniqueId$1,
    		getContext,
    		onDestroy,
    		onMount,
    		CHECK_VALID_JSON_DELAY,
    		JSON_STATUS_INVALID,
    		JSON_STATUS_REPAIRABLE,
    		JSON_STATUS_VALID,
    		MAX_AUTO_REPAIRABLE_SIZE,
    		MAX_DOCUMENT_SIZE_CODE_MODE,
    		SORT_MODAL_OPTIONS,
    		TRANSFORM_MODAL_OPTIONS,
    		activeElementIsChildOf,
    		getWindow,
    		formatSize,
    		findTextLocation,
    		keyComboFromEvent,
    		createFocusTracker,
    		Message,
    		ValidationErrorsOverview,
    		SortModal,
    		TransformModal,
    		ace: ace_1,
    		CodeMenu,
    		readOnly,
    		mainMenuBar,
    		text,
    		indentation,
    		aceTheme,
    		validator,
    		onChange,
    		onSwitchToTreeMode,
    		onError,
    		onFocus,
    		onBlur,
    		onRenderMenu,
    		debug,
    		aceEditorRef,
    		aceEditor,
    		aceEditorText,
    		domCodeMode,
    		onChangeDisabled,
    		acceptTooLarge,
    		validationErrorsList,
    		canUndo,
    		canRedo,
    		resizeObserver,
    		open,
    		sortModalId,
    		transformModalId,
    		focus,
    		patch,
    		resize,
    		handleFormat,
    		handleCompact,
    		handleRepair,
    		handleSort,
    		handleTransform,
    		handleUndo,
    		handleRedo,
    		handleKeyDown,
    		handleAcceptTooLarge,
    		handleSelectValidationError,
    		setSelection,
    		createAceEditor,
    		validationErrorToAnnotation,
    		refreshAnnotations,
    		setAceEditorValue,
    		onChangeAceEditorValue,
    		updateIndentation,
    		updateCanUndoRedo,
    		updateCancelUndoRedoDebounced,
    		emitOnChange,
    		jsonStatus,
    		jsonParseError,
    		checkValidJson,
    		checkValidJsonDebounced,
    		isNewDocument,
    		tooLarge,
    		aceEditorDisabled,
    		repairActions
    	});

    	$$self.$inject_state = $$props => {
    		if ("readOnly" in $$props) $$invalidate(1, readOnly = $$props.readOnly);
    		if ("mainMenuBar" in $$props) $$invalidate(2, mainMenuBar = $$props.mainMenuBar);
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("indentation" in $$props) $$invalidate(23, indentation = $$props.indentation);
    		if ("aceTheme" in $$props) $$invalidate(24, aceTheme = $$props.aceTheme);
    		if ("validator" in $$props) $$invalidate(25, validator = $$props.validator);
    		if ("onChange" in $$props) $$invalidate(26, onChange = $$props.onChange);
    		if ("onSwitchToTreeMode" in $$props) $$invalidate(3, onSwitchToTreeMode = $$props.onSwitchToTreeMode);
    		if ("onError" in $$props) $$invalidate(27, onError = $$props.onError);
    		if ("onFocus" in $$props) $$invalidate(28, onFocus = $$props.onFocus);
    		if ("onBlur" in $$props) $$invalidate(29, onBlur = $$props.onBlur);
    		if ("onRenderMenu" in $$props) $$invalidate(4, onRenderMenu = $$props.onRenderMenu);
    		if ("aceEditorRef" in $$props) $$invalidate(5, aceEditorRef = $$props.aceEditorRef);
    		if ("aceEditor" in $$props) aceEditor = $$props.aceEditor;
    		if ("aceEditorText" in $$props) aceEditorText = $$props.aceEditorText;
    		if ("domCodeMode" in $$props) $$invalidate(6, domCodeMode = $$props.domCodeMode);
    		if ("onChangeDisabled" in $$props) onChangeDisabled = $$props.onChangeDisabled;
    		if ("acceptTooLarge" in $$props) $$invalidate(32, acceptTooLarge = $$props.acceptTooLarge);
    		if ("validationErrorsList" in $$props) $$invalidate(7, validationErrorsList = $$props.validationErrorsList);
    		if ("canUndo" in $$props) $$invalidate(8, canUndo = $$props.canUndo);
    		if ("canRedo" in $$props) $$invalidate(9, canRedo = $$props.canRedo);
    		if ("resizeObserver" in $$props) resizeObserver = $$props.resizeObserver;
    		if ("jsonStatus" in $$props) $$invalidate(33, jsonStatus = $$props.jsonStatus);
    		if ("jsonParseError" in $$props) $$invalidate(10, jsonParseError = $$props.jsonParseError);
    		if ("isNewDocument" in $$props) $$invalidate(11, isNewDocument = $$props.isNewDocument);
    		if ("tooLarge" in $$props) $$invalidate(34, tooLarge = $$props.tooLarge);
    		if ("aceEditorDisabled" in $$props) $$invalidate(12, aceEditorDisabled = $$props.aceEditorDisabled);
    		if ("repairActions" in $$props) $$invalidate(13, repairActions = $$props.repairActions);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*text*/ 1) {
    			$$invalidate(11, isNewDocument = text.length === 0);
    		}

    		if ($$self.$$.dirty[0] & /*text*/ 1) {
    			$$invalidate(34, tooLarge = text && text.length > MAX_DOCUMENT_SIZE_CODE_MODE);
    		}

    		if ($$self.$$.dirty[1] & /*tooLarge, acceptTooLarge*/ 10) {
    			$$invalidate(12, aceEditorDisabled = tooLarge && !acceptTooLarge);
    		}

    		if ($$self.$$.dirty[0] & /*text*/ 1) {
    			setAceEditorValue(text);
    		}

    		if ($$self.$$.dirty[0] & /*indentation*/ 8388608) {
    			updateIndentation(indentation);
    		}

    		if ($$self.$$.dirty[0] & /*text*/ 1) {
    			// we pass unused arguments to trigger calling checkValidJson when text or validator changes
    			// TODO: find a better solution
    			checkValidJsonDebounced(text);
    		}

    		if ($$self.$$.dirty[0] & /*validator*/ 33554432) {
    			checkValidJson();
    		}

    		if ($$self.$$.dirty[1] & /*jsonStatus*/ 4) {
    			$$invalidate(13, repairActions = jsonStatus === JSON_STATUS_REPAIRABLE
    			? [
    					{
    						icon: faWrench,
    						text: "Auto repair",
    						title: "Automatically repair JSON",
    						onClick: handleRepair
    					}
    				]
    			: []);
    		}
    	};

    	return [
    		text,
    		readOnly,
    		mainMenuBar,
    		onSwitchToTreeMode,
    		onRenderMenu,
    		aceEditorRef,
    		domCodeMode,
    		validationErrorsList,
    		canUndo,
    		canRedo,
    		jsonParseError,
    		isNewDocument,
    		aceEditorDisabled,
    		repairActions,
    		handleFormat,
    		handleCompact,
    		handleSort,
    		handleTransform,
    		handleUndo,
    		handleRedo,
    		handleKeyDown,
    		handleAcceptTooLarge,
    		handleSelectValidationError,
    		indentation,
    		aceTheme,
    		validator,
    		onChange,
    		onError,
    		onFocus,
    		onBlur,
    		focus,
    		patch,
    		acceptTooLarge,
    		jsonStatus,
    		tooLarge,
    		div0_binding,
    		div1_binding
    	];
    }

    class CodeMode extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$i,
    			create_fragment$i,
    			safe_not_equal,
    			{
    				readOnly: 1,
    				mainMenuBar: 2,
    				text: 0,
    				indentation: 23,
    				aceTheme: 24,
    				validator: 25,
    				onChange: 26,
    				onSwitchToTreeMode: 3,
    				onError: 27,
    				onFocus: 28,
    				onBlur: 29,
    				onRenderMenu: 4,
    				focus: 30,
    				patch: 31
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CodeMode",
    			options,
    			id: create_fragment$i.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*onError*/ ctx[27] === undefined && !("onError" in props)) {
    			console.warn("<CodeMode> was created without expected prop 'onError'");
    		}
    	}

    	get readOnly() {
    		throw new Error("<CodeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readOnly(value) {
    		throw new Error("<CodeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mainMenuBar() {
    		throw new Error("<CodeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mainMenuBar(value) {
    		throw new Error("<CodeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<CodeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<CodeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indentation() {
    		throw new Error("<CodeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indentation(value) {
    		throw new Error("<CodeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get aceTheme() {
    		throw new Error("<CodeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set aceTheme(value) {
    		throw new Error("<CodeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get validator() {
    		throw new Error("<CodeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set validator(value) {
    		throw new Error("<CodeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onChange() {
    		throw new Error("<CodeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onChange(value) {
    		throw new Error("<CodeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSwitchToTreeMode() {
    		throw new Error("<CodeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSwitchToTreeMode(value) {
    		throw new Error("<CodeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onError() {
    		throw new Error("<CodeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onError(value) {
    		throw new Error("<CodeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onFocus() {
    		throw new Error("<CodeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onFocus(value) {
    		throw new Error("<CodeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onBlur() {
    		throw new Error("<CodeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onBlur(value) {
    		throw new Error("<CodeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onRenderMenu() {
    		throw new Error("<CodeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onRenderMenu(value) {
    		throw new Error("<CodeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focus() {
    		return this.$$.ctx[30];
    	}

    	set focus(value) {
    		throw new Error("<CodeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get patch() {
    		return this.$$.ctx[31];
    	}

    	set patch(value) {
    		throw new Error("<CodeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // Robert Penner's easeInOutQuad

    // find the rest of his easing functions here: http://robertpenner.com/easing/
    // find them exported for ES6 consumption here: https://github.com/jaxgeller/ez.js

    var easeInOutQuad = (t, b, c, d) => {
      t /= d / 2;
      if (t < 1) return c / 2 * t * t + b
      t--;
      return -c / 2 * (t * (t - 2) - 1) + b
    };

    const createJump = () => {
      // private variable cache
      // no variables are created during a jump, preventing memory leaks

      let container; // container element to be scrolled       (node)
      let element; // element to scroll to                   (node)

      let start; // where scroll starts                    (px)
      let stop; // where scroll stops                     (px)

      let offset; // adjustment from the stop position      (px)
      let easing; // easing function                        (function)
      let a11y; // accessibility support flag             (boolean)

      let distance; // distance of scroll                     (px)
      let duration; // scroll duration                        (ms)

      let timeStart; // time scroll started                    (ms)
      let timeElapsed; // time spent scrolling thus far          (ms)

      let next; // next scroll position                   (px)

      let callback; // to call when done scrolling            (function)

      let scrolling; // true whilst scrolling                  (boolean)

      // scroll position helper

      function location () {
        return container.scrollY || container.pageYOffset || container.scrollTop
      }

      // element offset helper

      function top (element) {
        const elementTop = element.getBoundingClientRect().top;
        const containerTop = container.getBoundingClientRect
          ? container.getBoundingClientRect().top
          : 0;

        return elementTop - containerTop + start
      }

      // scrollTo helper

      function scrollTo (top) {
        container.scrollTo
          ? container.scrollTo(0, top) // window
          : container.scrollTop = top; // custom container
      }

      // rAF loop helper

      function loop (timeCurrent) {
        // store time scroll started, if not started already
        if (!timeStart) {
          timeStart = timeCurrent;
        }

        // determine time spent scrolling so far
        timeElapsed = timeCurrent - timeStart;

        // calculate next scroll position
        next = easing(timeElapsed, start, distance, duration);

        // scroll to it
        scrollTo(next);

        scrolling = true;

        // check progress
        timeElapsed < duration
          ? requestAnimationFrame(loop) // continue scroll loop
          : done(); // scrolling is done
      }

      // scroll finished helper

      function done () {
        // account for rAF time rounding inaccuracies
        scrollTo(start + distance);

        // if scrolling to an element, and accessibility is enabled
        if (element && a11y) {
          // add tabindex indicating programmatic focus
          element.setAttribute('tabindex', '-1');

          // focus the element
          element.focus();
        }

        // if it exists, fire the callback
        if (typeof callback === 'function') {
          callback();
        }

        // reset time for next jump
        timeStart = false;

        // we're done scrolling
        scrolling = false;
      }

      // API

      function jump (target, options = {}) {
        // resolve options, or use defaults
        duration = options.duration || 1000;
        offset = options.offset || 0;
        callback = options.callback; // "undefined" is a suitable default, and won't be called
        easing = options.easing || easeInOutQuad;
        a11y = options.a11y || false;

        // resolve container
        switch (typeof options.container) {
          case 'object':
            // we assume container is an HTML element (Node)
            container = options.container;
            break

          case 'string':
            container = document.querySelector(options.container);
            break

          default:
            container = window;
        }

        // cache starting position
        start = location();

        // resolve target
        switch (typeof target) {
          // scroll from current position
          case 'number':
            element = undefined; // no element to scroll to
            a11y = false; // make sure accessibility is off
            stop = start + target;
            break

            // scroll to element (node)
            // bounding rect is relative to the viewport
          case 'object':
            element = target;
            stop = top(element);
            break

            // scroll to element (selector)
            // bounding rect is relative to the viewport
          case 'string':
            element = document.querySelector(target);
            stop = top(element);
            break
        }

        // resolve scroll distance, accounting for offset
        distance = stop - start + offset;

        // resolve duration
        switch (typeof options.duration) {
          // number in ms
          case 'number':
            duration = options.duration;
            break

            // function passed the distance of the scroll
          case 'function':
            duration = options.duration(distance);
            break
        }

        // start the loop if we're not already scrolling
        if (!scrolling) {
          requestAnimationFrame(loop);
        } else {
          // reset time for next jump
          timeStart = false;
        }
      }

      // expose only the jump method
      return jump
    };

    const MAX_HISTORY_ITEMS = 1000;

    /**
     * @typedef {*} HistoryItem
     * @property {Object} undo
     * @property {Object} redo
     */

    /**
     * @param {Object} [options]
     * @property {number} [maxItems]
     * @property {onChange} [({canUndo: boolean, canRedo: boolean, length: number}) => void]
     * @returns {Object}
     */
    function createHistory (options = {}) {
      const maxItems = options.maxItems || MAX_HISTORY_ITEMS;

      /**
       * items in history are sorted from newest first to oldest last
       * @type {HistoryItem[]}
       */
      let items = [];

      /**
       * @type {number}
       */
      let index = 0;

      /**
       * @return {boolean}
       */
      function canUndo () {
        return index < items.length
      }

      /**
       * @return {boolean}
       */
      function canRedo () {
        return index > 0
      }

      function getState () {
        return {
          canUndo: canUndo(),
          canRedo: canRedo(),
          length: items.length
        }
      }

      function handleChange () {
        if (options.onChange) {
          options.onChange(getState());
        }
      }

      /**
       * @param {HistoryItem} item
       */
      function add (item) {
        items = [item]
          .concat(items.slice(index))
          .slice(0, maxItems);

        index = 0;

        handleChange();
      }

      function clear () {
        items = [];
        index = 0;

        handleChange();
      }

      /**
       * @return {HistoryItem | undefined}
       */
      function undo () {
        if (canUndo()) {
          const item = items[index];
          index += 1;

          handleChange();

          return item
        }

        return undefined
      }

      /**
       * @return {HistoryItem | undefined}
       */
      function redo () {
        if (canRedo()) {
          index -= 1;

          handleChange();

          return items[index]
        }

        return undefined
      }

      return {
        add,
        clear,
        getState,
        undo,
        redo
      }
    }

    /**
     * Create a JSONPatch for an insert operation.
     *
     * This function needs the current data in order to be able to determine
     * a unique property name for the inserted node in case of duplicating
     * and object property
     *
     * @param {JSON} json
     * @param {JSON} state
     * @param {Path} path
     * @param {ClipboardValues} values
     * @return {JSONPatchDocument}
     */
    // TODO: write tests
    function insertBefore (json, state, path, values) { // TODO: find a better name and define datastructure for values
      const parentPath = initial(path);
      const parent = immutableJSONPatch.getIn(json, parentPath);

      if (Array.isArray(parent)) {
        // the path is parsed from a JSONPatch operation,
        // so array indices are a string which we have to parse into a number
        const offset = parseInt(last(path), 10);
        return values.map((entry, index) => ({
          op: 'add',
          path: immutableJSONPatch.compileJSONPointer(parentPath.concat(offset + index)),
          value: entry.value
        }))
      } else { // 'object'
        const afterKey = last(path);
        const keys = getKeys(state, parentPath);
        const nextKeys = getNextKeys(keys, afterKey, true);

        return [
          // insert new values
          ...values.map(entry => {
            const newProp = findUniqueName(entry.key, keys);
            return {
              op: 'add',
              path: immutableJSONPatch.compileJSONPointer(parentPath.concat(newProp)),
              value: entry.value
            }
          }),

          // move all lower down keys so the inserted key will maintain it's position
          ...nextKeys.map(key => moveDown(parentPath, key))
        ]
      }
    }

    /**
     * Create a JSONPatch for an append operation. The values will be appended
     * to the end of the array or object.
     *
     * This function needs the current data in order to be able to determine
     * a unique property name for the inserted node in case of duplicating
     * and object property
     *
     * @param {JSON} json
     * @param {Path} path
     * @param {ClipboardValues} values
     * @return {JSONPatchDocument}
     */
    function append (json, path, values) { // TODO: find a better name and define datastructure for values
      const parent = immutableJSONPatch.getIn(json, path);

      if (Array.isArray(parent)) {
        const offset = parent.length;
        return values.map((entry, index) => ({
          op: 'add',
          path: immutableJSONPatch.compileJSONPointer(path.concat(offset + index)),
          value: entry.value
        }))
      } else { // 'object'
        return values.map(entry => {
          const newProp = findUniqueName(entry.key, Object.keys(parent));
          return {
            op: 'add',
            path: immutableJSONPatch.compileJSONPointer(path.concat(newProp)),
            value: entry.value
          }
        })
      }
    }

    /**
     * Rename an object key
     * Not applicable to arrays
     *
     * @param {Path} parentPath
     * @param {string[]} keys
     * @param {string} oldKey
     * @param {string} newKey
     * @returns {JSONPatchDocument}
     */
    function rename (parentPath, keys, oldKey, newKey) {
      const filteredKeys = keys.filter(key => key !== oldKey);
      const newKeyUnique = findUniqueName(newKey, filteredKeys);
      const nextKeys = getNextKeys(keys, oldKey, false);

      return [
        // rename a key
        {
          op: 'move',
          from: immutableJSONPatch.compileJSONPointer(parentPath.concat(oldKey)),
          path: immutableJSONPatch.compileJSONPointer(parentPath.concat(newKeyUnique))
        },

        // move all lower down keys so the renamed key will maintain it's position
        ...nextKeys.map(key => moveDown(parentPath, key))
      ]
    }

    /**
     * Create a JSONPatch for an insert operation.
     *
     * This function needs the current data in order to be able to determine
     * a unique property name for the inserted node in case of duplicating
     * and object property
     *
     * @param {JSON} json
     * @param {JSON} state
     * @param {Path[]} paths
     * @param {ClipboardValues} values
     * @return {JSONPatchDocument}
     */
    function replace (json, state, paths, values) { // TODO: find a better name and define datastructure for values
      const firstPath = head(paths);
      const parentPath = initial(firstPath);
      const parent = immutableJSONPatch.getIn(json, parentPath);

      if (Array.isArray(parent)) {
        const firstPath = head(paths);
        const offset = firstPath ? parseInt(last(firstPath), 10) : 0;

        return [
          // remove operations
          ...removeAll(paths),

          // insert operations
          ...values.map((entry, index) => ({
            op: 'add',
            path: immutableJSONPatch.compileJSONPointer(parentPath.concat(index + offset)),
            value: entry.value
          }))
        ]
      } else { // parent is Object
        // if we're going to replace an existing object with key "a" with a new
        // key "a", we must not create a new unique name "a (copy)".
        const lastPath = last(paths);
        const parentPath = initial(lastPath);
        const beforeKey = last(lastPath);
        const keys = getKeys(state, parentPath);
        const nextKeys = getNextKeys(keys, beforeKey, false);
        const removeKeys = new Set(paths.map(path => last(path)));
        const filteredKeys = keys.filter(key => !removeKeys.has(key));

        return [
          // remove operations
          ...removeAll(paths),

          // insert operations
          ...values.map(entry => {
            const newProp = findUniqueName(entry.key, filteredKeys);
            return {
              op: 'add',
              path: immutableJSONPatch.compileJSONPointer(parentPath.concat(newProp)),
              value: entry.value
            }
          }),

          // move down operations
          // move all lower down keys so the renamed key will maintain it's position
          ...nextKeys.map(key => moveDown(parentPath, key))
        ]
      }
    }

    /**
     * Create a JSONPatch for a duplicate action.
     *
     * This function needs the current data in order to be able to determine
     * a unique property name for the duplicated node in case of duplicating
     * and object property
     *
     * @param {JSON} json
     * @param {JSON} state
     * @param {Path[]} paths
     * @return {JSONPatchDocument}
     */
    function duplicate (json, state, paths) {
      // FIXME: here we assume selection.paths is sorted correctly, that's a dangerous assumption
      const lastPath = last(paths);

      if (isEmpty(lastPath)) {
        throw new Error('Cannot duplicate root object')
      }

      const parentPath = initial(lastPath);
      const beforeKey = last(lastPath);
      const parent = immutableJSONPatch.getIn(json, parentPath);

      if (Array.isArray(parent)) {
        const lastPath = last(paths);
        const offset = lastPath ? (parseInt(last(lastPath), 10) + 1) : 0;

        return [
          // copy operations
          ...paths.map((path, index) => ({
            op: 'copy',
            from: immutableJSONPatch.compileJSONPointer(path),
            path: immutableJSONPatch.compileJSONPointer(parentPath.concat(index + offset))
          }))
        ]
      } else { // 'object'
        const keys = getKeys(state, parentPath);
        const nextKeys = getNextKeys(keys, beforeKey, false);

        return [
          // copy operations
          ...paths.map(path => {
            const prop = last(path);
            const newProp = findUniqueName(prop, keys);

            return {
              op: 'copy',
              from: immutableJSONPatch.compileJSONPointer(path),
              path: immutableJSONPatch.compileJSONPointer(parentPath.concat(newProp))
            }
          }),

          // move down operations
          // move all lower down keys so the renamed key will maintain it's position
          ...nextKeys.map(key => moveDown(parentPath, key))
        ]
      }
    }

    /**
     * Create a JSONPatch for an extract action.
     *
     * @param {JSON} json
     * @param {JSON} state
     * @param {Selection} selection
     * @return {JSONPatchDocument}
     */
    // TODO: write unit tests
    function extract (json, state, selection) {
      if (selection.type === SELECTION_TYPE.VALUE) {
        return [
          {
            op: 'move',
            from: immutableJSONPatch.compileJSONPointer(selection.focusPath),
            path: ''
          }
        ]
      }

      if (selection.type === SELECTION_TYPE.MULTI) {
        const parentPath = initial(selection.focusPath);
        const parent = immutableJSONPatch.getIn(json, parentPath);

        if (Array.isArray(parent)) {
          const value = selection.paths.map(path => {
            const index = last(path);
            return parent[index]
          });

          return [
            {
              op: 'replace',
              path: '',
              value
            }
          ]
        } else { // object
          const value = {};
          selection.paths.forEach(path => {
            const key = last(path);
            value[key] = parent[key];
          });

          return [
            {
              op: 'replace',
              path: '',
              value
            }
          ]
        }
      }

      // this should never happen
      throw new Error('Cannot extract: unsupported type of selection ' + JSON.stringify(selection))
    }

    /**
     * @param {JSON} json
     * @param {JSON} state
     * @param {Selection} selection
     * @param {string} clipboardText
     * @return {JSONPatchDocument}
     */
    // TODO: write unit tests
    function insert (json, state, selection, clipboardText) {
      if (selection.type === SELECTION_TYPE.KEY) {
        // rename key
        const clipboard = parseAndRepairOrUndefined(clipboardText);
        const parentPath = initial(selection.focusPath);
        const keys = getKeys(state, parentPath);
        const oldKey = last(selection.focusPath);
        const newKey = typeof clipboard === 'string'
          ? clipboard
          : clipboardText;

        return rename(parentPath, keys, oldKey, newKey)
      }

      if (
        selection.type === SELECTION_TYPE.VALUE ||
        (selection.type === SELECTION_TYPE.MULTI && isEmpty(selection.focusPath)) // root selected
      ) {
        // replace selected value (new value can be primitive or an array/object with contents)
        try {
          return [
            {
              op: 'replace',
              path: immutableJSONPatch.compileJSONPointer(selection.focusPath),
              value: parsePartialJson(clipboardText, parseAndRepair)
            }
          ]
        } catch (err) {
          // parsing failed -> just paste the raw text as value
          return [
            {
              op: 'replace',
              path: immutableJSONPatch.compileJSONPointer(selection.focusPath),
              value: clipboardText
            }
          ]
        }
      }

      if (selection.type === SELECTION_TYPE.MULTI) {
        const newValues = clipboardToValues(clipboardText);

        return replace(json, state, selection.paths, newValues)
      }

      if (selection.type === SELECTION_TYPE.AFTER) {
        const newValues = clipboardToValues(clipboardText);
        const path = selection.focusPath;
        const parentPath = initial(path);
        const parent = immutableJSONPatch.getIn(json, parentPath);

        if (Array.isArray(parent)) {
          const index = last(path);
          const nextItemPath = parentPath.concat([index + 1]);

          return insertBefore(json, state, nextItemPath, newValues)
        } else { // value is an Object
          const key = last(path);
          const keys = getKeys(state, parentPath);
          if (isEmpty(keys) || last(keys) === key) {
            return append(json, parentPath, newValues)
          } else {
            const index = keys.indexOf(key);
            const nextKey = keys[index + 1];
            const nextKeyPath = parentPath.concat([nextKey]);

            return insertBefore(json, state, nextKeyPath, newValues)
          }
        }
      }

      if (selection.type === SELECTION_TYPE.INSIDE) {
        const newValues = clipboardToValues(clipboardText);
        const path = selection.focusPath;
        const value = immutableJSONPatch.getIn(json, path);

        if (Array.isArray(value)) {
          const firstItemPath = path.concat([0]);
          return insertBefore(json, state, firstItemPath, newValues)
        } else { // value is an Object
          const keys = getKeys(state, path);
          if (isEmpty(keys)) {
            return append(json, path, newValues)
          } else {
            const firstKey = head(keys);
            const firstKeyPath = path.concat([firstKey]);

            return insertBefore(json, state, firstKeyPath, newValues)
          }
        }
      }

      // this should never happen
      throw new Error('Cannot insert: unsupported type of selection ' + JSON.stringify(selection))
    }

    function createNewValue (json, selection, type) {
      if (type === 'object') {
        return {}
      }

      if (type === 'array') {
        return []
      }

      if (type === 'structure') {
        const parentPath = getParentPath(selection);
        const parent = immutableJSONPatch.getIn(json, parentPath);

        if (Array.isArray(parent) && !isEmpty(parent)) {
          const jsonExample = head(parent);
          if (isObjectOrArray(jsonExample)) {
            return cloneDeepWith(jsonExample, (value) => {
              return Array.isArray(value)
                ? []
                : isObject(value)
                  ? undefined // leave object as is, will recurse into it
                  : ''
            })
          } else {
            // just a primitive value
            return ''
          }
        }
      }

      // type === value,
      // or type === structure but the parent is no array or an array containing
      // primitive values (and no objects having any structure).
      return ''
    }

    /**
     * Create a JSONPatch for a multiple remove operation
     * @param {Path[]} paths
     * @return {JSONPatchDocument}
     */
    function removeAll (paths) {
      return paths
        .map(path => ({
          op: 'remove',
          path: immutableJSONPatch.compileJSONPointer(path)
        }))
        .reverse() // reverse is needed for arrays: delete the last index first
    }

    // helper function to move a key down in an object,
    // so another key can get positioned before the moved down keys
    function moveDown (parentPath, key) {
      return {
        op: 'move',
        from: immutableJSONPatch.compileJSONPointer(parentPath.concat(key)),
        path: immutableJSONPatch.compileJSONPointer(parentPath.concat(key))
      }
    }

    /**
     * @param {string} clipboardText
     * @returns {Array.<{key: string, value: *}>}
     */
    function clipboardToValues (clipboardText) {
      // clipboardOriginal must not fix partial JSON, we need clipboardOriginal
      // mostly to determine whether the original JSON was an object/array or not
      const clipboardOriginal = parseAndRepairOrUndefined(clipboardText);
      const clipboardRepaired = clipboardOriginal !== undefined
        ? clipboardOriginal // just performance optimization
        : parsePartialJson(clipboardText, parseAndRepair);

      if (isObjectOrArray(clipboardOriginal)) {
        return [{ key: 'New item', value: clipboardRepaired }]
      }

      if (Array.isArray(clipboardRepaired)) {
        return clipboardRepaired.map((value, index) => {
          return { key: 'New item ' + index, value }
        })
      }

      if (isObject(clipboardRepaired)) {
        return Object.keys(clipboardRepaired).map(key => {
          return { key, value: clipboardRepaired[key] }
        })
      }

      // regular value
      return [
        { key: 'New item', value: clipboardRepaired }
      ]
    }

    /**
     * @param {JSON} json
     * @param {JSON} state
     * @param {Selection} selection
     * @returns {{newSelection: Selection, operations: JSONPatchDocument}}
     */
    // TODO: write unit tests
    function createRemoveOperations (json, state, selection) {
      if (selection.type === SELECTION_TYPE.KEY) {
        // FIXME: DOESN'T work yet
        const parentPath = initial(selection.focusPath);
        const keys = getKeys(state, parentPath);
        const oldKey = last(selection.focusPath);
        const newKey = '';

        const operations = rename(parentPath, keys, oldKey, newKey);
        const newSelection = createSelectionFromOperations(json, operations);

        return { operations, newSelection }
      }

      if (selection.type === SELECTION_TYPE.VALUE) {
        const operations = [{
          op: 'replace',
          path: immutableJSONPatch.compileJSONPointer(selection.focusPath),
          value: ''
        }];

        return { operations, newSelection: selection }
      }

      if (selection.type === SELECTION_TYPE.MULTI) {
        const operations = removeAll(selection.paths);
        const lastPath = last(selection.paths);

        if (isEmpty(lastPath)) {
          // there is no parent, this is the root document
          const operations = [{ op: 'replace', path: '', value: '' }];

          const newSelection = createSelection(json, state, {
            type: SELECTION_TYPE.VALUE,
            path: []
          });

          return { operations, newSelection }
        }

        const parentPath = initial(lastPath);
        const parent = immutableJSONPatch.getIn(json, parentPath);

        if (Array.isArray(parent)) {
          const firstPath = head(selection.paths);
          const index = last(firstPath);
          const newSelection = index === 0
            ? createSelection(json, state, {
              type: SELECTION_TYPE.INSIDE,
              path: parentPath
            })
            : createSelection(json, state, {
              type: SELECTION_TYPE.AFTER,
              path: parentPath.concat([index - 1])
            });

          return { operations, newSelection }
        } else { // parent is object
          const keys = getKeys(state, parentPath);
          const firstPath = head(selection.paths);
          const key = last(firstPath);
          const index = keys.indexOf(key);
          const previousKey = keys[index - 1];
          const newSelection = index === 0
            ? createSelection(json, state, {
              type: SELECTION_TYPE.INSIDE,
              path: parentPath
            })
            : createSelection(json, state, {
              type: SELECTION_TYPE.AFTER,
              path: parentPath.concat([previousKey])
            });

          return { operations, newSelection }
        }
      }

      // this should never happen
      throw new Error('Cannot remove: unsupported type of selection ' + JSON.stringify(selection))
    }

    /**
     * @typedef {Object} SearchResult
     * @property {Object} items
     * @property {Object} itemsWithActive
     * @property {Path[]} flatItems
     * @property {Path} activeItem
     * @property {number} activeIndex
     * @property {number} count
     */

    // TODO: comment
    function updateSearchResult (json, flatResults, previousResult) {
      const flatItems = flatResults;

      const items = createRecursiveSearchResults(json, flatItems);

      const activeItem = (previousResult && previousResult.activeItem &&
        immutableJSONPatch.existsIn(items, previousResult.activeItem))
        ? previousResult.activeItem
        : flatItems[0];

      const activeIndex = flatItems.findIndex(item => isEqual(item, activeItem));

      const itemsWithActive = (items && activeItem && activeIndex !== -1)
        ? immutableJSONPatch.setIn(items, activeItem, ACTIVE_SEARCH_RESULT)
        : items;

      return {
        items,
        itemsWithActive,
        flatItems,
        count: flatItems.length,
        activeItem,
        activeIndex: activeIndex
      }
    }

    // TODO: comment
    function createRecursiveSearchResults (referenceJson, flatResults) {
      // TODO: smart update result based on previous results to make the results immutable when there is no actual change
      let result = {};

      flatResults.forEach(path => {
        const parentPath = initial(path);
        if (!immutableJSONPatch.existsIn(result, parentPath)) {
          const item = immutableJSONPatch.getIn(referenceJson, parentPath);
          result = immutableJSONPatch.setIn(result, parentPath, Array.isArray(item) ? [] : {}, true);
        }

        result = immutableJSONPatch.setIn(result, path, SEARCH_RESULT);
      });

      return result
    }

    /**
     * @param {SearchResult} searchResult
     * @return {SearchResult}
     */
    function searchNext (searchResult) {
      const nextActiveIndex = searchResult.activeIndex < searchResult.flatItems.length - 1
        ? searchResult.activeIndex + 1
        : searchResult.flatItems.length > 0
          ? 0
          : -1;

      const nextActiveItem = searchResult.flatItems[nextActiveIndex];

      const itemsWithActive = nextActiveItem
        ? immutableJSONPatch.setIn(searchResult.items, nextActiveItem, ACTIVE_SEARCH_RESULT, true)
        : searchResult.items;

      return {
        ...searchResult,
        itemsWithActive,
        activeItem: nextActiveItem,
        activeIndex: nextActiveIndex
      }
    }

    /**
     * @param {SearchResult} searchResult
     * @return {SearchResult}
     */
    function searchPrevious (searchResult) {
      const previousActiveIndex = searchResult.activeIndex > 0
        ? searchResult.activeIndex - 1
        : searchResult.flatItems.length - 1;

      const previousActiveItem = searchResult.flatItems[previousActiveIndex];

      const itemsWithActive = previousActiveItem
        ? immutableJSONPatch.setIn(searchResult.items, previousActiveItem, ACTIVE_SEARCH_RESULT, true)
        : searchResult.items;

      return {
        ...searchResult,
        itemsWithActive,
        activeItem: previousActiveItem,
        activeIndex: previousActiveIndex
      }
    }

    async function tick () {
      return new Promise(setTimeout)
    }

    // TODO: comment
    function searchAsync (searchText, json, state, { onProgress, onDone, maxResults = Infinity, yieldAfterItemCount = 10000 }) {
      // TODO: what is a good value for yieldAfterItemCount? (larger means faster results but also less responsive during search)
      const search = searchGenerator(searchText, json, state, yieldAfterItemCount);

      // TODO: implement pause after having found x results (like 999)?

      let cancelled = false;
      const results = [];
      let newResults = false;

      async function executeSearch () {
        if (!searchText || searchText === '') {
          onDone(results);
          return
        }

        let next;
        do {
          next = search.next();
          if (next.value) {
            if (results.length < maxResults) {
              results.push(next.value); // TODO: make this immutable?
              newResults = true;
            } else {
              // max results limit reached
              cancelled = true;
              onDone(results);
            }
          } else {
            // time for a small break, give the browser space to do stuff
            if (newResults) {
              newResults = false;
              if (onProgress) {
                onProgress(results);
              }
            }

            await tick();
          }

          // eslint-disable-next-line no-unmodified-loop-condition
        } while (!cancelled && !next.done)

        if (next.done) {
          onDone(results);
        } // else: cancelled
      }

      // start searching on the next tick
      setTimeout(executeSearch);

      return {
        cancel: () => {
          cancelled = true;
        }
      }
    }

    // TODO: comment
    function * searchGenerator (searchText, json, state = undefined, yieldAfterItemCount = undefined) {
      let count = 0;

      function * incrementCounter () {
        count++;
        if (typeof yieldAfterItemCount === 'number' && count % yieldAfterItemCount === 0) {
          // pause every x items
          yield null;
        }
      }

      function * searchRecursiveAsync (searchText, json, state, path) {
        const type = valueType(json);

        if (type === 'array') {
          for (let i = 0; i < json.length; i++) {
            yield * searchRecursiveAsync(searchText, json[i], state ? state[i] : undefined, path.concat([i]));
          }
        } else if (type === 'object') {
          const keys = state
            ? state[STATE_KEYS]
            : Object.keys(json);

          for (const key of keys) {
            if (typeof key === 'string' && containsCaseInsensitive(key, searchText)) {
              yield path.concat([key, STATE_SEARCH_PROPERTY]);
            }
            yield * incrementCounter();

            yield * searchRecursiveAsync(searchText, json[key], state ? state[key] : undefined, path.concat([key]));
          }
        } else { // type is a value
          if (containsCaseInsensitive(json, searchText)) {
            yield path.concat([STATE_SEARCH_VALUE]);
          }
          yield * incrementCounter();
        }
      }

      return yield * searchRecursiveAsync(searchText, json, state, [])
    }

    /**
     * Do a case insensitive search for a search text in a text
     * @param {String} text
     * @param {String} searchText
     * @return {boolean} Returns true if `search` is found in `text`
     */
    function containsCaseInsensitive (text, searchText) {
      return String(text).toLowerCase().indexOf(searchText.toLowerCase()) !== -1
    }

    /**
     * Create a nested map with validation errors,
     * and also create error messages for the parent nodes of the nodes having an error.
     *
     * @param {ValidationError[]} validationErrors
     * @return {Object.<string, string> | undefined} Returns a nested object containing
     */
    function mapValidationErrors (validationErrors) {
      let object;

      validationErrors.forEach(validationError => {
        const errorPath = validationError.path.concat([VALIDATION_ERROR]);
        object = immutableJSONPatch.setIn(object, errorPath, validationError, true);
      });

      // create error entries for all parent nodes
      validationErrors.forEach(validationError => {
        const path = validationError.path;
        let parentPath = path;

        while (parentPath.length > 0) {
          parentPath = initial(parentPath);

          const parentErrorPath = parentPath.concat([VALIDATION_ERROR]);
          if (!immutableJSONPatch.existsIn(object, parentErrorPath)) {
            const error = {
              isChildError: true,
              path: parentPath,
              message: 'Contains invalid data'
            };
            object = immutableJSONPatch.setIn(object, parentErrorPath, error, true);
          }
        }
      });

      return object
    }

    /* node_modules\svelte-jsoneditor\src\components\modes\repairmode\RepairMode.svelte generated by Svelte v3.38.2 */
    const file$f = "node_modules\\svelte-jsoneditor\\src\\components\\modes\\repairmode\\RepairMode.svelte";

    // (164:4) 
    function create_left_slot(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Repair invalid JSON, then click apply";
    			attr_dev(div, "slot", "left");
    			attr_dev(div, "class", "info svelte-1x4hlp9");
    			add_location(div, file$f, 163, 4, 3277);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_left_slot.name,
    		type: "slot",
    		source: "(164:4) ",
    		ctx
    	});

    	return block;
    }

    // (176:2) {:else}
    function create_else_block$5(ctx) {
    	let message;
    	let current;

    	message = new Message({
    			props: {
    				type: "success",
    				message: "JSON is valid now and can be parsed.",
    				actions: /*successActions*/ ctx[7]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(message.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(message, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const message_changes = {};
    			if (dirty & /*successActions*/ 128) message_changes.actions = /*successActions*/ ctx[7];
    			message.$set(message_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(message.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(message.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(message, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(176:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (169:2) {#if error}
    function create_if_block$7(ctx) {
    	let message;
    	let current;

    	message = new Message({
    			props: {
    				type: "error",
    				icon: faExclamationTriangle,
    				message: `Cannot parse JSON: ${/*error*/ ctx[2].message}`,
    				actions: /*errorActions*/ ctx[6]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(message.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(message, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const message_changes = {};
    			if (dirty & /*error*/ 4) message_changes.message = `Cannot parse JSON: ${/*error*/ ctx[2].message}`;
    			if (dirty & /*errorActions*/ 64) message_changes.actions = /*errorActions*/ ctx[6];
    			message.$set(message_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(message.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(message.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(message, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(169:2) {#if error}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let div;
    	let menu;
    	let t0;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let textarea;
    	let current;
    	let mounted;
    	let dispose;

    	menu = new Menu({
    			props: {
    				items: /*items*/ ctx[5],
    				$$slots: { left: [create_left_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block$7, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*error*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(menu.$$.fragment);
    			t0 = space();
    			if_block.c();
    			t1 = space();
    			textarea = element("textarea");
    			textarea.value = /*text*/ ctx[0];
    			textarea.readOnly = /*readOnly*/ ctx[1];
    			attr_dev(textarea, "class", "json-text svelte-1x4hlp9");
    			attr_dev(textarea, "autocomplete", "off");
    			attr_dev(textarea, "autocapitalize", "off");
    			attr_dev(textarea, "spellcheck", "false");
    			add_location(textarea, file$f, 182, 2, 3690);
    			attr_dev(div, "class", "json-repair svelte-1x4hlp9");
    			add_location(div, file$f, 158, 0, 3193);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(menu, div, null);
    			append_dev(div, t0);
    			if_blocks[current_block_type_index].m(div, null);
    			append_dev(div, t1);
    			append_dev(div, textarea);
    			/*textarea_binding*/ ctx[21](textarea);
    			/*div_binding*/ ctx[22](div);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(textarea, "input", /*handleChange*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const menu_changes = {};
    			if (dirty & /*items*/ 32) menu_changes.items = /*items*/ ctx[5];

    			if (dirty & /*$$scope*/ 536870912) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			menu.$set(menu_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, t1);
    			}

    			if (!current || dirty & /*text*/ 1) {
    				prop_dev(textarea, "value", /*text*/ ctx[0]);
    			}

    			if (!current || dirty & /*readOnly*/ 2) {
    				prop_dev(textarea, "readOnly", /*readOnly*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(menu);
    			if_blocks[current_block_type_index].d();
    			/*textarea_binding*/ ctx[21](null);
    			/*div_binding*/ ctx[22](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let error;
    	let repairable;
    	let defaultItems;
    	let items;
    	let gotoAction;
    	let repairAction;
    	let errorActions;
    	let successActions;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("RepairMode", slots, []);
    	let { text = "" } = $$props;
    	let { readOnly = false } = $$props;
    	let { onParse } = $$props;
    	let { onRepair } = $$props;
    	let { onChange = null } = $$props;
    	let { onApply } = $$props;
    	let { onCancel } = $$props;
    	let { onFocus } = $$props;
    	let { onBlur } = $$props;

    	let { onRenderMenu = () => {
    		
    	} } = $$props;

    	const debug = browser("jsoneditor:JSONRepair");
    	let domJsonRepair;
    	let domTextArea;

    	createFocusTracker({
    		onMount,
    		onDestroy,
    		getWindow: () => getWindow(domJsonRepair),
    		hasFocus: () => activeElementIsChildOf(domJsonRepair),
    		onFocus: () => {
    			if (onFocus) {
    				onFocus();
    			}
    		},
    		onBlur: () => {
    			if (onBlur) {
    				onBlur();
    			}
    		}
    	});

    	function getErrorMessage(jsonText) {
    		try {
    			onParse(jsonText);
    			return null;
    		} catch(err) {
    			return normalizeJsonParseError(jsonText, err.message);
    		}
    	}

    	function isRepairable(jsonText) {
    		try {
    			onRepair(jsonText);
    			return true;
    		} catch(err) {
    			return false;
    		}
    	}

    	function goToError() {
    		if (domTextArea && error && error.position != null) {
    			domTextArea.setSelectionRange(error.position, error.position);

    			setTimeout(() => {
    				domTextArea.focus();
    			});
    		}
    	}

    	function handleChange(event) {
    		debug("handleChange");
    		const value = event.target.value;

    		if (text === value) {
    			return;
    		}

    		$$invalidate(0, text = value);

    		if (onChange) {
    			onChange(text);
    		}
    	}

    	function handleApply() {
    		onApply(text);
    	}

    	function handleRepair() {
    		try {
    			// TODO: simpleJsonRepair should also partially apply fixes. Now it's all or nothing
    			$$invalidate(0, text = onRepair(text));

    			if (onChange) {
    				onChange(text);
    			}
    		} catch(err) {
    			
    		} // no need to do something with the error
    	}

    	const writable_props = [
    		"text",
    		"readOnly",
    		"onParse",
    		"onRepair",
    		"onChange",
    		"onApply",
    		"onCancel",
    		"onFocus",
    		"onBlur",
    		"onRenderMenu"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<RepairMode> was created with unknown prop '${key}'`);
    	});

    	function textarea_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			domTextArea = $$value;
    			$$invalidate(4, domTextArea);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			domJsonRepair = $$value;
    			$$invalidate(3, domJsonRepair);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("readOnly" in $$props) $$invalidate(1, readOnly = $$props.readOnly);
    		if ("onParse" in $$props) $$invalidate(9, onParse = $$props.onParse);
    		if ("onRepair" in $$props) $$invalidate(10, onRepair = $$props.onRepair);
    		if ("onChange" in $$props) $$invalidate(11, onChange = $$props.onChange);
    		if ("onApply" in $$props) $$invalidate(12, onApply = $$props.onApply);
    		if ("onCancel" in $$props) $$invalidate(13, onCancel = $$props.onCancel);
    		if ("onFocus" in $$props) $$invalidate(14, onFocus = $$props.onFocus);
    		if ("onBlur" in $$props) $$invalidate(15, onBlur = $$props.onBlur);
    		if ("onRenderMenu" in $$props) $$invalidate(16, onRenderMenu = $$props.onRenderMenu);
    	};

    	$$self.$capture_state = () => ({
    		faArrowDown,
    		faCheck,
    		faExclamationTriangle,
    		faTimes,
    		faWrench,
    		createDebug: browser,
    		Message,
    		onDestroy,
    		onMount,
    		activeElementIsChildOf,
    		getWindow,
    		normalizeJsonParseError,
    		createFocusTracker,
    		Menu,
    		text,
    		readOnly,
    		onParse,
    		onRepair,
    		onChange,
    		onApply,
    		onCancel,
    		onFocus,
    		onBlur,
    		onRenderMenu,
    		debug,
    		domJsonRepair,
    		domTextArea,
    		getErrorMessage,
    		isRepairable,
    		goToError,
    		handleChange,
    		handleApply,
    		handleRepair,
    		error,
    		repairable,
    		defaultItems,
    		items,
    		gotoAction,
    		repairAction,
    		errorActions,
    		successActions
    	});

    	$$self.$inject_state = $$props => {
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("readOnly" in $$props) $$invalidate(1, readOnly = $$props.readOnly);
    		if ("onParse" in $$props) $$invalidate(9, onParse = $$props.onParse);
    		if ("onRepair" in $$props) $$invalidate(10, onRepair = $$props.onRepair);
    		if ("onChange" in $$props) $$invalidate(11, onChange = $$props.onChange);
    		if ("onApply" in $$props) $$invalidate(12, onApply = $$props.onApply);
    		if ("onCancel" in $$props) $$invalidate(13, onCancel = $$props.onCancel);
    		if ("onFocus" in $$props) $$invalidate(14, onFocus = $$props.onFocus);
    		if ("onBlur" in $$props) $$invalidate(15, onBlur = $$props.onBlur);
    		if ("onRenderMenu" in $$props) $$invalidate(16, onRenderMenu = $$props.onRenderMenu);
    		if ("domJsonRepair" in $$props) $$invalidate(3, domJsonRepair = $$props.domJsonRepair);
    		if ("domTextArea" in $$props) $$invalidate(4, domTextArea = $$props.domTextArea);
    		if ("error" in $$props) $$invalidate(2, error = $$props.error);
    		if ("repairable" in $$props) $$invalidate(17, repairable = $$props.repairable);
    		if ("defaultItems" in $$props) $$invalidate(18, defaultItems = $$props.defaultItems);
    		if ("items" in $$props) $$invalidate(5, items = $$props.items);
    		if ("gotoAction" in $$props) $$invalidate(19, gotoAction = $$props.gotoAction);
    		if ("repairAction" in $$props) $$invalidate(20, repairAction = $$props.repairAction);
    		if ("errorActions" in $$props) $$invalidate(6, errorActions = $$props.errorActions);
    		if ("successActions" in $$props) $$invalidate(7, successActions = $$props.successActions);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*text*/ 1) {
    			$$invalidate(2, error = getErrorMessage(text));
    		}

    		if ($$self.$$.dirty & /*text*/ 1) {
    			$$invalidate(17, repairable = isRepairable(text));
    		}

    		if ($$self.$$.dirty & /*error*/ 4) {
    			debug("error", error);
    		}

    		if ($$self.$$.dirty & /*onCancel*/ 8192) {
    			$$invalidate(18, defaultItems = [
    				{ space: true },
    				{
    					icon: faTimes,
    					title: "Cancel repair",
    					className: "cancel",
    					onClick: onCancel
    				}
    			]);
    		}

    		if ($$self.$$.dirty & /*onRenderMenu, defaultItems*/ 327680) {
    			$$invalidate(5, items = onRenderMenu("repair", defaultItems) || defaultItems);
    		}

    		if ($$self.$$.dirty & /*repairable, gotoAction, repairAction*/ 1703936) {
    			$$invalidate(6, errorActions = repairable ? [gotoAction, repairAction] : [gotoAction]);
    		}

    		if ($$self.$$.dirty & /*readOnly*/ 2) {
    			$$invalidate(7, successActions = [
    				{
    					icon: faCheck,
    					text: "Apply",
    					title: "Apply fixed JSON",
    					disabled: readOnly,
    					onClick: handleApply
    				}
    			]);
    		}
    	};

    	$$invalidate(19, gotoAction = {
    		icon: faArrowDown,
    		text: "Show me",
    		title: "Scroll to the error location",
    		onClick: goToError
    	});

    	$$invalidate(20, repairAction = {
    		icon: faWrench,
    		text: "Auto repair",
    		title: "Automatically repair JSON",
    		onClick: handleRepair
    	});

    	return [
    		text,
    		readOnly,
    		error,
    		domJsonRepair,
    		domTextArea,
    		items,
    		errorActions,
    		successActions,
    		handleChange,
    		onParse,
    		onRepair,
    		onChange,
    		onApply,
    		onCancel,
    		onFocus,
    		onBlur,
    		onRenderMenu,
    		repairable,
    		defaultItems,
    		gotoAction,
    		repairAction,
    		textarea_binding,
    		div_binding
    	];
    }

    class RepairMode extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {
    			text: 0,
    			readOnly: 1,
    			onParse: 9,
    			onRepair: 10,
    			onChange: 11,
    			onApply: 12,
    			onCancel: 13,
    			onFocus: 14,
    			onBlur: 15,
    			onRenderMenu: 16
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RepairMode",
    			options,
    			id: create_fragment$h.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*onParse*/ ctx[9] === undefined && !("onParse" in props)) {
    			console.warn("<RepairMode> was created without expected prop 'onParse'");
    		}

    		if (/*onRepair*/ ctx[10] === undefined && !("onRepair" in props)) {
    			console.warn("<RepairMode> was created without expected prop 'onRepair'");
    		}

    		if (/*onApply*/ ctx[12] === undefined && !("onApply" in props)) {
    			console.warn("<RepairMode> was created without expected prop 'onApply'");
    		}

    		if (/*onCancel*/ ctx[13] === undefined && !("onCancel" in props)) {
    			console.warn("<RepairMode> was created without expected prop 'onCancel'");
    		}

    		if (/*onFocus*/ ctx[14] === undefined && !("onFocus" in props)) {
    			console.warn("<RepairMode> was created without expected prop 'onFocus'");
    		}

    		if (/*onBlur*/ ctx[15] === undefined && !("onBlur" in props)) {
    			console.warn("<RepairMode> was created without expected prop 'onBlur'");
    		}
    	}

    	get text() {
    		throw new Error("<RepairMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<RepairMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get readOnly() {
    		throw new Error("<RepairMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readOnly(value) {
    		throw new Error("<RepairMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onParse() {
    		throw new Error("<RepairMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onParse(value) {
    		throw new Error("<RepairMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onRepair() {
    		throw new Error("<RepairMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onRepair(value) {
    		throw new Error("<RepairMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onChange() {
    		throw new Error("<RepairMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onChange(value) {
    		throw new Error("<RepairMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onApply() {
    		throw new Error("<RepairMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onApply(value) {
    		throw new Error("<RepairMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onCancel() {
    		throw new Error("<RepairMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onCancel(value) {
    		throw new Error("<RepairMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onFocus() {
    		throw new Error("<RepairMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onFocus(value) {
    		throw new Error("<RepairMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onBlur() {
    		throw new Error("<RepairMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onBlur(value) {
    		throw new Error("<RepairMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onRenderMenu() {
    		throw new Error("<RepairMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onRenderMenu(value) {
    		throw new Error("<RepairMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\modals\JSONRepairModal.svelte generated by Svelte v3.38.2 */

    function create_fragment$g(ctx) {
    	let jsonrepaircomponent;
    	let updating_text;
    	let current;

    	function jsonrepaircomponent_text_binding(value) {
    		/*jsonrepaircomponent_text_binding*/ ctx[9](value);
    	}

    	let jsonrepaircomponent_props = {
    		onParse: /*onParse*/ ctx[1],
    		onRepair: /*onRepair*/ ctx[2],
    		onApply: /*handleApply*/ ctx[6],
    		onCancel: /*handleCancel*/ ctx[7],
    		onFocus: /*onFocus*/ ctx[3],
    		onBlur: /*onBlur*/ ctx[4],
    		onRenderMenu: /*onRenderMenu*/ ctx[5]
    	};

    	if (/*text*/ ctx[0] !== void 0) {
    		jsonrepaircomponent_props.text = /*text*/ ctx[0];
    	}

    	jsonrepaircomponent = new RepairMode({
    			props: jsonrepaircomponent_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind$2(jsonrepaircomponent, "text", jsonrepaircomponent_text_binding));

    	const block = {
    		c: function create() {
    			create_component(jsonrepaircomponent.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(jsonrepaircomponent, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const jsonrepaircomponent_changes = {};
    			if (dirty & /*onParse*/ 2) jsonrepaircomponent_changes.onParse = /*onParse*/ ctx[1];
    			if (dirty & /*onRepair*/ 4) jsonrepaircomponent_changes.onRepair = /*onRepair*/ ctx[2];
    			if (dirty & /*onFocus*/ 8) jsonrepaircomponent_changes.onFocus = /*onFocus*/ ctx[3];
    			if (dirty & /*onBlur*/ 16) jsonrepaircomponent_changes.onBlur = /*onBlur*/ ctx[4];
    			if (dirty & /*onRenderMenu*/ 32) jsonrepaircomponent_changes.onRenderMenu = /*onRenderMenu*/ ctx[5];

    			if (!updating_text && dirty & /*text*/ 1) {
    				updating_text = true;
    				jsonrepaircomponent_changes.text = /*text*/ ctx[0];
    				add_flush_callback(() => updating_text = false);
    			}

    			jsonrepaircomponent.$set(jsonrepaircomponent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(jsonrepaircomponent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(jsonrepaircomponent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(jsonrepaircomponent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("JSONRepairModal", slots, []);
    	let { text } = $$props;
    	let { onParse } = $$props;
    	let { onRepair } = $$props;
    	let { onApply } = $$props;
    	let { onFocus } = $$props;
    	let { onBlur } = $$props;
    	let { onRenderMenu } = $$props;
    	const { close } = getContext("simple-modal");

    	function handleApply(repairedText) {
    		close();
    		onApply(repairedText);
    	}

    	function handleCancel() {
    		close();
    	}

    	const writable_props = ["text", "onParse", "onRepair", "onApply", "onFocus", "onBlur", "onRenderMenu"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<JSONRepairModal> was created with unknown prop '${key}'`);
    	});

    	function jsonrepaircomponent_text_binding(value) {
    		text = value;
    		$$invalidate(0, text);
    	}

    	$$self.$$set = $$props => {
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("onParse" in $$props) $$invalidate(1, onParse = $$props.onParse);
    		if ("onRepair" in $$props) $$invalidate(2, onRepair = $$props.onRepair);
    		if ("onApply" in $$props) $$invalidate(8, onApply = $$props.onApply);
    		if ("onFocus" in $$props) $$invalidate(3, onFocus = $$props.onFocus);
    		if ("onBlur" in $$props) $$invalidate(4, onBlur = $$props.onBlur);
    		if ("onRenderMenu" in $$props) $$invalidate(5, onRenderMenu = $$props.onRenderMenu);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		JSONRepairComponent: RepairMode,
    		text,
    		onParse,
    		onRepair,
    		onApply,
    		onFocus,
    		onBlur,
    		onRenderMenu,
    		close,
    		handleApply,
    		handleCancel
    	});

    	$$self.$inject_state = $$props => {
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("onParse" in $$props) $$invalidate(1, onParse = $$props.onParse);
    		if ("onRepair" in $$props) $$invalidate(2, onRepair = $$props.onRepair);
    		if ("onApply" in $$props) $$invalidate(8, onApply = $$props.onApply);
    		if ("onFocus" in $$props) $$invalidate(3, onFocus = $$props.onFocus);
    		if ("onBlur" in $$props) $$invalidate(4, onBlur = $$props.onBlur);
    		if ("onRenderMenu" in $$props) $$invalidate(5, onRenderMenu = $$props.onRenderMenu);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		text,
    		onParse,
    		onRepair,
    		onFocus,
    		onBlur,
    		onRenderMenu,
    		handleApply,
    		handleCancel,
    		onApply,
    		jsonrepaircomponent_text_binding
    	];
    }

    class JSONRepairModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$g, create_fragment$g, not_equal, {
    			text: 0,
    			onParse: 1,
    			onRepair: 2,
    			onApply: 8,
    			onFocus: 3,
    			onBlur: 4,
    			onRenderMenu: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "JSONRepairModal",
    			options,
    			id: create_fragment$g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*text*/ ctx[0] === undefined && !("text" in props)) {
    			console.warn("<JSONRepairModal> was created without expected prop 'text'");
    		}

    		if (/*onParse*/ ctx[1] === undefined && !("onParse" in props)) {
    			console.warn("<JSONRepairModal> was created without expected prop 'onParse'");
    		}

    		if (/*onRepair*/ ctx[2] === undefined && !("onRepair" in props)) {
    			console.warn("<JSONRepairModal> was created without expected prop 'onRepair'");
    		}

    		if (/*onApply*/ ctx[8] === undefined && !("onApply" in props)) {
    			console.warn("<JSONRepairModal> was created without expected prop 'onApply'");
    		}

    		if (/*onFocus*/ ctx[3] === undefined && !("onFocus" in props)) {
    			console.warn("<JSONRepairModal> was created without expected prop 'onFocus'");
    		}

    		if (/*onBlur*/ ctx[4] === undefined && !("onBlur" in props)) {
    			console.warn("<JSONRepairModal> was created without expected prop 'onBlur'");
    		}

    		if (/*onRenderMenu*/ ctx[5] === undefined && !("onRenderMenu" in props)) {
    			console.warn("<JSONRepairModal> was created without expected prop 'onRenderMenu'");
    		}
    	}

    	get text() {
    		throw new Error("<JSONRepairModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<JSONRepairModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onParse() {
    		throw new Error("<JSONRepairModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onParse(value) {
    		throw new Error("<JSONRepairModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onRepair() {
    		throw new Error("<JSONRepairModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onRepair(value) {
    		throw new Error("<JSONRepairModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onApply() {
    		throw new Error("<JSONRepairModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onApply(value) {
    		throw new Error("<JSONRepairModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onFocus() {
    		throw new Error("<JSONRepairModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onFocus(value) {
    		throw new Error("<JSONRepairModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onBlur() {
    		throw new Error("<JSONRepairModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onBlur(value) {
    		throw new Error("<JSONRepairModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onRenderMenu() {
    		throw new Error("<JSONRepairModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onRenderMenu(value) {
    		throw new Error("<JSONRepairModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\modes\treemode\contextmenu\ContextMenu.svelte generated by Svelte v3.38.2 */
    const file$e = "node_modules\\svelte-jsoneditor\\src\\components\\modes\\treemode\\contextmenu\\ContextMenu.svelte";

    function create_fragment$f(ctx) {
    	let div10;
    	let div0;
    	let button0;
    	let icon0;
    	let t0;
    	let button0_disabled_value;
    	let t1;
    	let button1;
    	let icon1;
    	let t2;
    	let button1_disabled_value;
    	let t3;
    	let div1;
    	let t4;
    	let div2;
    	let button2;
    	let icon2;
    	let t5;
    	let button2_disabled_value;
    	let t6;
    	let button3;
    	let icon3;
    	let t7;
    	let button3_disabled_value;
    	let t8;
    	let button4;
    	let icon4;
    	let t9;
    	let button4_disabled_value;
    	let t10;
    	let div3;
    	let t11;
    	let div7;
    	let div4;
    	let button5;
    	let icon5;
    	let t12;
    	let button5_disabled_value;
    	let t13;
    	let button6;
    	let icon6;
    	let t14;
    	let button6_disabled_value;
    	let t15;
    	let button7;
    	let icon7;
    	let t16;
    	let button7_disabled_value;
    	let t17;
    	let button8;
    	let icon8;
    	let t18;
    	let button8_disabled_value;
    	let t19;
    	let button9;
    	let icon9;
    	let t20;
    	let button9_disabled_value;
    	let t21;
    	let div6;
    	let div5;
    	let t22;
    	let t23;
    	let t24;
    	let button10;
    	let span1;
    	let span0;
    	let t26;
    	let button10_title_value;
    	let button10_disabled_value;
    	let t27;
    	let button11;
    	let span2;
    	let t29;
    	let button11_title_value;
    	let button11_disabled_value;
    	let t30;
    	let button12;
    	let span3;
    	let t32;
    	let button12_title_value;
    	let button12_disabled_value;
    	let t33;
    	let button13;
    	let span5;
    	let span4;
    	let t35;
    	let button13_title_value;
    	let button13_disabled_value;
    	let t36;
    	let div8;
    	let t37;
    	let div9;
    	let button14;
    	let icon10;
    	let t38;
    	let button14_disabled_value;
    	let t39;
    	let button15;
    	let icon11;
    	let t40;
    	let button15_disabled_value;
    	let current;
    	let mounted;
    	let dispose;
    	icon0 = new Icon({ props: { data: faPen }, $$inline: true });
    	icon1 = new Icon({ props: { data: faPen }, $$inline: true });
    	icon2 = new Icon({ props: { data: faCut }, $$inline: true });
    	icon3 = new Icon({ props: { data: faCopy }, $$inline: true });
    	icon4 = new Icon({ props: { data: faPaste }, $$inline: true });
    	icon5 = new Icon({ props: { data: faTimes }, $$inline: true });
    	icon6 = new Icon({ props: { data: faClone }, $$inline: true });

    	icon7 = new Icon({
    			props: { data: faCropAlt },
    			$$inline: true
    		});

    	icon8 = new Icon({
    			props: { data: faSortAmountDownAlt },
    			$$inline: true
    		});

    	icon9 = new Icon({
    			props: { data: faFilter },
    			$$inline: true
    		});

    	icon10 = new Icon({
    			props: { data: faCaretSquareUp },
    			$$inline: true
    		});

    	icon11 = new Icon({
    			props: { data: faCaretSquareDown },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div10 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			create_component(icon0.$$.fragment);
    			t0 = text(" Edit key");
    			t1 = space();
    			button1 = element("button");
    			create_component(icon1.$$.fragment);
    			t2 = text(" Edit value");
    			t3 = space();
    			div1 = element("div");
    			t4 = space();
    			div2 = element("div");
    			button2 = element("button");
    			create_component(icon2.$$.fragment);
    			t5 = text(" Cut");
    			t6 = space();
    			button3 = element("button");
    			create_component(icon3.$$.fragment);
    			t7 = text(" Copy");
    			t8 = space();
    			button4 = element("button");
    			create_component(icon4.$$.fragment);
    			t9 = text(" Paste");
    			t10 = space();
    			div3 = element("div");
    			t11 = space();
    			div7 = element("div");
    			div4 = element("div");
    			button5 = element("button");
    			create_component(icon5.$$.fragment);
    			t12 = text(" Remove");
    			t13 = space();
    			button6 = element("button");
    			create_component(icon6.$$.fragment);
    			t14 = text(" Duplicate");
    			t15 = space();
    			button7 = element("button");
    			create_component(icon7.$$.fragment);
    			t16 = text(" Extract");
    			t17 = space();
    			button8 = element("button");
    			create_component(icon8.$$.fragment);
    			t18 = text(" Sort");
    			t19 = space();
    			button9 = element("button");
    			create_component(icon9.$$.fragment);
    			t20 = text(" Transform");
    			t21 = space();
    			div6 = element("div");
    			div5 = element("div");
    			t22 = text(/*insertText*/ ctx[8]);
    			t23 = text(":");
    			t24 = space();
    			button10 = element("button");
    			span1 = element("span");
    			span0 = element("span");
    			span0.textContent = `${"+"}`;
    			t26 = text(" Structure");
    			t27 = space();
    			button11 = element("button");
    			span2 = element("span");
    			span2.textContent = `${"{}"}`;
    			t29 = text(" Object");
    			t30 = space();
    			button12 = element("button");
    			span3 = element("span");
    			span3.textContent = "[]";
    			t32 = text(" Array");
    			t33 = space();
    			button13 = element("button");
    			span5 = element("span");
    			span4 = element("span");
    			span4.textContent = "\"";
    			t35 = text(" Value");
    			t36 = space();
    			div8 = element("div");
    			t37 = space();
    			div9 = element("div");
    			button14 = element("button");
    			create_component(icon10.$$.fragment);
    			t38 = text(" Insert before");
    			t39 = space();
    			button15 = element("button");
    			create_component(icon11.$$.fragment);
    			t40 = text(" Insert after");
    			attr_dev(button0, "title", "Edit the key (Double-click on the key)");
    			attr_dev(button0, "data-name", "edit-key");
    			attr_dev(button0, "data-down", "cut,copy,paste");
    			attr_dev(button0, "data-right", "edit-value");
    			button0.disabled = button0_disabled_value = !/*canEditKey*/ ctx[6];
    			attr_dev(button0, "class", "svelte-1pz6wfc");
    			add_location(button0, file$e, 219, 4, 5293);
    			attr_dev(button1, "title", "Edit the value (Double-click on the value)");
    			attr_dev(button1, "data-name", "edit-value");
    			attr_dev(button1, "data-down", "paste,copy,cut");
    			attr_dev(button1, "data-left", "edit-key");
    			button1.disabled = button1_disabled_value = !/*canEditValue*/ ctx[7];
    			attr_dev(button1, "class", "svelte-1pz6wfc");
    			add_location(button1, file$e, 229, 4, 5565);
    			attr_dev(div0, "class", "row svelte-1pz6wfc");
    			add_location(div0, file$e, 218, 2, 5271);
    			attr_dev(div1, "class", "separator svelte-1pz6wfc");
    			add_location(div1, file$e, 240, 2, 5853);
    			attr_dev(button2, "title", "Cut selected contents (Ctrl+X)");
    			attr_dev(button2, "data-name", "cut");
    			attr_dev(button2, "data-up", "edit-key,edit-value");
    			attr_dev(button2, "data-down", "remove");
    			attr_dev(button2, "data-right", "copy");
    			button2.disabled = button2_disabled_value = !/*hasSelectionContents*/ ctx[2];
    			attr_dev(button2, "class", "svelte-1pz6wfc");
    			add_location(button2, file$e, 242, 4, 5907);
    			attr_dev(button3, "title", "Copy selected contents (Ctrl+C)");
    			attr_dev(button3, "data-name", "copy");
    			attr_dev(button3, "data-up", "edit-key,edit-value");
    			attr_dev(button3, "data-down", "insert-structure");
    			attr_dev(button3, "data-left", "cut");
    			attr_dev(button3, "data-right", "paste");
    			button3.disabled = button3_disabled_value = !/*hasSelectionContents*/ ctx[2];
    			attr_dev(button3, "class", "svelte-1pz6wfc");
    			add_location(button3, file$e, 252, 4, 6184);
    			attr_dev(button4, "title", "Paste clipboard contents (Ctrl+V)");
    			attr_dev(button4, "data-name", "paste");
    			attr_dev(button4, "data-up", "edit-value,edit-key");
    			attr_dev(button4, "data-down", "insert-structure");
    			attr_dev(button4, "data-left", "copy");
    			button4.disabled = button4_disabled_value = !/*hasSelection*/ ctx[0];
    			attr_dev(button4, "class", "svelte-1pz6wfc");
    			add_location(button4, file$e, 264, 4, 6504);
    			attr_dev(div2, "class", "row svelte-1pz6wfc");
    			add_location(div2, file$e, 241, 2, 5885);
    			attr_dev(div3, "class", "separator svelte-1pz6wfc");
    			add_location(div3, file$e, 276, 2, 6805);
    			attr_dev(button5, "title", "Remove selected contents (Delete)");
    			attr_dev(button5, "data-name", "remove");
    			attr_dev(button5, "data-up", "cut,copy,paste");
    			attr_dev(button5, "data-down", "duplicate");
    			attr_dev(button5, "data-right", "insert-structure");
    			button5.disabled = button5_disabled_value = !/*hasSelectionContents*/ ctx[2];
    			attr_dev(button5, "class", "svelte-1pz6wfc");
    			add_location(button5, file$e, 279, 6, 6886);
    			attr_dev(button6, "title", "Duplicate selected contents (Ctrl+D)");
    			attr_dev(button6, "data-name", "duplicate");
    			attr_dev(button6, "data-up", "remove");
    			attr_dev(button6, "data-down", "extract");
    			attr_dev(button6, "data-right", "insert-structure");
    			button6.disabled = button6_disabled_value = !/*canDuplicate*/ ctx[4];
    			attr_dev(button6, "class", "svelte-1pz6wfc");
    			add_location(button6, file$e, 290, 6, 7214);
    			attr_dev(button7, "title", "Extract selected contents");
    			attr_dev(button7, "data-name", "extract");
    			attr_dev(button7, "data-up", "duplicate");
    			attr_dev(button7, "data-down", "sort");
    			attr_dev(button7, "data-right", "insert-object");
    			button7.disabled = button7_disabled_value = !/*canExtract*/ ctx[5];
    			attr_dev(button7, "class", "svelte-1pz6wfc");
    			add_location(button7, file$e, 301, 6, 7536);
    			attr_dev(button8, "title", "Sort array or object contents");
    			attr_dev(button8, "data-name", "sort");
    			attr_dev(button8, "data-up", "extract");
    			attr_dev(button8, "data-down", "transform");
    			attr_dev(button8, "data-right", "insert-array");
    			button8.disabled = button8_disabled_value = !/*hasSelectionContents*/ ctx[2];
    			attr_dev(button8, "class", "svelte-1pz6wfc");
    			add_location(button8, file$e, 312, 6, 7838);
    			attr_dev(button9, "title", "Transform array or object contents (filter, sort, project)");
    			attr_dev(button9, "data-name", "transform");
    			attr_dev(button9, "data-up", "sort");
    			attr_dev(button9, "data-down", "insert-before");
    			attr_dev(button9, "data-right", "insert-value");
    			button9.disabled = button9_disabled_value = !/*hasSelectionContents*/ ctx[2];
    			attr_dev(button9, "class", "svelte-1pz6wfc");
    			add_location(button9, file$e, 323, 6, 8157);
    			attr_dev(div4, "class", "column svelte-1pz6wfc");
    			add_location(div4, file$e, 278, 4, 6859);
    			attr_dev(div5, "class", "label svelte-1pz6wfc");
    			add_location(div5, file$e, 336, 6, 8546);
    			attr_dev(span0, "class", "plus svelte-1pz6wfc");
    			add_location(span0, file$e, 348, 29, 8909);
    			attr_dev(span1, "class", "insert svelte-1pz6wfc");
    			add_location(span1, file$e, 348, 8, 8888);
    			attr_dev(button10, "title", button10_title_value = "" + (/*insertText*/ ctx[8] + " structure"));
    			attr_dev(button10, "data-name", "insert-structure");
    			attr_dev(button10, "data-up", "paste,copy,cut");
    			attr_dev(button10, "data-down", "insert-object");
    			attr_dev(button10, "data-left", "duplicate");
    			button10.disabled = button10_disabled_value = !/*hasSelection*/ ctx[0];
    			attr_dev(button10, "class", "svelte-1pz6wfc");
    			add_location(button10, file$e, 339, 6, 8607);
    			attr_dev(span2, "class", "insert svelte-1pz6wfc");
    			add_location(span2, file$e, 359, 8, 9251);
    			attr_dev(button11, "title", button11_title_value = "" + (/*insertText*/ ctx[8] + " object"));
    			attr_dev(button11, "data-name", "insert-object");
    			attr_dev(button11, "data-up", "insert-structure");
    			attr_dev(button11, "data-down", "insert-array");
    			attr_dev(button11, "data-left", "extract");
    			button11.disabled = button11_disabled_value = !/*hasSelection*/ ctx[0];
    			attr_dev(button11, "class", "svelte-1pz6wfc");
    			add_location(button11, file$e, 350, 6, 8980);
    			attr_dev(span3, "class", "insert svelte-1pz6wfc");
    			add_location(span3, file$e, 370, 8, 9577);
    			attr_dev(button12, "title", button12_title_value = "" + (/*insertText*/ ctx[8] + " array"));
    			attr_dev(button12, "data-name", "insert-array");
    			attr_dev(button12, "data-up", "insert-object");
    			attr_dev(button12, "data-down", "insert-value");
    			attr_dev(button12, "data-left", "sort");
    			button12.disabled = button12_disabled_value = !/*hasSelection*/ ctx[0];
    			attr_dev(button12, "class", "svelte-1pz6wfc");
    			add_location(button12, file$e, 361, 6, 9315);
    			attr_dev(span4, "class", "quote svelte-1pz6wfc");
    			add_location(span4, file$e, 381, 29, 9923);
    			attr_dev(span5, "class", "insert svelte-1pz6wfc");
    			add_location(span5, file$e, 381, 8, 9902);
    			attr_dev(button13, "title", button13_title_value = "" + (/*insertText*/ ctx[8] + " value"));
    			attr_dev(button13, "data-name", "insert-value");
    			attr_dev(button13, "data-up", "insert-array");
    			attr_dev(button13, "data-down", "insert-after");
    			attr_dev(button13, "data-left", "transform");
    			button13.disabled = button13_disabled_value = !/*hasSelection*/ ctx[0];
    			attr_dev(button13, "class", "svelte-1pz6wfc");
    			add_location(button13, file$e, 372, 6, 9636);
    			attr_dev(div6, "class", "column svelte-1pz6wfc");
    			add_location(div6, file$e, 335, 4, 8519);
    			attr_dev(div7, "class", "row svelte-1pz6wfc");
    			add_location(div7, file$e, 277, 2, 6837);
    			attr_dev(div8, "class", "separator svelte-1pz6wfc");
    			add_location(div8, file$e, 385, 2, 10003);
    			attr_dev(button14, "title", "Select area before current entry to insert or paste contents");
    			attr_dev(button14, "data-name", "insert-before");
    			attr_dev(button14, "data-up", "transform");
    			attr_dev(button14, "data-right", "insert-after");
    			button14.disabled = button14_disabled_value = !/*hasSelectionContents*/ ctx[2] || /*rootSelected*/ ctx[1];
    			attr_dev(button14, "class", "svelte-1pz6wfc");
    			add_location(button14, file$e, 387, 4, 10057);
    			attr_dev(button15, "title", "Select area after current entry to insert or paste contents");
    			attr_dev(button15, "data-name", "insert-after");
    			attr_dev(button15, "data-up", "insert-value");
    			attr_dev(button15, "data-left", "insert-before");
    			button15.disabled = button15_disabled_value = !/*hasSelectionContents*/ ctx[2] || /*rootSelected*/ ctx[1];
    			attr_dev(button15, "class", "svelte-1pz6wfc");
    			add_location(button15, file$e, 397, 4, 10397);
    			attr_dev(div9, "class", "row svelte-1pz6wfc");
    			add_location(div9, file$e, 386, 2, 10035);
    			attr_dev(div10, "class", "jsoneditor-contextmenu svelte-1pz6wfc");
    			add_location(div10, file$e, 213, 0, 5171);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div10, anchor);
    			append_dev(div10, div0);
    			append_dev(div0, button0);
    			mount_component(icon0, button0, null);
    			append_dev(button0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, button1);
    			mount_component(icon1, button1, null);
    			append_dev(button1, t2);
    			append_dev(div10, t3);
    			append_dev(div10, div1);
    			append_dev(div10, t4);
    			append_dev(div10, div2);
    			append_dev(div2, button2);
    			mount_component(icon2, button2, null);
    			append_dev(button2, t5);
    			append_dev(div2, t6);
    			append_dev(div2, button3);
    			mount_component(icon3, button3, null);
    			append_dev(button3, t7);
    			append_dev(div2, t8);
    			append_dev(div2, button4);
    			mount_component(icon4, button4, null);
    			append_dev(button4, t9);
    			append_dev(div10, t10);
    			append_dev(div10, div3);
    			append_dev(div10, t11);
    			append_dev(div10, div7);
    			append_dev(div7, div4);
    			append_dev(div4, button5);
    			mount_component(icon5, button5, null);
    			append_dev(button5, t12);
    			append_dev(div4, t13);
    			append_dev(div4, button6);
    			mount_component(icon6, button6, null);
    			append_dev(button6, t14);
    			append_dev(div4, t15);
    			append_dev(div4, button7);
    			mount_component(icon7, button7, null);
    			append_dev(button7, t16);
    			append_dev(div4, t17);
    			append_dev(div4, button8);
    			mount_component(icon8, button8, null);
    			append_dev(button8, t18);
    			append_dev(div4, t19);
    			append_dev(div4, button9);
    			mount_component(icon9, button9, null);
    			append_dev(button9, t20);
    			append_dev(div7, t21);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, t22);
    			append_dev(div5, t23);
    			append_dev(div6, t24);
    			append_dev(div6, button10);
    			append_dev(button10, span1);
    			append_dev(span1, span0);
    			append_dev(button10, t26);
    			append_dev(div6, t27);
    			append_dev(div6, button11);
    			append_dev(button11, span2);
    			append_dev(button11, t29);
    			append_dev(div6, t30);
    			append_dev(div6, button12);
    			append_dev(button12, span3);
    			append_dev(button12, t32);
    			append_dev(div6, t33);
    			append_dev(div6, button13);
    			append_dev(button13, span5);
    			append_dev(span5, span4);
    			append_dev(button13, t35);
    			append_dev(div10, t36);
    			append_dev(div10, div8);
    			append_dev(div10, t37);
    			append_dev(div10, div9);
    			append_dev(div9, button14);
    			mount_component(icon10, button14, null);
    			append_dev(button14, t38);
    			append_dev(div9, t39);
    			append_dev(div9, button15);
    			mount_component(icon11, button15, null);
    			append_dev(button15, t40);
    			/*div10_binding*/ ctx[43](div10);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*handleEditKey*/ ctx[9], false, false, false),
    					listen_dev(button1, "click", /*handleEditValue*/ ctx[10], false, false, false),
    					listen_dev(button2, "click", /*handleCut*/ ctx[11], false, false, false),
    					listen_dev(button3, "click", /*handleCopy*/ ctx[12], false, false, false),
    					listen_dev(button4, "click", /*handlePaste*/ ctx[13], false, false, false),
    					listen_dev(button5, "click", /*handleRemove*/ ctx[14], false, false, false),
    					listen_dev(button6, "click", /*handleDuplicate*/ ctx[15], false, false, false),
    					listen_dev(button7, "click", /*handleExtract*/ ctx[16], false, false, false),
    					listen_dev(button8, "click", /*handleSort*/ ctx[18], false, false, false),
    					listen_dev(button9, "click", /*handleTransform*/ ctx[19], false, false, false),
    					listen_dev(button10, "click", /*click_handler*/ ctx[39], false, false, false),
    					listen_dev(button11, "click", /*click_handler_1*/ ctx[40], false, false, false),
    					listen_dev(button12, "click", /*click_handler_2*/ ctx[41], false, false, false),
    					listen_dev(button13, "click", /*click_handler_3*/ ctx[42], false, false, false),
    					listen_dev(button14, "click", /*handleInsertBefore*/ ctx[20], false, false, false),
    					listen_dev(button15, "click", /*handleInsertAfter*/ ctx[21], false, false, false),
    					listen_dev(div10, "keydown", /*handleKeyDown*/ ctx[22], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*canEditKey*/ 64 && button0_disabled_value !== (button0_disabled_value = !/*canEditKey*/ ctx[6])) {
    				prop_dev(button0, "disabled", button0_disabled_value);
    			}

    			if (!current || dirty[0] & /*canEditValue*/ 128 && button1_disabled_value !== (button1_disabled_value = !/*canEditValue*/ ctx[7])) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}

    			if (!current || dirty[0] & /*hasSelectionContents*/ 4 && button2_disabled_value !== (button2_disabled_value = !/*hasSelectionContents*/ ctx[2])) {
    				prop_dev(button2, "disabled", button2_disabled_value);
    			}

    			if (!current || dirty[0] & /*hasSelectionContents*/ 4 && button3_disabled_value !== (button3_disabled_value = !/*hasSelectionContents*/ ctx[2])) {
    				prop_dev(button3, "disabled", button3_disabled_value);
    			}

    			if (!current || dirty[0] & /*hasSelection*/ 1 && button4_disabled_value !== (button4_disabled_value = !/*hasSelection*/ ctx[0])) {
    				prop_dev(button4, "disabled", button4_disabled_value);
    			}

    			if (!current || dirty[0] & /*hasSelectionContents*/ 4 && button5_disabled_value !== (button5_disabled_value = !/*hasSelectionContents*/ ctx[2])) {
    				prop_dev(button5, "disabled", button5_disabled_value);
    			}

    			if (!current || dirty[0] & /*canDuplicate*/ 16 && button6_disabled_value !== (button6_disabled_value = !/*canDuplicate*/ ctx[4])) {
    				prop_dev(button6, "disabled", button6_disabled_value);
    			}

    			if (!current || dirty[0] & /*canExtract*/ 32 && button7_disabled_value !== (button7_disabled_value = !/*canExtract*/ ctx[5])) {
    				prop_dev(button7, "disabled", button7_disabled_value);
    			}

    			if (!current || dirty[0] & /*hasSelectionContents*/ 4 && button8_disabled_value !== (button8_disabled_value = !/*hasSelectionContents*/ ctx[2])) {
    				prop_dev(button8, "disabled", button8_disabled_value);
    			}

    			if (!current || dirty[0] & /*hasSelectionContents*/ 4 && button9_disabled_value !== (button9_disabled_value = !/*hasSelectionContents*/ ctx[2])) {
    				prop_dev(button9, "disabled", button9_disabled_value);
    			}

    			if (!current || dirty[0] & /*insertText*/ 256) set_data_dev(t22, /*insertText*/ ctx[8]);

    			if (!current || dirty[0] & /*insertText*/ 256 && button10_title_value !== (button10_title_value = "" + (/*insertText*/ ctx[8] + " structure"))) {
    				attr_dev(button10, "title", button10_title_value);
    			}

    			if (!current || dirty[0] & /*hasSelection*/ 1 && button10_disabled_value !== (button10_disabled_value = !/*hasSelection*/ ctx[0])) {
    				prop_dev(button10, "disabled", button10_disabled_value);
    			}

    			if (!current || dirty[0] & /*insertText*/ 256 && button11_title_value !== (button11_title_value = "" + (/*insertText*/ ctx[8] + " object"))) {
    				attr_dev(button11, "title", button11_title_value);
    			}

    			if (!current || dirty[0] & /*hasSelection*/ 1 && button11_disabled_value !== (button11_disabled_value = !/*hasSelection*/ ctx[0])) {
    				prop_dev(button11, "disabled", button11_disabled_value);
    			}

    			if (!current || dirty[0] & /*insertText*/ 256 && button12_title_value !== (button12_title_value = "" + (/*insertText*/ ctx[8] + " array"))) {
    				attr_dev(button12, "title", button12_title_value);
    			}

    			if (!current || dirty[0] & /*hasSelection*/ 1 && button12_disabled_value !== (button12_disabled_value = !/*hasSelection*/ ctx[0])) {
    				prop_dev(button12, "disabled", button12_disabled_value);
    			}

    			if (!current || dirty[0] & /*insertText*/ 256 && button13_title_value !== (button13_title_value = "" + (/*insertText*/ ctx[8] + " value"))) {
    				attr_dev(button13, "title", button13_title_value);
    			}

    			if (!current || dirty[0] & /*hasSelection*/ 1 && button13_disabled_value !== (button13_disabled_value = !/*hasSelection*/ ctx[0])) {
    				prop_dev(button13, "disabled", button13_disabled_value);
    			}

    			if (!current || dirty[0] & /*hasSelectionContents, rootSelected*/ 6 && button14_disabled_value !== (button14_disabled_value = !/*hasSelectionContents*/ ctx[2] || /*rootSelected*/ ctx[1])) {
    				prop_dev(button14, "disabled", button14_disabled_value);
    			}

    			if (!current || dirty[0] & /*hasSelectionContents, rootSelected*/ 6 && button15_disabled_value !== (button15_disabled_value = !/*hasSelectionContents*/ ctx[2] || /*rootSelected*/ ctx[1])) {
    				prop_dev(button15, "disabled", button15_disabled_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon0.$$.fragment, local);
    			transition_in(icon1.$$.fragment, local);
    			transition_in(icon2.$$.fragment, local);
    			transition_in(icon3.$$.fragment, local);
    			transition_in(icon4.$$.fragment, local);
    			transition_in(icon5.$$.fragment, local);
    			transition_in(icon6.$$.fragment, local);
    			transition_in(icon7.$$.fragment, local);
    			transition_in(icon8.$$.fragment, local);
    			transition_in(icon9.$$.fragment, local);
    			transition_in(icon10.$$.fragment, local);
    			transition_in(icon11.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon0.$$.fragment, local);
    			transition_out(icon1.$$.fragment, local);
    			transition_out(icon2.$$.fragment, local);
    			transition_out(icon3.$$.fragment, local);
    			transition_out(icon4.$$.fragment, local);
    			transition_out(icon5.$$.fragment, local);
    			transition_out(icon6.$$.fragment, local);
    			transition_out(icon7.$$.fragment, local);
    			transition_out(icon8.$$.fragment, local);
    			transition_out(icon9.$$.fragment, local);
    			transition_out(icon10.$$.fragment, local);
    			transition_out(icon11.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div10);
    			destroy_component(icon0);
    			destroy_component(icon1);
    			destroy_component(icon2);
    			destroy_component(icon3);
    			destroy_component(icon4);
    			destroy_component(icon5);
    			destroy_component(icon6);
    			destroy_component(icon7);
    			destroy_component(icon8);
    			destroy_component(icon9);
    			destroy_component(icon10);
    			destroy_component(icon11);
    			/*div10_binding*/ ctx[43](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let hasSelection;
    	let rootSelected;
    	let hasSelectionContents;
    	let canDuplicate;
    	let canExtract;
    	let canEditKey;
    	let canEditValue;
    	let insertText;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContextMenu", slots, []);
    	let { json } = $$props;
    	let { selection } = $$props;
    	let { onCloseContextMenu } = $$props;
    	let { onEditKey } = $$props;
    	let { onEditValue } = $$props;
    	let { onCut } = $$props;
    	let { onCopy } = $$props;
    	let { onPaste } = $$props;
    	let { onRemove } = $$props;
    	let { onDuplicate } = $$props;
    	let { onExtract } = $$props;
    	let { onInsertBefore } = $$props;
    	let { onInsert } = $$props;
    	let { onInsertAfter } = $$props;
    	let { onSort } = $$props;
    	let { onTransform } = $$props;
    	let refContextMenu;

    	onMount(() => {
    		setTimeout(() => {
    			const firstEnabledButton = [...refContextMenu.querySelectorAll("button")].find(button => !button.disabled);

    			if (firstEnabledButton) {
    				firstEnabledButton.focus();
    			}
    		});
    	});

    	function handleEditKey() {
    		onCloseContextMenu();
    		onEditKey();
    	}

    	function handleEditValue() {
    		onCloseContextMenu();
    		onEditValue();
    	}

    	function handleCut() {
    		onCloseContextMenu();
    		onCut();
    	}

    	function handleCopy() {
    		onCloseContextMenu();
    		onCopy();
    	}

    	function handlePaste() {
    		onCloseContextMenu();
    		onPaste();
    	}

    	function handleRemove() {
    		onCloseContextMenu();
    		onRemove();
    	}

    	function handleDuplicate() {
    		onCloseContextMenu();
    		onDuplicate();
    	}

    	function handleExtract() {
    		onCloseContextMenu();
    		onExtract();
    	}

    	function handleInsert(type) {
    		onCloseContextMenu();
    		onInsert(type);
    	}

    	function handleSort() {
    		onCloseContextMenu();
    		onSort();
    	}

    	function handleTransform() {
    		onCloseContextMenu();
    		onTransform();
    	}

    	function handleInsertBefore() {
    		onCloseContextMenu();
    		onInsertBefore();
    	}

    	function handleInsertAfter() {
    		onCloseContextMenu();
    		onInsertAfter();
    	}

    	function handleKeyDown(event) {
    		const combo = keyComboFromEvent(event).replace(/^Command\+/, "Ctrl+");

    		/**
     * Find first enabled sibling button.
     * Uses hints from the button attributes itself: data-name, data-up,
     * data-down, data-left, data-right.
     * @param {Element} currentButton
     * @param {'left' | 'right' | 'up' | 'down'} direction
     */
    		function findNextButton(currentButton, direction) {
    			const optionsString = currentButton.getAttribute("data-" + direction);

    			if (optionsString) {
    				const options = optionsString.split(",");

    				// Step 1: find exact match
    				for (const option of options) {
    					const match = refContextMenu.querySelector(`button[data-name="${option}"]`);

    					if (match && !match.disabled) {
    						return match;
    					}
    				}

    				// Step 2: recurse over multiple buttons to find an enabled one
    				for (const option of options) {
    					const match = refContextMenu.querySelector(`button[data-name="${option}"]`);

    					if (match && match.disabled) {
    						const match2 = findNextButton(match, direction);

    						if (match2) {
    							return match2;
    						}
    					}
    				}
    			}
    		}

    		function focusNextButton(currentButton, direction) {
    			const next = findNextButton(currentButton, direction);

    			if (next) {
    				next.focus();
    			}
    		}

    		if (combo === "Up" || combo === "Down" || combo === "Left" || combo === "Right") {
    			event.preventDefault();
    			focusNextButton(event.target, combo.toLowerCase());
    		}
    	}

    	const writable_props = [
    		"json",
    		"selection",
    		"onCloseContextMenu",
    		"onEditKey",
    		"onEditValue",
    		"onCut",
    		"onCopy",
    		"onPaste",
    		"onRemove",
    		"onDuplicate",
    		"onExtract",
    		"onInsertBefore",
    		"onInsert",
    		"onInsertAfter",
    		"onSort",
    		"onTransform"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ContextMenu> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => handleInsert("structure");
    	const click_handler_1 = () => handleInsert("object");
    	const click_handler_2 = () => handleInsert("array");
    	const click_handler_3 = () => handleInsert("value");

    	function div10_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			refContextMenu = $$value;
    			$$invalidate(3, refContextMenu);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("json" in $$props) $$invalidate(23, json = $$props.json);
    		if ("selection" in $$props) $$invalidate(24, selection = $$props.selection);
    		if ("onCloseContextMenu" in $$props) $$invalidate(25, onCloseContextMenu = $$props.onCloseContextMenu);
    		if ("onEditKey" in $$props) $$invalidate(26, onEditKey = $$props.onEditKey);
    		if ("onEditValue" in $$props) $$invalidate(27, onEditValue = $$props.onEditValue);
    		if ("onCut" in $$props) $$invalidate(28, onCut = $$props.onCut);
    		if ("onCopy" in $$props) $$invalidate(29, onCopy = $$props.onCopy);
    		if ("onPaste" in $$props) $$invalidate(30, onPaste = $$props.onPaste);
    		if ("onRemove" in $$props) $$invalidate(31, onRemove = $$props.onRemove);
    		if ("onDuplicate" in $$props) $$invalidate(32, onDuplicate = $$props.onDuplicate);
    		if ("onExtract" in $$props) $$invalidate(33, onExtract = $$props.onExtract);
    		if ("onInsertBefore" in $$props) $$invalidate(34, onInsertBefore = $$props.onInsertBefore);
    		if ("onInsert" in $$props) $$invalidate(35, onInsert = $$props.onInsert);
    		if ("onInsertAfter" in $$props) $$invalidate(36, onInsertAfter = $$props.onInsertAfter);
    		if ("onSort" in $$props) $$invalidate(37, onSort = $$props.onSort);
    		if ("onTransform" in $$props) $$invalidate(38, onTransform = $$props.onTransform);
    	};

    	$$self.$capture_state = () => ({
    		faCaretSquareDown,
    		faCaretSquareUp,
    		faClone,
    		faCopy,
    		faCropAlt,
    		faCut,
    		faFilter,
    		faPaste,
    		faPen,
    		faSortAmountDownAlt,
    		faTimes,
    		getIn: immutableJSONPatch.getIn,
    		initial,
    		isEmpty,
    		onMount,
    		Icon,
    		SELECTION_TYPE,
    		keyComboFromEvent,
    		isObjectOrArray,
    		json,
    		selection,
    		onCloseContextMenu,
    		onEditKey,
    		onEditValue,
    		onCut,
    		onCopy,
    		onPaste,
    		onRemove,
    		onDuplicate,
    		onExtract,
    		onInsertBefore,
    		onInsert,
    		onInsertAfter,
    		onSort,
    		onTransform,
    		refContextMenu,
    		handleEditKey,
    		handleEditValue,
    		handleCut,
    		handleCopy,
    		handlePaste,
    		handleRemove,
    		handleDuplicate,
    		handleExtract,
    		handleInsert,
    		handleSort,
    		handleTransform,
    		handleInsertBefore,
    		handleInsertAfter,
    		handleKeyDown,
    		hasSelection,
    		rootSelected,
    		hasSelectionContents,
    		canDuplicate,
    		canExtract,
    		canEditKey,
    		canEditValue,
    		insertText
    	});

    	$$self.$inject_state = $$props => {
    		if ("json" in $$props) $$invalidate(23, json = $$props.json);
    		if ("selection" in $$props) $$invalidate(24, selection = $$props.selection);
    		if ("onCloseContextMenu" in $$props) $$invalidate(25, onCloseContextMenu = $$props.onCloseContextMenu);
    		if ("onEditKey" in $$props) $$invalidate(26, onEditKey = $$props.onEditKey);
    		if ("onEditValue" in $$props) $$invalidate(27, onEditValue = $$props.onEditValue);
    		if ("onCut" in $$props) $$invalidate(28, onCut = $$props.onCut);
    		if ("onCopy" in $$props) $$invalidate(29, onCopy = $$props.onCopy);
    		if ("onPaste" in $$props) $$invalidate(30, onPaste = $$props.onPaste);
    		if ("onRemove" in $$props) $$invalidate(31, onRemove = $$props.onRemove);
    		if ("onDuplicate" in $$props) $$invalidate(32, onDuplicate = $$props.onDuplicate);
    		if ("onExtract" in $$props) $$invalidate(33, onExtract = $$props.onExtract);
    		if ("onInsertBefore" in $$props) $$invalidate(34, onInsertBefore = $$props.onInsertBefore);
    		if ("onInsert" in $$props) $$invalidate(35, onInsert = $$props.onInsert);
    		if ("onInsertAfter" in $$props) $$invalidate(36, onInsertAfter = $$props.onInsertAfter);
    		if ("onSort" in $$props) $$invalidate(37, onSort = $$props.onSort);
    		if ("onTransform" in $$props) $$invalidate(38, onTransform = $$props.onTransform);
    		if ("refContextMenu" in $$props) $$invalidate(3, refContextMenu = $$props.refContextMenu);
    		if ("hasSelection" in $$props) $$invalidate(0, hasSelection = $$props.hasSelection);
    		if ("rootSelected" in $$props) $$invalidate(1, rootSelected = $$props.rootSelected);
    		if ("hasSelectionContents" in $$props) $$invalidate(2, hasSelectionContents = $$props.hasSelectionContents);
    		if ("canDuplicate" in $$props) $$invalidate(4, canDuplicate = $$props.canDuplicate);
    		if ("canExtract" in $$props) $$invalidate(5, canExtract = $$props.canExtract);
    		if ("canEditKey" in $$props) $$invalidate(6, canEditKey = $$props.canEditKey);
    		if ("canEditValue" in $$props) $$invalidate(7, canEditValue = $$props.canEditValue);
    		if ("insertText" in $$props) $$invalidate(8, insertText = $$props.insertText);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*selection*/ 16777216) {
    			$$invalidate(0, hasSelection = selection != null);
    		}

    		if ($$self.$$.dirty[0] & /*hasSelection, selection*/ 16777217) {
    			$$invalidate(1, rootSelected = hasSelection && isEmpty(selection.focusPath));
    		}

    		if ($$self.$$.dirty[0] & /*selection*/ 16777216) {
    			$$invalidate(2, hasSelectionContents = selection != null && (selection.type === SELECTION_TYPE.MULTI || selection.type === SELECTION_TYPE.KEY || selection.type === SELECTION_TYPE.VALUE));
    		}

    		if ($$self.$$.dirty[0] & /*selection, hasSelectionContents, rootSelected*/ 16777222) {
    			$$invalidate(4, canDuplicate = selection != null && hasSelectionContents && !rootSelected); // must not be root
    		}

    		if ($$self.$$.dirty[0] & /*selection, rootSelected*/ 16777218) {
    			$$invalidate(5, canExtract = selection != null && (selection.type === SELECTION_TYPE.MULTI || selection.type === SELECTION_TYPE.VALUE) && !rootSelected); // must not be root
    		}

    		if ($$self.$$.dirty[0] & /*selection, rootSelected, json*/ 25165826) {
    			$$invalidate(6, canEditKey = selection != null && (selection.type === SELECTION_TYPE.KEY || selection.type === SELECTION_TYPE.VALUE || selection.type === SELECTION_TYPE.MULTI && selection.paths.length === 1) && !rootSelected && !Array.isArray(immutableJSONPatch.getIn(json, initial(selection.focusPath))));
    		}

    		if ($$self.$$.dirty[0] & /*selection, json*/ 25165824) {
    			$$invalidate(7, canEditValue = selection != null && (selection.type === SELECTION_TYPE.KEY || selection.type === SELECTION_TYPE.VALUE || selection.type === SELECTION_TYPE.MULTI && selection.paths.length === 1) && !isObjectOrArray(immutableJSONPatch.getIn(json, selection.focusPath)));
    		}

    		if ($$self.$$.dirty[0] & /*hasSelectionContents*/ 4) {
    			$$invalidate(8, insertText = hasSelectionContents ? "Replace with" : "Insert");
    		}
    	};

    	return [
    		hasSelection,
    		rootSelected,
    		hasSelectionContents,
    		refContextMenu,
    		canDuplicate,
    		canExtract,
    		canEditKey,
    		canEditValue,
    		insertText,
    		handleEditKey,
    		handleEditValue,
    		handleCut,
    		handleCopy,
    		handlePaste,
    		handleRemove,
    		handleDuplicate,
    		handleExtract,
    		handleInsert,
    		handleSort,
    		handleTransform,
    		handleInsertBefore,
    		handleInsertAfter,
    		handleKeyDown,
    		json,
    		selection,
    		onCloseContextMenu,
    		onEditKey,
    		onEditValue,
    		onCut,
    		onCopy,
    		onPaste,
    		onRemove,
    		onDuplicate,
    		onExtract,
    		onInsertBefore,
    		onInsert,
    		onInsertAfter,
    		onSort,
    		onTransform,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		div10_binding
    	];
    }

    class ContextMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$f,
    			create_fragment$f,
    			not_equal,
    			{
    				json: 23,
    				selection: 24,
    				onCloseContextMenu: 25,
    				onEditKey: 26,
    				onEditValue: 27,
    				onCut: 28,
    				onCopy: 29,
    				onPaste: 30,
    				onRemove: 31,
    				onDuplicate: 32,
    				onExtract: 33,
    				onInsertBefore: 34,
    				onInsert: 35,
    				onInsertAfter: 36,
    				onSort: 37,
    				onTransform: 38
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContextMenu",
    			options,
    			id: create_fragment$f.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*json*/ ctx[23] === undefined && !("json" in props)) {
    			console.warn("<ContextMenu> was created without expected prop 'json'");
    		}

    		if (/*selection*/ ctx[24] === undefined && !("selection" in props)) {
    			console.warn("<ContextMenu> was created without expected prop 'selection'");
    		}

    		if (/*onCloseContextMenu*/ ctx[25] === undefined && !("onCloseContextMenu" in props)) {
    			console.warn("<ContextMenu> was created without expected prop 'onCloseContextMenu'");
    		}

    		if (/*onEditKey*/ ctx[26] === undefined && !("onEditKey" in props)) {
    			console.warn("<ContextMenu> was created without expected prop 'onEditKey'");
    		}

    		if (/*onEditValue*/ ctx[27] === undefined && !("onEditValue" in props)) {
    			console.warn("<ContextMenu> was created without expected prop 'onEditValue'");
    		}

    		if (/*onCut*/ ctx[28] === undefined && !("onCut" in props)) {
    			console.warn("<ContextMenu> was created without expected prop 'onCut'");
    		}

    		if (/*onCopy*/ ctx[29] === undefined && !("onCopy" in props)) {
    			console.warn("<ContextMenu> was created without expected prop 'onCopy'");
    		}

    		if (/*onPaste*/ ctx[30] === undefined && !("onPaste" in props)) {
    			console.warn("<ContextMenu> was created without expected prop 'onPaste'");
    		}

    		if (/*onRemove*/ ctx[31] === undefined && !("onRemove" in props)) {
    			console.warn("<ContextMenu> was created without expected prop 'onRemove'");
    		}

    		if (/*onDuplicate*/ ctx[32] === undefined && !("onDuplicate" in props)) {
    			console.warn("<ContextMenu> was created without expected prop 'onDuplicate'");
    		}

    		if (/*onExtract*/ ctx[33] === undefined && !("onExtract" in props)) {
    			console.warn("<ContextMenu> was created without expected prop 'onExtract'");
    		}

    		if (/*onInsertBefore*/ ctx[34] === undefined && !("onInsertBefore" in props)) {
    			console.warn("<ContextMenu> was created without expected prop 'onInsertBefore'");
    		}

    		if (/*onInsert*/ ctx[35] === undefined && !("onInsert" in props)) {
    			console.warn("<ContextMenu> was created without expected prop 'onInsert'");
    		}

    		if (/*onInsertAfter*/ ctx[36] === undefined && !("onInsertAfter" in props)) {
    			console.warn("<ContextMenu> was created without expected prop 'onInsertAfter'");
    		}

    		if (/*onSort*/ ctx[37] === undefined && !("onSort" in props)) {
    			console.warn("<ContextMenu> was created without expected prop 'onSort'");
    		}

    		if (/*onTransform*/ ctx[38] === undefined && !("onTransform" in props)) {
    			console.warn("<ContextMenu> was created without expected prop 'onTransform'");
    		}
    	}

    	get json() {
    		throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set json(value) {
    		throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selection() {
    		throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selection(value) {
    		throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onCloseContextMenu() {
    		throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onCloseContextMenu(value) {
    		throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onEditKey() {
    		throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onEditKey(value) {
    		throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onEditValue() {
    		throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onEditValue(value) {
    		throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onCut() {
    		throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onCut(value) {
    		throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onCopy() {
    		throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onCopy(value) {
    		throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onPaste() {
    		throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onPaste(value) {
    		throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onRemove() {
    		throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onRemove(value) {
    		throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onDuplicate() {
    		throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onDuplicate(value) {
    		throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onExtract() {
    		throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onExtract(value) {
    		throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onInsertBefore() {
    		throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onInsertBefore(value) {
    		throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onInsert() {
    		throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onInsert(value) {
    		throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onInsertAfter() {
    		throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onInsertAfter(value) {
    		throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSort() {
    		throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSort(value) {
    		throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onTransform() {
    		throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onTransform(value) {
    		throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /*!
      Copyright (c) 2018 Jed Watson.
      Licensed under the MIT License (MIT), see
      http://jedwatson.github.io/classnames
    */

    var classnames = createCommonjsModule(function (module) {
    /* global define */

    (function () {

    	var hasOwn = {}.hasOwnProperty;

    	function classNames() {
    		var classes = [];

    		for (var i = 0; i < arguments.length; i++) {
    			var arg = arguments[i];
    			if (!arg) continue;

    			var argType = typeof arg;

    			if (argType === 'string' || argType === 'number') {
    				classes.push(arg);
    			} else if (Array.isArray(arg)) {
    				if (arg.length) {
    					var inner = classNames.apply(null, arg);
    					if (inner) {
    						classes.push(inner);
    					}
    				}
    			} else if (argType === 'object') {
    				if (arg.toString === Object.prototype.toString) {
    					for (var key in arg) {
    						if (hasOwn.call(arg, key) && arg[key]) {
    							classes.push(key);
    						}
    					}
    				} else {
    					classes.push(arg.toString());
    				}
    			}
    		}

    		return classes.join(' ');
    	}

    	if (module.exports) {
    		classNames.default = classNames;
    		module.exports = classNames;
    	} else {
    		window.classNames = classNames;
    	}
    }());
    });

    /* node_modules\svelte-jsoneditor\src\components\modes\treemode\CollapsedItems.svelte generated by Svelte v3.38.2 */
    const file$d = "node_modules\\svelte-jsoneditor\\src\\components\\modes\\treemode\\CollapsedItems.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (43:5) {#each expandItemsSections as expandItemsSection     }
    function create_each_block$2(ctx) {
    	let button;
    	let t0;
    	let t1_value = /*expandItemsSection*/ ctx[11].start + "";
    	let t1;
    	let t2;
    	let t3_value = /*expandItemsSection*/ ctx[11].end + "";
    	let t3;
    	let t4;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[10](/*expandItemsSection*/ ctx[11]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			t0 = text("show ");
    			t1 = text(t1_value);
    			t2 = text("-");
    			t3 = text(t3_value);
    			t4 = space();
    			attr_dev(button, "class", "expand-items svelte-1w9eqxv");
    			add_location(button, file$d, 43, 5, 1204);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t0);
    			append_dev(button, t1);
    			append_dev(button, t2);
    			append_dev(button, t3);
    			append_dev(button, t4);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*expandItemsSections*/ 16 && t1_value !== (t1_value = /*expandItemsSection*/ ctx[11].start + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*expandItemsSections*/ 16 && t3_value !== (t3_value = /*expandItemsSection*/ ctx[11].end + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(43:5) {#each expandItemsSections as expandItemsSection     }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let div2_style_value;
    	let mounted;
    	let dispose;
    	let each_value = /*expandItemsSections*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text("Items ");
    			t1 = text(/*startIndex*/ ctx[2]);
    			t2 = text("-");
    			t3 = text(/*endIndex*/ ctx[3]);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "text svelte-1w9eqxv");
    			add_location(div0, file$d, 41, 4, 1092);
    			add_location(div1, file$d, 40, 2, 1082);
    			attr_dev(div2, "class", "collapsed-items svelte-1w9eqxv");
    			attr_dev(div2, "style", div2_style_value = /*getIndentationStyle*/ ctx[5](/*path*/ ctx[0].length + 2));
    			add_location(div2, file$d, 35, 0, 967);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, t2);
    			append_dev(div0, t3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			if (!mounted) {
    				dispose = listen_dev(div2, "mousemove", handleMouseMove, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*startIndex*/ 4) set_data_dev(t1, /*startIndex*/ ctx[2]);
    			if (dirty & /*endIndex*/ 8) set_data_dev(t3, /*endIndex*/ ctx[3]);

    			if (dirty & /*onExpandSection, path, expandItemsSections*/ 19) {
    				each_value = /*expandItemsSections*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*path*/ 1 && div2_style_value !== (div2_style_value = /*getIndentationStyle*/ ctx[5](/*path*/ ctx[0].length + 2))) {
    				attr_dev(div2, "style", div2_style_value);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function handleMouseMove(event) {
    	// prevent the whole array from being selected whilst dragging over
    	// a section with collapsed items
    	event.stopPropagation();
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let visibleSection;
    	let startIndex;
    	let endIndex;
    	let expandItemsSections;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CollapsedItems", slots, []);
    	let { visibleSections } = $$props;
    	let { sectionIndex } = $$props;
    	let { total } = $$props;
    	let { path } = $$props;
    	let { onExpandSection } = $$props;

    	// TODO: this is duplicated from the same function in JSONNode
    	function getIndentationStyle(level) {
    		return `margin-left: ${level * INDENTATION_WIDTH}px`;
    	}

    	const writable_props = ["visibleSections", "sectionIndex", "total", "path", "onExpandSection"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CollapsedItems> was created with unknown prop '${key}'`);
    	});

    	const click_handler = expandItemsSection => onExpandSection(path, expandItemsSection);

    	$$self.$$set = $$props => {
    		if ("visibleSections" in $$props) $$invalidate(6, visibleSections = $$props.visibleSections);
    		if ("sectionIndex" in $$props) $$invalidate(7, sectionIndex = $$props.sectionIndex);
    		if ("total" in $$props) $$invalidate(8, total = $$props.total);
    		if ("path" in $$props) $$invalidate(0, path = $$props.path);
    		if ("onExpandSection" in $$props) $$invalidate(1, onExpandSection = $$props.onExpandSection);
    	};

    	$$self.$capture_state = () => ({
    		INDENTATION_WIDTH,
    		getExpandItemsSections,
    		visibleSections,
    		sectionIndex,
    		total,
    		path,
    		onExpandSection,
    		getIndentationStyle,
    		handleMouseMove,
    		visibleSection,
    		startIndex,
    		endIndex,
    		expandItemsSections
    	});

    	$$self.$inject_state = $$props => {
    		if ("visibleSections" in $$props) $$invalidate(6, visibleSections = $$props.visibleSections);
    		if ("sectionIndex" in $$props) $$invalidate(7, sectionIndex = $$props.sectionIndex);
    		if ("total" in $$props) $$invalidate(8, total = $$props.total);
    		if ("path" in $$props) $$invalidate(0, path = $$props.path);
    		if ("onExpandSection" in $$props) $$invalidate(1, onExpandSection = $$props.onExpandSection);
    		if ("visibleSection" in $$props) $$invalidate(9, visibleSection = $$props.visibleSection);
    		if ("startIndex" in $$props) $$invalidate(2, startIndex = $$props.startIndex);
    		if ("endIndex" in $$props) $$invalidate(3, endIndex = $$props.endIndex);
    		if ("expandItemsSections" in $$props) $$invalidate(4, expandItemsSections = $$props.expandItemsSections);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*visibleSections, sectionIndex*/ 192) {
    			$$invalidate(9, visibleSection = visibleSections[sectionIndex]);
    		}

    		if ($$self.$$.dirty & /*visibleSection*/ 512) {
    			$$invalidate(2, startIndex = visibleSection.end);
    		}

    		if ($$self.$$.dirty & /*visibleSections, sectionIndex, total*/ 448) {
    			$$invalidate(3, endIndex = visibleSections[sectionIndex + 1]
    			? visibleSections[sectionIndex + 1].start
    			: total);
    		}

    		if ($$self.$$.dirty & /*startIndex, endIndex*/ 12) {
    			$$invalidate(4, expandItemsSections = getExpandItemsSections(startIndex, endIndex));
    		}
    	};

    	return [
    		path,
    		onExpandSection,
    		startIndex,
    		endIndex,
    		expandItemsSections,
    		getIndentationStyle,
    		visibleSections,
    		sectionIndex,
    		total,
    		visibleSection,
    		click_handler
    	];
    }

    class CollapsedItems extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
    			visibleSections: 6,
    			sectionIndex: 7,
    			total: 8,
    			path: 0,
    			onExpandSection: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CollapsedItems",
    			options,
    			id: create_fragment$e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*visibleSections*/ ctx[6] === undefined && !("visibleSections" in props)) {
    			console.warn("<CollapsedItems> was created without expected prop 'visibleSections'");
    		}

    		if (/*sectionIndex*/ ctx[7] === undefined && !("sectionIndex" in props)) {
    			console.warn("<CollapsedItems> was created without expected prop 'sectionIndex'");
    		}

    		if (/*total*/ ctx[8] === undefined && !("total" in props)) {
    			console.warn("<CollapsedItems> was created without expected prop 'total'");
    		}

    		if (/*path*/ ctx[0] === undefined && !("path" in props)) {
    			console.warn("<CollapsedItems> was created without expected prop 'path'");
    		}

    		if (/*onExpandSection*/ ctx[1] === undefined && !("onExpandSection" in props)) {
    			console.warn("<CollapsedItems> was created without expected prop 'onExpandSection'");
    		}
    	}

    	get visibleSections() {
    		throw new Error("<CollapsedItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set visibleSections(value) {
    		throw new Error("<CollapsedItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sectionIndex() {
    		throw new Error("<CollapsedItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sectionIndex(value) {
    		throw new Error("<CollapsedItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get total() {
    		throw new Error("<CollapsedItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set total(value) {
    		throw new Error("<CollapsedItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get path() {
    		throw new Error("<CollapsedItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set path(value) {
    		throw new Error("<CollapsedItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onExpandSection() {
    		throw new Error("<CollapsedItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onExpandSection(value) {
    		throw new Error("<CollapsedItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\modes\treemode\contextmenu\ContextMenuButton.svelte generated by Svelte v3.38.2 */

    const file$c = "node_modules\\svelte-jsoneditor\\src\\components\\modes\\treemode\\contextmenu\\ContextMenuButton.svelte";

    function create_fragment$d(ctx) {
    	let button;
    	let icon;
    	let current;
    	let mounted;
    	let dispose;

    	icon = new Icon({
    			props: { data: faCaretDown },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(icon.$$.fragment);
    			attr_dev(button, "class", "context-menu-button svelte-2iakqw");
    			attr_dev(button, "title", CONTEXT_MENU_EXPLANATION);
    			toggle_class(button, "selected", /*selected*/ ctx[0]);
    			add_location(button, file$c, 28, 0, 636);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			mount_component(icon, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*selected*/ 1) {
    				toggle_class(button, "selected", /*selected*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(icon);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContextMenuButton", slots, []);
    	let { selected } = $$props;
    	let { onContextMenu } = $$props;

    	function handleClick(event) {
    		let buttonElem = event.target;

    		while (buttonElem && buttonElem.nodeName !== "BUTTON") {
    			buttonElem = buttonElem.parentNode;
    		}

    		if (buttonElem) {
    			onContextMenu({
    				anchor: buttonElem,
    				width: CONTEXT_MENU_WIDTH,
    				height: CONTEXT_MENU_HEIGHT
    			});
    		}
    	}

    	const writable_props = ["selected", "onContextMenu"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ContextMenuButton> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
    		if ("onContextMenu" in $$props) $$invalidate(2, onContextMenu = $$props.onContextMenu);
    	};

    	$$self.$capture_state = () => ({
    		faCaretDown,
    		Icon,
    		CONTEXT_MENU_EXPLANATION,
    		CONTEXT_MENU_HEIGHT,
    		CONTEXT_MENU_WIDTH,
    		selected,
    		onContextMenu,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
    		if ("onContextMenu" in $$props) $$invalidate(2, onContextMenu = $$props.onContextMenu);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [selected, handleClick, onContextMenu];
    }

    class ContextMenuButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { selected: 0, onContextMenu: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContextMenuButton",
    			options,
    			id: create_fragment$d.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*selected*/ ctx[0] === undefined && !("selected" in props)) {
    			console.warn("<ContextMenuButton> was created without expected prop 'selected'");
    		}

    		if (/*onContextMenu*/ ctx[2] === undefined && !("onContextMenu" in props)) {
    			console.warn("<ContextMenuButton> was created without expected prop 'onContextMenu'");
    		}
    	}

    	get selected() {
    		throw new Error("<ContextMenuButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<ContextMenuButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onContextMenu() {
    		throw new Error("<ContextMenuButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onContextMenu(value) {
    		throw new Error("<ContextMenuButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\modes\treemode\JSONKey.svelte generated by Svelte v3.38.2 */
    const file$b = "node_modules\\svelte-jsoneditor\\src\\components\\modes\\treemode\\JSONKey.svelte";

    function create_fragment$c(ctx) {
    	let div;
    	let div_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "data-type", "selectable-key");
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*keyClass*/ ctx[2]) + " svelte-w9irbp"));
    			attr_dev(div, "contenteditable", /*editKey*/ ctx[1]);
    			attr_dev(div, "spellcheck", "false");
    			add_location(div, file$b, 134, 0, 3152);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			/*div_binding*/ ctx[15](div);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "input", /*handleKeyInput*/ ctx[3], false, false, false),
    					listen_dev(div, "dblclick", /*handleKeyDoubleClick*/ ctx[5], false, false, false),
    					listen_dev(div, "keydown", /*handleKeyKeyDown*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*keyClass*/ 4 && div_class_value !== (div_class_value = "" + (null_to_empty(/*keyClass*/ ctx[2]) + " svelte-w9irbp"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*editKey*/ 2) {
    				attr_dev(div, "contenteditable", /*editKey*/ ctx[1]);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[15](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let selectedKey;
    	let editKey;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("JSONKey", slots, []);
    	let { path } = $$props;
    	let { key } = $$props;
    	let { readOnly } = $$props;
    	let { onUpdateKey } = $$props;
    	let { selection } = $$props;
    	let { onSelect } = $$props;
    	let { searchResult } = $$props;

    	onDestroy(() => {
    		updateKey();
    	});

    	let domKey;
    	let newKey = key;
    	let keyClass;

    	function updateKey() {
    		if (key !== newKey) {
    			// must be handled by the parent which has knowledge about the other keys
    			const uniqueKey = onUpdateKey(key, newKey);

    			if (uniqueKey !== newKey) {
    				setDomKey(uniqueKey);
    			}
    		}
    	}

    	function getDomKey() {
    		if (!domKey) {
    			return key;
    		}

    		return getPlainText(domKey);
    	}

    	function setDomKey(updatedKey) {
    		if (domKey) {
    			$$invalidate(13, newKey = updatedKey);
    			setPlainText(domKey, updatedKey);
    		}
    	}

    	function focusKey() {
    		// TODO: this timeout is ugly
    		setTimeout(() => {
    			if (domKey) {
    				setCursorToEnd(domKey);
    			}
    		});
    	}

    	function handleKeyInput() {
    		$$invalidate(13, newKey = getDomKey());

    		if (newKey === "") {
    			// immediately update to cleanup any left over <br/>
    			setDomKey("");
    		}
    	}

    	async function handleKeyKeyDown(event) {
    		const combo = keyComboFromEvent(event);
    		event.stopPropagation();

    		if (combo === "Escape") {
    			// cancel changes
    			setDomKey(key);

    			onSelect({ type: SELECTION_TYPE.KEY, path });
    		}

    		if (!readOnly && (combo === "Enter" || combo === "Tab")) {
    			// updating newKey here is important to handle when contents are changed
    			// programmatically when edit mode is opened after typing a character
    			$$invalidate(13, newKey = getDomKey());

    			// apply changes
    			updateKey();

    			// we apply selection on next tick, since the actual path will change
    			await tick$1();

    			onSelect({
    				type: SELECTION_TYPE.KEY,
    				path,
    				next: true
    			});
    		}
    	}

    	function handleKeyDoubleClick(event) {
    		if (!editKey && !readOnly) {
    			event.preventDefault();

    			onSelect({
    				type: SELECTION_TYPE.KEY,
    				path,
    				edit: true
    			});
    		}
    	}

    	function getKeyClass(key, searchResult) {
    		return classnames("editable-div", "key", {
    			search: searchResult && searchResult[STATE_SEARCH_PROPERTY],
    			active: searchResult && searchResult[STATE_SEARCH_PROPERTY] === ACTIVE_SEARCH_RESULT,
    			empty: key === ""
    		});
    	}

    	const writable_props = [
    		"path",
    		"key",
    		"readOnly",
    		"onUpdateKey",
    		"selection",
    		"onSelect",
    		"searchResult"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<JSONKey> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			domKey = $$value;
    			$$invalidate(0, domKey);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("path" in $$props) $$invalidate(6, path = $$props.path);
    		if ("key" in $$props) $$invalidate(7, key = $$props.key);
    		if ("readOnly" in $$props) $$invalidate(8, readOnly = $$props.readOnly);
    		if ("onUpdateKey" in $$props) $$invalidate(9, onUpdateKey = $$props.onUpdateKey);
    		if ("selection" in $$props) $$invalidate(10, selection = $$props.selection);
    		if ("onSelect" in $$props) $$invalidate(11, onSelect = $$props.onSelect);
    		if ("searchResult" in $$props) $$invalidate(12, searchResult = $$props.searchResult);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		isEqual,
    		onDestroy,
    		tick: tick$1,
    		ACTIVE_SEARCH_RESULT,
    		STATE_SEARCH_PROPERTY,
    		SELECTION_TYPE,
    		getPlainText,
    		setCursorToEnd,
    		setPlainText,
    		keyComboFromEvent,
    		path,
    		key,
    		readOnly,
    		onUpdateKey,
    		selection,
    		onSelect,
    		searchResult,
    		domKey,
    		newKey,
    		keyClass,
    		updateKey,
    		getDomKey,
    		setDomKey,
    		focusKey,
    		handleKeyInput,
    		handleKeyKeyDown,
    		handleKeyDoubleClick,
    		getKeyClass,
    		selectedKey,
    		editKey
    	});

    	$$self.$inject_state = $$props => {
    		if ("path" in $$props) $$invalidate(6, path = $$props.path);
    		if ("key" in $$props) $$invalidate(7, key = $$props.key);
    		if ("readOnly" in $$props) $$invalidate(8, readOnly = $$props.readOnly);
    		if ("onUpdateKey" in $$props) $$invalidate(9, onUpdateKey = $$props.onUpdateKey);
    		if ("selection" in $$props) $$invalidate(10, selection = $$props.selection);
    		if ("onSelect" in $$props) $$invalidate(11, onSelect = $$props.onSelect);
    		if ("searchResult" in $$props) $$invalidate(12, searchResult = $$props.searchResult);
    		if ("domKey" in $$props) $$invalidate(0, domKey = $$props.domKey);
    		if ("newKey" in $$props) $$invalidate(13, newKey = $$props.newKey);
    		if ("keyClass" in $$props) $$invalidate(2, keyClass = $$props.keyClass);
    		if ("selectedKey" in $$props) $$invalidate(14, selectedKey = $$props.selectedKey);
    		if ("editKey" in $$props) $$invalidate(1, editKey = $$props.editKey);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*selection, path*/ 1088) {
    			$$invalidate(14, selectedKey = selection && selection.type === SELECTION_TYPE.KEY
    			? isEqual(selection.focusPath, path)
    			: false);
    		}

    		if ($$self.$$.dirty & /*selectedKey, selection*/ 17408) {
    			$$invalidate(1, editKey = selectedKey && selection && selection.edit === true);
    		}

    		if ($$self.$$.dirty & /*newKey, searchResult*/ 12288) {
    			$$invalidate(2, keyClass = getKeyClass(newKey, searchResult));
    		}

    		if ($$self.$$.dirty & /*editKey*/ 2) {
    			if (editKey === true) {
    				// edit changed to true -> set focus to end of input
    				focusKey();
    			}
    		}

    		if ($$self.$$.dirty & /*domKey, key*/ 129) {
    			if (domKey) {
    				setDomKey(key);
    			}
    		}

    		if ($$self.$$.dirty & /*editKey*/ 2) {
    			if (editKey === false) {
    				updateKey();
    			}
    		}
    	};

    	return [
    		domKey,
    		editKey,
    		keyClass,
    		handleKeyInput,
    		handleKeyKeyDown,
    		handleKeyDoubleClick,
    		path,
    		key,
    		readOnly,
    		onUpdateKey,
    		selection,
    		onSelect,
    		searchResult,
    		newKey,
    		selectedKey,
    		div_binding
    	];
    }

    class JSONKey extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
    			path: 6,
    			key: 7,
    			readOnly: 8,
    			onUpdateKey: 9,
    			selection: 10,
    			onSelect: 11,
    			searchResult: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "JSONKey",
    			options,
    			id: create_fragment$c.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*path*/ ctx[6] === undefined && !("path" in props)) {
    			console.warn("<JSONKey> was created without expected prop 'path'");
    		}

    		if (/*key*/ ctx[7] === undefined && !("key" in props)) {
    			console.warn("<JSONKey> was created without expected prop 'key'");
    		}

    		if (/*readOnly*/ ctx[8] === undefined && !("readOnly" in props)) {
    			console.warn("<JSONKey> was created without expected prop 'readOnly'");
    		}

    		if (/*onUpdateKey*/ ctx[9] === undefined && !("onUpdateKey" in props)) {
    			console.warn("<JSONKey> was created without expected prop 'onUpdateKey'");
    		}

    		if (/*selection*/ ctx[10] === undefined && !("selection" in props)) {
    			console.warn("<JSONKey> was created without expected prop 'selection'");
    		}

    		if (/*onSelect*/ ctx[11] === undefined && !("onSelect" in props)) {
    			console.warn("<JSONKey> was created without expected prop 'onSelect'");
    		}

    		if (/*searchResult*/ ctx[12] === undefined && !("searchResult" in props)) {
    			console.warn("<JSONKey> was created without expected prop 'searchResult'");
    		}
    	}

    	get path() {
    		throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set path(value) {
    		throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get readOnly() {
    		throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readOnly(value) {
    		throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onUpdateKey() {
    		throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onUpdateKey(value) {
    		throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selection() {
    		throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selection(value) {
    		throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSelect() {
    		throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSelect(value) {
    		throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get searchResult() {
    		throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set searchResult(value) {
    		throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /*!
     * Font Awesome Free 5.15.3 by @fontawesome - https://fontawesome.com
     * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
     */
    var faCheckSquare = {
      prefix: 'far',
      iconName: 'check-square',
      icon: [448, 512, [], "f14a", "M400 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zm0 400H48V80h352v352zm-35.864-241.724L191.547 361.48c-4.705 4.667-12.303 4.637-16.97-.068l-90.781-91.516c-4.667-4.705-4.637-12.303.069-16.971l22.719-22.536c4.705-4.667 12.303-4.637 16.97.069l59.792 60.277 141.352-140.216c4.705-4.667 12.303-4.637 16.97.068l22.536 22.718c4.667 4.706 4.637 12.304-.068 16.971z"]
    };
    var faSquare = {
      prefix: 'far',
      iconName: 'square',
      icon: [448, 512, [], "f0c8", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-6 400H54c-3.3 0-6-2.7-6-6V86c0-3.3 2.7-6 6-6h340c3.3 0 6 2.7 6 6v340c0 3.3-2.7 6-6 6z"]
    };

    /* node_modules\svelte-jsoneditor\src\components\modes\treemode\BooleanToggle.svelte generated by Svelte v3.38.2 */
    const file$a = "node_modules\\svelte-jsoneditor\\src\\components\\modes\\treemode\\BooleanToggle.svelte";

    function create_fragment$b(ctx) {
    	let div;
    	let icon;
    	let current;
    	let mounted;
    	let dispose;

    	icon = new Icon({
    			props: {
    				data: /*value*/ ctx[0] === true ? faCheckSquare : faSquare
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(icon.$$.fragment);
    			attr_dev(div, "class", "boolean-toggle svelte-1e7scas");
    			attr_dev(div, "title", "Click to toggle this boolean value");
    			add_location(div, file$a, 21, 0, 438);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(icon, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "mousedown", /*toggleBooleanValue*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const icon_changes = {};
    			if (dirty & /*value*/ 1) icon_changes.data = /*value*/ ctx[0] === true ? faCheckSquare : faSquare;
    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("BooleanToggle", slots, []);
    	let { onPatch } = $$props;
    	let { path } = $$props;
    	let { value } = $$props;

    	function toggleBooleanValue(event) {
    		event.stopPropagation();

    		onPatch(
    			[
    				{
    					op: "replace",
    					path: immutableJSONPatch.compileJSONPointer(path),
    					value: !value
    				}
    			],
    			null
    		);
    	}

    	const writable_props = ["onPatch", "path", "value"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BooleanToggle> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("onPatch" in $$props) $$invalidate(2, onPatch = $$props.onPatch);
    		if ("path" in $$props) $$invalidate(3, path = $$props.path);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    	};

    	$$self.$capture_state = () => ({
    		faCheckSquare,
    		faSquare,
    		compileJSONPointer: immutableJSONPatch.compileJSONPointer,
    		Icon,
    		onPatch,
    		path,
    		value,
    		toggleBooleanValue
    	});

    	$$self.$inject_state = $$props => {
    		if ("onPatch" in $$props) $$invalidate(2, onPatch = $$props.onPatch);
    		if ("path" in $$props) $$invalidate(3, path = $$props.path);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [value, toggleBooleanValue, onPatch, path];
    }

    class BooleanToggle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { onPatch: 2, path: 3, value: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BooleanToggle",
    			options,
    			id: create_fragment$b.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*onPatch*/ ctx[2] === undefined && !("onPatch" in props)) {
    			console.warn("<BooleanToggle> was created without expected prop 'onPatch'");
    		}

    		if (/*path*/ ctx[3] === undefined && !("path" in props)) {
    			console.warn("<BooleanToggle> was created without expected prop 'path'");
    		}

    		if (/*value*/ ctx[0] === undefined && !("value" in props)) {
    			console.warn("<BooleanToggle> was created without expected prop 'value'");
    		}
    	}

    	get onPatch() {
    		throw new Error("<BooleanToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onPatch(value) {
    		throw new Error("<BooleanToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get path() {
    		throw new Error("<BooleanToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set path(value) {
    		throw new Error("<BooleanToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<BooleanToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<BooleanToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\modes\treemode\JSONValue.svelte generated by Svelte v3.38.2 */
    const file$9 = "node_modules\\svelte-jsoneditor\\src\\components\\modes\\treemode\\JSONValue.svelte";

    // (151:0) {#if (!editValue && (value === true || value === false))}
    function create_if_block$6(ctx) {
    	let booleantoggle;
    	let current;

    	booleantoggle = new BooleanToggle({
    			props: {
    				path: /*path*/ ctx[1],
    				value: /*value*/ ctx[0],
    				onPatch: /*onPatch*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(booleantoggle.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(booleantoggle, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const booleantoggle_changes = {};
    			if (dirty & /*path*/ 2) booleantoggle_changes.path = /*path*/ ctx[1];
    			if (dirty & /*value*/ 1) booleantoggle_changes.value = /*value*/ ctx[0];
    			if (dirty & /*onPatch*/ 4) booleantoggle_changes.onPatch = /*onPatch*/ ctx[2];
    			booleantoggle.$set(booleantoggle_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(booleantoggle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(booleantoggle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(booleantoggle, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(151:0) {#if (!editValue && (value === true || value === false))}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let t;
    	let div;
    	let div_class_value;
    	let div_title_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = !/*editValue*/ ctx[4] && (/*value*/ ctx[0] === true || /*value*/ ctx[0] === false) && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			div = element("div");
    			attr_dev(div, "data-type", "selectable-value");
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*valueClass*/ ctx[5]) + " svelte-1dn48jf"));
    			attr_dev(div, "contenteditable", /*editValue*/ ctx[4]);
    			attr_dev(div, "spellcheck", "false");

    			attr_dev(div, "title", div_title_value = /*valueIsUrl*/ ctx[6]
    			? "Ctrl+Click or Ctrl+Enter to open url in new window"
    			: null);

    			add_location(div, file$9, 158, 0, 3860);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			/*div_binding*/ ctx[17](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "input", /*handleValueInput*/ ctx[7], false, false, false),
    					listen_dev(div, "click", /*handleValueClick*/ ctx[8], false, false, false),
    					listen_dev(div, "dblclick", /*handleValueDoubleClick*/ ctx[9], false, false, false),
    					listen_dev(div, "keydown", /*handleValueKeyDown*/ ctx[10], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*editValue*/ ctx[4] && (/*value*/ ctx[0] === true || /*value*/ ctx[0] === false)) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*editValue, value*/ 17) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*valueClass*/ 32 && div_class_value !== (div_class_value = "" + (null_to_empty(/*valueClass*/ ctx[5]) + " svelte-1dn48jf"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (!current || dirty & /*editValue*/ 16) {
    				attr_dev(div, "contenteditable", /*editValue*/ ctx[4]);
    			}

    			if (!current || dirty & /*valueIsUrl*/ 64 && div_title_value !== (div_title_value = /*valueIsUrl*/ ctx[6]
    			? "Ctrl+Click or Ctrl+Enter to open url in new window"
    			: null)) {
    				attr_dev(div, "title", div_title_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[17](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let selectedValue;
    	let editValue;
    	let valueIsUrl;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("JSONValue", slots, []);
    	let { path } = $$props;
    	let { value } = $$props;
    	let { readOnly } = $$props;
    	let { onPatch } = $$props;
    	let { selection } = $$props;
    	let { onSelect } = $$props;
    	let { searchResult } = $$props;

    	onDestroy(() => {
    		updateValue();
    	});

    	let domValue;
    	let newValue = value;
    	let valueClass;

    	function updateValue() {
    		if (newValue !== value) {
    			$$invalidate(0, value = newValue); // prevent loops when value and newValue are temporarily not in sync

    			onPatch([
    				{
    					op: "replace",
    					path: immutableJSONPatch.compileJSONPointer(path),
    					value: newValue
    				}
    			]);
    		}
    	}

    	function getDomValue() {
    		if (!domValue) {
    			return value;
    		}

    		const valueText = getPlainText(domValue);
    		return stringConvert(valueText); // TODO: implement support for type "string"
    	}

    	function setDomValue(updatedValue) {
    		if (domValue) {
    			$$invalidate(15, newValue = updatedValue);
    			setPlainText(domValue, updatedValue);
    		}
    	}

    	function focusValue() {
    		// TODO: this timeout is ugly
    		setTimeout(() => {
    			if (domValue) {
    				setCursorToEnd(domValue);
    			}
    		});
    	}

    	function getValueClass(value, searchResult) {
    		const type = valueType(value);

    		return classnames("editable-div", SELECTION_TYPE.VALUE, type, {
    			search: searchResult && searchResult[STATE_SEARCH_VALUE],
    			active: searchResult && searchResult[STATE_SEARCH_VALUE] === ACTIVE_SEARCH_RESULT,
    			url: isUrl(value),
    			empty: typeof value === "string" && value.length === 0
    		});
    	}

    	function handleValueInput() {
    		$$invalidate(15, newValue = getDomValue());

    		if (newValue === "") {
    			// immediately update to cleanup any left over <br/>
    			setDomValue("");
    		}
    	}

    	function handleValueClick(event) {
    		if (valueIsUrl && event.ctrlKey) {
    			event.preventDefault();
    			event.stopPropagation();
    			window.open(value, "_blank");
    		}
    	}

    	function handleValueDoubleClick(event) {
    		if (!readOnly && !editValue) {
    			event.preventDefault();

    			onSelect({
    				type: SELECTION_TYPE.VALUE,
    				path,
    				edit: true
    			});
    		}
    	}

    	function handleValueKeyDown(event) {
    		event.stopPropagation();
    		const combo = keyComboFromEvent(event);

    		if (combo === "Escape") {
    			// cancel changes
    			setDomValue(value);

    			onSelect({ type: SELECTION_TYPE.VALUE, path });
    		}

    		if (!readOnly && (combo === "Enter" || combo === "Tab")) {
    			// updating newValue here is important to handle when contents are changed
    			// programmatically when edit mode is opened after typing a character
    			$$invalidate(15, newValue = getDomValue());

    			// apply changes
    			updateValue();

    			onSelect({
    				type: SELECTION_TYPE.VALUE,
    				path,
    				nextInside: true
    			});
    		}
    	}

    	const writable_props = [
    		"path",
    		"value",
    		"readOnly",
    		"onPatch",
    		"selection",
    		"onSelect",
    		"searchResult"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<JSONValue> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			domValue = $$value;
    			$$invalidate(3, domValue);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("path" in $$props) $$invalidate(1, path = $$props.path);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("readOnly" in $$props) $$invalidate(11, readOnly = $$props.readOnly);
    		if ("onPatch" in $$props) $$invalidate(2, onPatch = $$props.onPatch);
    		if ("selection" in $$props) $$invalidate(12, selection = $$props.selection);
    		if ("onSelect" in $$props) $$invalidate(13, onSelect = $$props.onSelect);
    		if ("searchResult" in $$props) $$invalidate(14, searchResult = $$props.searchResult);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		compileJSONPointer: immutableJSONPatch.compileJSONPointer,
    		isEqual,
    		onDestroy,
    		ACTIVE_SEARCH_RESULT,
    		STATE_SEARCH_VALUE,
    		SELECTION_TYPE,
    		getPlainText,
    		setCursorToEnd,
    		setPlainText,
    		keyComboFromEvent,
    		isUrl,
    		stringConvert,
    		valueType,
    		BooleanToggle,
    		path,
    		value,
    		readOnly,
    		onPatch,
    		selection,
    		onSelect,
    		searchResult,
    		domValue,
    		newValue,
    		valueClass,
    		updateValue,
    		getDomValue,
    		setDomValue,
    		focusValue,
    		getValueClass,
    		handleValueInput,
    		handleValueClick,
    		handleValueDoubleClick,
    		handleValueKeyDown,
    		selectedValue,
    		editValue,
    		valueIsUrl
    	});

    	$$self.$inject_state = $$props => {
    		if ("path" in $$props) $$invalidate(1, path = $$props.path);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("readOnly" in $$props) $$invalidate(11, readOnly = $$props.readOnly);
    		if ("onPatch" in $$props) $$invalidate(2, onPatch = $$props.onPatch);
    		if ("selection" in $$props) $$invalidate(12, selection = $$props.selection);
    		if ("onSelect" in $$props) $$invalidate(13, onSelect = $$props.onSelect);
    		if ("searchResult" in $$props) $$invalidate(14, searchResult = $$props.searchResult);
    		if ("domValue" in $$props) $$invalidate(3, domValue = $$props.domValue);
    		if ("newValue" in $$props) $$invalidate(15, newValue = $$props.newValue);
    		if ("valueClass" in $$props) $$invalidate(5, valueClass = $$props.valueClass);
    		if ("selectedValue" in $$props) $$invalidate(16, selectedValue = $$props.selectedValue);
    		if ("editValue" in $$props) $$invalidate(4, editValue = $$props.editValue);
    		if ("valueIsUrl" in $$props) $$invalidate(6, valueIsUrl = $$props.valueIsUrl);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*selection, path*/ 4098) {
    			$$invalidate(16, selectedValue = selection && selection.type === SELECTION_TYPE.VALUE
    			? isEqual(selection.focusPath, path)
    			: false);
    		}

    		if ($$self.$$.dirty & /*newValue, searchResult*/ 49152) {
    			$$invalidate(5, valueClass = getValueClass(newValue, searchResult));
    		}

    		if ($$self.$$.dirty & /*selectedValue, selection*/ 69632) {
    			$$invalidate(4, editValue = selectedValue && selection && selection.edit === true);
    		}

    		if ($$self.$$.dirty & /*value*/ 1) {
    			$$invalidate(6, valueIsUrl = isUrl(value));
    		}

    		if ($$self.$$.dirty & /*editValue*/ 16) {
    			if (editValue === true) {
    				focusValue();
    			}
    		}

    		if ($$self.$$.dirty & /*editValue*/ 16) {
    			if (editValue === false) {
    				updateValue();
    			}
    		}

    		if ($$self.$$.dirty & /*domValue, value*/ 9) {
    			if (domValue) {
    				setDomValue(value);
    			}
    		}
    	};

    	return [
    		value,
    		path,
    		onPatch,
    		domValue,
    		editValue,
    		valueClass,
    		valueIsUrl,
    		handleValueInput,
    		handleValueClick,
    		handleValueDoubleClick,
    		handleValueKeyDown,
    		readOnly,
    		selection,
    		onSelect,
    		searchResult,
    		newValue,
    		selectedValue,
    		div_binding
    	];
    }

    class JSONValue extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
    			path: 1,
    			value: 0,
    			readOnly: 11,
    			onPatch: 2,
    			selection: 12,
    			onSelect: 13,
    			searchResult: 14
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "JSONValue",
    			options,
    			id: create_fragment$a.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*path*/ ctx[1] === undefined && !("path" in props)) {
    			console.warn("<JSONValue> was created without expected prop 'path'");
    		}

    		if (/*value*/ ctx[0] === undefined && !("value" in props)) {
    			console.warn("<JSONValue> was created without expected prop 'value'");
    		}

    		if (/*readOnly*/ ctx[11] === undefined && !("readOnly" in props)) {
    			console.warn("<JSONValue> was created without expected prop 'readOnly'");
    		}

    		if (/*onPatch*/ ctx[2] === undefined && !("onPatch" in props)) {
    			console.warn("<JSONValue> was created without expected prop 'onPatch'");
    		}

    		if (/*selection*/ ctx[12] === undefined && !("selection" in props)) {
    			console.warn("<JSONValue> was created without expected prop 'selection'");
    		}

    		if (/*onSelect*/ ctx[13] === undefined && !("onSelect" in props)) {
    			console.warn("<JSONValue> was created without expected prop 'onSelect'");
    		}

    		if (/*searchResult*/ ctx[14] === undefined && !("searchResult" in props)) {
    			console.warn("<JSONValue> was created without expected prop 'searchResult'");
    		}
    	}

    	get path() {
    		throw new Error("<JSONValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set path(value) {
    		throw new Error("<JSONValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<JSONValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<JSONValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get readOnly() {
    		throw new Error("<JSONValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readOnly(value) {
    		throw new Error("<JSONValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onPatch() {
    		throw new Error("<JSONValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onPatch(value) {
    		throw new Error("<JSONValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selection() {
    		throw new Error("<JSONValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selection(value) {
    		throw new Error("<JSONValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSelect() {
    		throw new Error("<JSONValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSelect(value) {
    		throw new Error("<JSONValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get searchResult() {
    		throw new Error("<JSONValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set searchResult(value) {
    		throw new Error("<JSONValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // used by JSONNode during dragging
    const singleton = {
      mousedown: false,
      selectionAnchor: null, // Path
      selectionAnchorType: null, // Selection type
      selectionFocus: null // Path
    };

    /* node_modules\sveltip\src\Sveltip.svelte generated by Svelte v3.38.2 */

    const file$8 = "node_modules\\sveltip\\src\\Sveltip.svelte";

    function create_fragment$9(ctx) {
    	let div1;
    	let span;
    	let t0;
    	let div0;
    	let t1;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			span = element("span");
    			if (default_slot) default_slot.c();
    			t0 = space();
    			div0 = element("div");
    			t1 = text(/*text*/ ctx[0]);
    			attr_dev(span, "class", "slot svelte-8o3ila");
    			add_location(span, file$8, 11, 4, 257);
    			attr_dev(div0, "class", "bubble svelte-8o3ila");
    			toggle_class(div0, "light", /*light*/ ctx[1]);
    			toggle_class(div0, "dark", /*dark*/ ctx[2]);
    			toggle_class(div0, "left", /*left*/ ctx[6]);
    			toggle_class(div0, "right", /*right*/ ctx[5]);
    			toggle_class(div0, "bottom", /*bottom*/ ctx[4]);
    			toggle_class(div0, "top", /*top*/ ctx[3]);
    			add_location(div0, file$8, 12, 4, 296);
    			attr_dev(div1, "class", "container svelte-8o3ila");
    			add_location(div1, file$8, 10, 2, 229);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, t1);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*text*/ 1) set_data_dev(t1, /*text*/ ctx[0]);

    			if (dirty & /*light*/ 2) {
    				toggle_class(div0, "light", /*light*/ ctx[1]);
    			}

    			if (dirty & /*dark*/ 4) {
    				toggle_class(div0, "dark", /*dark*/ ctx[2]);
    			}

    			if (dirty & /*left*/ 64) {
    				toggle_class(div0, "left", /*left*/ ctx[6]);
    			}

    			if (dirty & /*right*/ 32) {
    				toggle_class(div0, "right", /*right*/ ctx[5]);
    			}

    			if (dirty & /*bottom*/ 16) {
    				toggle_class(div0, "bottom", /*bottom*/ ctx[4]);
    			}

    			if (dirty & /*top*/ 8) {
    				toggle_class(div0, "top", /*top*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Sveltip", slots, ['default']);
    	let { text = "" } = $$props;
    	let { light = false } = $$props;
    	let { dark = false } = $$props;
    	let { top = false } = $$props;
    	let { bottom = false } = $$props;
    	let { right = false } = $$props;
    	let { left = false } = $$props;
    	const writable_props = ["text", "light", "dark", "top", "bottom", "right", "left"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Sveltip> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("light" in $$props) $$invalidate(1, light = $$props.light);
    		if ("dark" in $$props) $$invalidate(2, dark = $$props.dark);
    		if ("top" in $$props) $$invalidate(3, top = $$props.top);
    		if ("bottom" in $$props) $$invalidate(4, bottom = $$props.bottom);
    		if ("right" in $$props) $$invalidate(5, right = $$props.right);
    		if ("left" in $$props) $$invalidate(6, left = $$props.left);
    		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		text,
    		light,
    		dark,
    		top,
    		bottom,
    		right,
    		left
    	});

    	$$self.$inject_state = $$props => {
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("light" in $$props) $$invalidate(1, light = $$props.light);
    		if ("dark" in $$props) $$invalidate(2, dark = $$props.dark);
    		if ("top" in $$props) $$invalidate(3, top = $$props.top);
    		if ("bottom" in $$props) $$invalidate(4, bottom = $$props.bottom);
    		if ("right" in $$props) $$invalidate(5, right = $$props.right);
    		if ("left" in $$props) $$invalidate(6, left = $$props.left);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [text, light, dark, top, bottom, right, left, $$scope, slots];
    }

    class Sveltip extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
    			text: 0,
    			light: 1,
    			dark: 2,
    			top: 3,
    			bottom: 4,
    			right: 5,
    			left: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Sveltip",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get text() {
    		throw new Error("<Sveltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Sveltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get light() {
    		throw new Error("<Sveltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set light(value) {
    		throw new Error("<Sveltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dark() {
    		throw new Error("<Sveltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dark(value) {
    		throw new Error("<Sveltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get top() {
    		throw new Error("<Sveltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set top(value) {
    		throw new Error("<Sveltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bottom() {
    		throw new Error("<Sveltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bottom(value) {
    		throw new Error("<Sveltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get right() {
    		throw new Error("<Sveltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set right(value) {
    		throw new Error("<Sveltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get left() {
    		throw new Error("<Sveltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set left(value) {
    		throw new Error("<Sveltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\modes\treemode\ValidationError.svelte generated by Svelte v3.38.2 */
    const file$7 = "node_modules\\svelte-jsoneditor\\src\\components\\modes\\treemode\\ValidationError.svelte";

    // (14:0) <Sveltip dark text={message} top >
    function create_default_slot$1(ctx) {
    	let button;
    	let icon;
    	let current;
    	let mounted;
    	let dispose;

    	icon = new Icon({
    			props: { data: faExclamationTriangle },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(icon.$$.fragment);
    			attr_dev(button, "class", "validation-error svelte-1ewxg2y");
    			add_location(button, file$7, 14, 2, 358);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			mount_component(icon, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*onExpand*/ ctx[0])) /*onExpand*/ ctx[0].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(icon);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(14:0) <Sveltip dark text={message} top >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let sveltip;
    	let current;

    	sveltip = new Sveltip({
    			props: {
    				dark: true,
    				text: /*message*/ ctx[1],
    				top: true,
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(sveltip.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(sveltip, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const sveltip_changes = {};
    			if (dirty & /*message*/ 2) sveltip_changes.text = /*message*/ ctx[1];

    			if (dirty & /*$$scope, onExpand*/ 9) {
    				sveltip_changes.$$scope = { dirty, ctx };
    			}

    			sveltip.$set(sveltip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sveltip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sveltip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(sveltip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let message;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ValidationError", slots, []);
    	let { validationError } = $$props;
    	let { onExpand } = $$props;
    	const writable_props = ["validationError", "onExpand"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ValidationError> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("validationError" in $$props) $$invalidate(2, validationError = $$props.validationError);
    		if ("onExpand" in $$props) $$invalidate(0, onExpand = $$props.onExpand);
    	};

    	$$self.$capture_state = () => ({
    		faExclamationTriangle,
    		Icon,
    		Sveltip,
    		validationError,
    		onExpand,
    		message
    	});

    	$$self.$inject_state = $$props => {
    		if ("validationError" in $$props) $$invalidate(2, validationError = $$props.validationError);
    		if ("onExpand" in $$props) $$invalidate(0, onExpand = $$props.onExpand);
    		if ("message" in $$props) $$invalidate(1, message = $$props.message);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*validationError*/ 4) {
    			$$invalidate(1, message = validationError.isChildError
    			? "Contains invalid data"
    			: validationError.message);
    		}
    	};

    	return [onExpand, message, validationError];
    }

    class ValidationError$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, { validationError: 2, onExpand: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ValidationError",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*validationError*/ ctx[2] === undefined && !("validationError" in props)) {
    			console.warn("<ValidationError> was created without expected prop 'validationError'");
    		}

    		if (/*onExpand*/ ctx[0] === undefined && !("onExpand" in props)) {
    			console.warn("<ValidationError> was created without expected prop 'onExpand'");
    		}
    	}

    	get validationError() {
    		throw new Error("<ValidationError>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set validationError(value) {
    		throw new Error("<ValidationError>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onExpand() {
    		throw new Error("<ValidationError>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onExpand(value) {
    		throw new Error("<ValidationError>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\modes\treemode\JSONNode.svelte generated by Svelte v3.38.2 */

    const { Object: Object_1 } = globals;
    const file$6 = "node_modules\\svelte-jsoneditor\\src\\components\\modes\\treemode\\JSONNode.svelte";
    const get_identifier_slot_changes_2 = dirty => ({});
    const get_identifier_slot_context_2 = ctx => ({});

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[49] = list[i];
    	return child_ctx;
    }

    const get_identifier_slot_changes_1 = dirty => ({});
    const get_identifier_slot_context_1 = ctx => ({});

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[43] = list[i];
    	child_ctx[45] = i;
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[46] = list[i];
    	child_ctx[48] = i;
    	return child_ctx;
    }

    const get_identifier_slot_changes = dirty => ({});
    const get_identifier_slot_context = ctx => ({});

    // (504:2) {:else}
    function create_else_block_5(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let jsonvalue;
    	let t2;
    	let show_if = /*selection*/ ctx[13] && (/*selection*/ ctx[13].type === SELECTION_TYPE.VALUE || /*selection*/ ctx[13].type === SELECTION_TYPE.MULTI) && !/*selection*/ ctx[13].edit && isEqual(/*selection*/ ctx[13].focusPath, /*path*/ ctx[1]);
    	let t3;
    	let t4;
    	let current;
    	const identifier_slot_template = /*#slots*/ ctx[39].identifier;
    	const identifier_slot = create_slot(identifier_slot_template, ctx, /*$$scope*/ ctx[40], get_identifier_slot_context_2);
    	let if_block0 = !/*root*/ ctx[24] && create_if_block_24(ctx);

    	jsonvalue = new JSONValue({
    			props: {
    				path: /*path*/ ctx[1],
    				value: /*value*/ ctx[0],
    				readOnly: /*readOnly*/ ctx[3],
    				onPatch: /*onPatch*/ ctx[6],
    				selection: /*selection*/ ctx[13],
    				onSelect: /*onSelect*/ ctx[9],
    				searchResult: /*searchResult*/ ctx[4]
    			},
    			$$inline: true
    		});

    	let if_block1 = show_if && create_if_block_23(ctx);
    	let if_block2 = /*validationError*/ ctx[23] && create_if_block_22(ctx);
    	let if_block3 = !/*root*/ ctx[24] && create_if_block_21(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if (identifier_slot) identifier_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			create_component(jsonvalue.$$.fragment);
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			attr_dev(div0, "class", "contents svelte-1f20tgc");
    			add_location(div0, file$6, 505, 6, 16649);
    			attr_dev(div1, "class", "contents-outer svelte-1f20tgc");
    			attr_dev(div1, "style", /*indentationStyle*/ ctx[26]);
    			add_location(div1, file$6, 504, 4, 16588);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			if (identifier_slot) {
    				identifier_slot.m(div0, null);
    			}

    			append_dev(div0, t0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t1);
    			mount_component(jsonvalue, div0, null);
    			append_dev(div0, t2);
    			if (if_block1) if_block1.m(div0, null);
    			append_dev(div1, t3);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div1, t4);
    			if (if_block3) if_block3.m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (identifier_slot) {
    				if (identifier_slot.p && (!current || dirty[1] & /*$$scope*/ 512)) {
    					update_slot(identifier_slot, identifier_slot_template, ctx, /*$$scope*/ ctx[40], dirty, get_identifier_slot_changes_2, get_identifier_slot_context_2);
    				}
    			}

    			if (!/*root*/ ctx[24]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_24(ctx);
    					if_block0.c();
    					if_block0.m(div0, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			const jsonvalue_changes = {};
    			if (dirty[0] & /*path*/ 2) jsonvalue_changes.path = /*path*/ ctx[1];
    			if (dirty[0] & /*value*/ 1) jsonvalue_changes.value = /*value*/ ctx[0];
    			if (dirty[0] & /*readOnly*/ 8) jsonvalue_changes.readOnly = /*readOnly*/ ctx[3];
    			if (dirty[0] & /*onPatch*/ 64) jsonvalue_changes.onPatch = /*onPatch*/ ctx[6];
    			if (dirty[0] & /*selection*/ 8192) jsonvalue_changes.selection = /*selection*/ ctx[13];
    			if (dirty[0] & /*onSelect*/ 512) jsonvalue_changes.onSelect = /*onSelect*/ ctx[9];
    			if (dirty[0] & /*searchResult*/ 16) jsonvalue_changes.searchResult = /*searchResult*/ ctx[4];
    			jsonvalue.$set(jsonvalue_changes);
    			if (dirty[0] & /*selection, path*/ 8194) show_if = /*selection*/ ctx[13] && (/*selection*/ ctx[13].type === SELECTION_TYPE.VALUE || /*selection*/ ctx[13].type === SELECTION_TYPE.MULTI) && !/*selection*/ ctx[13].edit && isEqual(/*selection*/ ctx[13].focusPath, /*path*/ ctx[1]);

    			if (show_if) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*selection, path*/ 8194) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_23(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div0, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*validationError*/ ctx[23]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*validationError*/ 8388608) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_22(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div1, t4);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (!/*root*/ ctx[24]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_21(ctx);
    					if_block3.c();
    					if_block3.m(div1, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (!current || dirty[0] & /*indentationStyle*/ 67108864) {
    				attr_dev(div1, "style", /*indentationStyle*/ ctx[26]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(identifier_slot, local);
    			transition_in(jsonvalue.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(identifier_slot, local);
    			transition_out(jsonvalue.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (identifier_slot) identifier_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			destroy_component(jsonvalue);
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_5.name,
    		type: "else",
    		source: "(504:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (389:30) 
    function create_if_block_10(ctx) {
    	let div3;
    	let div2;
    	let button;
    	let current_block_type_index;
    	let if_block0;
    	let t0;
    	let t1;
    	let t2;
    	let div1;
    	let div0;
    	let t3;
    	let show_if = /*selection*/ ctx[13] && (/*selection*/ ctx[13].type === SELECTION_TYPE.VALUE || /*selection*/ ctx[13].type === SELECTION_TYPE.MULTI) && !/*selection*/ ctx[13].edit && isEqual(/*selection*/ ctx[13].focusPath, /*path*/ ctx[1]);
    	let t4;
    	let t5;
    	let t6;
    	let if_block6_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_20, create_else_block_4];
    	const if_blocks = [];

    	function select_block_type_4(ctx, dirty) {
    		if (/*expanded*/ ctx[20]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_4(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const identifier_slot_template = /*#slots*/ ctx[39].identifier;
    	const identifier_slot = create_slot(identifier_slot_template, ctx, /*$$scope*/ ctx[40], get_identifier_slot_context_1);
    	let if_block1 = !/*root*/ ctx[24] && create_if_block_19(ctx);

    	function select_block_type_5(ctx, dirty) {
    		if (/*expanded*/ ctx[20]) return create_if_block_18;
    		return create_else_block_3;
    	}

    	let current_block_type = select_block_type_5(ctx);
    	let if_block2 = current_block_type(ctx);
    	let if_block3 = show_if && create_if_block_17(ctx);
    	let if_block4 = /*validationError*/ ctx[23] && (!/*expanded*/ ctx[20] || !/*validationError*/ ctx[23].isChildError) && create_if_block_16(ctx);

    	function select_block_type_6(ctx, dirty) {
    		if (/*expanded*/ ctx[20]) return create_if_block_14;
    		if (!/*root*/ ctx[24]) return create_if_block_15;
    	}

    	let current_block_type_1 = select_block_type_6(ctx);
    	let if_block5 = current_block_type_1 && current_block_type_1(ctx);
    	let if_block6 = /*expanded*/ ctx[20] && create_if_block_11(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			button = element("button");
    			if_block0.c();
    			t0 = space();
    			if (identifier_slot) identifier_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div1 = element("div");
    			div0 = element("div");
    			if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			t4 = space();
    			if (if_block4) if_block4.c();
    			t5 = space();
    			if (if_block5) if_block5.c();
    			t6 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty$1();
    			attr_dev(button, "class", "expand svelte-1f20tgc");
    			attr_dev(button, "title", "Expand or collapse this object (Ctrl+Click to expand/collapse recursively)");
    			add_location(button, file$6, 391, 8, 12445);
    			attr_dev(div0, "class", "meta-inner svelte-1f20tgc");
    			add_location(div0, file$6, 407, 10, 12950);
    			attr_dev(div1, "class", "meta svelte-1f20tgc");
    			attr_dev(div1, "data-type", "selectable-value");
    			add_location(div1, file$6, 406, 8, 12891);
    			attr_dev(div2, "class", "header svelte-1f20tgc");
    			add_location(div2, file$6, 390, 6, 12416);
    			attr_dev(div3, "class", "header-outer svelte-1f20tgc");
    			attr_dev(div3, "style", /*indentationStyle*/ ctx[26]);
    			add_location(div3, file$6, 389, 4, 12357);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, button);
    			if_blocks[current_block_type_index].m(button, null);
    			append_dev(div2, t0);

    			if (identifier_slot) {
    				identifier_slot.m(div2, null);
    			}

    			append_dev(div2, t1);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			if_block2.m(div0, null);
    			append_dev(div2, t3);
    			if (if_block3) if_block3.m(div2, null);
    			append_dev(div3, t4);
    			if (if_block4) if_block4.m(div3, null);
    			append_dev(div3, t5);
    			if (if_block5) if_block5.m(div3, null);
    			insert_dev(target, t6, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*toggleExpand*/ ctx[28], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_4(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(button, null);
    			}

    			if (identifier_slot) {
    				if (identifier_slot.p && (!current || dirty[1] & /*$$scope*/ 512)) {
    					update_slot(identifier_slot, identifier_slot_template, ctx, /*$$scope*/ ctx[40], dirty, get_identifier_slot_changes_1, get_identifier_slot_context_1);
    				}
    			}

    			if (!/*root*/ ctx[24]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_19(ctx);
    					if_block1.c();
    					if_block1.m(div2, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (current_block_type === (current_block_type = select_block_type_5(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(div0, null);
    				}
    			}

    			if (dirty[0] & /*selection, path*/ 8194) show_if = /*selection*/ ctx[13] && (/*selection*/ ctx[13].type === SELECTION_TYPE.VALUE || /*selection*/ ctx[13].type === SELECTION_TYPE.MULTI) && !/*selection*/ ctx[13].edit && isEqual(/*selection*/ ctx[13].focusPath, /*path*/ ctx[1]);

    			if (show_if) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*selection, path*/ 8194) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_17(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div2, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*validationError*/ ctx[23] && (!/*expanded*/ ctx[20] || !/*validationError*/ ctx[23].isChildError)) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[0] & /*validationError, expanded*/ 9437184) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_16(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div3, t5);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_6(ctx)) && if_block5) {
    				if_block5.p(ctx, dirty);
    			} else {
    				if (if_block5) if_block5.d(1);
    				if_block5 = current_block_type_1 && current_block_type_1(ctx);

    				if (if_block5) {
    					if_block5.c();
    					if_block5.m(div3, null);
    				}
    			}

    			if (!current || dirty[0] & /*indentationStyle*/ 67108864) {
    				attr_dev(div3, "style", /*indentationStyle*/ ctx[26]);
    			}

    			if (/*expanded*/ ctx[20]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[0] & /*expanded*/ 1048576) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_11(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(identifier_slot, local);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block6);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(identifier_slot, local);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block6);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if_blocks[current_block_type_index].d();
    			if (identifier_slot) identifier_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();

    			if (if_block5) {
    				if_block5.d();
    			}

    			if (detaching) detach_dev(t6);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(389:30) ",
    		ctx
    	});

    	return block;
    }

    // (276:2) {#if type === 'array'}
    function create_if_block$5(ctx) {
    	let div3;
    	let div2;
    	let button;
    	let current_block_type_index;
    	let if_block0;
    	let t0;
    	let t1;
    	let t2;
    	let div1;
    	let div0;
    	let t3;
    	let show_if = /*selection*/ ctx[13] && (/*selection*/ ctx[13].type === SELECTION_TYPE.VALUE || /*selection*/ ctx[13].type === SELECTION_TYPE.MULTI) && !/*selection*/ ctx[13].edit && isEqual(/*selection*/ ctx[13].focusPath, /*path*/ ctx[1]);
    	let t4;
    	let t5;
    	let t6;
    	let if_block6_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_9, create_else_block_2$1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*expanded*/ ctx[20]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const identifier_slot_template = /*#slots*/ ctx[39].identifier;
    	const identifier_slot = create_slot(identifier_slot_template, ctx, /*$$scope*/ ctx[40], get_identifier_slot_context);
    	let if_block1 = !/*root*/ ctx[24] && create_if_block_8(ctx);

    	function select_block_type_2(ctx, dirty) {
    		if (/*expanded*/ ctx[20]) return create_if_block_7;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block2 = current_block_type(ctx);
    	let if_block3 = show_if && create_if_block_6(ctx);
    	let if_block4 = /*validationError*/ ctx[23] && (!/*expanded*/ ctx[20] || !/*validationError*/ ctx[23].isChildError) && create_if_block_5(ctx);

    	function select_block_type_3(ctx, dirty) {
    		if (/*expanded*/ ctx[20]) return create_if_block_4;
    		return create_else_block$4;
    	}

    	let current_block_type_1 = select_block_type_3(ctx);
    	let if_block5 = current_block_type_1(ctx);
    	let if_block6 = /*expanded*/ ctx[20] && create_if_block_1$3(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			button = element("button");
    			if_block0.c();
    			t0 = space();
    			if (identifier_slot) identifier_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div1 = element("div");
    			div0 = element("div");
    			if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			t4 = space();
    			if (if_block4) if_block4.c();
    			t5 = space();
    			if_block5.c();
    			t6 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty$1();
    			attr_dev(button, "class", "expand svelte-1f20tgc");
    			attr_dev(button, "title", "Expand or collapse this array (Ctrl+Click to expand/collapse recursively)");
    			add_location(button, file$6, 278, 8, 8116);
    			attr_dev(div0, "class", "meta-inner svelte-1f20tgc");
    			attr_dev(div0, "data-type", "selectable-value");
    			add_location(div0, file$6, 294, 10, 8590);
    			attr_dev(div1, "class", "meta svelte-1f20tgc");
    			add_location(div1, file$6, 293, 8, 8561);
    			attr_dev(div2, "class", "header svelte-1f20tgc");
    			add_location(div2, file$6, 277, 6, 8087);
    			attr_dev(div3, "class", "header-outer svelte-1f20tgc");
    			attr_dev(div3, "style", /*indentationStyle*/ ctx[26]);
    			add_location(div3, file$6, 276, 4, 8028);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, button);
    			if_blocks[current_block_type_index].m(button, null);
    			append_dev(div2, t0);

    			if (identifier_slot) {
    				identifier_slot.m(div2, null);
    			}

    			append_dev(div2, t1);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			if_block2.m(div0, null);
    			append_dev(div2, t3);
    			if (if_block3) if_block3.m(div2, null);
    			append_dev(div3, t4);
    			if (if_block4) if_block4.m(div3, null);
    			append_dev(div3, t5);
    			if_block5.m(div3, null);
    			insert_dev(target, t6, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*toggleExpand*/ ctx[28], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(button, null);
    			}

    			if (identifier_slot) {
    				if (identifier_slot.p && (!current || dirty[1] & /*$$scope*/ 512)) {
    					update_slot(identifier_slot, identifier_slot_template, ctx, /*$$scope*/ ctx[40], dirty, get_identifier_slot_changes, get_identifier_slot_context);
    				}
    			}

    			if (!/*root*/ ctx[24]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_8(ctx);
    					if_block1.c();
    					if_block1.m(div2, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(div0, null);
    				}
    			}

    			if (dirty[0] & /*selection, path*/ 8194) show_if = /*selection*/ ctx[13] && (/*selection*/ ctx[13].type === SELECTION_TYPE.VALUE || /*selection*/ ctx[13].type === SELECTION_TYPE.MULTI) && !/*selection*/ ctx[13].edit && isEqual(/*selection*/ ctx[13].focusPath, /*path*/ ctx[1]);

    			if (show_if) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*selection, path*/ 8194) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_6(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div2, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*validationError*/ ctx[23] && (!/*expanded*/ ctx[20] || !/*validationError*/ ctx[23].isChildError)) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[0] & /*validationError, expanded*/ 9437184) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_5(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div3, t5);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_3(ctx)) && if_block5) {
    				if_block5.p(ctx, dirty);
    			} else {
    				if_block5.d(1);
    				if_block5 = current_block_type_1(ctx);

    				if (if_block5) {
    					if_block5.c();
    					if_block5.m(div3, null);
    				}
    			}

    			if (!current || dirty[0] & /*indentationStyle*/ 67108864) {
    				attr_dev(div3, "style", /*indentationStyle*/ ctx[26]);
    			}

    			if (/*expanded*/ ctx[20]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[0] & /*expanded*/ 1048576) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_1$3(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(identifier_slot, local);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block6);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(identifier_slot, local);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block6);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if_blocks[current_block_type_index].d();
    			if (identifier_slot) identifier_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if_block5.d();
    			if (detaching) detach_dev(t6);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(276:2) {#if type === 'array'}",
    		ctx
    	});

    	return block;
    }

    // (508:8) {#if !root}
    function create_if_block_24(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = ":";
    			attr_dev(div, "class", "separator svelte-1f20tgc");
    			add_location(div, file$6, 508, 10, 16738);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_24.name,
    		type: "if",
    		source: "(508:8) {#if !root}",
    		ctx
    	});

    	return block;
    }

    // (520:8) {#if selection && (selection.type === SELECTION_TYPE.VALUE || selection.type === SELECTION_TYPE.MULTI) && !selection.edit && isEqual(selection.focusPath, path)}
    function create_if_block_23(ctx) {
    	let div;
    	let contextmenubutton;
    	let current;

    	contextmenubutton = new ContextMenuButton({
    			props: {
    				selected: true,
    				onContextMenu: /*onContextMenu*/ ctx[10]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(contextmenubutton.$$.fragment);
    			attr_dev(div, "class", "context-menu-button-anchor svelte-1f20tgc");
    			add_location(div, file$6, 520, 10, 17196);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(contextmenubutton, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const contextmenubutton_changes = {};
    			if (dirty[0] & /*onContextMenu*/ 1024) contextmenubutton_changes.onContextMenu = /*onContextMenu*/ ctx[10];
    			contextmenubutton.$set(contextmenubutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contextmenubutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contextmenubutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(contextmenubutton);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_23.name,
    		type: "if",
    		source: "(520:8) {#if selection && (selection.type === SELECTION_TYPE.VALUE || selection.type === SELECTION_TYPE.MULTI) && !selection.edit && isEqual(selection.focusPath, path)}",
    		ctx
    	});

    	return block;
    }

    // (526:6) {#if validationError}
    function create_if_block_22(ctx) {
    	let validationerror;
    	let current;

    	validationerror = new ValidationError$1({
    			props: {
    				validationError: /*validationError*/ ctx[23],
    				onExpand: /*handleExpand*/ ctx[29]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(validationerror.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(validationerror, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const validationerror_changes = {};
    			if (dirty[0] & /*validationError*/ 8388608) validationerror_changes.validationError = /*validationError*/ ctx[23];
    			validationerror.$set(validationerror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(validationerror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(validationerror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(validationerror, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_22.name,
    		type: "if",
    		source: "(526:6) {#if validationError}",
    		ctx
    	});

    	return block;
    }

    // (529:6) {#if !root}
    function create_if_block_21(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "insert-selection-area after svelte-1f20tgc");
    			attr_dev(div, "data-type", "insert-selection-area-after");
    			add_location(div, file$6, 529, 8, 17513);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "mousedown", /*handleInsertAfter*/ ctx[36], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_21.name,
    		type: "if",
    		source: "(529:6) {#if !root}",
    		ctx
    	});

    	return block;
    }

    // (399:10) {:else}
    function create_else_block_4(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: { data: faCaretRight },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop$2,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4.name,
    		type: "else",
    		source: "(399:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (397:10) {#if expanded}
    function create_if_block_20(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: { data: faCaretDown },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop$2,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_20.name,
    		type: "if",
    		source: "(397:10) {#if expanded}",
    		ctx
    	});

    	return block;
    }

    // (404:8) {#if !root}
    function create_if_block_19(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = ":";
    			attr_dev(div, "class", "separator svelte-1f20tgc");
    			add_location(div, file$6, 404, 10, 12838);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_19.name,
    		type: "if",
    		source: "(404:8) {#if !root}",
    		ctx
    	});

    	return block;
    }

    // (413:12) {:else}
    function create_else_block_3(ctx) {
    	let div0;
    	let t1;
    	let button;
    	let t2_value = Object.keys(/*value*/ ctx[0]).length + "";
    	let t2;
    	let t3;
    	let t4;
    	let div1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "{";
    			t1 = space();
    			button = element("button");
    			t2 = text(t2_value);
    			t3 = text(" props");
    			t4 = space();
    			div1 = element("div");
    			div1.textContent = "}";
    			attr_dev(div0, "class", "bracket svelte-1f20tgc");
    			add_location(div0, file$6, 413, 14, 13127);
    			attr_dev(button, "class", "tag svelte-1f20tgc");
    			add_location(button, file$6, 414, 14, 13178);
    			attr_dev(div1, "class", "bracket svelte-1f20tgc");
    			add_location(div1, file$6, 415, 14, 13279);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, button, anchor);
    			append_dev(button, t2);
    			append_dev(button, t3);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div1, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleExpand*/ ctx[29], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*value*/ 1 && t2_value !== (t2_value = Object.keys(/*value*/ ctx[0]).length + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(413:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (409:12) {#if expanded}
    function create_if_block_18(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "{";
    			attr_dev(div, "class", "bracket expanded svelte-1f20tgc");
    			add_location(div, file$6, 409, 14, 13016);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_18.name,
    		type: "if",
    		source: "(409:12) {#if expanded}",
    		ctx
    	});

    	return block;
    }

    // (420:8) {#if selection && (selection.type === SELECTION_TYPE.VALUE || selection.type === SELECTION_TYPE.MULTI) && !selection.edit && isEqual(selection.focusPath, path)}
    function create_if_block_17(ctx) {
    	let div;
    	let contextmenubutton;
    	let current;

    	contextmenubutton = new ContextMenuButton({
    			props: {
    				selected: true,
    				onContextMenu: /*onContextMenu*/ ctx[10]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(contextmenubutton.$$.fragment);
    			attr_dev(div, "class", "context-menu-button-anchor svelte-1f20tgc");
    			add_location(div, file$6, 420, 10, 13544);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(contextmenubutton, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const contextmenubutton_changes = {};
    			if (dirty[0] & /*onContextMenu*/ 1024) contextmenubutton_changes.onContextMenu = /*onContextMenu*/ ctx[10];
    			contextmenubutton.$set(contextmenubutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contextmenubutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contextmenubutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(contextmenubutton);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17.name,
    		type: "if",
    		source: "(420:8) {#if selection && (selection.type === SELECTION_TYPE.VALUE || selection.type === SELECTION_TYPE.MULTI) && !selection.edit && isEqual(selection.focusPath, path)}",
    		ctx
    	});

    	return block;
    }

    // (426:6) {#if validationError && (!expanded || !validationError.isChildError)}
    function create_if_block_16(ctx) {
    	let validationerror;
    	let current;

    	validationerror = new ValidationError$1({
    			props: {
    				validationError: /*validationError*/ ctx[23],
    				onExpand: /*handleExpand*/ ctx[29]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(validationerror.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(validationerror, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const validationerror_changes = {};
    			if (dirty[0] & /*validationError*/ 8388608) validationerror_changes.validationError = /*validationError*/ ctx[23];
    			validationerror.$set(validationerror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(validationerror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(validationerror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(validationerror, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16.name,
    		type: "if",
    		source: "(426:6) {#if validationError && (!expanded || !validationError.isChildError)}",
    		ctx
    	});

    	return block;
    }

    // (436:8) {#if !root}
    function create_if_block_15(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "insert-selection-area after svelte-1f20tgc");
    			attr_dev(div, "data-type", "insert-selection-area-after");
    			add_location(div, file$6, 436, 10, 14119);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "mousedown", /*handleInsertAfter*/ ctx[36], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15.name,
    		type: "if",
    		source: "(436:8) {#if !root}",
    		ctx
    	});

    	return block;
    }

    // (429:6) {#if expanded}
    function create_if_block_14(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "insert-selection-area inside svelte-1f20tgc");
    			attr_dev(div, "data-type", "insert-selection-area-inside");
    			add_location(div, file$6, 429, 8, 13912);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "mousedown", /*handleInsertInside*/ ctx[35], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14.name,
    		type: "if",
    		source: "(429:6) {#if expanded}",
    		ctx
    	});

    	return block;
    }

    // (445:4) {#if expanded}
    function create_if_block_11(ctx) {
    	let div1;
    	let div0;
    	let contextmenubutton;
    	let div0_style_value;
    	let t0;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let div4;
    	let div3;
    	let div2;
    	let t3;
    	let current;

    	contextmenubutton = new ContextMenuButton({
    			props: {
    				selected: /*selectedInside*/ ctx[17],
    				onContextMenu: /*handleInsertInsideOpenContextMenu*/ ctx[37]
    			},
    			$$inline: true
    		});

    	let each_value_2 = /*keys*/ ctx[22];
    	validate_each_argument(each_value_2);
    	const get_key = ctx => /*state*/ ctx[2][/*key*/ ctx[49]][STATE_ID];
    	validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		let child_ctx = get_each_context_2(ctx, each_value_2, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_2(key, child_ctx));
    	}

    	let if_block = !/*root*/ ctx[24] && create_if_block_12(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(contextmenubutton.$$.fragment);
    			t0 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div2.textContent = "}";
    			t3 = space();
    			if (if_block) if_block.c();
    			attr_dev(div0, "class", "insert-area inside svelte-1f20tgc");
    			attr_dev(div0, "data-type", "insert-selection-area-inside");
    			attr_dev(div0, "style", div0_style_value = /*getIndentationStyle*/ ctx[27](/*path*/ ctx[1].length + 1));
    			attr_dev(div0, "title", INSERT_EXPLANATION);
    			toggle_class(div0, "hovered", /*hover*/ ctx[14] === HOVER_INSERT_INSIDE);
    			toggle_class(div0, "selected", /*selectedInside*/ ctx[17]);
    			add_location(div0, file$6, 446, 8, 14377);
    			attr_dev(div1, "class", "props svelte-1f20tgc");
    			add_location(div1, file$6, 445, 6, 14349);
    			attr_dev(div2, "class", "bracket svelte-1f20tgc");
    			add_location(div2, file$6, 492, 10, 16288);
    			attr_dev(div3, "data-type", "selectable-value");
    			attr_dev(div3, "class", "footer svelte-1f20tgc");
    			add_location(div3, file$6, 491, 8, 16228);
    			attr_dev(div4, "class", "footer-outer svelte-1f20tgc");
    			attr_dev(div4, "style", /*indentationStyle*/ ctx[26]);
    			add_location(div4, file$6, 490, 6, 16167);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(contextmenubutton, div0, null);
    			append_dev(div1, t0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			insert_dev(target, t1, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div4, t3);
    			if (if_block) if_block.m(div4, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const contextmenubutton_changes = {};
    			if (dirty[0] & /*selectedInside*/ 131072) contextmenubutton_changes.selected = /*selectedInside*/ ctx[17];
    			contextmenubutton.$set(contextmenubutton_changes);

    			if (!current || dirty[0] & /*path*/ 2 && div0_style_value !== (div0_style_value = /*getIndentationStyle*/ ctx[27](/*path*/ ctx[1].length + 1))) {
    				attr_dev(div0, "style", div0_style_value);
    			}

    			if (dirty[0] & /*hover*/ 16384) {
    				toggle_class(div0, "hovered", /*hover*/ ctx[14] === HOVER_INSERT_INSIDE);
    			}

    			if (dirty[0] & /*selectedInside*/ 131072) {
    				toggle_class(div0, "selected", /*selectedInside*/ ctx[17]);
    			}

    			if (dirty[0] & /*value, keys, path, state, readOnly, searchResult, validationErrors, onPatch, onInsert, onExpand, onSelect, onExpandSection, onContextMenu, onClassName, selection, handleUpdateKey*/ 1077952511) {
    				each_value_2 = /*keys*/ ctx[22];
    				validate_each_argument(each_value_2);
    				group_outros();
    				validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each_1_lookup, div1, outro_and_destroy_block, create_each_block_2, null, get_each_context_2);
    				check_outros();
    			}

    			if (!/*root*/ ctx[24]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_12(ctx);
    					if_block.c();
    					if_block.m(div4, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (!current || dirty[0] & /*indentationStyle*/ 67108864) {
    				attr_dev(div4, "style", /*indentationStyle*/ ctx[26]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contextmenubutton.$$.fragment, local);

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contextmenubutton.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(contextmenubutton);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div4);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(445:4) {#if expanded}",
    		ctx
    	});

    	return block;
    }

    // (484:14) {#if selection && selection.type === SELECTION_TYPE.KEY && !selection.edit && isEqual(selection.focusPath, path.concat(key))}
    function create_if_block_13(ctx) {
    	let contextmenubutton;
    	let current;

    	contextmenubutton = new ContextMenuButton({
    			props: {
    				selected: true,
    				onContextMenu: /*onContextMenu*/ ctx[10]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(contextmenubutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(contextmenubutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const contextmenubutton_changes = {};
    			if (dirty[0] & /*onContextMenu*/ 1024) contextmenubutton_changes.onContextMenu = /*onContextMenu*/ ctx[10];
    			contextmenubutton.$set(contextmenubutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contextmenubutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contextmenubutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(contextmenubutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(484:14) {#if selection && selection.type === SELECTION_TYPE.KEY && !selection.edit && isEqual(selection.focusPath, path.concat(key))}",
    		ctx
    	});

    	return block;
    }

    // (474:12) 
    function create_identifier_slot_1(ctx) {
    	let div;
    	let jsonkey;
    	let t0;
    	let show_if = /*selection*/ ctx[13] && /*selection*/ ctx[13].type === SELECTION_TYPE.KEY && !/*selection*/ ctx[13].edit && isEqual(/*selection*/ ctx[13].focusPath, /*path*/ ctx[1].concat(/*key*/ ctx[49]));
    	let t1;
    	let current;

    	jsonkey = new JSONKey({
    			props: {
    				path: /*path*/ ctx[1].concat(/*key*/ ctx[49]),
    				key: /*key*/ ctx[49],
    				readOnly: /*readOnly*/ ctx[3],
    				onUpdateKey: /*handleUpdateKey*/ ctx[30],
    				selection: /*selection*/ ctx[13],
    				onSelect: /*onSelect*/ ctx[9],
    				searchResult: /*searchResult*/ ctx[4]
    				? /*searchResult*/ ctx[4][/*key*/ ctx[49]]
    				: undefined
    			},
    			$$inline: true
    		});

    	let if_block = show_if && create_if_block_13(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(jsonkey.$$.fragment);
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			attr_dev(div, "slot", "identifier");
    			attr_dev(div, "class", "identifier svelte-1f20tgc");
    			add_location(div, file$6, 473, 12, 15463);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(jsonkey, div, null);
    			append_dev(div, t0);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const jsonkey_changes = {};
    			if (dirty[0] & /*path, keys*/ 4194306) jsonkey_changes.path = /*path*/ ctx[1].concat(/*key*/ ctx[49]);
    			if (dirty[0] & /*keys*/ 4194304) jsonkey_changes.key = /*key*/ ctx[49];
    			if (dirty[0] & /*readOnly*/ 8) jsonkey_changes.readOnly = /*readOnly*/ ctx[3];
    			if (dirty[0] & /*selection*/ 8192) jsonkey_changes.selection = /*selection*/ ctx[13];
    			if (dirty[0] & /*onSelect*/ 512) jsonkey_changes.onSelect = /*onSelect*/ ctx[9];

    			if (dirty[0] & /*searchResult, keys*/ 4194320) jsonkey_changes.searchResult = /*searchResult*/ ctx[4]
    			? /*searchResult*/ ctx[4][/*key*/ ctx[49]]
    			: undefined;

    			jsonkey.$set(jsonkey_changes);
    			if (dirty[0] & /*selection, path, keys*/ 4202498) show_if = /*selection*/ ctx[13] && /*selection*/ ctx[13].type === SELECTION_TYPE.KEY && !/*selection*/ ctx[13].edit && isEqual(/*selection*/ ctx[13].focusPath, /*path*/ ctx[1].concat(/*key*/ ctx[49]));

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*selection, path, keys*/ 4202498) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_13(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(jsonkey.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(jsonkey.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(jsonkey);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_identifier_slot_1.name,
    		type: "slot",
    		source: "(474:12) ",
    		ctx
    	});

    	return block;
    }

    // (457:8) {#each keys as key (state[key][STATE_ID])}
    function create_each_block_2(key_1, ctx) {
    	let first;
    	let jsonnode;
    	let current;

    	jsonnode = new JSONNode({
    			props: {
    				value: /*value*/ ctx[0][/*key*/ ctx[49]],
    				path: /*path*/ ctx[1].concat(/*key*/ ctx[49]),
    				state: /*state*/ ctx[2][/*key*/ ctx[49]],
    				readOnly: /*readOnly*/ ctx[3],
    				searchResult: /*searchResult*/ ctx[4]
    				? /*searchResult*/ ctx[4][/*key*/ ctx[49]]
    				: undefined,
    				validationErrors: /*validationErrors*/ ctx[5]
    				? /*validationErrors*/ ctx[5][/*key*/ ctx[49]]
    				: undefined,
    				onPatch: /*onPatch*/ ctx[6],
    				onInsert: /*onInsert*/ ctx[7],
    				onExpand: /*onExpand*/ ctx[8],
    				onSelect: /*onSelect*/ ctx[9],
    				onExpandSection: /*onExpandSection*/ ctx[12],
    				onContextMenu: /*onContextMenu*/ ctx[10],
    				onClassName: /*onClassName*/ ctx[11],
    				selection: /*selection*/ ctx[13],
    				$$slots: { identifier: [create_identifier_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty$1();
    			create_component(jsonnode.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(jsonnode, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const jsonnode_changes = {};
    			if (dirty[0] & /*value, keys*/ 4194305) jsonnode_changes.value = /*value*/ ctx[0][/*key*/ ctx[49]];
    			if (dirty[0] & /*path, keys*/ 4194306) jsonnode_changes.path = /*path*/ ctx[1].concat(/*key*/ ctx[49]);
    			if (dirty[0] & /*state, keys*/ 4194308) jsonnode_changes.state = /*state*/ ctx[2][/*key*/ ctx[49]];
    			if (dirty[0] & /*readOnly*/ 8) jsonnode_changes.readOnly = /*readOnly*/ ctx[3];

    			if (dirty[0] & /*searchResult, keys*/ 4194320) jsonnode_changes.searchResult = /*searchResult*/ ctx[4]
    			? /*searchResult*/ ctx[4][/*key*/ ctx[49]]
    			: undefined;

    			if (dirty[0] & /*validationErrors, keys*/ 4194336) jsonnode_changes.validationErrors = /*validationErrors*/ ctx[5]
    			? /*validationErrors*/ ctx[5][/*key*/ ctx[49]]
    			: undefined;

    			if (dirty[0] & /*onPatch*/ 64) jsonnode_changes.onPatch = /*onPatch*/ ctx[6];
    			if (dirty[0] & /*onInsert*/ 128) jsonnode_changes.onInsert = /*onInsert*/ ctx[7];
    			if (dirty[0] & /*onExpand*/ 256) jsonnode_changes.onExpand = /*onExpand*/ ctx[8];
    			if (dirty[0] & /*onSelect*/ 512) jsonnode_changes.onSelect = /*onSelect*/ ctx[9];
    			if (dirty[0] & /*onExpandSection*/ 4096) jsonnode_changes.onExpandSection = /*onExpandSection*/ ctx[12];
    			if (dirty[0] & /*onContextMenu*/ 1024) jsonnode_changes.onContextMenu = /*onContextMenu*/ ctx[10];
    			if (dirty[0] & /*onClassName*/ 2048) jsonnode_changes.onClassName = /*onClassName*/ ctx[11];
    			if (dirty[0] & /*selection*/ 8192) jsonnode_changes.selection = /*selection*/ ctx[13];

    			if (dirty[0] & /*onContextMenu, selection, path, keys, readOnly, onSelect, searchResult*/ 4204058 | dirty[1] & /*$$scope*/ 512) {
    				jsonnode_changes.$$scope = { dirty, ctx };
    			}

    			jsonnode.$set(jsonnode_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(jsonnode.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(jsonnode.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(jsonnode, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(457:8) {#each keys as key (state[key][STATE_ID])}",
    		ctx
    	});

    	return block;
    }

    // (495:8) {#if !root}
    function create_if_block_12(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "insert-selection-area after svelte-1f20tgc");
    			attr_dev(div, "data-type", "insert-selection-area-after");
    			add_location(div, file$6, 495, 10, 16369);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "mousedown", /*handleInsertAfter*/ ctx[36], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(495:8) {#if !root}",
    		ctx
    	});

    	return block;
    }

    // (286:10) {:else}
    function create_else_block_2$1(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: { data: faCaretRight },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop$2,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(286:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (284:10) {#if expanded}
    function create_if_block_9(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: { data: faCaretDown },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop$2,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(284:10) {#if expanded}",
    		ctx
    	});

    	return block;
    }

    // (291:8) {#if !root}
    function create_if_block_8(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = ":";
    			attr_dev(div, "class", "separator svelte-1f20tgc");
    			add_location(div, file$6, 291, 10, 8508);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(291:8) {#if !root}",
    		ctx
    	});

    	return block;
    }

    // (300:12) {:else}
    function create_else_block_1$1(ctx) {
    	let div0;
    	let t1;
    	let button;
    	let t2_value = /*value*/ ctx[0].length + "";
    	let t2;
    	let t3;
    	let t4;
    	let div1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "[";
    			t1 = space();
    			button = element("button");
    			t2 = text(t2_value);
    			t3 = text(" items");
    			t4 = space();
    			div1 = element("div");
    			div1.textContent = "]";
    			attr_dev(div0, "class", "bracket svelte-1f20tgc");
    			add_location(div0, file$6, 300, 14, 8789);
    			attr_dev(button, "class", "tag svelte-1f20tgc");
    			add_location(button, file$6, 301, 14, 8832);
    			attr_dev(div1, "class", "bracket svelte-1f20tgc");
    			add_location(div1, file$6, 302, 14, 8920);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, button, anchor);
    			append_dev(button, t2);
    			append_dev(button, t3);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div1, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleExpand*/ ctx[29], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*value*/ 1 && t2_value !== (t2_value = /*value*/ ctx[0].length + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(300:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (296:12) {#if expanded}
    function create_if_block_7(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "[";
    			attr_dev(div, "class", "bracket expanded svelte-1f20tgc");
    			add_location(div, file$6, 296, 14, 8685);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(296:12) {#if expanded}",
    		ctx
    	});

    	return block;
    }

    // (307:8) {#if selection && (selection.type === SELECTION_TYPE.VALUE || selection.type === SELECTION_TYPE.MULTI) && !selection.edit && isEqual(selection.focusPath, path)}
    function create_if_block_6(ctx) {
    	let div;
    	let contextmenubutton;
    	let current;

    	contextmenubutton = new ContextMenuButton({
    			props: {
    				selected: true,
    				onContextMenu: /*onContextMenu*/ ctx[10]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(contextmenubutton.$$.fragment);
    			attr_dev(div, "class", "context-menu-button-anchor svelte-1f20tgc");
    			add_location(div, file$6, 307, 10, 9178);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(contextmenubutton, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const contextmenubutton_changes = {};
    			if (dirty[0] & /*onContextMenu*/ 1024) contextmenubutton_changes.onContextMenu = /*onContextMenu*/ ctx[10];
    			contextmenubutton.$set(contextmenubutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contextmenubutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contextmenubutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(contextmenubutton);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(307:8) {#if selection && (selection.type === SELECTION_TYPE.VALUE || selection.type === SELECTION_TYPE.MULTI) && !selection.edit && isEqual(selection.focusPath, path)}",
    		ctx
    	});

    	return block;
    }

    // (313:6) {#if validationError && (!expanded || !validationError.isChildError)}
    function create_if_block_5(ctx) {
    	let validationerror;
    	let current;

    	validationerror = new ValidationError$1({
    			props: {
    				validationError: /*validationError*/ ctx[23],
    				onExpand: /*handleExpand*/ ctx[29]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(validationerror.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(validationerror, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const validationerror_changes = {};
    			if (dirty[0] & /*validationError*/ 8388608) validationerror_changes.validationError = /*validationError*/ ctx[23];
    			validationerror.$set(validationerror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(validationerror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(validationerror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(validationerror, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(313:6) {#if validationError && (!expanded || !validationError.isChildError)}",
    		ctx
    	});

    	return block;
    }

    // (322:6) {:else}
    function create_else_block$4(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "insert-selection-area after svelte-1f20tgc");
    			attr_dev(div, "data-type", "insert-selection-area-after");
    			add_location(div, file$6, 322, 8, 9731);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "mousedown", /*handleInsertAfter*/ ctx[36], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(322:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (316:6) {#if expanded}
    function create_if_block_4(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "insert-selection-area inside svelte-1f20tgc");
    			attr_dev(div, "data-type", "insert-selection-area-inside");
    			add_location(div, file$6, 316, 8, 9546);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "mousedown", /*handleInsertInside*/ ctx[35], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(316:6) {#if expanded}",
    		ctx
    	});

    	return block;
    }

    // (330:4) {#if expanded}
    function create_if_block_1$3(ctx) {
    	let div1;
    	let div0;
    	let contextmenubutton;
    	let div0_style_value;
    	let t0;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let div3;
    	let div2;
    	let span;
    	let t3;
    	let current;

    	contextmenubutton = new ContextMenuButton({
    			props: {
    				selected: /*selectedInside*/ ctx[17],
    				onContextMenu: /*handleInsertInsideOpenContextMenu*/ ctx[37]
    			},
    			$$inline: true
    		});

    	let each_value = /*visibleSections*/ ctx[21];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*sectionIndex*/ ctx[45];
    	validate_each_keys(ctx, each_value, get_each_context$1, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$1(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
    	}

    	let if_block = !/*root*/ ctx[24] && create_if_block_2$1(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(contextmenubutton.$$.fragment);
    			t0 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			div3 = element("div");
    			div2 = element("div");
    			span = element("span");
    			span.textContent = "]";
    			t3 = space();
    			if (if_block) if_block.c();
    			attr_dev(div0, "class", "insert-area inside svelte-1f20tgc");
    			attr_dev(div0, "data-type", "insert-selection-area-inside");
    			attr_dev(div0, "style", div0_style_value = /*getIndentationStyle*/ ctx[27](/*path*/ ctx[1].length + 1));
    			attr_dev(div0, "title", INSERT_EXPLANATION);
    			toggle_class(div0, "hovered", /*hover*/ ctx[14] === HOVER_INSERT_INSIDE);
    			toggle_class(div0, "selected", /*selectedInside*/ ctx[17]);
    			add_location(div0, file$6, 331, 8, 9967);
    			attr_dev(div1, "class", "items svelte-1f20tgc");
    			add_location(div1, file$6, 330, 6, 9939);
    			attr_dev(span, "class", "bracket svelte-1f20tgc");
    			add_location(span, file$6, 377, 10, 12041);
    			attr_dev(div2, "data-type", "selectable-value");
    			attr_dev(div2, "class", "footer svelte-1f20tgc");
    			add_location(div2, file$6, 376, 8, 11981);
    			attr_dev(div3, "class", "footer-outer svelte-1f20tgc");
    			attr_dev(div3, "style", /*indentationStyle*/ ctx[26]);
    			add_location(div3, file$6, 375, 6, 11920);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(contextmenubutton, div0, null);
    			append_dev(div1, t0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			insert_dev(target, t1, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, span);
    			append_dev(div3, t3);
    			if (if_block) if_block.m(div3, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const contextmenubutton_changes = {};
    			if (dirty[0] & /*selectedInside*/ 131072) contextmenubutton_changes.selected = /*selectedInside*/ ctx[17];
    			contextmenubutton.$set(contextmenubutton_changes);

    			if (!current || dirty[0] & /*path*/ 2 && div0_style_value !== (div0_style_value = /*getIndentationStyle*/ ctx[27](/*path*/ ctx[1].length + 1))) {
    				attr_dev(div0, "style", div0_style_value);
    			}

    			if (dirty[0] & /*hover*/ 16384) {
    				toggle_class(div0, "hovered", /*hover*/ ctx[14] === HOVER_INSERT_INSIDE);
    			}

    			if (dirty[0] & /*selectedInside*/ 131072) {
    				toggle_class(div0, "selected", /*selectedInside*/ ctx[17]);
    			}

    			if (dirty[0] & /*visibleSections, value, path, onExpandSection, state, readOnly, searchResult, validationErrors, onPatch, onInsert, onExpand, onSelect, onContextMenu, onClassName, selection*/ 2113535) {
    				each_value = /*visibleSections*/ ctx[21];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$1, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block$1, null, get_each_context$1);
    				check_outros();
    			}

    			if (!/*root*/ ctx[24]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$1(ctx);
    					if_block.c();
    					if_block.m(div3, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (!current || dirty[0] & /*indentationStyle*/ 67108864) {
    				attr_dev(div3, "style", /*indentationStyle*/ ctx[26]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contextmenubutton.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contextmenubutton.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(contextmenubutton);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div3);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(330:4) {#if expanded}",
    		ctx
    	});

    	return block;
    }

    // (360:14) 
    function create_identifier_slot(ctx) {
    	let div1;
    	let div0;
    	let t_value = /*visibleSection*/ ctx[43].start + /*itemIndex*/ ctx[48] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t = text(t_value);
    			attr_dev(div0, "class", "index svelte-1f20tgc");
    			add_location(div0, file$6, 360, 16, 11451);
    			attr_dev(div1, "slot", "identifier");
    			attr_dev(div1, "class", "identifier svelte-1f20tgc");
    			add_location(div1, file$6, 359, 14, 11392);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*visibleSections, value*/ 2097153 && t_value !== (t_value = /*visibleSection*/ ctx[43].start + /*itemIndex*/ ctx[48] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_identifier_slot.name,
    		type: "slot",
    		source: "(360:14) ",
    		ctx
    	});

    	return block;
    }

    // (343:10) {#each value.slice(visibleSection.start, Math.min(visibleSection.end, value.length)) as item, itemIndex (state[visibleSection.start + itemIndex][STATE_ID])}
    function create_each_block_1$1(key_1, ctx) {
    	let first;
    	let jsonnode;
    	let current;

    	jsonnode = new JSONNode({
    			props: {
    				value: /*item*/ ctx[46],
    				path: /*path*/ ctx[1].concat(/*visibleSection*/ ctx[43].start + /*itemIndex*/ ctx[48]),
    				state: /*state*/ ctx[2][/*visibleSection*/ ctx[43].start + /*itemIndex*/ ctx[48]],
    				readOnly: /*readOnly*/ ctx[3],
    				searchResult: /*searchResult*/ ctx[4]
    				? /*searchResult*/ ctx[4][/*visibleSection*/ ctx[43].start + /*itemIndex*/ ctx[48]]
    				: undefined,
    				validationErrors: /*validationErrors*/ ctx[5]
    				? /*validationErrors*/ ctx[5][/*visibleSection*/ ctx[43].start + /*itemIndex*/ ctx[48]]
    				: undefined,
    				onPatch: /*onPatch*/ ctx[6],
    				onInsert: /*onInsert*/ ctx[7],
    				onExpand: /*onExpand*/ ctx[8],
    				onSelect: /*onSelect*/ ctx[9],
    				onExpandSection: /*onExpandSection*/ ctx[12],
    				onContextMenu: /*onContextMenu*/ ctx[10],
    				onClassName: /*onClassName*/ ctx[11],
    				selection: /*selection*/ ctx[13],
    				$$slots: { identifier: [create_identifier_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty$1();
    			create_component(jsonnode.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(jsonnode, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const jsonnode_changes = {};
    			if (dirty[0] & /*value, visibleSections*/ 2097153) jsonnode_changes.value = /*item*/ ctx[46];
    			if (dirty[0] & /*path, visibleSections, value*/ 2097155) jsonnode_changes.path = /*path*/ ctx[1].concat(/*visibleSection*/ ctx[43].start + /*itemIndex*/ ctx[48]);
    			if (dirty[0] & /*state, visibleSections, value*/ 2097157) jsonnode_changes.state = /*state*/ ctx[2][/*visibleSection*/ ctx[43].start + /*itemIndex*/ ctx[48]];
    			if (dirty[0] & /*readOnly*/ 8) jsonnode_changes.readOnly = /*readOnly*/ ctx[3];

    			if (dirty[0] & /*searchResult, visibleSections, value*/ 2097169) jsonnode_changes.searchResult = /*searchResult*/ ctx[4]
    			? /*searchResult*/ ctx[4][/*visibleSection*/ ctx[43].start + /*itemIndex*/ ctx[48]]
    			: undefined;

    			if (dirty[0] & /*validationErrors, visibleSections, value*/ 2097185) jsonnode_changes.validationErrors = /*validationErrors*/ ctx[5]
    			? /*validationErrors*/ ctx[5][/*visibleSection*/ ctx[43].start + /*itemIndex*/ ctx[48]]
    			: undefined;

    			if (dirty[0] & /*onPatch*/ 64) jsonnode_changes.onPatch = /*onPatch*/ ctx[6];
    			if (dirty[0] & /*onInsert*/ 128) jsonnode_changes.onInsert = /*onInsert*/ ctx[7];
    			if (dirty[0] & /*onExpand*/ 256) jsonnode_changes.onExpand = /*onExpand*/ ctx[8];
    			if (dirty[0] & /*onSelect*/ 512) jsonnode_changes.onSelect = /*onSelect*/ ctx[9];
    			if (dirty[0] & /*onExpandSection*/ 4096) jsonnode_changes.onExpandSection = /*onExpandSection*/ ctx[12];
    			if (dirty[0] & /*onContextMenu*/ 1024) jsonnode_changes.onContextMenu = /*onContextMenu*/ ctx[10];
    			if (dirty[0] & /*onClassName*/ 2048) jsonnode_changes.onClassName = /*onClassName*/ ctx[11];
    			if (dirty[0] & /*selection*/ 8192) jsonnode_changes.selection = /*selection*/ ctx[13];

    			if (dirty[0] & /*visibleSections, value*/ 2097153 | dirty[1] & /*$$scope*/ 512) {
    				jsonnode_changes.$$scope = { dirty, ctx };
    			}

    			jsonnode.$set(jsonnode_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(jsonnode.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(jsonnode.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(jsonnode, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(343:10) {#each value.slice(visibleSection.start, Math.min(visibleSection.end, value.length)) as item, itemIndex (state[visibleSection.start + itemIndex][STATE_ID])}",
    		ctx
    	});

    	return block;
    }

    // (365:10) {#if visibleSection.end < value.length}
    function create_if_block_3(ctx) {
    	let collapseditems;
    	let current;

    	collapseditems = new CollapsedItems({
    			props: {
    				visibleSections: /*visibleSections*/ ctx[21],
    				sectionIndex: /*sectionIndex*/ ctx[45],
    				total: /*value*/ ctx[0].length,
    				path: /*path*/ ctx[1],
    				onExpandSection: /*onExpandSection*/ ctx[12]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(collapseditems.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(collapseditems, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const collapseditems_changes = {};
    			if (dirty[0] & /*visibleSections*/ 2097152) collapseditems_changes.visibleSections = /*visibleSections*/ ctx[21];
    			if (dirty[0] & /*visibleSections*/ 2097152) collapseditems_changes.sectionIndex = /*sectionIndex*/ ctx[45];
    			if (dirty[0] & /*value*/ 1) collapseditems_changes.total = /*value*/ ctx[0].length;
    			if (dirty[0] & /*path*/ 2) collapseditems_changes.path = /*path*/ ctx[1];
    			if (dirty[0] & /*onExpandSection*/ 4096) collapseditems_changes.onExpandSection = /*onExpandSection*/ ctx[12];
    			collapseditems.$set(collapseditems_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(collapseditems.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(collapseditems.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(collapseditems, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(365:10) {#if visibleSection.end < value.length}",
    		ctx
    	});

    	return block;
    }

    // (342:8) {#each visibleSections as visibleSection, sectionIndex (sectionIndex)}
    function create_each_block$1(key_1, ctx) {
    	let first;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t;
    	let if_block_anchor;
    	let current;
    	let each_value_1 = /*value*/ ctx[0].slice(/*visibleSection*/ ctx[43].start, Math.min(/*visibleSection*/ ctx[43].end, /*value*/ ctx[0].length));
    	validate_each_argument(each_value_1);
    	const get_key = ctx => /*state*/ ctx[2][/*visibleSection*/ ctx[43].start + /*itemIndex*/ ctx[48]][STATE_ID];
    	validate_each_keys(ctx, each_value_1, get_each_context_1$1, get_key);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$1(key, child_ctx));
    	}

    	let if_block = /*visibleSection*/ ctx[43].end < /*value*/ ctx[0].length && create_if_block_3(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty$1();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*value, visibleSections, path, state, readOnly, searchResult, validationErrors, onPatch, onInsert, onExpand, onSelect, onExpandSection, onContextMenu, onClassName, selection*/ 2113535) {
    				each_value_1 = /*value*/ ctx[0].slice(/*visibleSection*/ ctx[43].start, Math.min(/*visibleSection*/ ctx[43].end, /*value*/ ctx[0].length));
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1$1, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, t.parentNode, outro_and_destroy_block, create_each_block_1$1, t, get_each_context_1$1);
    				check_outros();
    			}

    			if (/*visibleSection*/ ctx[43].end < /*value*/ ctx[0].length) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*visibleSections, value*/ 2097153) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(342:8) {#each visibleSections as visibleSection, sectionIndex (sectionIndex)}",
    		ctx
    	});

    	return block;
    }

    // (380:8) {#if !root}
    function create_if_block_2$1(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "insert-selection-area after svelte-1f20tgc");
    			attr_dev(div, "data-type", "insert-selection-area-after");
    			add_location(div, file$6, 380, 10, 12117);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "mousedown", /*handleInsertAfter*/ ctx[36], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(380:8) {#if !root}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let div1;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let div0;
    	let contextmenubutton;
    	let div1_class_value;
    	let div1_data_path_value;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block$5, create_if_block_10, create_else_block_5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*type*/ ctx[25] === "array") return 0;
    		if (/*type*/ ctx[25] === "object") return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	contextmenubutton = new ContextMenuButton({
    			props: {
    				selected: /*selectedAfter*/ ctx[16],
    				onContextMenu: /*handleInsertAfterOpenContextMenu*/ ctx[38]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if_block.c();
    			t = space();
    			div0 = element("div");
    			create_component(contextmenubutton.$$.fragment);
    			attr_dev(div0, "class", "insert-area after svelte-1f20tgc");
    			attr_dev(div0, "data-type", "insert-selection-area-after");
    			attr_dev(div0, "style", /*indentationStyle*/ ctx[26]);
    			attr_dev(div0, "title", INSERT_EXPLANATION);
    			toggle_class(div0, "hovered", /*hover*/ ctx[14] === HOVER_INSERT_AFTER);
    			toggle_class(div0, "selected", /*selectedAfter*/ ctx[16]);
    			add_location(div0, file$6, 537, 2, 17706);
    			attr_dev(div1, "class", div1_class_value = "" + (null_to_empty(classnames("json-node", { expanded: /*expanded*/ ctx[20] }, /*onClassName*/ ctx[11](/*path*/ ctx[1], /*value*/ ctx[0]))) + " svelte-1f20tgc"));
    			attr_dev(div1, "data-path", div1_data_path_value = immutableJSONPatch.compileJSONPointer(/*path*/ ctx[1]));
    			toggle_class(div1, "root", /*root*/ ctx[24]);
    			toggle_class(div1, "selected", /*selected*/ ctx[15]);
    			toggle_class(div1, "selected-key", /*selectedKey*/ ctx[18]);
    			toggle_class(div1, "selected-value", /*selectedValue*/ ctx[19]);
    			toggle_class(div1, "hovered", /*hover*/ ctx[14] === HOVER_COLLECTION);
    			add_location(div1, file$6, 262, 0, 7582);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			if_blocks[current_block_type_index].m(div1, null);
    			append_dev(div1, t);
    			append_dev(div1, div0);
    			mount_component(contextmenubutton, div0, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div1, "mousedown", /*handleMouseDown*/ ctx[31], false, false, false),
    					listen_dev(div1, "mousemove", /*handleMouseMove*/ ctx[32], false, false, false),
    					listen_dev(div1, "mouseover", /*handleMouseOver*/ ctx[33], false, false, false),
    					listen_dev(div1, "mouseout", /*handleMouseOut*/ ctx[34], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div1, t);
    			}

    			const contextmenubutton_changes = {};
    			if (dirty[0] & /*selectedAfter*/ 65536) contextmenubutton_changes.selected = /*selectedAfter*/ ctx[16];
    			contextmenubutton.$set(contextmenubutton_changes);

    			if (!current || dirty[0] & /*indentationStyle*/ 67108864) {
    				attr_dev(div0, "style", /*indentationStyle*/ ctx[26]);
    			}

    			if (dirty[0] & /*hover*/ 16384) {
    				toggle_class(div0, "hovered", /*hover*/ ctx[14] === HOVER_INSERT_AFTER);
    			}

    			if (dirty[0] & /*selectedAfter*/ 65536) {
    				toggle_class(div0, "selected", /*selectedAfter*/ ctx[16]);
    			}

    			if (!current || dirty[0] & /*expanded, onClassName, path, value*/ 1050627 && div1_class_value !== (div1_class_value = "" + (null_to_empty(classnames("json-node", { expanded: /*expanded*/ ctx[20] }, /*onClassName*/ ctx[11](/*path*/ ctx[1], /*value*/ ctx[0]))) + " svelte-1f20tgc"))) {
    				attr_dev(div1, "class", div1_class_value);
    			}

    			if (!current || dirty[0] & /*path*/ 2 && div1_data_path_value !== (div1_data_path_value = immutableJSONPatch.compileJSONPointer(/*path*/ ctx[1]))) {
    				attr_dev(div1, "data-path", div1_data_path_value);
    			}

    			if (dirty[0] & /*expanded, onClassName, path, value, root*/ 17827843) {
    				toggle_class(div1, "root", /*root*/ ctx[24]);
    			}

    			if (dirty[0] & /*expanded, onClassName, path, value, selected*/ 1083395) {
    				toggle_class(div1, "selected", /*selected*/ ctx[15]);
    			}

    			if (dirty[0] & /*expanded, onClassName, path, value, selectedKey*/ 1312771) {
    				toggle_class(div1, "selected-key", /*selectedKey*/ ctx[18]);
    			}

    			if (dirty[0] & /*expanded, onClassName, path, value, selectedValue*/ 1574915) {
    				toggle_class(div1, "selected-value", /*selectedValue*/ ctx[19]);
    			}

    			if (dirty[0] & /*expanded, onClassName, path, value, hover*/ 1067011) {
    				toggle_class(div1, "hovered", /*hover*/ ctx[14] === HOVER_COLLECTION);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(contextmenubutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(contextmenubutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if_blocks[current_block_type_index].d();
    			destroy_component(contextmenubutton);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let selected;
    	let selectedAfter;
    	let selectedInside;
    	let selectedKey;
    	let selectedValue;
    	let expanded;
    	let visibleSections;
    	let keys;
    	let validationError;
    	let root;
    	let type;
    	let indentationStyle;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("JSONNode", slots, ['identifier']);
    	let { value } = $$props;
    	let { path } = $$props;
    	let { state } = $$props;
    	let { readOnly } = $$props;
    	let { searchResult } = $$props;
    	let { validationErrors } = $$props;
    	let { onPatch } = $$props;
    	let { onInsert } = $$props;
    	let { onExpand } = $$props;
    	let { onSelect } = $$props;
    	let { onContextMenu } = $$props;
    	let { onClassName } = $$props;
    	let { onExpandSection } = $$props;
    	let { selection } = $$props;
    	let hover = null;

    	function getIndentationStyle(level) {
    		return `margin-left: ${level * INDENTATION_WIDTH}px`;
    	}

    	function toggleExpand(event) {
    		event.stopPropagation();
    		const recursive = event.ctrlKey;
    		onExpand(path, !expanded, recursive);
    	}

    	function handleExpand(event) {
    		event.stopPropagation();
    		onExpand(path, true);
    	}

    	function handleUpdateKey(oldKey, newKey) {
    		const operations = rename(path, keys, oldKey, newKey);
    		onPatch(operations);

    		// It is possible that the applied key differs from newKey,
    		// to prevent duplicate keys. Here we figure out the actually applied key
    		const newKeyUnique = last(immutableJSONPatch.getIn(operations, [0, "path"]));

    		return newKeyUnique;
    	}

    	function handleMouseDown(event) {
    		// check if the mouse down is not happening in the key or value input fields or on a button
    		if (isContentEditableDiv(event.target) || isChildOfNodeName(event.target, "BUTTON")) {
    			return;
    		}

    		event.stopPropagation();
    		event.preventDefault();
    		const anchorType = getSelectionTypeFromTarget(event.target);

    		// when right clicking inside the current selection, do nothing
    		if (event.button === 2 && selection && isPathInsideSelection(selection, path, anchorType)) {
    			return;
    		}

    		// TODO: implement start of a drag event when dragging selection with left mouse button
    		singleton.mousedown = true;

    		singleton.selectionAnchor = path;
    		singleton.selectionAnchorType = anchorType;
    		singleton.selectionFocus = path;

    		if (event.shiftKey) {
    			// Shift+Click will select multiple entries
    			onSelect({
    				type: SELECTION_TYPE.MULTI,
    				anchorPath: selection.anchorPath,
    				focusPath: path
    			});
    		} else {
    			switch (anchorType) {
    				case SELECTION_TYPE.KEY:
    					onSelect({ type: SELECTION_TYPE.KEY, path });
    					break;
    				case SELECTION_TYPE.VALUE:
    					onSelect({ type: SELECTION_TYPE.VALUE, path });
    					break;
    				case SELECTION_TYPE.MULTI:
    					if (root && event.target.hasAttribute("data-path")) {
    						const lastCaretPosition = last(getVisibleCaretPositions(value, state));
    						onSelect(lastCaretPosition);
    					} else {
    						onSelect({
    							type: SELECTION_TYPE.MULTI,
    							anchorPath: path,
    							focusPath: path
    						});
    					}
    					break;
    				case SELECTION_TYPE.AFTER:
    				case SELECTION_TYPE.INSIDE:
    					// do nothing: event already handled by event listener on the element or component itself
    					// TODO: move the logic here instead of in separate event listeners
    					break;
    			}
    		}

    		// we attach the mouse up event listener to the global document,
    		// so we will not miss if the mouse up is happening outside of the editor
    		document.addEventListener("mouseup", handleMouseUp);
    	}

    	function handleMouseMove(event) {
    		if (singleton.mousedown) {
    			event.preventDefault();
    			event.stopPropagation();

    			if (singleton.selectionFocus == null) {
    				// First move event, no selection yet.
    				// Clear the default selection of the browser
    				if (window.getSelection) {
    					window.getSelection().empty();
    				}
    			}

    			const selectionType = getSelectionTypeFromTarget(event.target);

    			if (!isEqual(path, singleton.selectionFocus) || selectionType !== singleton.selectionAnchorType) {
    				singleton.selectionFocus = path;

    				onSelect({
    					anchorPath: singleton.selectionAnchor,
    					focusPath: singleton.selectionFocus
    				});
    			}
    		}
    	}

    	function handleMouseUp(event) {
    		if (singleton.mousedown) {
    			event.stopPropagation();
    			singleton.mousedown = false;
    		}

    		document.removeEventListener("mouseup", handleMouseUp);
    	}

    	function handleMouseOver(event) {
    		event.stopPropagation();

    		if (isChildOfAttribute(event.target, "data-type", "selectable-value")) {
    			$$invalidate(14, hover = HOVER_COLLECTION);
    		} else if (isChildOfAttribute(event.target, "data-type", "insert-selection-area-inside")) {
    			$$invalidate(14, hover = HOVER_INSERT_INSIDE);
    		} else if (isChildOfAttribute(event.target, "data-type", "insert-selection-area-after")) {
    			$$invalidate(14, hover = HOVER_INSERT_AFTER);
    		}
    	}

    	function handleMouseOut(event) {
    		event.stopPropagation();
    		$$invalidate(14, hover = null);
    	}

    	function handleInsertInside() {
    		onSelect({ type: SELECTION_TYPE.INSIDE, path });
    	}

    	function handleInsertAfter() {
    		onSelect({ type: SELECTION_TYPE.AFTER, path });
    	}

    	function handleInsertInsideOpenContextMenu(event) {
    		handleInsertInside();
    		onContextMenu(event);
    	}

    	function handleInsertAfterOpenContextMenu(event) {
    		handleInsertAfter();
    		onContextMenu(event);
    	}

    	const writable_props = [
    		"value",
    		"path",
    		"state",
    		"readOnly",
    		"searchResult",
    		"validationErrors",
    		"onPatch",
    		"onInsert",
    		"onExpand",
    		"onSelect",
    		"onContextMenu",
    		"onClassName",
    		"onExpandSection",
    		"selection"
    	];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<JSONNode> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("path" in $$props) $$invalidate(1, path = $$props.path);
    		if ("state" in $$props) $$invalidate(2, state = $$props.state);
    		if ("readOnly" in $$props) $$invalidate(3, readOnly = $$props.readOnly);
    		if ("searchResult" in $$props) $$invalidate(4, searchResult = $$props.searchResult);
    		if ("validationErrors" in $$props) $$invalidate(5, validationErrors = $$props.validationErrors);
    		if ("onPatch" in $$props) $$invalidate(6, onPatch = $$props.onPatch);
    		if ("onInsert" in $$props) $$invalidate(7, onInsert = $$props.onInsert);
    		if ("onExpand" in $$props) $$invalidate(8, onExpand = $$props.onExpand);
    		if ("onSelect" in $$props) $$invalidate(9, onSelect = $$props.onSelect);
    		if ("onContextMenu" in $$props) $$invalidate(10, onContextMenu = $$props.onContextMenu);
    		if ("onClassName" in $$props) $$invalidate(11, onClassName = $$props.onClassName);
    		if ("onExpandSection" in $$props) $$invalidate(12, onExpandSection = $$props.onExpandSection);
    		if ("selection" in $$props) $$invalidate(13, selection = $$props.selection);
    		if ("$$scope" in $$props) $$invalidate(40, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		faCaretDown,
    		faCaretRight,
    		classnames,
    		compileJSONPointer: immutableJSONPatch.compileJSONPointer,
    		getIn: immutableJSONPatch.getIn,
    		isEqual,
    		last,
    		Icon,
    		HOVER_COLLECTION,
    		HOVER_INSERT_AFTER,
    		HOVER_INSERT_INSIDE,
    		INDENTATION_WIDTH,
    		INSERT_EXPLANATION,
    		STATE_EXPANDED,
    		STATE_ID,
    		STATE_KEYS,
    		STATE_VISIBLE_SECTIONS,
    		VALIDATION_ERROR,
    		getVisibleCaretPositions,
    		rename,
    		isPathInsideSelection,
    		SELECTION_TYPE,
    		getSelectionTypeFromTarget,
    		isChildOfAttribute,
    		isChildOfNodeName,
    		isContentEditableDiv,
    		valueType,
    		CollapsedItems,
    		ContextMenuButton,
    		JSONKey,
    		JSONValue,
    		singleton,
    		ValidationError: ValidationError$1,
    		value,
    		path,
    		state,
    		readOnly,
    		searchResult,
    		validationErrors,
    		onPatch,
    		onInsert,
    		onExpand,
    		onSelect,
    		onContextMenu,
    		onClassName,
    		onExpandSection,
    		selection,
    		hover,
    		getIndentationStyle,
    		toggleExpand,
    		handleExpand,
    		handleUpdateKey,
    		handleMouseDown,
    		handleMouseMove,
    		handleMouseUp,
    		handleMouseOver,
    		handleMouseOut,
    		handleInsertInside,
    		handleInsertAfter,
    		handleInsertInsideOpenContextMenu,
    		handleInsertAfterOpenContextMenu,
    		selected,
    		selectedAfter,
    		selectedInside,
    		selectedKey,
    		selectedValue,
    		expanded,
    		visibleSections,
    		keys,
    		validationError,
    		root,
    		type,
    		indentationStyle
    	});

    	$$self.$inject_state = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("path" in $$props) $$invalidate(1, path = $$props.path);
    		if ("state" in $$props) $$invalidate(2, state = $$props.state);
    		if ("readOnly" in $$props) $$invalidate(3, readOnly = $$props.readOnly);
    		if ("searchResult" in $$props) $$invalidate(4, searchResult = $$props.searchResult);
    		if ("validationErrors" in $$props) $$invalidate(5, validationErrors = $$props.validationErrors);
    		if ("onPatch" in $$props) $$invalidate(6, onPatch = $$props.onPatch);
    		if ("onInsert" in $$props) $$invalidate(7, onInsert = $$props.onInsert);
    		if ("onExpand" in $$props) $$invalidate(8, onExpand = $$props.onExpand);
    		if ("onSelect" in $$props) $$invalidate(9, onSelect = $$props.onSelect);
    		if ("onContextMenu" in $$props) $$invalidate(10, onContextMenu = $$props.onContextMenu);
    		if ("onClassName" in $$props) $$invalidate(11, onClassName = $$props.onClassName);
    		if ("onExpandSection" in $$props) $$invalidate(12, onExpandSection = $$props.onExpandSection);
    		if ("selection" in $$props) $$invalidate(13, selection = $$props.selection);
    		if ("hover" in $$props) $$invalidate(14, hover = $$props.hover);
    		if ("selected" in $$props) $$invalidate(15, selected = $$props.selected);
    		if ("selectedAfter" in $$props) $$invalidate(16, selectedAfter = $$props.selectedAfter);
    		if ("selectedInside" in $$props) $$invalidate(17, selectedInside = $$props.selectedInside);
    		if ("selectedKey" in $$props) $$invalidate(18, selectedKey = $$props.selectedKey);
    		if ("selectedValue" in $$props) $$invalidate(19, selectedValue = $$props.selectedValue);
    		if ("expanded" in $$props) $$invalidate(20, expanded = $$props.expanded);
    		if ("visibleSections" in $$props) $$invalidate(21, visibleSections = $$props.visibleSections);
    		if ("keys" in $$props) $$invalidate(22, keys = $$props.keys);
    		if ("validationError" in $$props) $$invalidate(23, validationError = $$props.validationError);
    		if ("root" in $$props) $$invalidate(24, root = $$props.root);
    		if ("type" in $$props) $$invalidate(25, type = $$props.type);
    		if ("indentationStyle" in $$props) $$invalidate(26, indentationStyle = $$props.indentationStyle);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*selection, path*/ 8194) {
    			// TODO: this is not efficient. Create a nested object with the selection and pass that
    			$$invalidate(15, selected = selection && selection.pathsMap
    			? selection.pathsMap[immutableJSONPatch.compileJSONPointer(path)] === true
    			: false);
    		}

    		if ($$self.$$.dirty[0] & /*selection, path*/ 8194) {
    			$$invalidate(16, selectedAfter = selection && selection.type === SELECTION_TYPE.AFTER
    			? isEqual(selection.focusPath, path)
    			: false);
    		}

    		if ($$self.$$.dirty[0] & /*selection, path*/ 8194) {
    			$$invalidate(17, selectedInside = selection && selection.type === SELECTION_TYPE.INSIDE
    			? isEqual(selection.focusPath, path)
    			: false);
    		}

    		if ($$self.$$.dirty[0] & /*selection, path*/ 8194) {
    			$$invalidate(18, selectedKey = selection && selection.type === SELECTION_TYPE.KEY
    			? isEqual(selection.focusPath, path)
    			: false);
    		}

    		if ($$self.$$.dirty[0] & /*selection, path*/ 8194) {
    			$$invalidate(19, selectedValue = selection && selection.type === SELECTION_TYPE.VALUE
    			? isEqual(selection.focusPath, path)
    			: false);
    		}

    		if ($$self.$$.dirty[0] & /*state*/ 4) {
    			$$invalidate(20, expanded = state[STATE_EXPANDED]);
    		}

    		if ($$self.$$.dirty[0] & /*state*/ 4) {
    			$$invalidate(21, visibleSections = state[STATE_VISIBLE_SECTIONS]);
    		}

    		if ($$self.$$.dirty[0] & /*state*/ 4) {
    			$$invalidate(22, keys = state[STATE_KEYS]);
    		}

    		if ($$self.$$.dirty[0] & /*validationErrors*/ 32) {
    			$$invalidate(23, validationError = validationErrors && validationErrors[VALIDATION_ERROR]);
    		}

    		if ($$self.$$.dirty[0] & /*path*/ 2) {
    			$$invalidate(24, root = path.length === 0);
    		}

    		if ($$self.$$.dirty[0] & /*value*/ 1) {
    			$$invalidate(25, type = valueType(value));
    		}

    		if ($$self.$$.dirty[0] & /*path*/ 2) {
    			$$invalidate(26, indentationStyle = getIndentationStyle(path.length));
    		}
    	};

    	return [
    		value,
    		path,
    		state,
    		readOnly,
    		searchResult,
    		validationErrors,
    		onPatch,
    		onInsert,
    		onExpand,
    		onSelect,
    		onContextMenu,
    		onClassName,
    		onExpandSection,
    		selection,
    		hover,
    		selected,
    		selectedAfter,
    		selectedInside,
    		selectedKey,
    		selectedValue,
    		expanded,
    		visibleSections,
    		keys,
    		validationError,
    		root,
    		type,
    		indentationStyle,
    		getIndentationStyle,
    		toggleExpand,
    		handleExpand,
    		handleUpdateKey,
    		handleMouseDown,
    		handleMouseMove,
    		handleMouseOver,
    		handleMouseOut,
    		handleInsertInside,
    		handleInsertAfter,
    		handleInsertInsideOpenContextMenu,
    		handleInsertAfterOpenContextMenu,
    		slots,
    		$$scope
    	];
    }

    class JSONNode extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$7,
    			create_fragment$7,
    			not_equal,
    			{
    				value: 0,
    				path: 1,
    				state: 2,
    				readOnly: 3,
    				searchResult: 4,
    				validationErrors: 5,
    				onPatch: 6,
    				onInsert: 7,
    				onExpand: 8,
    				onSelect: 9,
    				onContextMenu: 10,
    				onClassName: 11,
    				onExpandSection: 12,
    				selection: 13
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "JSONNode",
    			options,
    			id: create_fragment$7.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*value*/ ctx[0] === undefined && !("value" in props)) {
    			console.warn("<JSONNode> was created without expected prop 'value'");
    		}

    		if (/*path*/ ctx[1] === undefined && !("path" in props)) {
    			console.warn("<JSONNode> was created without expected prop 'path'");
    		}

    		if (/*state*/ ctx[2] === undefined && !("state" in props)) {
    			console.warn("<JSONNode> was created without expected prop 'state'");
    		}

    		if (/*readOnly*/ ctx[3] === undefined && !("readOnly" in props)) {
    			console.warn("<JSONNode> was created without expected prop 'readOnly'");
    		}

    		if (/*searchResult*/ ctx[4] === undefined && !("searchResult" in props)) {
    			console.warn("<JSONNode> was created without expected prop 'searchResult'");
    		}

    		if (/*validationErrors*/ ctx[5] === undefined && !("validationErrors" in props)) {
    			console.warn("<JSONNode> was created without expected prop 'validationErrors'");
    		}

    		if (/*onPatch*/ ctx[6] === undefined && !("onPatch" in props)) {
    			console.warn("<JSONNode> was created without expected prop 'onPatch'");
    		}

    		if (/*onInsert*/ ctx[7] === undefined && !("onInsert" in props)) {
    			console.warn("<JSONNode> was created without expected prop 'onInsert'");
    		}

    		if (/*onExpand*/ ctx[8] === undefined && !("onExpand" in props)) {
    			console.warn("<JSONNode> was created without expected prop 'onExpand'");
    		}

    		if (/*onSelect*/ ctx[9] === undefined && !("onSelect" in props)) {
    			console.warn("<JSONNode> was created without expected prop 'onSelect'");
    		}

    		if (/*onContextMenu*/ ctx[10] === undefined && !("onContextMenu" in props)) {
    			console.warn("<JSONNode> was created without expected prop 'onContextMenu'");
    		}

    		if (/*onClassName*/ ctx[11] === undefined && !("onClassName" in props)) {
    			console.warn("<JSONNode> was created without expected prop 'onClassName'");
    		}

    		if (/*onExpandSection*/ ctx[12] === undefined && !("onExpandSection" in props)) {
    			console.warn("<JSONNode> was created without expected prop 'onExpandSection'");
    		}

    		if (/*selection*/ ctx[13] === undefined && !("selection" in props)) {
    			console.warn("<JSONNode> was created without expected prop 'selection'");
    		}
    	}

    	get value() {
    		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get path() {
    		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set path(value) {
    		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get state() {
    		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set state(value) {
    		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get readOnly() {
    		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readOnly(value) {
    		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get searchResult() {
    		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set searchResult(value) {
    		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get validationErrors() {
    		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set validationErrors(value) {
    		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onPatch() {
    		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onPatch(value) {
    		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onInsert() {
    		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onInsert(value) {
    		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onExpand() {
    		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onExpand(value) {
    		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSelect() {
    		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSelect(value) {
    		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onContextMenu() {
    		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onContextMenu(value) {
    		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClassName() {
    		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClassName(value) {
    		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onExpandSection() {
    		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onExpandSection(value) {
    		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selection() {
    		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selection(value) {
    		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\modes\treemode\menu\SearchBox.svelte generated by Svelte v3.38.2 */
    const file$5 = "node_modules\\svelte-jsoneditor\\src\\components\\modes\\treemode\\menu\\SearchBox.svelte";

    // (73:6) {:else}
    function create_else_block$3(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: { data: faSearch },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop$2,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(73:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (71:6) {#if searching}
    function create_if_block$4(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: { data: faCircleNotch, spin: true },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop$2,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(71:6) {#if searching}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let div1;
    	let form;
    	let button0;
    	let current_block_type_index;
    	let if_block;
    	let t0;
    	let label;
    	let input;
    	let t1;
    	let div0;

    	let t2_value = (/*activeIndex*/ ctx[2] !== -1
    	? `${/*activeIndex*/ ctx[2] + 1}/`
    	: "") + "";

    	let t2;
    	let t3;
    	let t4;
    	let button1;
    	let icon0;
    	let t5;
    	let button2;
    	let icon1;
    	let t6;
    	let button3;
    	let icon2;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block$4, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*searching*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	icon0 = new Icon({
    			props: { data: faChevronDown },
    			$$inline: true
    		});

    	icon1 = new Icon({
    			props: { data: faChevronUp },
    			$$inline: true
    		});

    	icon2 = new Icon({ props: { data: faTimes }, $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			form = element("form");
    			button0 = element("button");
    			if_block.c();
    			t0 = space();
    			label = element("label");
    			input = element("input");
    			t1 = space();
    			div0 = element("div");
    			t2 = text(t2_value);
    			t3 = text(/*formattedResultCount*/ ctx[6]);
    			t4 = space();
    			button1 = element("button");
    			create_component(icon0.$$.fragment);
    			t5 = space();
    			button2 = element("button");
    			create_component(icon1.$$.fragment);
    			t6 = space();
    			button3 = element("button");
    			create_component(icon2.$$.fragment);
    			attr_dev(button0, "class", "search-icon svelte-qm3270");
    			add_location(button0, file$5, 69, 4, 1833);
    			attr_dev(input, "class", "search-input svelte-qm3270");
    			attr_dev(input, "type", "text");
    			input.value = /*text*/ ctx[0];
    			add_location(input, file$5, 77, 6, 2039);
    			attr_dev(label, "about", "search input");
    			add_location(label, file$5, 76, 4, 2004);
    			attr_dev(div0, "class", "search-count svelte-qm3270");
    			toggle_class(div0, "visible", /*text*/ ctx[0] !== "");
    			add_location(div0, file$5, 85, 4, 2201);
    			attr_dev(button1, "class", "search-next svelte-qm3270");
    			attr_dev(button1, "type", "button");
    			add_location(button1, file$5, 88, 4, 2349);
    			attr_dev(button2, "class", "search-previous svelte-qm3270");
    			attr_dev(button2, "type", "button");
    			add_location(button2, file$5, 91, 4, 2464);
    			attr_dev(button3, "class", "search-clear svelte-qm3270");
    			attr_dev(button3, "type", "button");
    			add_location(button3, file$5, 94, 4, 2585);
    			attr_dev(form, "class", "search-form svelte-qm3270");
    			add_location(form, file$5, 68, 2, 1750);
    			attr_dev(div1, "class", "search-box svelte-qm3270");
    			add_location(div1, file$5, 67, 0, 1723);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, form);
    			append_dev(form, button0);
    			if_blocks[current_block_type_index].m(button0, null);
    			append_dev(form, t0);
    			append_dev(form, label);
    			append_dev(label, input);
    			append_dev(form, t1);
    			append_dev(form, div0);
    			append_dev(div0, t2);
    			append_dev(div0, t3);
    			append_dev(form, t4);
    			append_dev(form, button1);
    			mount_component(icon0, button1, null);
    			append_dev(form, t5);
    			append_dev(form, button2);
    			mount_component(icon1, button2, null);
    			append_dev(form, t6);
    			append_dev(form, button3);
    			mount_component(icon2, button3, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*handleInput*/ ctx[8], false, false, false),
    					action_destroyer(initSearchInput.call(null, input)),
    					listen_dev(
    						button1,
    						"click",
    						function () {
    							if (is_function(/*onNext*/ ctx[4])) /*onNext*/ ctx[4].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						button2,
    						"click",
    						function () {
    							if (is_function(/*onPrevious*/ ctx[3])) /*onPrevious*/ ctx[3].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						button3,
    						"click",
    						function () {
    							if (is_function(/*onClose*/ ctx[5])) /*onClose*/ ctx[5].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(form, "submit", /*handleSubmit*/ ctx[7], false, false, false),
    					listen_dev(form, "keydown", /*handleKeyDown*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(button0, null);
    			}

    			if (!current || dirty & /*text*/ 1 && input.value !== /*text*/ ctx[0]) {
    				prop_dev(input, "value", /*text*/ ctx[0]);
    			}

    			if ((!current || dirty & /*activeIndex*/ 4) && t2_value !== (t2_value = (/*activeIndex*/ ctx[2] !== -1
    			? `${/*activeIndex*/ ctx[2] + 1}/`
    			: "") + "")) set_data_dev(t2, t2_value);

    			if (!current || dirty & /*formattedResultCount*/ 64) set_data_dev(t3, /*formattedResultCount*/ ctx[6]);

    			if (dirty & /*text*/ 1) {
    				toggle_class(div0, "visible", /*text*/ ctx[0] !== "");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(icon0.$$.fragment, local);
    			transition_in(icon1.$$.fragment, local);
    			transition_in(icon2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(icon0.$$.fragment, local);
    			transition_out(icon1.$$.fragment, local);
    			transition_out(icon2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if_blocks[current_block_type_index].d();
    			destroy_component(icon0);
    			destroy_component(icon1);
    			destroy_component(icon2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function initSearchInput(element) {
    	element.select();
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let formattedResultCount;
    	let onChangeDebounced;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SearchBox", slots, []);
    	let { text = "" } = $$props;
    	let { searching } = $$props;
    	let inputText = "";
    	let { resultCount = 0 } = $$props;
    	let { activeIndex = 0 } = $$props;

    	let { onChange = () => {
    		
    	} } = $$props;

    	let { onPrevious = () => {
    		
    	} } = $$props;

    	let { onNext = () => {
    		
    	} } = $$props;

    	let { onClose = () => {
    		
    	} } = $$props;

    	function handleSubmit(event) {
    		event.preventDefault();
    		const pendingChanges = text !== inputText;

    		if (pendingChanges) {
    			onChangeDebounced.cancel();
    			onChange(inputText);
    		} else {
    			onNext();
    		}
    	}

    	function handleInput(event) {
    		inputText = event.target.value;
    		onChangeDebounced(inputText);
    	} // TODO: fire debounced onChange

    	function handleKeyDown(event) {
    		// key events must not be handled by the generic keydown handler of the
    		// whole JSONEditor.
    		event.stopPropagation();

    		const combo = keyComboFromEvent(event);

    		if (combo === "Ctrl+Enter" || combo === "Command+Enter") {
    			event.preventDefault();
    		} // TODO: move focus to the active element

    		if (combo === "Escape") {
    			event.preventDefault();
    			onClose();
    		}
    	}

    	const writable_props = [
    		"text",
    		"searching",
    		"resultCount",
    		"activeIndex",
    		"onChange",
    		"onPrevious",
    		"onNext",
    		"onClose"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SearchBox> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("searching" in $$props) $$invalidate(1, searching = $$props.searching);
    		if ("resultCount" in $$props) $$invalidate(10, resultCount = $$props.resultCount);
    		if ("activeIndex" in $$props) $$invalidate(2, activeIndex = $$props.activeIndex);
    		if ("onChange" in $$props) $$invalidate(11, onChange = $$props.onChange);
    		if ("onPrevious" in $$props) $$invalidate(3, onPrevious = $$props.onPrevious);
    		if ("onNext" in $$props) $$invalidate(4, onNext = $$props.onNext);
    		if ("onClose" in $$props) $$invalidate(5, onClose = $$props.onClose);
    	};

    	$$self.$capture_state = () => ({
    		debounce: debounce$1,
    		Icon,
    		faCircleNotch,
    		faSearch,
    		faChevronDown,
    		faChevronUp,
    		faTimes,
    		DEBOUNCE_DELAY,
    		MAX_SEARCH_RESULTS,
    		keyComboFromEvent,
    		text,
    		searching,
    		inputText,
    		resultCount,
    		activeIndex,
    		onChange,
    		onPrevious,
    		onNext,
    		onClose,
    		handleSubmit,
    		handleInput,
    		handleKeyDown,
    		initSearchInput,
    		formattedResultCount,
    		onChangeDebounced
    	});

    	$$self.$inject_state = $$props => {
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("searching" in $$props) $$invalidate(1, searching = $$props.searching);
    		if ("inputText" in $$props) inputText = $$props.inputText;
    		if ("resultCount" in $$props) $$invalidate(10, resultCount = $$props.resultCount);
    		if ("activeIndex" in $$props) $$invalidate(2, activeIndex = $$props.activeIndex);
    		if ("onChange" in $$props) $$invalidate(11, onChange = $$props.onChange);
    		if ("onPrevious" in $$props) $$invalidate(3, onPrevious = $$props.onPrevious);
    		if ("onNext" in $$props) $$invalidate(4, onNext = $$props.onNext);
    		if ("onClose" in $$props) $$invalidate(5, onClose = $$props.onClose);
    		if ("formattedResultCount" in $$props) $$invalidate(6, formattedResultCount = $$props.formattedResultCount);
    		if ("onChangeDebounced" in $$props) onChangeDebounced = $$props.onChangeDebounced;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*resultCount*/ 1024) {
    			$$invalidate(6, formattedResultCount = resultCount >= MAX_SEARCH_RESULTS
    			? `${MAX_SEARCH_RESULTS - 1}+`
    			: String(resultCount));
    		}

    		if ($$self.$$.dirty & /*onChange*/ 2048) {
    			onChangeDebounced = debounce$1(onChange, DEBOUNCE_DELAY);
    		}
    	};

    	return [
    		text,
    		searching,
    		activeIndex,
    		onPrevious,
    		onNext,
    		onClose,
    		formattedResultCount,
    		handleSubmit,
    		handleInput,
    		handleKeyDown,
    		resultCount,
    		onChange
    	];
    }

    class SearchBox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$6, create_fragment$6, not_equal, {
    			text: 0,
    			searching: 1,
    			resultCount: 10,
    			activeIndex: 2,
    			onChange: 11,
    			onPrevious: 3,
    			onNext: 4,
    			onClose: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SearchBox",
    			options,
    			id: create_fragment$6.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*searching*/ ctx[1] === undefined && !("searching" in props)) {
    			console.warn("<SearchBox> was created without expected prop 'searching'");
    		}
    	}

    	get text() {
    		throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get searching() {
    		throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set searching(value) {
    		throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resultCount() {
    		throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set resultCount(value) {
    		throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeIndex() {
    		throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeIndex(value) {
    		throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onChange() {
    		throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onChange(value) {
    		throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onPrevious() {
    		throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onPrevious(value) {
    		throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onNext() {
    		throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onNext(value) {
    		throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClose() {
    		throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClose(value) {
    		throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\modes\treemode\menu\TreeMenu.svelte generated by Svelte v3.38.2 */
    const file$4 = "node_modules\\svelte-jsoneditor\\src\\components\\modes\\treemode\\menu\\TreeMenu.svelte";

    // (122:4) {#if showSearch}
    function create_if_block$3(ctx) {
    	let searchbox;
    	let current;

    	searchbox = new SearchBox({
    			props: {
    				text: /*searchText*/ ctx[1],
    				resultCount: /*searchResult*/ ctx[2]
    				? /*searchResult*/ ctx[2].count
    				: 0,
    				activeIndex: /*searchResult*/ ctx[2]
    				? /*searchResult*/ ctx[2].activeIndex
    				: 0,
    				searching: /*searching*/ ctx[3],
    				onChange: /*onSearchText*/ ctx[4],
    				onNext: /*onNextSearchResult*/ ctx[5],
    				onPrevious: /*onPreviousSearchResult*/ ctx[6],
    				onClose: /*clearSearchResult*/ ctx[8]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(searchbox.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(searchbox, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const searchbox_changes = {};
    			if (dirty & /*searchText*/ 2) searchbox_changes.text = /*searchText*/ ctx[1];

    			if (dirty & /*searchResult*/ 4) searchbox_changes.resultCount = /*searchResult*/ ctx[2]
    			? /*searchResult*/ ctx[2].count
    			: 0;

    			if (dirty & /*searchResult*/ 4) searchbox_changes.activeIndex = /*searchResult*/ ctx[2]
    			? /*searchResult*/ ctx[2].activeIndex
    			: 0;

    			if (dirty & /*searching*/ 8) searchbox_changes.searching = /*searching*/ ctx[3];
    			if (dirty & /*onSearchText*/ 16) searchbox_changes.onChange = /*onSearchText*/ ctx[4];
    			if (dirty & /*onNextSearchResult*/ 32) searchbox_changes.onNext = /*onNextSearchResult*/ ctx[5];
    			if (dirty & /*onPreviousSearchResult*/ 64) searchbox_changes.onPrevious = /*onPreviousSearchResult*/ ctx[6];
    			searchbox.$set(searchbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(searchbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(searchbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(searchbox, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(122:4) {#if showSearch}",
    		ctx
    	});

    	return block;
    }

    // (121:2) 
    function create_right_slot(ctx) {
    	let div;
    	let current;
    	let if_block = /*showSearch*/ ctx[0] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "slot", "right");
    			attr_dev(div, "class", "search-box-container svelte-328t6q");
    			add_location(div, file$4, 120, 2, 2531);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*showSearch*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showSearch*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_right_slot.name,
    		type: "slot",
    		source: "(121:2) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let menu;
    	let current;

    	menu = new Menu({
    			props: {
    				items: /*items*/ ctx[7],
    				$$slots: { right: [create_right_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const menu_changes = {};
    			if (dirty & /*items*/ 128) menu_changes.items = /*items*/ ctx[7];

    			if (dirty & /*$$scope, searchText, searchResult, searching, onSearchText, onNextSearchResult, onPreviousSearchResult, showSearch*/ 4194431) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let defaultItems;
    	let items;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TreeMenu", slots, []);
    	let { readOnly } = $$props;
    	let { searchText } = $$props;
    	let { searchResult } = $$props;
    	let { searching } = $$props;
    	let { showSearch = false } = $$props;
    	let { historyState } = $$props;
    	let { onExpandAll } = $$props;
    	let { onCollapseAll } = $$props;
    	let { onUndo } = $$props;
    	let { onRedo } = $$props;
    	let { onSort } = $$props;
    	let { onTransform } = $$props;
    	let { onContextMenu } = $$props;
    	let { onSearchText } = $$props;
    	let { onNextSearchResult } = $$props;
    	let { onPreviousSearchResult } = $$props;
    	let { onFocus } = $$props;

    	let { onRenderMenu = () => {
    		
    	} } = $$props;

    	function handleToggleSearch() {
    		$$invalidate(0, showSearch = !showSearch);
    	}

    	function clearSearchResult() {
    		$$invalidate(0, showSearch = false);
    		onSearchText("");
    		setTimeout(onFocus);
    	}

    	const writable_props = [
    		"readOnly",
    		"searchText",
    		"searchResult",
    		"searching",
    		"showSearch",
    		"historyState",
    		"onExpandAll",
    		"onCollapseAll",
    		"onUndo",
    		"onRedo",
    		"onSort",
    		"onTransform",
    		"onContextMenu",
    		"onSearchText",
    		"onNextSearchResult",
    		"onPreviousSearchResult",
    		"onFocus",
    		"onRenderMenu"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TreeMenu> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("readOnly" in $$props) $$invalidate(9, readOnly = $$props.readOnly);
    		if ("searchText" in $$props) $$invalidate(1, searchText = $$props.searchText);
    		if ("searchResult" in $$props) $$invalidate(2, searchResult = $$props.searchResult);
    		if ("searching" in $$props) $$invalidate(3, searching = $$props.searching);
    		if ("showSearch" in $$props) $$invalidate(0, showSearch = $$props.showSearch);
    		if ("historyState" in $$props) $$invalidate(10, historyState = $$props.historyState);
    		if ("onExpandAll" in $$props) $$invalidate(11, onExpandAll = $$props.onExpandAll);
    		if ("onCollapseAll" in $$props) $$invalidate(12, onCollapseAll = $$props.onCollapseAll);
    		if ("onUndo" in $$props) $$invalidate(13, onUndo = $$props.onUndo);
    		if ("onRedo" in $$props) $$invalidate(14, onRedo = $$props.onRedo);
    		if ("onSort" in $$props) $$invalidate(15, onSort = $$props.onSort);
    		if ("onTransform" in $$props) $$invalidate(16, onTransform = $$props.onTransform);
    		if ("onContextMenu" in $$props) $$invalidate(17, onContextMenu = $$props.onContextMenu);
    		if ("onSearchText" in $$props) $$invalidate(4, onSearchText = $$props.onSearchText);
    		if ("onNextSearchResult" in $$props) $$invalidate(5, onNextSearchResult = $$props.onNextSearchResult);
    		if ("onPreviousSearchResult" in $$props) $$invalidate(6, onPreviousSearchResult = $$props.onPreviousSearchResult);
    		if ("onFocus" in $$props) $$invalidate(18, onFocus = $$props.onFocus);
    		if ("onRenderMenu" in $$props) $$invalidate(19, onRenderMenu = $$props.onRenderMenu);
    	};

    	$$self.$capture_state = () => ({
    		faEllipsisV,
    		faFilter,
    		faRedo,
    		faSearch,
    		faSortAmountDownAlt,
    		faUndo,
    		CONTEXT_MENU_EXPLANATION,
    		faJSONEditorCollapse,
    		faJSONEditorExpand,
    		Menu,
    		SearchBox,
    		readOnly,
    		searchText,
    		searchResult,
    		searching,
    		showSearch,
    		historyState,
    		onExpandAll,
    		onCollapseAll,
    		onUndo,
    		onRedo,
    		onSort,
    		onTransform,
    		onContextMenu,
    		onSearchText,
    		onNextSearchResult,
    		onPreviousSearchResult,
    		onFocus,
    		onRenderMenu,
    		handleToggleSearch,
    		clearSearchResult,
    		defaultItems,
    		items
    	});

    	$$self.$inject_state = $$props => {
    		if ("readOnly" in $$props) $$invalidate(9, readOnly = $$props.readOnly);
    		if ("searchText" in $$props) $$invalidate(1, searchText = $$props.searchText);
    		if ("searchResult" in $$props) $$invalidate(2, searchResult = $$props.searchResult);
    		if ("searching" in $$props) $$invalidate(3, searching = $$props.searching);
    		if ("showSearch" in $$props) $$invalidate(0, showSearch = $$props.showSearch);
    		if ("historyState" in $$props) $$invalidate(10, historyState = $$props.historyState);
    		if ("onExpandAll" in $$props) $$invalidate(11, onExpandAll = $$props.onExpandAll);
    		if ("onCollapseAll" in $$props) $$invalidate(12, onCollapseAll = $$props.onCollapseAll);
    		if ("onUndo" in $$props) $$invalidate(13, onUndo = $$props.onUndo);
    		if ("onRedo" in $$props) $$invalidate(14, onRedo = $$props.onRedo);
    		if ("onSort" in $$props) $$invalidate(15, onSort = $$props.onSort);
    		if ("onTransform" in $$props) $$invalidate(16, onTransform = $$props.onTransform);
    		if ("onContextMenu" in $$props) $$invalidate(17, onContextMenu = $$props.onContextMenu);
    		if ("onSearchText" in $$props) $$invalidate(4, onSearchText = $$props.onSearchText);
    		if ("onNextSearchResult" in $$props) $$invalidate(5, onNextSearchResult = $$props.onNextSearchResult);
    		if ("onPreviousSearchResult" in $$props) $$invalidate(6, onPreviousSearchResult = $$props.onPreviousSearchResult);
    		if ("onFocus" in $$props) $$invalidate(18, onFocus = $$props.onFocus);
    		if ("onRenderMenu" in $$props) $$invalidate(19, onRenderMenu = $$props.onRenderMenu);
    		if ("defaultItems" in $$props) $$invalidate(20, defaultItems = $$props.defaultItems);
    		if ("items" in $$props) $$invalidate(7, items = $$props.items);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*onExpandAll, onCollapseAll, onSort, readOnly, onTransform, onContextMenu, onUndo, historyState, onRedo*/ 261632) {
    			/* @type {MenuItem[]} */
    			$$invalidate(20, defaultItems = [
    				{
    					icon: faJSONEditorExpand,
    					title: "Expand all",
    					className: "expand-all",
    					onClick: onExpandAll
    				},
    				{
    					icon: faJSONEditorCollapse,
    					title: "Collapse all",
    					className: "collapse-all",
    					onClick: onCollapseAll
    				},
    				{ separator: true },
    				{
    					icon: faSortAmountDownAlt,
    					title: "Sort",
    					className: "sort",
    					onClick: onSort,
    					disabled: readOnly
    				},
    				{
    					icon: faFilter,
    					title: "Transform contents (filter, sort, project)",
    					className: "transform",
    					onClick: onTransform,
    					disabled: readOnly
    				},
    				{
    					icon: faSearch,
    					title: "Search (Ctrl+F)",
    					className: "search",
    					onClick: handleToggleSearch
    				},
    				{
    					icon: faEllipsisV,
    					title: CONTEXT_MENU_EXPLANATION,
    					className: "contextmenu",
    					onClick: onContextMenu
    				},
    				{ separator: true },
    				{
    					icon: faUndo,
    					title: "Undo (Ctrl+Z)",
    					className: "undo",
    					onClick: onUndo,
    					disabled: !historyState.canUndo
    				},
    				{
    					icon: faRedo,
    					title: "Redo (Ctrl+Shift+Z)",
    					className: "redo",
    					onClick: onRedo,
    					disabled: !historyState.canRedo
    				},
    				{ space: true }
    			]);
    		}

    		if ($$self.$$.dirty & /*onRenderMenu, defaultItems*/ 1572864) {
    			$$invalidate(7, items = onRenderMenu("tree", defaultItems) || defaultItems);
    		}
    	};

    	return [
    		showSearch,
    		searchText,
    		searchResult,
    		searching,
    		onSearchText,
    		onNextSearchResult,
    		onPreviousSearchResult,
    		items,
    		clearSearchResult,
    		readOnly,
    		historyState,
    		onExpandAll,
    		onCollapseAll,
    		onUndo,
    		onRedo,
    		onSort,
    		onTransform,
    		onContextMenu,
    		onFocus,
    		onRenderMenu,
    		defaultItems
    	];
    }

    class TreeMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$5, create_fragment$5, not_equal, {
    			readOnly: 9,
    			searchText: 1,
    			searchResult: 2,
    			searching: 3,
    			showSearch: 0,
    			historyState: 10,
    			onExpandAll: 11,
    			onCollapseAll: 12,
    			onUndo: 13,
    			onRedo: 14,
    			onSort: 15,
    			onTransform: 16,
    			onContextMenu: 17,
    			onSearchText: 4,
    			onNextSearchResult: 5,
    			onPreviousSearchResult: 6,
    			onFocus: 18,
    			onRenderMenu: 19
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TreeMenu",
    			options,
    			id: create_fragment$5.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*readOnly*/ ctx[9] === undefined && !("readOnly" in props)) {
    			console.warn("<TreeMenu> was created without expected prop 'readOnly'");
    		}

    		if (/*searchText*/ ctx[1] === undefined && !("searchText" in props)) {
    			console.warn("<TreeMenu> was created without expected prop 'searchText'");
    		}

    		if (/*searchResult*/ ctx[2] === undefined && !("searchResult" in props)) {
    			console.warn("<TreeMenu> was created without expected prop 'searchResult'");
    		}

    		if (/*searching*/ ctx[3] === undefined && !("searching" in props)) {
    			console.warn("<TreeMenu> was created without expected prop 'searching'");
    		}

    		if (/*historyState*/ ctx[10] === undefined && !("historyState" in props)) {
    			console.warn("<TreeMenu> was created without expected prop 'historyState'");
    		}

    		if (/*onExpandAll*/ ctx[11] === undefined && !("onExpandAll" in props)) {
    			console.warn("<TreeMenu> was created without expected prop 'onExpandAll'");
    		}

    		if (/*onCollapseAll*/ ctx[12] === undefined && !("onCollapseAll" in props)) {
    			console.warn("<TreeMenu> was created without expected prop 'onCollapseAll'");
    		}

    		if (/*onUndo*/ ctx[13] === undefined && !("onUndo" in props)) {
    			console.warn("<TreeMenu> was created without expected prop 'onUndo'");
    		}

    		if (/*onRedo*/ ctx[14] === undefined && !("onRedo" in props)) {
    			console.warn("<TreeMenu> was created without expected prop 'onRedo'");
    		}

    		if (/*onSort*/ ctx[15] === undefined && !("onSort" in props)) {
    			console.warn("<TreeMenu> was created without expected prop 'onSort'");
    		}

    		if (/*onTransform*/ ctx[16] === undefined && !("onTransform" in props)) {
    			console.warn("<TreeMenu> was created without expected prop 'onTransform'");
    		}

    		if (/*onContextMenu*/ ctx[17] === undefined && !("onContextMenu" in props)) {
    			console.warn("<TreeMenu> was created without expected prop 'onContextMenu'");
    		}

    		if (/*onSearchText*/ ctx[4] === undefined && !("onSearchText" in props)) {
    			console.warn("<TreeMenu> was created without expected prop 'onSearchText'");
    		}

    		if (/*onNextSearchResult*/ ctx[5] === undefined && !("onNextSearchResult" in props)) {
    			console.warn("<TreeMenu> was created without expected prop 'onNextSearchResult'");
    		}

    		if (/*onPreviousSearchResult*/ ctx[6] === undefined && !("onPreviousSearchResult" in props)) {
    			console.warn("<TreeMenu> was created without expected prop 'onPreviousSearchResult'");
    		}

    		if (/*onFocus*/ ctx[18] === undefined && !("onFocus" in props)) {
    			console.warn("<TreeMenu> was created without expected prop 'onFocus'");
    		}
    	}

    	get readOnly() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readOnly(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get searchText() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set searchText(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get searchResult() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set searchResult(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get searching() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set searching(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showSearch() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showSearch(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get historyState() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set historyState(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onExpandAll() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onExpandAll(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onCollapseAll() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onCollapseAll(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onUndo() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onUndo(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onRedo() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onRedo(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSort() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSort(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onTransform() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onTransform(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onContextMenu() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onContextMenu(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSearchText() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSearchText(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onNextSearchResult() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onNextSearchResult(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onPreviousSearchResult() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onPreviousSearchResult(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onFocus() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onFocus(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onRenderMenu() {
    		throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onRenderMenu(value) {
    		throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\modes\treemode\TreeMode.svelte generated by Svelte v3.38.2 */

    const { console: console_1$2 } = globals;
    const file$3 = "node_modules\\svelte-jsoneditor\\src\\components\\modes\\treemode\\TreeMode.svelte";

    // (1300:2) {#if mainMenuBar}
    function create_if_block_2(ctx) {
    	let treemenu;
    	let updating_showSearch;
    	let current;

    	function treemenu_showSearch_binding(value) {
    		/*treemenu_showSearch_binding*/ ctx[58](value);
    	}

    	let treemenu_props = {
    		readOnly: /*readOnly*/ ctx[0],
    		historyState: /*historyState*/ ctx[19],
    		searchText: /*searchText*/ ctx[11],
    		searching: /*searching*/ ctx[17],
    		searchResult: /*searchResult*/ ctx[18],
    		onExpandAll: /*handleExpandAll*/ ctx[35],
    		onCollapseAll: /*handleCollapseAll*/ ctx[36],
    		onUndo: /*handleUndo*/ ctx[28],
    		onRedo: /*handleRedo*/ ctx[29],
    		onSort: /*handleSortAll*/ ctx[30],
    		onTransform: /*handleTransformAll*/ ctx[31],
    		onContextMenu: /*handleContextMenuFromTreeMenu*/ ctx[43],
    		onSearchText: /*handleSearchText*/ ctx[22],
    		onNextSearchResult: /*handleNextSearchResult*/ ctx[23],
    		onPreviousSearchResult: /*handlePreviousSearchResult*/ ctx[24],
    		onFocus: /*focus*/ ctx[7],
    		onRenderMenu: /*onRenderMenu*/ ctx[5]
    	};

    	if (/*showSearch*/ ctx[16] !== void 0) {
    		treemenu_props.showSearch = /*showSearch*/ ctx[16];
    	}

    	treemenu = new TreeMenu({ props: treemenu_props, $$inline: true });
    	binding_callbacks.push(() => bind$2(treemenu, "showSearch", treemenu_showSearch_binding));

    	const block = {
    		c: function create() {
    			create_component(treemenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(treemenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const treemenu_changes = {};
    			if (dirty[0] & /*readOnly*/ 1) treemenu_changes.readOnly = /*readOnly*/ ctx[0];
    			if (dirty[0] & /*historyState*/ 524288) treemenu_changes.historyState = /*historyState*/ ctx[19];
    			if (dirty[0] & /*searchText*/ 2048) treemenu_changes.searchText = /*searchText*/ ctx[11];
    			if (dirty[0] & /*searching*/ 131072) treemenu_changes.searching = /*searching*/ ctx[17];
    			if (dirty[0] & /*searchResult*/ 262144) treemenu_changes.searchResult = /*searchResult*/ ctx[18];
    			if (dirty[0] & /*onRenderMenu*/ 32) treemenu_changes.onRenderMenu = /*onRenderMenu*/ ctx[5];

    			if (!updating_showSearch && dirty[0] & /*showSearch*/ 65536) {
    				updating_showSearch = true;
    				treemenu_changes.showSearch = /*showSearch*/ ctx[16];
    				add_flush_callback(() => updating_showSearch = false);
    			}

    			treemenu.$set(treemenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(treemenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(treemenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(treemenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(1300:2) {#if mainMenuBar}",
    		ctx
    	});

    	return block;
    }

    // (1351:2) {:else}
    function create_else_block$2(ctx) {
    	let div;
    	let jsonnode;
    	let t0;
    	let validationerrorsoverview;
    	let t1;
    	let if_block_anchor;
    	let current;

    	jsonnode = new JSONNode({
    			props: {
    				value: /*json*/ ctx[8],
    				path: [],
    				state: /*state*/ ctx[9],
    				readOnly: /*readOnly*/ ctx[0],
    				searchResult: /*searchResult*/ ctx[18] && /*searchResult*/ ctx[18].itemsWithActive,
    				validationErrors: /*validationErrors*/ ctx[21],
    				onPatch: /*handlePatch*/ ctx[33],
    				onInsert: /*handleInsert*/ ctx[27],
    				onExpand: /*handleExpand*/ ctx[34],
    				onSelect: /*handleSelect*/ ctx[37],
    				onExpandSection: /*handleExpandSection*/ ctx[38],
    				onContextMenu: /*openContextMenu*/ ctx[41],
    				onClassName: /*onClassName*/ ctx[6] || noop,
    				selection: /*selection*/ ctx[10]
    			},
    			$$inline: true
    		});

    	validationerrorsoverview = new ValidationErrorsOverview({
    			props: {
    				validationErrorsList: /*validationErrorsList*/ ctx[12],
    				selectError: /*handleSelectValidationError*/ ctx[25]
    			},
    			$$inline: true
    		});

    	let if_block = /*textIsRepaired*/ ctx[20] && /*externalText*/ ctx[1] !== undefined && create_if_block_1$2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(jsonnode.$$.fragment);
    			t0 = space();
    			create_component(validationerrorsoverview.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    			attr_dev(div, "class", "contents svelte-rrdnzi");
    			add_location(div, file$3, 1351, 4, 35670);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(jsonnode, div, null);
    			/*div_binding*/ ctx[60](div);
    			insert_dev(target, t0, anchor);
    			mount_component(validationerrorsoverview, target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const jsonnode_changes = {};
    			if (dirty[0] & /*json*/ 256) jsonnode_changes.value = /*json*/ ctx[8];
    			if (dirty[0] & /*state*/ 512) jsonnode_changes.state = /*state*/ ctx[9];
    			if (dirty[0] & /*readOnly*/ 1) jsonnode_changes.readOnly = /*readOnly*/ ctx[0];
    			if (dirty[0] & /*searchResult*/ 262144) jsonnode_changes.searchResult = /*searchResult*/ ctx[18] && /*searchResult*/ ctx[18].itemsWithActive;
    			if (dirty[0] & /*validationErrors*/ 2097152) jsonnode_changes.validationErrors = /*validationErrors*/ ctx[21];
    			if (dirty[0] & /*onClassName*/ 64) jsonnode_changes.onClassName = /*onClassName*/ ctx[6] || noop;
    			if (dirty[0] & /*selection*/ 1024) jsonnode_changes.selection = /*selection*/ ctx[10];
    			jsonnode.$set(jsonnode_changes);
    			const validationerrorsoverview_changes = {};
    			if (dirty[0] & /*validationErrorsList*/ 4096) validationerrorsoverview_changes.validationErrorsList = /*validationErrorsList*/ ctx[12];
    			validationerrorsoverview.$set(validationerrorsoverview_changes);

    			if (/*textIsRepaired*/ ctx[20] && /*externalText*/ ctx[1] !== undefined) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*textIsRepaired, externalText*/ 1048578) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(jsonnode.$$.fragment, local);
    			transition_in(validationerrorsoverview.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(jsonnode.$$.fragment, local);
    			transition_out(validationerrorsoverview.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(jsonnode);
    			/*div_binding*/ ctx[60](null);
    			if (detaching) detach_dev(t0);
    			destroy_component(validationerrorsoverview, detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(1351:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (1333:2) {#if json === undefined}
    function create_if_block$2(ctx) {
    	let message;
    	let t0;
    	let div;
    	let t1;
    	let current;
    	let mounted;
    	let dispose;

    	message = new Message({
    			props: {
    				type: "error",
    				message: "The loaded JSON document is invalid and could not be repaired automatically.",
    				actions: [
    					{
    						icon: faCode,
    						text: "Repair manually",
    						onClick: /*onRequestRepair*/ ctx[4]
    					}
    				]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(message.$$.fragment);
    			t0 = space();
    			div = element("div");
    			t1 = text(/*externalText*/ ctx[1]);
    			attr_dev(div, "class", "preview svelte-rrdnzi");
    			add_location(div, file$3, 1344, 4, 35449);
    		},
    		m: function mount(target, anchor) {
    			mount_component(message, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, t1);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "mousedown", mousedown_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const message_changes = {};

    			if (dirty[0] & /*onRequestRepair*/ 16) message_changes.actions = [
    				{
    					icon: faCode,
    					text: "Repair manually",
    					onClick: /*onRequestRepair*/ ctx[4]
    				}
    			];

    			message.$set(message_changes);
    			if (!current || dirty[0] & /*externalText*/ 2) set_data_dev(t1, /*externalText*/ ctx[1]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(message.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(message.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(message, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(1333:2) {#if json === undefined}",
    		ctx
    	});

    	return block;
    }

    // (1376:4) {#if textIsRepaired && externalText !== undefined}
    function create_if_block_1$2(ctx) {
    	let message;
    	let current;

    	message = new Message({
    			props: {
    				type: "success",
    				message: "The loaded JSON document was invalid but is successfully repaired.",
    				actions: [
    					{
    						icon: faCheck,
    						text: "Ok",
    						onClick: /*emitOnChange*/ ctx[32]
    					},
    					{
    						icon: faCode,
    						text: "Repair manually instead",
    						onClick: /*onRequestRepair*/ ctx[4]
    					}
    				]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(message.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(message, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const message_changes = {};

    			if (dirty[0] & /*onRequestRepair*/ 16) message_changes.actions = [
    				{
    					icon: faCheck,
    					text: "Ok",
    					onClick: /*emitOnChange*/ ctx[32]
    				},
    				{
    					icon: faCode,
    					text: "Repair manually instead",
    					onClick: /*onRequestRepair*/ ctx[4]
    				}
    			];

    			message.$set(message_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(message.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(message.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(message, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(1376:4) {#if textIsRepaired && externalText !== undefined}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let div;
    	let t0;
    	let label;
    	let input;
    	let t1;
    	let current_block_type_index;
    	let if_block1;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*mainMenuBar*/ ctx[2] && create_if_block_2(ctx);
    	const if_block_creators = [create_if_block$2, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*json*/ ctx[8] === undefined) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			label = element("label");
    			input = element("input");
    			t1 = space();
    			if_block1.c();
    			attr_dev(input, "class", "hidden-input svelte-rrdnzi");
    			attr_dev(input, "tabindex", "-1");
    			add_location(input, file$3, 1325, 4, 35000);
    			attr_dev(label, "class", "hidden-input-label svelte-rrdnzi");
    			add_location(label, file$3, 1324, 2, 34961);
    			attr_dev(div, "class", "tree-mode svelte-rrdnzi");
    			toggle_class(div, "visible", /*visible*/ ctx[3]);
    			add_location(div, file$3, 1291, 0, 34113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, label);
    			append_dev(label, input);
    			/*input_binding*/ ctx[59](input);
    			append_dev(div, t1);
    			if_blocks[current_block_type_index].m(div, null);
    			/*div_binding_1*/ ctx[61](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "paste", /*handlePaste*/ ctx[26], false, false, false),
    					listen_dev(div, "keydown", /*handleKeyDown*/ ctx[39], false, false, false),
    					listen_dev(div, "mousedown", /*handleMouseDown*/ ctx[40], false, false, false),
    					listen_dev(div, "contextmenu", /*handleContextMenu*/ ctx[42], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*mainMenuBar*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*mainMenuBar*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div, null);
    			}

    			if (dirty[0] & /*visible*/ 8) {
    				toggle_class(div, "visible", /*visible*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			/*input_binding*/ ctx[59](null);
    			if_blocks[current_block_type_index].d();
    			/*div_binding_1*/ ctx[61](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function noop() {
    	
    }

    function defaultExpand(path) {
    	return path.length < 1
    	? true
    	: path.length === 1 && path[0] === 0; // first item of an array?
    }

    const mousedown_handler = event => {
    	// this event handler is needed here because on mousedown we set focus to the editor
    	event.stopPropagation();
    };

    function instance$4($$self, $$props, $$invalidate) {
    	let textIsUnrepairable;
    	let validationErrorsList;
    	let validationErrors;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TreeMode", slots, []);
    	const debug = browser("jsoneditor:TreeMode");
    	const { open } = getContext("simple-modal");
    	const sortModalId = uniqueId$1();
    	const transformModalId = uniqueId$1();
    	const { openAbsolutePopup, closeAbsolutePopup } = getContext("absolute-popup");
    	let refContents;
    	let refHiddenInput;
    	let refJsonEditor;
    	let hasFocus = false;
    	const jump = createJump();
    	let { readOnly = false } = $$props;
    	let { externalJson } = $$props;
    	let { externalText } = $$props;
    	let { mainMenuBar = true } = $$props;
    	let { validator = null } = $$props;
    	let { visible = true } = $$props;
    	let { indentation = 2 } = $$props;
    	let { onError } = $$props;
    	let { onChange } = $$props;

    	let { onRequestRepair = () => {
    		
    	} } = $$props;

    	let { onRenderMenu = () => {
    		
    	} } = $$props;

    	let { onClassName } = $$props;
    	let { onFocus } = $$props;
    	let { onBlur } = $$props;

    	createFocusTracker({
    		onMount,
    		onDestroy,
    		getWindow: () => getWindow(refJsonEditor),
    		hasFocus: () => activeElementIsChildOf(refJsonEditor),
    		onFocus: () => {
    			hasFocus = true;

    			if (onFocus) {
    				onFocus();
    			}
    		},
    		onBlur: () => {
    			hasFocus = false;

    			if (onBlur) {
    				onBlur();
    			}
    		}
    	});

    	let json = externalJson;
    	let state = syncState(json, undefined, [], defaultExpand);
    	let selection = null;
    	let showSearch = false;
    	let searching = false;
    	let searchText = "";
    	let searchResult;
    	let searchHandler;

    	function handleSearchProgress(results) {
    		$$invalidate(18, searchResult = updateSearchResult(json, results, searchResult));
    	}

    	const handleSearchProgressDebounced = throttle(handleSearchProgress, SEARCH_PROGRESS_THROTTLE);

    	function handleSearchDone(results) {
    		$$invalidate(18, searchResult = updateSearchResult(json, results, searchResult));
    		$$invalidate(17, searching = false);
    	} // debug('finished search')

    	async function handleSearchText(text) {
    		$$invalidate(11, searchText = text);
    		await tick$1(); // await for the search results to be updated
    		await focusActiveSearchResult(searchResult && searchResult.activeItem);
    	}

    	async function handleNextSearchResult() {
    		$$invalidate(18, searchResult = searchNext(searchResult));
    		await focusActiveSearchResult(searchResult && searchResult.activeItem);
    	}

    	async function handlePreviousSearchResult() {
    		$$invalidate(18, searchResult = searchPrevious(searchResult));
    		await focusActiveSearchResult(searchResult && searchResult.activeItem);
    	}

    	async function focusActiveSearchResult(activeItem) {
    		if (activeItem) {
    			const path = initial(activeItem);
    			$$invalidate(9, state = expandPath(json, state, path));
    			await tick$1();
    			scrollTo(path);
    		}
    	}

    	/**
     * @param {ValidationError} error
     **/
    	function handleSelectValidationError(error) {
    		debug("select validation error", error);

    		$$invalidate(10, selection = createSelection(json, state, {
    			type: SELECTION_TYPE.VALUE,
    			path: error.path
    		}));

    		scrollTo(error.path);
    		focus();
    	}

    	const history = createHistory({
    		onChange: state => {
    			$$invalidate(19, historyState = state);
    		}
    	});

    	let historyState = history.getState();

    	function expand(callback = () => true) {
    		$$invalidate(9, state = syncState(json, state, [], callback, true));
    	}

    	function collapse(callback = () => false) {
    		$$invalidate(9, state = syncState(json, state, [], callback, true));
    	}

    	let textIsRepaired = false;

    	function get() {
    		return json;
    	}

    	function applyExternalJson(updatedJson) {
    		if (updatedJson === undefined) {
    			return;
    		}

    		// TODO: this is inefficient. Make an optional flag promising that the updates are immutable so we don't have to do a deep equality check? First do some profiling!
    		const isChanged = !isEqual(json, updatedJson);

    		const isNew = json === undefined;
    		debug("update", { isChanged, isNew });

    		if (!isChanged) {
    			// no actual change, don't do anything
    			return;
    		}

    		const prevState = isNew ? undefined : state;
    		const prevJson = json;
    		$$invalidate(8, json = updatedJson);
    		$$invalidate(9, state = syncState(json, prevState, [], defaultExpand));

    		if (!isNew && prevState) {
    			history.add({
    				undo: [{ op: "replace", path: "", value: prevJson }],
    				redo: [{ op: "replace", path: "", value: json }],
    				prevState,
    				state,
    				prevSelection: removeEditModeFromSelection(selection),
    				selection: removeEditModeFromSelection(selection)
    			});
    		}
    	}

    	function applyExternalText(text) {
    		if (text === undefined || externalJson !== undefined) {
    			return;
    		}

    		$$invalidate(20, textIsRepaired = false);

    		try {
    			applyExternalJson(JSON.parse(text));
    		} catch(err) {
    			try {
    				applyExternalJson(JSON.parse(jsonrepair_min(text)));
    				$$invalidate(20, textIsRepaired = true);
    			} catch(err) {
    				$$invalidate(8, json = undefined);
    			}
    		}
    	}

    	function patch(operations, newSelection) {
    		const prevState = state;
    		const prevSelection = selection;
    		debug("patch", operations, newSelection);
    		const undo = immutableJSONPatch.revertJSONPatch(json, operations);
    		const update = documentStatePatch(json, state, operations);
    		$$invalidate(8, json = update.json);
    		$$invalidate(9, state = update.state);

    		if (newSelection) {
    			$$invalidate(10, selection = newSelection);
    		}

    		history.add({
    			undo,
    			redo: operations,
    			prevState,
    			state,
    			prevSelection: removeEditModeFromSelection(prevSelection),
    			selection: removeEditModeFromSelection(newSelection || selection)
    		});

    		return { json, undo, redo: operations };
    	}

    	function hasSelectionContents() {
    		return selection && (selection.type === SELECTION_TYPE.MULTI || selection.type === SELECTION_TYPE.KEY || selection.type === SELECTION_TYPE.VALUE);
    	}

    	function handleEditKey() {
    		if (readOnly || !selection) {
    			return;
    		}

    		$$invalidate(10, selection = createSelection(json, state, {
    			type: SELECTION_TYPE.KEY,
    			path: selection.focusPath,
    			edit: true
    		}));
    	}

    	function handleEditValue() {
    		if (readOnly || !selection) {
    			return;
    		}

    		$$invalidate(10, selection = createSelection(json, state, {
    			type: SELECTION_TYPE.VALUE,
    			path: selection.focusPath,
    			edit: true
    		}));
    	}

    	async function handleCut() {
    		if (readOnly || !hasSelectionContents()) {
    			return;
    		}

    		const clipboard = selectionToPartialJson(json, selection, indentation);

    		if (clipboard == null) {
    			return;
    		}

    		debug("cut", { selection, clipboard });

    		try {
    			await navigator.clipboard.writeText(clipboard);
    		} catch(err) {
    			onError(err);
    		}

    		const { operations, newSelection } = createRemoveOperations(json, state, selection);
    		handlePatch(operations, newSelection);
    	}

    	async function handleCopy() {
    		const clipboard = selectionToPartialJson(json, selection, indentation);

    		if (clipboard == null) {
    			return;
    		}

    		debug("copy", { clipboard });

    		try {
    			await navigator.clipboard.writeText(clipboard);
    		} catch(err) {
    			onError(err);
    		}
    	}

    	function handlePaste(event) {
    		event.preventDefault();

    		if (readOnly || !selection) {
    			return;
    		}

    		const clipboardText = event.clipboardData.getData("text/plain");

    		try {
    			doPaste(clipboardText);
    		} catch(err) {
    			openRepairModal(clipboardText, repairedText => {
    				debug("repaired pasted text: ", repairedText);
    				doPaste(repairedText);
    			});
    		}
    	}

    	function handlePasteFromMenu() {
    		open(
    			CopyPasteModal,
    			{},
    			{
    				...SIMPLE_MODAL_OPTIONS,
    				styleWindow: {
    					...SIMPLE_MODAL_OPTIONS.styleWindow,
    					width: "450px"
    				}
    			},
    			{ onClose: () => setTimeout(onFocus) }
    		);
    	}

    	function doPaste(clipboardText) {
    		const operations = insert(json, state, selection, clipboardText);
    		debug("paste", { clipboardText, operations, selection });
    		handlePatch(operations);

    		// expand newly inserted object/array
    		operations.filter(operation => isObjectOrArray(operation.value)).forEach(async operation => {
    			const path = parseJSONPointerWithArrayIndices(json, operation.path);
    			handleExpand(path, true, false);
    		});
    	}

    	function openRepairModal(text, onApply) {
    		open(
    			JSONRepairModal,
    			{
    				text,
    				onParse: parsePartialJson,
    				onRepair: repairPartialJson,
    				onApply,
    				onRenderMenu,
    				onFocus,
    				onBlur
    			},
    			{
    				...SIMPLE_MODAL_OPTIONS,
    				styleWindow: {
    					...SIMPLE_MODAL_OPTIONS.styleWindow,
    					width: "600px",
    					height: "500px"
    				},
    				styleContent: { padding: 0, height: "100%" }
    			},
    			{ onClose: () => focus() }
    		);
    	}

    	function handleRemove() {
    		if (readOnly || !selection) {
    			return;
    		}

    		// in case of a selected key or value, we change the selection to the whole
    		// entry to remove this, we do not want to clear a key or value only.
    		const removeSelection = selection.type === SELECTION_TYPE.KEY || selection.type === SELECTION_TYPE.VALUE
    		? createSelection(json, state, {
    				type: SELECTION_TYPE.MULTI,
    				anchorPath: selection.anchorPath,
    				focusPath: selection.focusPath
    			})
    		: selection;

    		const { operations, newSelection } = createRemoveOperations(json, state, removeSelection);
    		debug("remove", { operations, selection, newSelection });
    		handlePatch(operations, newSelection);
    	}

    	function handleDuplicate() {
    		if (readOnly || !hasSelectionContents() || isEmpty(selection.focusPath)) {
    			return; // root selected, cannot duplicate
    		}

    		debug("duplicate", { selection });
    		const operations = duplicate(json, state, selection.paths || [selection.focusPath]);
    		handlePatch(operations);
    	}

    	function handleExtract() {
    		if (readOnly || !selection || selection.type !== SELECTION_TYPE.MULTI && selection.type !== SELECTION_TYPE.VALUE || isEmpty(selection.focusPath)) {
    			return; // root selected, cannot extract
    		}

    		debug("extract", { selection });
    		const operations = extract(json, state, selection);
    		handlePatch(operations);

    		if (isObjectOrArray(json)) {
    			// expand extracted object/array
    			handleExpand([], true, true);

    			focus(); // TODO: find a more robust way to keep focus than sprinkling focusHiddenInput() everywhere
    		}
    	}

    	/**
     * @param {'value' | 'object' | 'array' | 'structure'} type
     */
    	function handleInsert(type) {
    		if (readOnly || !selection) {
    			return;
    		}

    		const newValue = createNewValue(json, selection, type);
    		const data = JSON.stringify(newValue);
    		const operations = insert(json, state, selection, data);
    		debug("handleInsert", { type, operations, newValue, data });
    		handlePatch(operations);

    		operations.filter(operation => operation.op === "add" || operation.op === "replace").forEach(async operation => {
    			const path = parseJSONPointerWithArrayIndices(json, operation.path);

    			if (isObjectOrArray(newValue)) {
    				// expand newly inserted object/array
    				handleExpand(path, true, true);

    				focus(); // TODO: find a more robust way to keep focus than sprinkling focusHiddenInput() everywhere
    			}

    			if (newValue === "") {
    				// open the newly inserted value in edit mode
    				const parent = !isEmpty(path) ? immutableJSONPatch.getIn(json, initial(path)) : null;

    				$$invalidate(10, selection = createSelection(json, state, {
    					type: isObject(parent)
    					? SELECTION_TYPE.KEY
    					: SELECTION_TYPE.VALUE,
    					path,
    					edit: true
    				}));

    				await tick$1();
    				setTimeout(() => replaceActiveElementContents(""));
    			}
    		});
    	}

    	/**
     * @param {'value' | 'object' | 'array' | 'structure'} type
     */
    	function handleInsertFromContextMenu(type) {
    		if (selection.type === SELECTION_TYPE.KEY) {
    			// in this case, we do not want to rename the key, but replace the property
    			$$invalidate(10, selection = createSelection(json, state, {
    				type: SELECTION_TYPE.VALUE,
    				path: selection.focusPath
    			}));
    		}

    		handleInsert(type);
    	}

    	function handleInsertBefore() {
    		const selectionBefore = getSelectionUp(json, state, selection, false);
    		debug("insert before", selection, selectionBefore);
    		const parentPath = initial(selection.focusPath);

    		if (isEqual(parentPath, initial(selectionBefore.focusPath))) {
    			$$invalidate(10, selection = createSelection(json, state, {
    				type: SELECTION_TYPE.AFTER,
    				path: selectionBefore.focusPath
    			}));
    		} else {
    			$$invalidate(10, selection = createSelection(json, state, {
    				type: SELECTION_TYPE.INSIDE,
    				path: parentPath
    			}));
    		}

    		tick$1().then(handleContextMenu);
    	}

    	function handleInsertAfter() {
    		const path = selection.paths
    		? last(selection.paths)
    		: selection.focusPath;

    		debug("insert after", path);
    		$$invalidate(10, selection = createSelection(json, state, { type: SELECTION_TYPE.AFTER, path }));
    		tick$1().then(handleContextMenu);
    	}

    	function replaceActiveElementContents(char) {
    		const activeElement = getWindow(refJsonEditor).document.activeElement;

    		if (activeElement.isContentEditable) {
    			activeElement.textContent = char;
    			setCursorToEnd(activeElement);
    		} // FIXME: should trigger an oninput, else the component will not update it's newKey/newValue variable
    	}

    	async function handleInsertCharacter(char) {
    		// a regular key like a, A, _, etc is entered.
    		// Replace selected contents with a new value having this first character as text
    		if (readOnly || !selection) {
    			return;
    		}

    		if (selection.type === SELECTION_TYPE.KEY) {
    			$$invalidate(10, selection = { ...selection, edit: true });
    			await tick$1();
    			setTimeout(() => replaceActiveElementContents(char));
    			return;
    		}

    		if (char === "{") {
    			handleInsert("object");
    		} else if (char === "[") {
    			handleInsert("array");
    		} else {
    			if (selection.type === SELECTION_TYPE.VALUE) {
    				if (!isObjectOrArray(immutableJSONPatch.getIn(json, selection.focusPath))) {
    					$$invalidate(10, selection = { ...selection, edit: true });
    					await tick$1();
    					setTimeout(() => replaceActiveElementContents(char));
    				} // TODO: replace the object/array with editing a text in edit mode?
    				//  (Ideally this this should not create an entry in history though,
    			} else //  a patch to change the object/array into a value)
    			{
    				await handleInsertValueWithCharacter(char); //  which isn't really possible right now since we have to apply
    			}
    		}
    	}

    	async function handleInsertValueWithCharacter(char) {
    		if (readOnly || !selection) {
    			return;
    		}

    		// first insert a new value
    		handleInsert("value");

    		// next, open the new value in edit mode and apply the current character
    		const path = selection.focusPath;

    		const parent = immutableJSONPatch.getIn(json, initial(path));

    		$$invalidate(10, selection = createSelection(json, state, {
    			type: Array.isArray(parent) || selection.type === SELECTION_TYPE.VALUE
    			? SELECTION_TYPE.VALUE
    			: SELECTION_TYPE.KEY,
    			path,
    			edit: true
    		}));

    		await tick$1();
    		setTimeout(() => replaceActiveElementContents(char));
    	}

    	function handleUndo() {
    		if (!history.getState().canUndo) {
    			return;
    		}

    		const item = history.undo();

    		if (!item) {
    			return;
    		}

    		$$invalidate(8, json = immutableJSONPatch.immutableJSONPatch(json, item.undo));
    		$$invalidate(9, state = item.prevState);
    		$$invalidate(10, selection = item.prevSelection);
    		debug("undo", { item, json, state, selection });
    		emitOnChange();
    		focus();
    	}

    	function handleRedo() {
    		if (!history.getState().canRedo) {
    			return;
    		}

    		const item = history.redo();

    		if (!item) {
    			return;
    		}

    		$$invalidate(8, json = immutableJSONPatch.immutableJSONPatch(json, item.redo));
    		$$invalidate(9, state = item.state);
    		$$invalidate(10, selection = item.selection);
    		debug("redo", { item, json, state, selection });
    		emitOnChange();
    		focus();
    	}

    	function openSortModal(selectedPath) {
    		if (readOnly) {
    			return;
    		}

    		open(
    			SortModal,
    			{
    				id: sortModalId,
    				json,
    				selectedPath,
    				onSort: async operations => {
    					debug("onSort", selectedPath, operations);
    					patch(operations, selection);

    					// expand the newly replaced array
    					handleExpand(selectedPath, true);
    				}, // FIXME: because we apply expand *after* the patch, when doing undo/redo, the expanded state is not restored
    				
    			},
    			SORT_MODAL_OPTIONS,
    			{ onClose: () => focus() }
    		);
    	}

    	function handleSortSelection() {
    		if (!selection) {
    			return;
    		}

    		const selectedPath = findRootPath(json, selection);
    		openSortModal(selectedPath);
    	}

    	function handleSortAll() {
    		const selectedPath = [];
    		openSortModal(selectedPath);
    	}

    	function openTransformModal(selectedPath) {
    		if (readOnly) {
    			return;
    		}

    		open(
    			TransformModal,
    			{
    				id: transformModalId,
    				json,
    				selectedPath,
    				indentation,
    				onTransform: async operations => {
    					debug("onTransform", selectedPath, operations);
    					patch(operations, selection);

    					// expand the newly replaced array
    					handleExpand(selectedPath, true);
    				}, // FIXME: because we apply expand *after* the patch, when doing undo/redo, the expanded state is not restored
    				
    			},
    			TRANSFORM_MODAL_OPTIONS,
    			{ onClose: () => focus() }
    		);
    	}

    	function handleTransformSelection() {
    		if (!selection) {
    			return;
    		}

    		const selectedPath = findRootPath(json, selection);
    		openTransformModal(selectedPath);
    	}

    	function handleTransformAll() {
    		const selectedPath = [];
    		openTransformModal(selectedPath);
    	}

    	async function scrollTo(path) {
    		$$invalidate(9, state = expandPath(json, state, path));
    		await tick$1();
    		const elem = findElement(path);
    		const offset = -(refContents.getBoundingClientRect().height / 4);

    		if (elem) {
    			debug("scrollTo", { path, elem, refContents });

    			jump(elem, {
    				container: refContents,
    				offset,
    				duration: SCROLL_DURATION
    			});
    		}
    	}

    	function findElement(path) {
    		return refContents.querySelector(`div[data-path="${immutableJSONPatch.compileJSONPointer(path)}"]`);
    	}

    	/**
     * If given path is outside of the visible viewport, scroll up/down.
     * When the path is already in view, nothing is done
     * @param {Path} path
     */
    	function scrollIntoView(path) {
    		const elem = refContents.querySelector(`div[data-path="${immutableJSONPatch.compileJSONPointer(path)}"]`);

    		if (elem) {
    			const viewPortRect = refContents.getBoundingClientRect();
    			const elemRect = elem.getBoundingClientRect();
    			const margin = 20;

    			const elemHeight = isObjectOrArray(immutableJSONPatch.getIn(json, path))
    			? margin
    			: elemRect.height; // do not use real height when array or object

    			if (elemRect.top < viewPortRect.top + margin) {
    				// scroll down
    				jump(elem, {
    					container: refContents,
    					offset: -margin,
    					duration: 0
    				});
    			} else if (elemRect.top + elemHeight > viewPortRect.bottom - margin) {
    				// scroll up
    				jump(elem, {
    					container: refContents,
    					offset: -(viewPortRect.height - elemHeight - margin),
    					duration: 0
    				});
    			}
    		}
    	}

    	function emitOnChange() {
    		onChange(json);
    	}

    	/**
     * @param {JSONPatchDocument} operations
     * @param {Selection} [newSelection] If no new selection is provided,
     *                                   The new selection will be determined
     *                                   based on the operations.
     */
    	function handlePatch(operations, newSelection = createSelectionFromOperations(json, operations)) {
    		if (readOnly) {
    			return;
    		}

    		debug("handlePatch", operations, newSelection);
    		const patchResult = patch(operations, newSelection);
    		emitOnChange();
    		return patchResult;
    	}

    	/**
     * Toggle expanded state of a node
     * @param {Path} path
     * @param {boolean} expanded  True to expand, false to collapse
     * @param {boolean} [recursive=false]  Only applicable when expanding
     */
    	function handleExpand(path, expanded, recursive = false) {
    		// TODO: move this function into documentState.js
    		if (recursive) {
    			$$invalidate(9, state = immutableJSONPatch.updateIn(state, path, childState => {
    				return syncState(immutableJSONPatch.getIn(json, path), childState, [], () => expanded, true);
    			}));
    		} else {
    			$$invalidate(9, state = immutableJSONPatch.setIn(state, path.concat(STATE_EXPANDED), expanded, true));

    			$$invalidate(9, state = immutableJSONPatch.updateIn(state, path, childState => {
    				return syncState(immutableJSONPatch.getIn(json, path), childState, [], defaultExpand, false);
    			}));
    		}

    		if (selection && !expanded) {
    			// check whether the selection is still visible and not collapsed
    			if (isSelectionInsidePath(selection, path)) {
    				// remove selection when not visible anymore
    				$$invalidate(10, selection = null);
    			}
    		}

    		// set focus to the hidden input, so we can capture quick keys like Ctrl+X, Ctrl+C, Ctrl+V
    		setTimeout(() => {
    			if (!activeElementIsChildOf(refJsonEditor)) {
    				focus();
    			}
    		});
    	}

    	function handleExpandAll() {
    		handleExpand([], true, true);
    	}

    	function handleCollapseAll() {
    		handleExpand([], false, true);
    	}

    	/**
     * @param {SelectionSchema} selectionSchema
     */
    	function handleSelect(selectionSchema) {
    		if (selectionSchema) {
    			$$invalidate(10, selection = createSelection(json, state, selectionSchema));
    		} else {
    			$$invalidate(10, selection = null);
    		}

    		// set focus to the hidden input, so we can capture quick keys like Ctrl+X, Ctrl+C, Ctrl+V
    		// we do this after a setTimeout in case the selection was made by clicking a button
    		setTimeout(() => focus());
    	}

    	function handleExpandSection(path, section) {
    		debug("handleExpandSection", path, section);
    		$$invalidate(9, state = expandSection(json, state, path, section));
    	}

    	function handleKeyDown(event) {
    		// get key combo, and normalize key combo from Mac: replace "Command+X" with "Ctrl+X" etc
    		const combo = keyComboFromEvent(event).replace(/^Command\+/, "Ctrl+");

    		const keepAnchorPath = event.shiftKey;

    		if (combo === "Ctrl+X") {
    			event.preventDefault();
    			handleCut();
    		}

    		if (combo === "Ctrl+C") {
    			event.preventDefault();
    			handleCopy();
    		}

    		// Ctrl+V (paste) is handled by the on:paste event
    		if (combo === "Ctrl+D") {
    			event.preventDefault();
    			handleDuplicate();
    		}

    		if (combo === "Delete") {
    			event.preventDefault();
    			handleRemove();
    		}

    		if (combo === "Insert") {
    			event.preventDefault();
    			handleInsert("structure");
    		}

    		if (combo === "Ctrl+A") {
    			event.preventDefault();
    			$$invalidate(10, selection = selectAll());
    		}

    		if (combo === "Ctrl+Q") {
    			handleContextMenu(event);
    		}

    		if (combo === "Up" || combo === "Shift+Up") {
    			event.preventDefault();

    			$$invalidate(10, selection = selection
    			? getSelectionUp(json, state, selection, keepAnchorPath) || selection
    			: getInitialSelection(json, state));

    			scrollIntoView(selection.focusPath);
    		}

    		if (combo === "Down" || combo === "Shift+Down") {
    			event.preventDefault();

    			$$invalidate(10, selection = selection
    			? getSelectionDown(json, state, selection, keepAnchorPath) || selection
    			: getInitialSelection(json, state));

    			scrollIntoView(selection.focusPath);
    		}

    		if (combo === "Left" || combo === "Shift+Left") {
    			event.preventDefault();

    			$$invalidate(10, selection = selection
    			? getSelectionLeft(json, state, selection, keepAnchorPath) || selection
    			: getInitialSelection(json, state));
    		}

    		if (combo === "Right" || combo === "Shift+Right") {
    			event.preventDefault();

    			$$invalidate(10, selection = selection
    			? getSelectionRight(json, state, selection, keepAnchorPath) || selection
    			: getInitialSelection(json, state));
    		}

    		if (combo === "Enter" && selection && !readOnly) {
    			// when the selection consists of one Array item, change selection to editing its value
    			// TODO: this is a bit hacky
    			if (selection.type === SELECTION_TYPE.MULTI && selection.paths.length === 1) {
    				const path = selection.focusPath;
    				const parent = immutableJSONPatch.getIn(json, initial(path));

    				if (Array.isArray(parent)) {
    					// change into selection of the value
    					$$invalidate(10, selection = createSelection(json, state, { type: SELECTION_TYPE.VALUE, path }));
    				}
    			}

    			if (selection.type === SELECTION_TYPE.KEY) {
    				// go to key edit mode
    				event.preventDefault();

    				$$invalidate(10, selection = { ...selection, edit: true });
    			}

    			if (selection.type === SELECTION_TYPE.VALUE) {
    				event.preventDefault();
    				const value = immutableJSONPatch.getIn(json, selection.focusPath);

    				if (isObjectOrArray(value)) {
    					// expand object/array
    					handleExpand(selection.focusPath, true);
    				} else {
    					// go to value edit mode
    					$$invalidate(10, selection = { ...selection, edit: true });
    				}
    			}
    		}

    		if (combo.length === (combo.startsWith("Shift+") ? 7 : 1) && selection) {
    			// a regular key like a, A, _, etc is entered.
    			// Replace selected contents with a new value having this first character as text
    			event.preventDefault();

    			handleInsertCharacter(event.key);
    			return;
    		}

    		if (combo === "Enter" && (selection.type === SELECTION_TYPE.AFTER || selection.type === SELECTION_TYPE.INSIDE)) {
    			// Enter on an insert area -> open the area in edit mode
    			event.preventDefault();

    			handleInsertCharacter("");
    			return;
    		}

    		if (combo === "Ctrl+Enter" && selection && selection.type === SELECTION_TYPE.VALUE) {
    			const value = immutableJSONPatch.getIn(json, selection.focusPath);

    			if (isUrl(value)) {
    				// open url in new page
    				window.open(value, "_blank");
    			}
    		}

    		if (combo === "Escape" && selection) {
    			event.preventDefault();
    			$$invalidate(10, selection = null);
    		}

    		if (combo === "Ctrl+F") {
    			event.preventDefault();
    			$$invalidate(16, showSearch = true);
    		}

    		if (combo === "Ctrl+Z") {
    			event.preventDefault();

    			// TODO: find a better way to restore focus
    			const activeElement = document.activeElement;

    			if (activeElement && activeElement.blur && activeElement.focus) {
    				activeElement.blur();

    				setTimeout(() => {
    					handleUndo();
    					setTimeout(() => activeElement.select());
    				});
    			} else {
    				handleUndo();
    			}
    		}

    		if (combo === "Ctrl+Shift+Z") {
    			event.preventDefault();

    			// TODO: find a better way to restore focus
    			const activeElement = document.activeElement;

    			if (activeElement && activeElement.blur && activeElement.focus) {
    				activeElement.blur();

    				setTimeout(() => {
    					handleRedo();
    					setTimeout(() => activeElement.select());
    				});
    			} else {
    				handleRedo();
    			}
    		}
    	}

    	function handleMouseDown(event) {
    		console.log("handleMouseDown", event);

    		// TODO: ugly to have to have two setTimeout here. Without it, hiddenInput will blur
    		setTimeout(() => {
    			setTimeout(() => {
    				if (!hasFocus && !isChildOfNodeName(event.target, "BUTTON")) {
    					// for example when clicking on the empty area in the main menu
    					focus();
    				}
    			});
    		});
    	}

    	function openContextMenu({ anchor, left, top, width, height }) {
    		const props = {
    			json,
    			selection,
    			onEditKey: handleEditKey,
    			onEditValue: handleEditValue,
    			onCut: handleCut,
    			onCopy: handleCopy,
    			onPaste: handlePasteFromMenu,
    			onRemove: handleRemove,
    			onDuplicate: handleDuplicate,
    			onExtract: handleExtract,
    			onInsertBefore: handleInsertBefore,
    			onInsert: handleInsertFromContextMenu,
    			onInsertAfter: handleInsertAfter,
    			onSort: handleSortSelection,
    			onTransform: handleTransformSelection,
    			onCloseContextMenu() {
    				closeAbsolutePopup();
    				focus();
    			}
    		};

    		openAbsolutePopup(ContextMenu, props, {
    			left,
    			top,
    			width,
    			height,
    			anchor,
    			closeOnOuterClick: true,
    			onClose: focus
    		});
    	}

    	function handleContextMenu(event) {
    		if (!selection || selection.edit) {
    			return;
    		}

    		if (event) {
    			event.stopPropagation();
    			event.preventDefault();
    		}

    		if (event && event.type === "contextmenu" && event.target !== refHiddenInput) {
    			// right mouse click to open context menu
    			openContextMenu({
    				left: event.clientX,
    				top: event.clientY,
    				width: CONTEXT_MENU_WIDTH,
    				height: CONTEXT_MENU_HEIGHT
    			});
    		} else {
    			// type === 'keydown' (from the quick key Ctrl+Q)
    			// or target is hidden input -> context menu button on keyboard
    			const anchor = refContents.querySelector(".context-menu-button.selected");

    			if (anchor) {
    				openContextMenu({
    					anchor,
    					width: CONTEXT_MENU_WIDTH,
    					height: CONTEXT_MENU_HEIGHT
    				});
    			} else {
    				// fallback on just displaying the ContextMenu top left
    				const rect = refContents.getBoundingClientRect();

    				openContextMenu({
    					top: rect.top + 2,
    					left: rect.left + 2,
    					width: CONTEXT_MENU_WIDTH,
    					height: CONTEXT_MENU_HEIGHT
    				});
    			}
    		}

    		return false;
    	}

    	function handleContextMenuFromTreeMenu(event) {
    		openContextMenu({
    			anchor: findParentWithNodeName(event.target, "BUTTON"),
    			width: CONTEXT_MENU_WIDTH,
    			height: CONTEXT_MENU_HEIGHT
    		});
    	}

    	function focus() {
    		// with just .focus(), sometimes the input doesn't react on onpaste events
    		// in Chrome when having a large document open and then doing cut/paste.
    		// Calling both .focus() and .select() did solve this issue.
    		refHiddenInput.focus();

    		refHiddenInput.select();
    	}

    	const writable_props = [
    		"readOnly",
    		"externalJson",
    		"externalText",
    		"mainMenuBar",
    		"validator",
    		"visible",
    		"indentation",
    		"onError",
    		"onChange",
    		"onRequestRepair",
    		"onRenderMenu",
    		"onClassName",
    		"onFocus",
    		"onBlur"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<TreeMode> was created with unknown prop '${key}'`);
    	});

    	function treemenu_showSearch_binding(value) {
    		showSearch = value;
    		$$invalidate(16, showSearch);
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			refHiddenInput = $$value;
    			$$invalidate(14, refHiddenInput);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			refContents = $$value;
    			$$invalidate(13, refContents);
    		});
    	}

    	function div_binding_1($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			refJsonEditor = $$value;
    			$$invalidate(15, refJsonEditor);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("readOnly" in $$props) $$invalidate(0, readOnly = $$props.readOnly);
    		if ("externalJson" in $$props) $$invalidate(44, externalJson = $$props.externalJson);
    		if ("externalText" in $$props) $$invalidate(1, externalText = $$props.externalText);
    		if ("mainMenuBar" in $$props) $$invalidate(2, mainMenuBar = $$props.mainMenuBar);
    		if ("validator" in $$props) $$invalidate(45, validator = $$props.validator);
    		if ("visible" in $$props) $$invalidate(3, visible = $$props.visible);
    		if ("indentation" in $$props) $$invalidate(46, indentation = $$props.indentation);
    		if ("onError" in $$props) $$invalidate(47, onError = $$props.onError);
    		if ("onChange" in $$props) $$invalidate(48, onChange = $$props.onChange);
    		if ("onRequestRepair" in $$props) $$invalidate(4, onRequestRepair = $$props.onRequestRepair);
    		if ("onRenderMenu" in $$props) $$invalidate(5, onRenderMenu = $$props.onRenderMenu);
    		if ("onClassName" in $$props) $$invalidate(6, onClassName = $$props.onClassName);
    		if ("onFocus" in $$props) $$invalidate(49, onFocus = $$props.onFocus);
    		if ("onBlur" in $$props) $$invalidate(50, onBlur = $$props.onBlur);
    	};

    	$$self.$capture_state = () => ({
    		faCheck,
    		faCode,
    		createDebug: browser,
    		compileJSONPointer: immutableJSONPatch.compileJSONPointer,
    		getIn: immutableJSONPatch.getIn,
    		immutableJSONPatch: immutableJSONPatch.immutableJSONPatch,
    		revertJSONPatch: immutableJSONPatch.revertJSONPatch,
    		setIn: immutableJSONPatch.setIn,
    		updateIn: immutableJSONPatch.updateIn,
    		jsonrepair: jsonrepair_min,
    		initial,
    		isEmpty,
    		isEqual,
    		last,
    		throttle,
    		uniqueId: uniqueId$1,
    		getContext,
    		onDestroy,
    		onMount,
    		tick: tick$1,
    		ValidationErrorsOverview,
    		createJump,
    		CONTEXT_MENU_HEIGHT,
    		CONTEXT_MENU_WIDTH,
    		MAX_SEARCH_RESULTS,
    		SCROLL_DURATION,
    		SEARCH_PROGRESS_THROTTLE,
    		SIMPLE_MODAL_OPTIONS,
    		SORT_MODAL_OPTIONS,
    		STATE_EXPANDED,
    		TRANSFORM_MODAL_OPTIONS,
    		documentStatePatch,
    		expandPath,
    		expandSection,
    		syncState,
    		createHistory,
    		createNewValue,
    		createRemoveOperations,
    		duplicate,
    		extract,
    		insert,
    		searchAsync,
    		searchNext,
    		searchPrevious,
    		updateSearchResult,
    		createSelection,
    		createSelectionFromOperations,
    		findRootPath,
    		getInitialSelection,
    		getSelectionDown,
    		getSelectionLeft,
    		getSelectionRight,
    		getSelectionUp,
    		isSelectionInsidePath,
    		removeEditModeFromSelection,
    		selectAll,
    		SELECTION_TYPE,
    		selectionToPartialJson,
    		mapValidationErrors,
    		activeElementIsChildOf,
    		findParentWithNodeName,
    		getWindow,
    		isChildOfNodeName,
    		setCursorToEnd,
    		parseJSONPointerWithArrayIndices,
    		parsePartialJson,
    		repairPartialJson,
    		keyComboFromEvent,
    		isObject,
    		isObjectOrArray,
    		isUrl,
    		createFocusTracker,
    		Message,
    		CopyPasteModal,
    		JSONRepairModal,
    		SortModal,
    		TransformModal,
    		ContextMenu,
    		JSONNode,
    		TreeMenu,
    		debug,
    		open,
    		sortModalId,
    		transformModalId,
    		openAbsolutePopup,
    		closeAbsolutePopup,
    		refContents,
    		refHiddenInput,
    		refJsonEditor,
    		hasFocus,
    		jump,
    		readOnly,
    		externalJson,
    		externalText,
    		mainMenuBar,
    		validator,
    		visible,
    		indentation,
    		onError,
    		onChange,
    		onRequestRepair,
    		onRenderMenu,
    		noop,
    		onClassName,
    		onFocus,
    		onBlur,
    		json,
    		state,
    		selection,
    		defaultExpand,
    		showSearch,
    		searching,
    		searchText,
    		searchResult,
    		searchHandler,
    		handleSearchProgress,
    		handleSearchProgressDebounced,
    		handleSearchDone,
    		handleSearchText,
    		handleNextSearchResult,
    		handlePreviousSearchResult,
    		focusActiveSearchResult,
    		handleSelectValidationError,
    		history,
    		historyState,
    		expand,
    		collapse,
    		textIsRepaired,
    		get,
    		applyExternalJson,
    		applyExternalText,
    		patch,
    		hasSelectionContents,
    		handleEditKey,
    		handleEditValue,
    		handleCut,
    		handleCopy,
    		handlePaste,
    		handlePasteFromMenu,
    		doPaste,
    		openRepairModal,
    		handleRemove,
    		handleDuplicate,
    		handleExtract,
    		handleInsert,
    		handleInsertFromContextMenu,
    		handleInsertBefore,
    		handleInsertAfter,
    		replaceActiveElementContents,
    		handleInsertCharacter,
    		handleInsertValueWithCharacter,
    		handleUndo,
    		handleRedo,
    		openSortModal,
    		handleSortSelection,
    		handleSortAll,
    		openTransformModal,
    		handleTransformSelection,
    		handleTransformAll,
    		scrollTo,
    		findElement,
    		scrollIntoView,
    		emitOnChange,
    		handlePatch,
    		handleExpand,
    		handleExpandAll,
    		handleCollapseAll,
    		handleSelect,
    		handleExpandSection,
    		handleKeyDown,
    		handleMouseDown,
    		openContextMenu,
    		handleContextMenu,
    		handleContextMenuFromTreeMenu,
    		focus,
    		textIsUnrepairable,
    		validationErrorsList,
    		validationErrors
    	});

    	$$self.$inject_state = $$props => {
    		if ("refContents" in $$props) $$invalidate(13, refContents = $$props.refContents);
    		if ("refHiddenInput" in $$props) $$invalidate(14, refHiddenInput = $$props.refHiddenInput);
    		if ("refJsonEditor" in $$props) $$invalidate(15, refJsonEditor = $$props.refJsonEditor);
    		if ("hasFocus" in $$props) hasFocus = $$props.hasFocus;
    		if ("readOnly" in $$props) $$invalidate(0, readOnly = $$props.readOnly);
    		if ("externalJson" in $$props) $$invalidate(44, externalJson = $$props.externalJson);
    		if ("externalText" in $$props) $$invalidate(1, externalText = $$props.externalText);
    		if ("mainMenuBar" in $$props) $$invalidate(2, mainMenuBar = $$props.mainMenuBar);
    		if ("validator" in $$props) $$invalidate(45, validator = $$props.validator);
    		if ("visible" in $$props) $$invalidate(3, visible = $$props.visible);
    		if ("indentation" in $$props) $$invalidate(46, indentation = $$props.indentation);
    		if ("onError" in $$props) $$invalidate(47, onError = $$props.onError);
    		if ("onChange" in $$props) $$invalidate(48, onChange = $$props.onChange);
    		if ("onRequestRepair" in $$props) $$invalidate(4, onRequestRepair = $$props.onRequestRepair);
    		if ("onRenderMenu" in $$props) $$invalidate(5, onRenderMenu = $$props.onRenderMenu);
    		if ("onClassName" in $$props) $$invalidate(6, onClassName = $$props.onClassName);
    		if ("onFocus" in $$props) $$invalidate(49, onFocus = $$props.onFocus);
    		if ("onBlur" in $$props) $$invalidate(50, onBlur = $$props.onBlur);
    		if ("json" in $$props) $$invalidate(8, json = $$props.json);
    		if ("state" in $$props) $$invalidate(9, state = $$props.state);
    		if ("selection" in $$props) $$invalidate(10, selection = $$props.selection);
    		if ("showSearch" in $$props) $$invalidate(16, showSearch = $$props.showSearch);
    		if ("searching" in $$props) $$invalidate(17, searching = $$props.searching);
    		if ("searchText" in $$props) $$invalidate(11, searchText = $$props.searchText);
    		if ("searchResult" in $$props) $$invalidate(18, searchResult = $$props.searchResult);
    		if ("searchHandler" in $$props) $$invalidate(57, searchHandler = $$props.searchHandler);
    		if ("historyState" in $$props) $$invalidate(19, historyState = $$props.historyState);
    		if ("textIsRepaired" in $$props) $$invalidate(20, textIsRepaired = $$props.textIsRepaired);
    		if ("textIsUnrepairable" in $$props) textIsUnrepairable = $$props.textIsUnrepairable;
    		if ("validationErrorsList" in $$props) $$invalidate(12, validationErrorsList = $$props.validationErrorsList);
    		if ("validationErrors" in $$props) $$invalidate(21, validationErrors = $$props.validationErrors);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*searchText, json, state*/ 2816 | $$self.$$.dirty[1] & /*searchHandler*/ 67108864) {
    			{
    				// cancel previous search when still running
    				if (searchHandler && searchHandler.cancel) {
    					// debug('cancel previous search')
    					searchHandler.cancel();
    				}

    				// debug('start search', searchText)
    				$$invalidate(17, searching = true);

    				$$invalidate(57, searchHandler = searchAsync(searchText, json, state, {
    					onProgress: handleSearchProgressDebounced,
    					onDone: handleSearchDone,
    					maxResults: MAX_SEARCH_RESULTS
    				}));
    			}
    		}

    		if ($$self.$$.dirty[1] & /*externalJson*/ 8192) {
    			// two-way binding of externalJson and json (internal)
    			// when receiving an updated prop, we have to update state.
    			// when changing json in the editor, the bound external property must be updated
    			applyExternalJson(externalJson);
    		}

    		if ($$self.$$.dirty[0] & /*externalText*/ 2) {
    			applyExternalText(externalText);
    		}

    		if ($$self.$$.dirty[0] & /*externalText, json*/ 258) {
    			textIsUnrepairable = externalText !== undefined && json === undefined;
    		}

    		if ($$self.$$.dirty[0] & /*json*/ 256 | $$self.$$.dirty[1] & /*validator*/ 16384) {
    			// TODO: debounce JSON schema validation
    			$$invalidate(12, validationErrorsList = validator ? validator(json) : []);
    		}

    		if ($$self.$$.dirty[0] & /*validationErrorsList*/ 4096) {
    			$$invalidate(21, validationErrors = mapValidationErrors(validationErrorsList));
    		}

    		if ($$self.$$.dirty[0] & /*json*/ 256) {
    			// TODO: cleanup logging
    			debug("json", json);
    		}

    		if ($$self.$$.dirty[0] & /*state*/ 512) {
    			debug("state", state);
    		}

    		if ($$self.$$.dirty[0] & /*selection*/ 1024) {
    			debug("selection", selection);
    		}
    	};

    	return [
    		readOnly,
    		externalText,
    		mainMenuBar,
    		visible,
    		onRequestRepair,
    		onRenderMenu,
    		onClassName,
    		focus,
    		json,
    		state,
    		selection,
    		searchText,
    		validationErrorsList,
    		refContents,
    		refHiddenInput,
    		refJsonEditor,
    		showSearch,
    		searching,
    		searchResult,
    		historyState,
    		textIsRepaired,
    		validationErrors,
    		handleSearchText,
    		handleNextSearchResult,
    		handlePreviousSearchResult,
    		handleSelectValidationError,
    		handlePaste,
    		handleInsert,
    		handleUndo,
    		handleRedo,
    		handleSortAll,
    		handleTransformAll,
    		emitOnChange,
    		handlePatch,
    		handleExpand,
    		handleExpandAll,
    		handleCollapseAll,
    		handleSelect,
    		handleExpandSection,
    		handleKeyDown,
    		handleMouseDown,
    		openContextMenu,
    		handleContextMenu,
    		handleContextMenuFromTreeMenu,
    		externalJson,
    		validator,
    		indentation,
    		onError,
    		onChange,
    		onFocus,
    		onBlur,
    		expand,
    		collapse,
    		get,
    		patch,
    		scrollTo,
    		findElement,
    		searchHandler,
    		treemenu_showSearch_binding,
    		input_binding,
    		div_binding,
    		div_binding_1
    	];
    }

    class TreeMode extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$4,
    			create_fragment$4,
    			not_equal,
    			{
    				readOnly: 0,
    				externalJson: 44,
    				externalText: 1,
    				mainMenuBar: 2,
    				validator: 45,
    				visible: 3,
    				indentation: 46,
    				onError: 47,
    				onChange: 48,
    				onRequestRepair: 4,
    				onRenderMenu: 5,
    				onClassName: 6,
    				onFocus: 49,
    				onBlur: 50,
    				expand: 51,
    				collapse: 52,
    				get: 53,
    				patch: 54,
    				scrollTo: 55,
    				findElement: 56,
    				focus: 7
    			},
    			[-1, -1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TreeMode",
    			options,
    			id: create_fragment$4.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*externalJson*/ ctx[44] === undefined && !("externalJson" in props)) {
    			console_1$2.warn("<TreeMode> was created without expected prop 'externalJson'");
    		}

    		if (/*externalText*/ ctx[1] === undefined && !("externalText" in props)) {
    			console_1$2.warn("<TreeMode> was created without expected prop 'externalText'");
    		}

    		if (/*onError*/ ctx[47] === undefined && !("onError" in props)) {
    			console_1$2.warn("<TreeMode> was created without expected prop 'onError'");
    		}

    		if (/*onChange*/ ctx[48] === undefined && !("onChange" in props)) {
    			console_1$2.warn("<TreeMode> was created without expected prop 'onChange'");
    		}

    		if (/*onClassName*/ ctx[6] === undefined && !("onClassName" in props)) {
    			console_1$2.warn("<TreeMode> was created without expected prop 'onClassName'");
    		}

    		if (/*onFocus*/ ctx[49] === undefined && !("onFocus" in props)) {
    			console_1$2.warn("<TreeMode> was created without expected prop 'onFocus'");
    		}

    		if (/*onBlur*/ ctx[50] === undefined && !("onBlur" in props)) {
    			console_1$2.warn("<TreeMode> was created without expected prop 'onBlur'");
    		}
    	}

    	get readOnly() {
    		throw new Error("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readOnly(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get externalJson() {
    		throw new Error("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set externalJson(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get externalText() {
    		throw new Error("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set externalText(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mainMenuBar() {
    		throw new Error("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mainMenuBar(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get validator() {
    		throw new Error("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set validator(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get visible() {
    		throw new Error("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set visible(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indentation() {
    		throw new Error("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indentation(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onError() {
    		throw new Error("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onError(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onChange() {
    		throw new Error("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onChange(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onRequestRepair() {
    		throw new Error("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onRequestRepair(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onRenderMenu() {
    		throw new Error("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onRenderMenu(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClassName() {
    		throw new Error("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClassName(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onFocus() {
    		throw new Error("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onFocus(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onBlur() {
    		throw new Error("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onBlur(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get expand() {
    		return this.$$.ctx[51];
    	}

    	set expand(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collapse() {
    		return this.$$.ctx[52];
    	}

    	set collapse(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get get() {
    		return this.$$.ctx[53];
    	}

    	set get(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get patch() {
    		return this.$$.ctx[54];
    	}

    	set patch(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollTo() {
    		return this.$$.ctx[55];
    	}

    	set scrollTo(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get findElement() {
    		return this.$$.ctx[56];
    	}

    	set findElement(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focus() {
    		return this.$$.ctx[7];
    	}

    	set focus(value) {
    		throw new Error("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-jsoneditor\src\components\JSONEditor.svelte generated by Svelte v3.38.2 */

    const { Error: Error_1, console: console_1$1 } = globals;
    const file$2 = "node_modules\\svelte-jsoneditor\\src\\components\\JSONEditor.svelte";

    // (294:8) {:else}
    function create_else_block$1(ctx) {
    	let t;
    	let treemode;
    	let current;
    	let if_block = /*isNewDocument*/ ctx[16] && create_if_block_1$1(ctx);

    	let treemode_props = {
    		readOnly: /*readOnly*/ ctx[5],
    		indentation: /*indentation*/ ctx[6],
    		externalJson: /*json*/ ctx[0],
    		externalText: /*text*/ ctx[1],
    		mainMenuBar: /*mainMenuBar*/ ctx[3],
    		validator: /*validator*/ ctx[4],
    		onError: /*onError*/ ctx[8],
    		onChange: /*handleChangeJson*/ ctx[18],
    		onRequestRepair: /*handleRequestRepair*/ ctx[19],
    		onClassName: /*onClassName*/ ctx[7],
    		onRenderMenu: /*handleCreateMenu*/ ctx[23],
    		onFocus: /*handleFocus*/ ctx[21],
    		onBlur: /*handleBlur*/ ctx[22],
    		visible: !/*isNewDocument*/ ctx[16]
    	};

    	treemode = new TreeMode({ props: treemode_props, $$inline: true });
    	/*treemode_binding*/ ctx[51](treemode);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			create_component(treemode.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(treemode, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*isNewDocument*/ ctx[16]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*isNewDocument*/ 65536) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const treemode_changes = {};
    			if (dirty[0] & /*readOnly*/ 32) treemode_changes.readOnly = /*readOnly*/ ctx[5];
    			if (dirty[0] & /*indentation*/ 64) treemode_changes.indentation = /*indentation*/ ctx[6];
    			if (dirty[0] & /*json*/ 1) treemode_changes.externalJson = /*json*/ ctx[0];
    			if (dirty[0] & /*text*/ 2) treemode_changes.externalText = /*text*/ ctx[1];
    			if (dirty[0] & /*mainMenuBar*/ 8) treemode_changes.mainMenuBar = /*mainMenuBar*/ ctx[3];
    			if (dirty[0] & /*validator*/ 16) treemode_changes.validator = /*validator*/ ctx[4];
    			if (dirty[0] & /*onError*/ 256) treemode_changes.onError = /*onError*/ ctx[8];
    			if (dirty[0] & /*onClassName*/ 128) treemode_changes.onClassName = /*onClassName*/ ctx[7];
    			if (dirty[0] & /*isNewDocument*/ 65536) treemode_changes.visible = !/*isNewDocument*/ ctx[16];
    			treemode.$set(treemode_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(treemode.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(treemode.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			/*treemode_binding*/ ctx[51](null);
    			destroy_component(treemode, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(294:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (279:8) {#if mode === MODE.CODE}
    function create_if_block$1(ctx) {
    	let codemode;
    	let current;

    	let codemode_props = {
    		text: /*textForCodeMode*/ ctx[15],
    		readOnly: /*readOnly*/ ctx[5],
    		indentation: /*indentation*/ ctx[6],
    		mainMenuBar: /*mainMenuBar*/ ctx[3],
    		validator: /*validator*/ ctx[4],
    		onChange: /*handleChangeText*/ ctx[17],
    		onSwitchToTreeMode: /*handleSwitchToTreeMode*/ ctx[20],
    		onError: /*onError*/ ctx[8],
    		onFocus: /*handleFocus*/ ctx[21],
    		onBlur: /*handleBlur*/ ctx[22],
    		onRenderMenu: /*handleCreateMenu*/ ctx[23]
    	};

    	codemode = new CodeMode({ props: codemode_props, $$inline: true });
    	/*codemode_binding*/ ctx[49](codemode);

    	const block = {
    		c: function create() {
    			create_component(codemode.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(codemode, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const codemode_changes = {};
    			if (dirty[0] & /*textForCodeMode*/ 32768) codemode_changes.text = /*textForCodeMode*/ ctx[15];
    			if (dirty[0] & /*readOnly*/ 32) codemode_changes.readOnly = /*readOnly*/ ctx[5];
    			if (dirty[0] & /*indentation*/ 64) codemode_changes.indentation = /*indentation*/ ctx[6];
    			if (dirty[0] & /*mainMenuBar*/ 8) codemode_changes.mainMenuBar = /*mainMenuBar*/ ctx[3];
    			if (dirty[0] & /*validator*/ 16) codemode_changes.validator = /*validator*/ ctx[4];
    			if (dirty[0] & /*onError*/ 256) codemode_changes.onError = /*onError*/ ctx[8];
    			codemode.$set(codemode_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(codemode.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(codemode.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*codemode_binding*/ ctx[49](null);
    			destroy_component(codemode, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(279:8) {#if mode === MODE.CODE}",
    		ctx
    	});

    	return block;
    }

    // (295:10) {#if isNewDocument}
    function create_if_block_1$1(ctx) {
    	let welcomemode;
    	let current;

    	let welcomemode_props = {
    		readOnly: /*readOnly*/ ctx[5],
    		onChange: /*handleChangeText*/ ctx[17],
    		onFocus: /*handleFocus*/ ctx[21],
    		onBlur: /*handleBlur*/ ctx[22],
    		onRenderMenu: /*handleCreateMenu*/ ctx[23]
    	};

    	welcomemode = new WelcomeMode({ props: welcomemode_props, $$inline: true });
    	/*welcomemode_binding*/ ctx[50](welcomemode);

    	const block = {
    		c: function create() {
    			create_component(welcomemode.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(welcomemode, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const welcomemode_changes = {};
    			if (dirty[0] & /*readOnly*/ 32) welcomemode_changes.readOnly = /*readOnly*/ ctx[5];
    			welcomemode.$set(welcomemode_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(welcomemode.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(welcomemode.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*welcomemode_binding*/ ctx[50](null);
    			destroy_component(welcomemode, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(295:10) {#if isNewDocument}",
    		ctx
    	});

    	return block;
    }

    // (278:6) {#key instanceId}
    function create_key_block(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$1, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*mode*/ ctx[2] === MODE.CODE) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block.name,
    		type: "key",
    		source: "(278:6) {#key instanceId}",
    		ctx
    	});

    	return block;
    }

    // (276:2) <AbsolutePopup>
    function create_default_slot_1(ctx) {
    	let div;
    	let previous_key = /*instanceId*/ ctx[9];
    	let current;
    	let key_block = create_key_block(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			key_block.c();
    			attr_dev(div, "class", "jsoneditor-main svelte-6c4pg8");
    			toggle_class(div, "focus", /*hasFocus*/ ctx[10]);
    			add_location(div, file$2, 276, 4, 5748);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			key_block.m(div, null);
    			/*div_binding*/ ctx[52](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*instanceId*/ 512 && not_equal(previous_key, previous_key = /*instanceId*/ ctx[9])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$2);
    				check_outros();
    				key_block = create_key_block(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(div, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}

    			if (dirty[0] & /*hasFocus*/ 1024) {
    				toggle_class(div, "focus", /*hasFocus*/ ctx[10]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			key_block.d(detaching);
    			/*div_binding*/ ctx[52](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(276:2) <AbsolutePopup>",
    		ctx
    	});

    	return block;
    }

    // (275:0) <Modal>
    function create_default_slot(ctx) {
    	let absolutepopup;
    	let current;

    	absolutepopup = new AbsolutePopup({
    			props: {
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(absolutepopup.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(absolutepopup, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const absolutepopup_changes = {};

    			if (dirty[0] & /*refJSONEditor, hasFocus, textForCodeMode, readOnly, indentation, mainMenuBar, validator, onError, refCodeMode, mode, json, text, onClassName, isNewDocument, refTreeMode, refWelcomeMode*/ 130559 | dirty[1] & /*$$scope*/ 33554432) {
    				absolutepopup_changes.$$scope = { dirty, ctx };
    			}

    			absolutepopup.$set(absolutepopup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(absolutepopup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(absolutepopup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(absolutepopup, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(275:0) <Modal>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let modal;
    	let current;

    	modal = new Modal({
    			props: {
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modal_changes = {};

    			if (dirty[0] & /*refJSONEditor, hasFocus, textForCodeMode, readOnly, indentation, mainMenuBar, validator, onError, refCodeMode, mode, json, text, onClassName, isNewDocument, refTreeMode, refWelcomeMode*/ 130559 | dirty[1] & /*$$scope*/ 33554432) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function destroy() {
    	this.$destroy();
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let textForCodeMode;
    	let isNewDocument;
    	let isCodeMode;
    	let modeMenuItems;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("JSONEditor", slots, []);
    	const debug = browser("jsoneditor:Main");
    	let { json = {} } = $$props;
    	let { text = undefined } = $$props;
    	let { readOnly = false } = $$props;
    	let { indentation = 2 } = $$props;
    	let { mode = MODE.TREE } = $$props;
    	let { mainMenuBar = true } = $$props;
    	let { validator = null } = $$props;
    	let { onChange = null } = $$props;

    	let { onClassName = () => {
    		
    	} } = $$props;

    	let { onRenderMenu = () => {
    		
    	} } = $$props;

    	let { onChangeMode = () => {
    		
    	} } = $$props;

    	let { onError = err => {
    		console.error(err);
    		alert(err.toString()); // TODO: create a nice alert modal
    	} } = $$props;

    	let { onFocus = () => {
    		
    	} } = $$props;

    	let { onBlur = () => {
    		
    	} } = $$props;

    	let instanceId = uniqueId();
    	let hasFocus = false;
    	let refJSONEditor;
    	let refTreeMode;
    	let refWelcomeMode;
    	let refCodeMode;

    	function get() {
    		return json !== undefined ? json : JSON.parse(text || "");
    	}

    	function getText() {
    		return typeof text === "string"
    		? text
    		: JSON.stringify(json, null, indentation);
    	}

    	function set(newJson) {
    		debug("set");

    		// new editor id -> will re-create the editor
    		$$invalidate(9, instanceId = uniqueId());

    		$$invalidate(1, text = undefined);
    		$$invalidate(0, json = newJson);
    	}

    	function setText(newText) {
    		debug("setText");

    		// new editor id -> will re-create the editor
    		$$invalidate(9, instanceId = uniqueId());

    		$$invalidate(1, text = newText);
    		$$invalidate(0, json = undefined);
    	}

    	function update(updatedJson) {
    		debug("update");
    		$$invalidate(1, text = undefined);
    		$$invalidate(0, json = updatedJson);
    	}

    	function updateText(updatedText) {
    		debug("updateText");
    		$$invalidate(1, text = updatedText);
    		$$invalidate(0, json = undefined);
    	}

    	function patch(operations, newSelection) {
    		if (json === undefined) {
    			try {
    				$$invalidate(0, json = JSON.parse(text));
    				$$invalidate(1, text = undefined);
    			} catch(err) {
    				throw new Error("Cannot apply patch: current document contains invalid JSON");
    			}
    		}

    		if (refTreeMode) {
    			return refTreeMode.patch(operations, newSelection);
    		}

    		if (refCodeMode) {
    			return refCodeMode.patch(operations);
    		}
    	}

    	function expand(callback) {
    		if (refTreeMode) {
    			return refTreeMode.expand(callback);
    		}

    		throw new Error(`Method expand is not available in mode "${mode}"`);
    	}

    	function collapse(callback) {
    		if (refTreeMode) {
    			return refTreeMode.collapse(callback);
    		}

    		throw new Error(`Method collapse is not available in mode "${mode}"`);
    	}

    	function scrollTo(path) {
    		if (refTreeMode) {
    			return refTreeMode.scrollTo(path);
    		}

    		// TODO: implement scrollTo for code mode
    		throw new Error(`Method scrollTo is not available in mode "${mode}"`);
    	}

    	function findElement(path) {
    		if (refTreeMode) {
    			return refTreeMode.findElement(path);
    		}

    		throw new Error(`Method findElement is not available in mode "${mode}"`);
    	}

    	function setValidator(newValidator) {
    		$$invalidate(4, validator = newValidator);
    	}

    	function getValidator() {
    		return validator;
    	}

    	function setMainMenuBar(newMainMenuBar) {
    		$$invalidate(3, mainMenuBar = newMainMenuBar);
    	}

    	function getMainMenuBar() {
    		return mainMenuBar;
    	}

    	function setMode(newMode) {
    		$$invalidate(2, mode = newMode);
    	}

    	function getMode() {
    		return mode;
    	}

    	function focus() {
    		if (refCodeMode) {
    			refCodeMode.focus();
    		} else if (refWelcomeMode) {
    			refWelcomeMode.focus();
    		} else if (refTreeMode) {
    			refTreeMode.focus();
    		}
    	}

    	function handleChangeText(updatedText) {
    		$$invalidate(1, text = updatedText);
    		$$invalidate(0, json = undefined);

    		if (onChange) {
    			onChange({ json, text });
    		}
    	}

    	function handleChangeJson(updatedJson) {
    		$$invalidate(0, json = updatedJson);
    		$$invalidate(1, text = undefined);

    		if (onChange) {
    			onChange({ json, text });
    		}
    	}

    	function handleRequestRepair() {
    		$$invalidate(2, mode = MODE.CODE);
    		onChangeMode(mode);
    	}

    	function handleSwitchToTreeMode() {
    		$$invalidate(2, mode = MODE.TREE);
    		onChangeMode(mode);
    	}

    	function handleFocus() {
    		$$invalidate(10, hasFocus = true);

    		if (onFocus) {
    			onFocus();
    		}
    	}

    	function handleBlur() {
    		$$invalidate(10, hasFocus = false);

    		if (onBlur) {
    			onBlur();
    		}
    	}

    	function toggleCodeMode() {
    		$$invalidate(2, mode = mode === MODE.CODE ? MODE.TREE : MODE.CODE);
    		onChangeMode(mode);
    		setTimeout(focus);
    	}

    	function handleCreateMenu(mode, items) {
    		const updatedItems = mode === MODE.TREE || mode === MODE.CODE
    		? modeMenuItems.concat(items)
    		: items;

    		return onRenderMenu(mode, updatedItems) || updatedItems;
    	}

    	const writable_props = [
    		"json",
    		"text",
    		"readOnly",
    		"indentation",
    		"mode",
    		"mainMenuBar",
    		"validator",
    		"onChange",
    		"onClassName",
    		"onRenderMenu",
    		"onChangeMode",
    		"onError",
    		"onFocus",
    		"onBlur"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<JSONEditor> was created with unknown prop '${key}'`);
    	});

    	function codemode_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			refCodeMode = $$value;
    			$$invalidate(14, refCodeMode);
    		});
    	}

    	function welcomemode_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			refWelcomeMode = $$value;
    			$$invalidate(13, refWelcomeMode);
    		});
    	}

    	function treemode_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			refTreeMode = $$value;
    			$$invalidate(12, refTreeMode);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			refJSONEditor = $$value;
    			$$invalidate(11, refJSONEditor);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("json" in $$props) $$invalidate(0, json = $$props.json);
    		if ("text" in $$props) $$invalidate(1, text = $$props.text);
    		if ("readOnly" in $$props) $$invalidate(5, readOnly = $$props.readOnly);
    		if ("indentation" in $$props) $$invalidate(6, indentation = $$props.indentation);
    		if ("mode" in $$props) $$invalidate(2, mode = $$props.mode);
    		if ("mainMenuBar" in $$props) $$invalidate(3, mainMenuBar = $$props.mainMenuBar);
    		if ("validator" in $$props) $$invalidate(4, validator = $$props.validator);
    		if ("onChange" in $$props) $$invalidate(24, onChange = $$props.onChange);
    		if ("onClassName" in $$props) $$invalidate(7, onClassName = $$props.onClassName);
    		if ("onRenderMenu" in $$props) $$invalidate(25, onRenderMenu = $$props.onRenderMenu);
    		if ("onChangeMode" in $$props) $$invalidate(26, onChangeMode = $$props.onChangeMode);
    		if ("onError" in $$props) $$invalidate(8, onError = $$props.onError);
    		if ("onFocus" in $$props) $$invalidate(27, onFocus = $$props.onFocus);
    		if ("onBlur" in $$props) $$invalidate(28, onBlur = $$props.onBlur);
    	};

    	$$self.$capture_state = () => ({
    		faCode,
    		AbsolutePopup,
    		createDebug: browser,
    		Modal,
    		WelcomeMode,
    		MODE,
    		uniqueId,
    		CodeMode,
    		TreeMode,
    		debug,
    		json,
    		text,
    		readOnly,
    		indentation,
    		mode,
    		mainMenuBar,
    		validator,
    		onChange,
    		onClassName,
    		onRenderMenu,
    		onChangeMode,
    		onError,
    		onFocus,
    		onBlur,
    		instanceId,
    		hasFocus,
    		refJSONEditor,
    		refTreeMode,
    		refWelcomeMode,
    		refCodeMode,
    		get,
    		getText,
    		set,
    		setText,
    		update,
    		updateText,
    		patch,
    		expand,
    		collapse,
    		scrollTo,
    		findElement,
    		setValidator,
    		getValidator,
    		setMainMenuBar,
    		getMainMenuBar,
    		setMode,
    		getMode,
    		focus,
    		destroy,
    		handleChangeText,
    		handleChangeJson,
    		handleRequestRepair,
    		handleSwitchToTreeMode,
    		handleFocus,
    		handleBlur,
    		toggleCodeMode,
    		handleCreateMenu,
    		textForCodeMode,
    		isNewDocument,
    		isCodeMode,
    		modeMenuItems
    	});

    	$$self.$inject_state = $$props => {
    		if ("json" in $$props) $$invalidate(0, json = $$props.json);
    		if ("text" in $$props) $$invalidate(1, text = $$props.text);
    		if ("readOnly" in $$props) $$invalidate(5, readOnly = $$props.readOnly);
    		if ("indentation" in $$props) $$invalidate(6, indentation = $$props.indentation);
    		if ("mode" in $$props) $$invalidate(2, mode = $$props.mode);
    		if ("mainMenuBar" in $$props) $$invalidate(3, mainMenuBar = $$props.mainMenuBar);
    		if ("validator" in $$props) $$invalidate(4, validator = $$props.validator);
    		if ("onChange" in $$props) $$invalidate(24, onChange = $$props.onChange);
    		if ("onClassName" in $$props) $$invalidate(7, onClassName = $$props.onClassName);
    		if ("onRenderMenu" in $$props) $$invalidate(25, onRenderMenu = $$props.onRenderMenu);
    		if ("onChangeMode" in $$props) $$invalidate(26, onChangeMode = $$props.onChangeMode);
    		if ("onError" in $$props) $$invalidate(8, onError = $$props.onError);
    		if ("onFocus" in $$props) $$invalidate(27, onFocus = $$props.onFocus);
    		if ("onBlur" in $$props) $$invalidate(28, onBlur = $$props.onBlur);
    		if ("instanceId" in $$props) $$invalidate(9, instanceId = $$props.instanceId);
    		if ("hasFocus" in $$props) $$invalidate(10, hasFocus = $$props.hasFocus);
    		if ("refJSONEditor" in $$props) $$invalidate(11, refJSONEditor = $$props.refJSONEditor);
    		if ("refTreeMode" in $$props) $$invalidate(12, refTreeMode = $$props.refTreeMode);
    		if ("refWelcomeMode" in $$props) $$invalidate(13, refWelcomeMode = $$props.refWelcomeMode);
    		if ("refCodeMode" in $$props) $$invalidate(14, refCodeMode = $$props.refCodeMode);
    		if ("textForCodeMode" in $$props) $$invalidate(15, textForCodeMode = $$props.textForCodeMode);
    		if ("isNewDocument" in $$props) $$invalidate(16, isNewDocument = $$props.isNewDocument);
    		if ("isCodeMode" in $$props) $$invalidate(48, isCodeMode = $$props.isCodeMode);
    		if ("modeMenuItems" in $$props) modeMenuItems = $$props.modeMenuItems;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*mode, json, text*/ 7) {
    			$$invalidate(15, textForCodeMode = mode === MODE.CODE ? getText() : undefined);
    		}

    		if ($$self.$$.dirty[0] & /*text, json*/ 3) {
    			$$invalidate(16, isNewDocument = text === "" && json === undefined);
    		}

    		if ($$self.$$.dirty[0] & /*mode*/ 4) {
    			$$invalidate(48, isCodeMode = mode === MODE.CODE);
    		}

    		if ($$self.$$.dirty[1] & /*isCodeMode*/ 131072) {
    			modeMenuItems = [
    				{
    					icon: faCode,
    					title: `Toggle code mode on/off (currently: ${isCodeMode ? "on" : "off"})`,
    					className: "code-mode" + (isCodeMode ? " selected" : ""),
    					onClick: toggleCodeMode
    				},
    				{ separator: true }
    			];
    		}
    	};

    	return [
    		json,
    		text,
    		mode,
    		mainMenuBar,
    		validator,
    		readOnly,
    		indentation,
    		onClassName,
    		onError,
    		instanceId,
    		hasFocus,
    		refJSONEditor,
    		refTreeMode,
    		refWelcomeMode,
    		refCodeMode,
    		textForCodeMode,
    		isNewDocument,
    		handleChangeText,
    		handleChangeJson,
    		handleRequestRepair,
    		handleSwitchToTreeMode,
    		handleFocus,
    		handleBlur,
    		handleCreateMenu,
    		onChange,
    		onRenderMenu,
    		onChangeMode,
    		onFocus,
    		onBlur,
    		get,
    		getText,
    		set,
    		setText,
    		update,
    		updateText,
    		patch,
    		expand,
    		collapse,
    		scrollTo,
    		findElement,
    		setValidator,
    		getValidator,
    		setMainMenuBar,
    		getMainMenuBar,
    		setMode,
    		getMode,
    		focus,
    		destroy,
    		isCodeMode,
    		codemode_binding,
    		welcomemode_binding,
    		treemode_binding,
    		div_binding
    	];
    }

    class JSONEditor$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$3,
    			create_fragment$3,
    			not_equal,
    			{
    				json: 0,
    				text: 1,
    				readOnly: 5,
    				indentation: 6,
    				mode: 2,
    				mainMenuBar: 3,
    				validator: 4,
    				onChange: 24,
    				onClassName: 7,
    				onRenderMenu: 25,
    				onChangeMode: 26,
    				onError: 8,
    				onFocus: 27,
    				onBlur: 28,
    				get: 29,
    				getText: 30,
    				set: 31,
    				setText: 32,
    				update: 33,
    				updateText: 34,
    				patch: 35,
    				expand: 36,
    				collapse: 37,
    				scrollTo: 38,
    				findElement: 39,
    				setValidator: 40,
    				getValidator: 41,
    				setMainMenuBar: 42,
    				getMainMenuBar: 43,
    				setMode: 44,
    				getMode: 45,
    				focus: 46,
    				destroy: 47
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "JSONEditor",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get json() {
    		throw new Error_1("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set json(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error_1("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get readOnly() {
    		throw new Error_1("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readOnly(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indentation() {
    		throw new Error_1("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indentation(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mode() {
    		throw new Error_1("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mode(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mainMenuBar() {
    		throw new Error_1("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mainMenuBar(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get validator() {
    		throw new Error_1("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set validator(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onChange() {
    		throw new Error_1("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onChange(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClassName() {
    		throw new Error_1("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClassName(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onRenderMenu() {
    		throw new Error_1("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onRenderMenu(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onChangeMode() {
    		throw new Error_1("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onChangeMode(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onError() {
    		throw new Error_1("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onError(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onFocus() {
    		throw new Error_1("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onFocus(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onBlur() {
    		throw new Error_1("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onBlur(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get get() {
    		return this.$$.ctx[29];
    	}

    	set get(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getText() {
    		return this.$$.ctx[30];
    	}

    	set getText(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get set() {
    		return this.$$.ctx[31];
    	}

    	set set(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setText() {
    		return this.$$.ctx[32];
    	}

    	set setText(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get update() {
    		return this.$$.ctx[33];
    	}

    	set update(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get updateText() {
    		return this.$$.ctx[34];
    	}

    	set updateText(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get patch() {
    		return this.$$.ctx[35];
    	}

    	set patch(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get expand() {
    		return this.$$.ctx[36];
    	}

    	set expand(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collapse() {
    		return this.$$.ctx[37];
    	}

    	set collapse(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollTo() {
    		return this.$$.ctx[38];
    	}

    	set scrollTo(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get findElement() {
    		return this.$$.ctx[39];
    	}

    	set findElement(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setValidator() {
    		return this.$$.ctx[40];
    	}

    	set setValidator(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getValidator() {
    		return this.$$.ctx[41];
    	}

    	set getValidator(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setMainMenuBar() {
    		return this.$$.ctx[42];
    	}

    	set setMainMenuBar(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getMainMenuBar() {
    		return this.$$.ctx[43];
    	}

    	set getMainMenuBar(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setMode() {
    		return this.$$.ctx[44];
    	}

    	set setMode(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getMode() {
    		return this.$$.ctx[45];
    	}

    	set getMode(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focus() {
    		return this.$$.ctx[46];
    	}

    	set focus(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get destroy() {
    		return destroy;
    	}

    	set destroy(value) {
    		throw new Error_1("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var code$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.regexpCode = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    class _CodeOrName {
    }
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class Name extends _CodeOrName {
        constructor(s) {
            super();
            if (!exports.IDENTIFIER.test(s))
                throw new Error("CodeGen: name must be a valid identifier");
            this.str = s;
        }
        toString() {
            return this.str;
        }
        emptyStr() {
            return false;
        }
        get names() {
            return { [this.str]: 1 };
        }
    }
    exports.Name = Name;
    class _Code extends _CodeOrName {
        constructor(code) {
            super();
            this._items = typeof code === "string" ? [code] : code;
        }
        toString() {
            return this.str;
        }
        emptyStr() {
            if (this._items.length > 1)
                return false;
            const item = this._items[0];
            return item === "" || item === '""';
        }
        get str() {
            var _a;
            return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, "")));
        }
        get names() {
            var _a;
            return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {
                if (c instanceof Name)
                    names[c.str] = (names[c.str] || 0) + 1;
                return names;
            }, {})));
        }
    }
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
        const code = [strs[0]];
        let i = 0;
        while (i < args.length) {
            addCodeArg(code, args[i]);
            code.push(strs[++i]);
        }
        return new _Code(code);
    }
    exports._ = _;
    const plus = new _Code("+");
    function str(strs, ...args) {
        const expr = [safeStringify(strs[0])];
        let i = 0;
        while (i < args.length) {
            expr.push(plus);
            addCodeArg(expr, args[i]);
            expr.push(plus, safeStringify(strs[++i]));
        }
        optimize(expr);
        return new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
        if (arg instanceof _Code)
            code.push(...arg._items);
        else if (arg instanceof Name)
            code.push(arg);
        else
            code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
        let i = 1;
        while (i < expr.length - 1) {
            if (expr[i] === plus) {
                const res = mergeExprItems(expr[i - 1], expr[i + 1]);
                if (res !== undefined) {
                    expr.splice(i - 1, 3, res);
                    continue;
                }
                expr[i++] = "+";
            }
            i++;
        }
    }
    function mergeExprItems(a, b) {
        if (b === '""')
            return a;
        if (a === '""')
            return b;
        if (typeof a == "string") {
            if (b instanceof Name || a[a.length - 1] !== '"')
                return;
            if (typeof b != "string")
                return `${a.slice(0, -1)}${b}"`;
            if (b[0] === '"')
                return a.slice(0, -1) + b.slice(1);
            return;
        }
        if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
            return `"${a}${b.slice(1)}`;
        return;
    }
    function strConcat(c1, c2) {
        return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    // TODO do not allow arrays here
    function interpolate(x) {
        return typeof x == "number" || typeof x == "boolean" || x === null
            ? x
            : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
        return new _Code(safeStringify(x));
    }
    exports.stringify = stringify;
    function safeStringify(x) {
        return JSON.stringify(x)
            .replace(/\u2028/g, "\\u2028")
            .replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key) {
        return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;
    }
    exports.getProperty = getProperty;
    function regexpCode(rx) {
        return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;

    });

    var scope = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;

    class ValueError extends Error {
        constructor(name) {
            super(`CodeGen: "code" for ${name} not defined`);
            this.value = name.value;
        }
    }
    var UsedValueState;
    (function (UsedValueState) {
        UsedValueState[UsedValueState["Started"] = 0] = "Started";
        UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
    })(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
    exports.varKinds = {
        const: new code$1.Name("const"),
        let: new code$1.Name("let"),
        var: new code$1.Name("var"),
    };
    class Scope {
        constructor({ prefixes, parent } = {}) {
            this._names = {};
            this._prefixes = prefixes;
            this._parent = parent;
        }
        toName(nameOrPrefix) {
            return nameOrPrefix instanceof code$1.Name ? nameOrPrefix : this.name(nameOrPrefix);
        }
        name(prefix) {
            return new code$1.Name(this._newName(prefix));
        }
        _newName(prefix) {
            const ng = this._names[prefix] || this._nameGroup(prefix);
            return `${prefix}${ng.index++}`;
        }
        _nameGroup(prefix) {
            var _a, _b;
            if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
                throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
            }
            return (this._names[prefix] = { prefix, index: 0 });
        }
    }
    exports.Scope = Scope;
    class ValueScopeName extends code$1.Name {
        constructor(prefix, nameStr) {
            super(nameStr);
            this.prefix = prefix;
        }
        setValue(value, { property, itemIndex }) {
            this.value = value;
            this.scopePath = code$1._ `.${new code$1.Name(property)}[${itemIndex}]`;
        }
    }
    exports.ValueScopeName = ValueScopeName;
    const line = code$1._ `\n`;
    class ValueScope extends Scope {
        constructor(opts) {
            super(opts);
            this._values = {};
            this._scope = opts.scope;
            this.opts = { ...opts, _n: opts.lines ? line : code$1.nil };
        }
        get() {
            return this._scope;
        }
        name(prefix) {
            return new ValueScopeName(prefix, this._newName(prefix));
        }
        value(nameOrPrefix, value) {
            var _a;
            if (value.ref === undefined)
                throw new Error("CodeGen: ref must be passed in value");
            const name = this.toName(nameOrPrefix);
            const { prefix } = name;
            const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
            let vs = this._values[prefix];
            if (vs) {
                const _name = vs.get(valueKey);
                if (_name)
                    return _name;
            }
            else {
                vs = this._values[prefix] = new Map();
            }
            vs.set(valueKey, name);
            const s = this._scope[prefix] || (this._scope[prefix] = []);
            const itemIndex = s.length;
            s[itemIndex] = value.ref;
            name.setValue(value, { property: prefix, itemIndex });
            return name;
        }
        getValue(prefix, keyOrRef) {
            const vs = this._values[prefix];
            if (!vs)
                return;
            return vs.get(keyOrRef);
        }
        scopeRefs(scopeName, values = this._values) {
            return this._reduceValues(values, (name) => {
                if (name.scopePath === undefined)
                    throw new Error(`CodeGen: name "${name}" has no value`);
                return code$1._ `${scopeName}${name.scopePath}`;
            });
        }
        scopeCode(values = this._values, usedValues, getCode) {
            return this._reduceValues(values, (name) => {
                if (name.value === undefined)
                    throw new Error(`CodeGen: name "${name}" has no value`);
                return name.value.code;
            }, usedValues, getCode);
        }
        _reduceValues(values, valueCode, usedValues = {}, getCode) {
            let code = code$1.nil;
            for (const prefix in values) {
                const vs = values[prefix];
                if (!vs)
                    continue;
                const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
                vs.forEach((name) => {
                    if (nameSet.has(name))
                        return;
                    nameSet.set(name, UsedValueState.Started);
                    let c = valueCode(name);
                    if (c) {
                        const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
                        code = code$1._ `${code}${def} ${name} = ${c};${this.opts._n}`;
                    }
                    else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
                        code = code$1._ `${code}${c}${this.opts._n}`;
                    }
                    else {
                        throw new ValueError(name);
                    }
                    nameSet.set(name, UsedValueState.Completed);
                });
            }
            return code;
        }
    }
    exports.ValueScope = ValueScope;

    });

    var codegen = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;


    var code_2 = code$1;
    Object.defineProperty(exports, "_", { enumerable: true, get: function () { return code_2._; } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function () { return code_2.str; } });
    Object.defineProperty(exports, "strConcat", { enumerable: true, get: function () { return code_2.strConcat; } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return code_2.nil; } });
    Object.defineProperty(exports, "getProperty", { enumerable: true, get: function () { return code_2.getProperty; } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return code_2.stringify; } });
    Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function () { return code_2.regexpCode; } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return code_2.Name; } });
    var scope_2 = scope;
    Object.defineProperty(exports, "Scope", { enumerable: true, get: function () { return scope_2.Scope; } });
    Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function () { return scope_2.ValueScope; } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });
    Object.defineProperty(exports, "varKinds", { enumerable: true, get: function () { return scope_2.varKinds; } });
    exports.operators = {
        GT: new code$1._Code(">"),
        GTE: new code$1._Code(">="),
        LT: new code$1._Code("<"),
        LTE: new code$1._Code("<="),
        EQ: new code$1._Code("==="),
        NEQ: new code$1._Code("!=="),
        NOT: new code$1._Code("!"),
        OR: new code$1._Code("||"),
        AND: new code$1._Code("&&"),
        ADD: new code$1._Code("+"),
    };
    class Node {
        optimizeNodes() {
            return this;
        }
        optimizeNames(_names, _constants) {
            return this;
        }
    }
    class Def extends Node {
        constructor(varKind, name, rhs) {
            super();
            this.varKind = varKind;
            this.name = name;
            this.rhs = rhs;
        }
        render({ es5, _n }) {
            const varKind = es5 ? scope.varKinds.var : this.varKind;
            const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
            return `${varKind} ${this.name}${rhs};` + _n;
        }
        optimizeNames(names, constants) {
            if (!names[this.name.str])
                return;
            if (this.rhs)
                this.rhs = optimizeExpr(this.rhs, names, constants);
            return this;
        }
        get names() {
            return this.rhs instanceof code$1._CodeOrName ? this.rhs.names : {};
        }
    }
    class Assign extends Node {
        constructor(lhs, rhs, sideEffects) {
            super();
            this.lhs = lhs;
            this.rhs = rhs;
            this.sideEffects = sideEffects;
        }
        render({ _n }) {
            return `${this.lhs} = ${this.rhs};` + _n;
        }
        optimizeNames(names, constants) {
            if (this.lhs instanceof code$1.Name && !names[this.lhs.str] && !this.sideEffects)
                return;
            this.rhs = optimizeExpr(this.rhs, names, constants);
            return this;
        }
        get names() {
            const names = this.lhs instanceof code$1.Name ? {} : { ...this.lhs.names };
            return addExprNames(names, this.rhs);
        }
    }
    class AssignOp extends Assign {
        constructor(lhs, op, rhs, sideEffects) {
            super(lhs, rhs, sideEffects);
            this.op = op;
        }
        render({ _n }) {
            return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
        }
    }
    class Label extends Node {
        constructor(label) {
            super();
            this.label = label;
            this.names = {};
        }
        render({ _n }) {
            return `${this.label}:` + _n;
        }
    }
    class Break extends Node {
        constructor(label) {
            super();
            this.label = label;
            this.names = {};
        }
        render({ _n }) {
            const label = this.label ? ` ${this.label}` : "";
            return `break${label};` + _n;
        }
    }
    class Throw extends Node {
        constructor(error) {
            super();
            this.error = error;
        }
        render({ _n }) {
            return `throw ${this.error};` + _n;
        }
        get names() {
            return this.error.names;
        }
    }
    class AnyCode extends Node {
        constructor(code) {
            super();
            this.code = code;
        }
        render({ _n }) {
            return `${this.code};` + _n;
        }
        optimizeNodes() {
            return `${this.code}` ? this : undefined;
        }
        optimizeNames(names, constants) {
            this.code = optimizeExpr(this.code, names, constants);
            return this;
        }
        get names() {
            return this.code instanceof code$1._CodeOrName ? this.code.names : {};
        }
    }
    class ParentNode extends Node {
        constructor(nodes = []) {
            super();
            this.nodes = nodes;
        }
        render(opts) {
            return this.nodes.reduce((code, n) => code + n.render(opts), "");
        }
        optimizeNodes() {
            const { nodes } = this;
            let i = nodes.length;
            while (i--) {
                const n = nodes[i].optimizeNodes();
                if (Array.isArray(n))
                    nodes.splice(i, 1, ...n);
                else if (n)
                    nodes[i] = n;
                else
                    nodes.splice(i, 1);
            }
            return nodes.length > 0 ? this : undefined;
        }
        optimizeNames(names, constants) {
            const { nodes } = this;
            let i = nodes.length;
            while (i--) {
                // iterating backwards improves 1-pass optimization
                const n = nodes[i];
                if (n.optimizeNames(names, constants))
                    continue;
                subtractNames(names, n.names);
                nodes.splice(i, 1);
            }
            return nodes.length > 0 ? this : undefined;
        }
        get names() {
            return this.nodes.reduce((names, n) => addNames(names, n.names), {});
        }
    }
    class BlockNode extends ParentNode {
        render(opts) {
            return "{" + opts._n + super.render(opts) + "}" + opts._n;
        }
    }
    class Root extends ParentNode {
    }
    class Else extends BlockNode {
    }
    Else.kind = "else";
    class If extends BlockNode {
        constructor(condition, nodes) {
            super(nodes);
            this.condition = condition;
        }
        render(opts) {
            let code = `if(${this.condition})` + super.render(opts);
            if (this.else)
                code += "else " + this.else.render(opts);
            return code;
        }
        optimizeNodes() {
            super.optimizeNodes();
            const cond = this.condition;
            if (cond === true)
                return this.nodes; // else is ignored here
            let e = this.else;
            if (e) {
                const ns = e.optimizeNodes();
                e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
            }
            if (e) {
                if (cond === false)
                    return e instanceof If ? e : e.nodes;
                if (this.nodes.length)
                    return this;
                return new If(not(cond), e instanceof If ? [e] : e.nodes);
            }
            if (cond === false || !this.nodes.length)
                return undefined;
            return this;
        }
        optimizeNames(names, constants) {
            var _a;
            this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
            if (!(super.optimizeNames(names, constants) || this.else))
                return;
            this.condition = optimizeExpr(this.condition, names, constants);
            return this;
        }
        get names() {
            const names = super.names;
            addExprNames(names, this.condition);
            if (this.else)
                addNames(names, this.else.names);
            return names;
        }
    }
    If.kind = "if";
    class For extends BlockNode {
    }
    For.kind = "for";
    class ForLoop extends For {
        constructor(iteration) {
            super();
            this.iteration = iteration;
        }
        render(opts) {
            return `for(${this.iteration})` + super.render(opts);
        }
        optimizeNames(names, constants) {
            if (!super.optimizeNames(names, constants))
                return;
            this.iteration = optimizeExpr(this.iteration, names, constants);
            return this;
        }
        get names() {
            return addNames(super.names, this.iteration.names);
        }
    }
    class ForRange extends For {
        constructor(varKind, name, from, to) {
            super();
            this.varKind = varKind;
            this.name = name;
            this.from = from;
            this.to = to;
        }
        render(opts) {
            const varKind = opts.es5 ? scope.varKinds.var : this.varKind;
            const { name, from, to } = this;
            return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
        }
        get names() {
            const names = addExprNames(super.names, this.from);
            return addExprNames(names, this.to);
        }
    }
    class ForIter extends For {
        constructor(loop, varKind, name, iterable) {
            super();
            this.loop = loop;
            this.varKind = varKind;
            this.name = name;
            this.iterable = iterable;
        }
        render(opts) {
            return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
        }
        optimizeNames(names, constants) {
            if (!super.optimizeNames(names, constants))
                return;
            this.iterable = optimizeExpr(this.iterable, names, constants);
            return this;
        }
        get names() {
            return addNames(super.names, this.iterable.names);
        }
    }
    class Func extends BlockNode {
        constructor(name, args, async) {
            super();
            this.name = name;
            this.args = args;
            this.async = async;
        }
        render(opts) {
            const _async = this.async ? "async " : "";
            return `${_async}function ${this.name}(${this.args})` + super.render(opts);
        }
    }
    Func.kind = "func";
    class Return extends ParentNode {
        render(opts) {
            return "return " + super.render(opts);
        }
    }
    Return.kind = "return";
    class Try extends BlockNode {
        render(opts) {
            let code = "try" + super.render(opts);
            if (this.catch)
                code += this.catch.render(opts);
            if (this.finally)
                code += this.finally.render(opts);
            return code;
        }
        optimizeNodes() {
            var _a, _b;
            super.optimizeNodes();
            (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
            (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
            return this;
        }
        optimizeNames(names, constants) {
            var _a, _b;
            super.optimizeNames(names, constants);
            (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
            (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
            return this;
        }
        get names() {
            const names = super.names;
            if (this.catch)
                addNames(names, this.catch.names);
            if (this.finally)
                addNames(names, this.finally.names);
            return names;
        }
    }
    class Catch extends BlockNode {
        constructor(error) {
            super();
            this.error = error;
        }
        render(opts) {
            return `catch(${this.error})` + super.render(opts);
        }
    }
    Catch.kind = "catch";
    class Finally extends BlockNode {
        render(opts) {
            return "finally" + super.render(opts);
        }
    }
    Finally.kind = "finally";
    class CodeGen {
        constructor(extScope, opts = {}) {
            this._values = {};
            this._blockStarts = [];
            this._constants = {};
            this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
            this._extScope = extScope;
            this._scope = new scope.Scope({ parent: extScope });
            this._nodes = [new Root()];
        }
        toString() {
            return this._root.render(this.opts);
        }
        // returns unique name in the internal scope
        name(prefix) {
            return this._scope.name(prefix);
        }
        // reserves unique name in the external scope
        scopeName(prefix) {
            return this._extScope.name(prefix);
        }
        // reserves unique name in the external scope and assigns value to it
        scopeValue(prefixOrName, value) {
            const name = this._extScope.value(prefixOrName, value);
            const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
            vs.add(name);
            return name;
        }
        getScopeValue(prefix, keyOrRef) {
            return this._extScope.getValue(prefix, keyOrRef);
        }
        // return code that assigns values in the external scope to the names that are used internally
        // (same names that were returned by gen.scopeName or gen.scopeValue)
        scopeRefs(scopeName) {
            return this._extScope.scopeRefs(scopeName, this._values);
        }
        scopeCode() {
            return this._extScope.scopeCode(this._values);
        }
        _def(varKind, nameOrPrefix, rhs, constant) {
            const name = this._scope.toName(nameOrPrefix);
            if (rhs !== undefined && constant)
                this._constants[name.str] = rhs;
            this._leafNode(new Def(varKind, name, rhs));
            return name;
        }
        // `const` declaration (`var` in es5 mode)
        const(nameOrPrefix, rhs, _constant) {
            return this._def(scope.varKinds.const, nameOrPrefix, rhs, _constant);
        }
        // `let` declaration with optional assignment (`var` in es5 mode)
        let(nameOrPrefix, rhs, _constant) {
            return this._def(scope.varKinds.let, nameOrPrefix, rhs, _constant);
        }
        // `var` declaration with optional assignment
        var(nameOrPrefix, rhs, _constant) {
            return this._def(scope.varKinds.var, nameOrPrefix, rhs, _constant);
        }
        // assignment code
        assign(lhs, rhs, sideEffects) {
            return this._leafNode(new Assign(lhs, rhs, sideEffects));
        }
        // `+=` code
        add(lhs, rhs) {
            return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
        }
        // appends passed SafeExpr to code or executes Block
        code(c) {
            if (typeof c == "function")
                c();
            else if (c !== code$1.nil)
                this._leafNode(new AnyCode(c));
            return this;
        }
        // returns code for object literal for the passed argument list of key-value pairs
        object(...keyValues) {
            const code = ["{"];
            for (const [key, value] of keyValues) {
                if (code.length > 1)
                    code.push(",");
                code.push(key);
                if (key !== value || this.opts.es5) {
                    code.push(":");
                    code$1.addCodeArg(code, value);
                }
            }
            code.push("}");
            return new code$1._Code(code);
        }
        // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
        if(condition, thenBody, elseBody) {
            this._blockNode(new If(condition));
            if (thenBody && elseBody) {
                this.code(thenBody).else().code(elseBody).endIf();
            }
            else if (thenBody) {
                this.code(thenBody).endIf();
            }
            else if (elseBody) {
                throw new Error('CodeGen: "else" body without "then" body');
            }
            return this;
        }
        // `else if` clause - invalid without `if` or after `else` clauses
        elseIf(condition) {
            return this._elseNode(new If(condition));
        }
        // `else` clause - only valid after `if` or `else if` clauses
        else() {
            return this._elseNode(new Else());
        }
        // end `if` statement (needed if gen.if was used only with condition)
        endIf() {
            return this._endBlockNode(If, Else);
        }
        _for(node, forBody) {
            this._blockNode(node);
            if (forBody)
                this.code(forBody).endFor();
            return this;
        }
        // a generic `for` clause (or statement if `forBody` is passed)
        for(iteration, forBody) {
            return this._for(new ForLoop(iteration), forBody);
        }
        // `for` statement for a range of values
        forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope.varKinds.var : scope.varKinds.let) {
            const name = this._scope.toName(nameOrPrefix);
            return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
        }
        // `for-of` statement (in es5 mode replace with a normal for loop)
        forOf(nameOrPrefix, iterable, forBody, varKind = scope.varKinds.const) {
            const name = this._scope.toName(nameOrPrefix);
            if (this.opts.es5) {
                const arr = iterable instanceof code$1.Name ? iterable : this.var("_arr", iterable);
                return this.forRange("_i", 0, code$1._ `${arr}.length`, (i) => {
                    this.var(name, code$1._ `${arr}[${i}]`);
                    forBody(name);
                });
            }
            return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
        }
        // `for-in` statement.
        // With option `ownProperties` replaced with a `for-of` loop for object keys
        forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope.varKinds.var : scope.varKinds.const) {
            if (this.opts.ownProperties) {
                return this.forOf(nameOrPrefix, code$1._ `Object.keys(${obj})`, forBody);
            }
            const name = this._scope.toName(nameOrPrefix);
            return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
        }
        // end `for` loop
        endFor() {
            return this._endBlockNode(For);
        }
        // `label` statement
        label(label) {
            return this._leafNode(new Label(label));
        }
        // `break` statement
        break(label) {
            return this._leafNode(new Break(label));
        }
        // `return` statement
        return(value) {
            const node = new Return();
            this._blockNode(node);
            this.code(value);
            if (node.nodes.length !== 1)
                throw new Error('CodeGen: "return" should have one node');
            return this._endBlockNode(Return);
        }
        // `try` statement
        try(tryBody, catchCode, finallyCode) {
            if (!catchCode && !finallyCode)
                throw new Error('CodeGen: "try" without "catch" and "finally"');
            const node = new Try();
            this._blockNode(node);
            this.code(tryBody);
            if (catchCode) {
                const error = this.name("e");
                this._currNode = node.catch = new Catch(error);
                catchCode(error);
            }
            if (finallyCode) {
                this._currNode = node.finally = new Finally();
                this.code(finallyCode);
            }
            return this._endBlockNode(Catch, Finally);
        }
        // `throw` statement
        throw(error) {
            return this._leafNode(new Throw(error));
        }
        // start self-balancing block
        block(body, nodeCount) {
            this._blockStarts.push(this._nodes.length);
            if (body)
                this.code(body).endBlock(nodeCount);
            return this;
        }
        // end the current self-balancing block
        endBlock(nodeCount) {
            const len = this._blockStarts.pop();
            if (len === undefined)
                throw new Error("CodeGen: not in self-balancing block");
            const toClose = this._nodes.length - len;
            if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
                throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
            }
            this._nodes.length = len;
            return this;
        }
        // `function` heading (or definition if funcBody is passed)
        func(name, args = code$1.nil, async, funcBody) {
            this._blockNode(new Func(name, args, async));
            if (funcBody)
                this.code(funcBody).endFunc();
            return this;
        }
        // end function definition
        endFunc() {
            return this._endBlockNode(Func);
        }
        optimize(n = 1) {
            while (n-- > 0) {
                this._root.optimizeNodes();
                this._root.optimizeNames(this._root.names, this._constants);
            }
        }
        _leafNode(node) {
            this._currNode.nodes.push(node);
            return this;
        }
        _blockNode(node) {
            this._currNode.nodes.push(node);
            this._nodes.push(node);
        }
        _endBlockNode(N1, N2) {
            const n = this._currNode;
            if (n instanceof N1 || (N2 && n instanceof N2)) {
                this._nodes.pop();
                return this;
            }
            throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
        }
        _elseNode(node) {
            const n = this._currNode;
            if (!(n instanceof If)) {
                throw new Error('CodeGen: "else" without "if"');
            }
            this._currNode = n.else = node;
            return this;
        }
        get _root() {
            return this._nodes[0];
        }
        get _currNode() {
            const ns = this._nodes;
            return ns[ns.length - 1];
        }
        set _currNode(node) {
            const ns = this._nodes;
            ns[ns.length - 1] = node;
        }
    }
    exports.CodeGen = CodeGen;
    function addNames(names, from) {
        for (const n in from)
            names[n] = (names[n] || 0) + (from[n] || 0);
        return names;
    }
    function addExprNames(names, from) {
        return from instanceof code$1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
        if (expr instanceof code$1.Name)
            return replaceName(expr);
        if (!canOptimize(expr))
            return expr;
        return new code$1._Code(expr._items.reduce((items, c) => {
            if (c instanceof code$1.Name)
                c = replaceName(c);
            if (c instanceof code$1._Code)
                items.push(...c._items);
            else
                items.push(c);
            return items;
        }, []));
        function replaceName(n) {
            const c = constants[n.str];
            if (c === undefined || names[n.str] !== 1)
                return n;
            delete names[n.str];
            return c;
        }
        function canOptimize(e) {
            return (e instanceof code$1._Code &&
                e._items.some((c) => c instanceof code$1.Name && names[c.str] === 1 && constants[c.str] !== undefined));
        }
    }
    function subtractNames(names, from) {
        for (const n in from)
            names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
        return typeof x == "boolean" || typeof x == "number" || x === null ? !x : code$1._ `!${par(x)}`;
    }
    exports.not = not;
    const andCode = mappend(exports.operators.AND);
    // boolean AND (&&) expression with the passed arguments
    function and(...args) {
        return args.reduce(andCode);
    }
    exports.and = and;
    const orCode = mappend(exports.operators.OR);
    // boolean OR (||) expression with the passed arguments
    function or(...args) {
        return args.reduce(orCode);
    }
    exports.or = or;
    function mappend(op) {
        return (x, y) => (x === code$1.nil ? y : y === code$1.nil ? x : code$1._ `${par(x)} ${op} ${par(y)}`);
    }
    function par(x) {
        return x instanceof code$1.Name ? x : code$1._ `(${x})`;
    }

    });

    var util = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;


    // TODO refactor to use Set
    function toHash(arr) {
        const hash = {};
        for (const item of arr)
            hash[item] = true;
        return hash;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
        if (typeof schema == "boolean")
            return schema;
        if (Object.keys(schema).length === 0)
            return true;
        checkUnknownRules(it, schema);
        return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
        const { opts, self } = it;
        if (!opts.strictSchema)
            return;
        if (typeof schema === "boolean")
            return;
        const rules = self.RULES.keywords;
        for (const key in schema) {
            if (!rules[key])
                checkStrictMode(it, `unknown keyword: "${key}"`);
        }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
        if (typeof schema == "boolean")
            return !schema;
        for (const key in schema)
            if (rules[key])
                return true;
        return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
        if (typeof schema == "boolean")
            return !schema;
        for (const key in schema)
            if (key !== "$ref" && RULES.all[key])
                return true;
        return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
        if (!$data) {
            if (typeof schema == "number" || typeof schema == "boolean")
                return schema;
            if (typeof schema == "string")
                return codegen._ `${schema}`;
        }
        return codegen._ `${topSchemaRef}${schemaPath}${codegen.getProperty(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
        return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
        return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
        if (typeof str == "number")
            return `${str}`;
        return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
        return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
        if (Array.isArray(xs)) {
            for (const x of xs)
                f(x);
        }
        else {
            f(xs);
        }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {
        return (gen, from, to, toName) => {
            const res = to === undefined
                ? from
                : to instanceof codegen.Name
                    ? (from instanceof codegen.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
                    : from instanceof codegen.Name
                        ? (mergeToName(gen, to, from), from)
                        : mergeValues(from, to);
            return toName === codegen.Name && !(res instanceof codegen.Name) ? resultToName(gen, res) : res;
        };
    }
    exports.mergeEvaluated = {
        props: makeMergeEvaluated({
            mergeNames: (gen, from, to) => gen.if(codegen._ `${to} !== true && ${from} !== undefined`, () => {
                gen.if(codegen._ `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, codegen._ `${to} || {}`).code(codegen._ `Object.assign(${to}, ${from})`));
            }),
            mergeToName: (gen, from, to) => gen.if(codegen._ `${to} !== true`, () => {
                if (from === true) {
                    gen.assign(to, true);
                }
                else {
                    gen.assign(to, codegen._ `${to} || {}`);
                    setEvaluated(gen, to, from);
                }
            }),
            mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
            resultToName: evaluatedPropsToName,
        }),
        items: makeMergeEvaluated({
            mergeNames: (gen, from, to) => gen.if(codegen._ `${to} !== true && ${from} !== undefined`, () => gen.assign(to, codegen._ `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
            mergeToName: (gen, from, to) => gen.if(codegen._ `${to} !== true`, () => gen.assign(to, from === true ? true : codegen._ `${to} > ${from} ? ${to} : ${from}`)),
            mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
            resultToName: (gen, items) => gen.var("items", items),
        }),
    };
    function evaluatedPropsToName(gen, ps) {
        if (ps === true)
            return gen.var("props", true);
        const props = gen.var("props", codegen._ `{}`);
        if (ps !== undefined)
            setEvaluated(gen, props, ps);
        return props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
        Object.keys(ps).forEach((p) => gen.assign(codegen._ `${props}${codegen.getProperty(p)}`, true));
    }
    exports.setEvaluated = setEvaluated;
    const snippets = {};
    function useFunc(gen, f) {
        return gen.scopeValue("func", {
            ref: f,
            code: snippets[f.code] || (snippets[f.code] = new code$1._Code(f.code)),
        });
    }
    exports.useFunc = useFunc;
    var Type;
    (function (Type) {
        Type[Type["Num"] = 0] = "Num";
        Type[Type["Str"] = 1] = "Str";
    })(Type = exports.Type || (exports.Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
        // let path
        if (dataProp instanceof codegen.Name) {
            const isNumber = dataPropType === Type.Num;
            return jsPropertySyntax
                ? isNumber
                    ? codegen._ `"[" + ${dataProp} + "]"`
                    : codegen._ `"['" + ${dataProp} + "']"`
                : isNumber
                    ? codegen._ `"/" + ${dataProp}`
                    : codegen._ `"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
        }
        return jsPropertySyntax ? codegen.getProperty(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
        if (!mode)
            return;
        msg = `strict mode: ${msg}`;
        if (mode === true)
            throw new Error(msg);
        it.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;

    });

    const names = {
        // validation function arguments
        data: new codegen.Name("data"),
        // args passed from referencing schema
        valCxt: new codegen.Name("valCxt"),
        instancePath: new codegen.Name("instancePath"),
        parentData: new codegen.Name("parentData"),
        parentDataProperty: new codegen.Name("parentDataProperty"),
        rootData: new codegen.Name("rootData"),
        dynamicAnchors: new codegen.Name("dynamicAnchors"),
        // function scoped variables
        vErrors: new codegen.Name("vErrors"),
        errors: new codegen.Name("errors"),
        this: new codegen.Name("this"),
        // "globals"
        self: new codegen.Name("self"),
        scope: new codegen.Name("scope"),
        // JTD serialize/parse name for JSON string and position
        json: new codegen.Name("json"),
        jsonPos: new codegen.Name("jsonPos"),
        jsonLen: new codegen.Name("jsonLen"),
        jsonPart: new codegen.Name("jsonPart"),
    };
    var _default$z = names;


    var names_1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$z
    }, '__esModule', {value: true});

    var errors = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;



    exports.keywordError = {
        message: ({ keyword }) => codegen.str `should pass "${keyword}" keyword validation`,
    };
    exports.keyword$DataError = {
        message: ({ keyword, schemaType }) => schemaType
            ? codegen.str `"${keyword}" keyword must be ${schemaType} ($data)`
            : codegen.str `"${keyword}" keyword is invalid ($data)`,
    };
    function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
        const { it } = cxt;
        const { gen, compositeRule, allErrors } = it;
        const errObj = errorObjectCode(cxt, error, errorPaths);
        if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
            addError(gen, errObj);
        }
        else {
            returnErrors(it, codegen._ `[${errObj}]`);
        }
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
        const { it } = cxt;
        const { gen, compositeRule, allErrors } = it;
        const errObj = errorObjectCode(cxt, error, errorPaths);
        addError(gen, errObj);
        if (!(compositeRule || allErrors)) {
            returnErrors(it, names_1.default.vErrors);
        }
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
        gen.assign(names_1.default.errors, errsCount);
        gen.if(codegen._ `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign(codegen._ `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {
        /* istanbul ignore if */
        if (errsCount === undefined)
            throw new Error("ajv implementation error");
        const err = gen.name("err");
        gen.forRange("i", errsCount, names_1.default.errors, (i) => {
            gen.const(err, codegen._ `${names_1.default.vErrors}[${i}]`);
            gen.if(codegen._ `${err}.instancePath === undefined`, () => gen.assign(codegen._ `${err}.instancePath`, codegen.strConcat(names_1.default.instancePath, it.errorPath)));
            gen.assign(codegen._ `${err}.schemaPath`, codegen.str `${it.errSchemaPath}/${keyword}`);
            if (it.opts.verbose) {
                gen.assign(codegen._ `${err}.schema`, schemaValue);
                gen.assign(codegen._ `${err}.data`, data);
            }
        });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
        const err = gen.const("err", errObj);
        gen.if(codegen._ `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, codegen._ `[${err}]`), codegen._ `${names_1.default.vErrors}.push(${err})`);
        gen.code(codegen._ `${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
        const { gen, validateName, schemaEnv } = it;
        if (schemaEnv.$async) {
            gen.throw(codegen._ `new ${it.ValidationError}(${errs})`);
        }
        else {
            gen.assign(codegen._ `${validateName}.errors`, errs);
            gen.return(false);
        }
    }
    const E = {
        keyword: new codegen.Name("keyword"),
        schemaPath: new codegen.Name("schemaPath"),
        params: new codegen.Name("params"),
        propertyName: new codegen.Name("propertyName"),
        message: new codegen.Name("message"),
        schema: new codegen.Name("schema"),
        parentSchema: new codegen.Name("parentSchema"),
    };
    function errorObjectCode(cxt, error, errorPaths) {
        const { createErrors } = cxt.it;
        if (createErrors === false)
            return codegen._ `{}`;
        return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
        const { gen, it } = cxt;
        const keyValues = [
            errorInstancePath(it, errorPaths),
            errorSchemaPath(cxt, errorPaths),
        ];
        extraErrorProps(cxt, error, keyValues);
        return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
        const instPath = instancePath
            ? codegen.str `${errorPath}${util.getErrorPath(instancePath, util.Type.Str)}`
            : errorPath;
        return [names_1.default.instancePath, codegen.strConcat(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
        let schPath = parentSchema ? errSchemaPath : codegen.str `${errSchemaPath}/${keyword}`;
        if (schemaPath) {
            schPath = codegen.str `${schPath}${util.getErrorPath(schemaPath, util.Type.Str)}`;
        }
        return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
        const { keyword, data, schemaValue, it } = cxt;
        const { opts, propertyName, topSchemaRef, schemaPath } = it;
        keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || codegen._ `{}`]);
        if (opts.messages) {
            keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
        }
        if (opts.verbose) {
            keyValues.push([E.schema, schemaValue], [E.parentSchema, codegen._ `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
        }
        if (propertyName)
            keyValues.push([E.propertyName, propertyName]);
    }

    });

    var boolSchema = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;



    const boolError = {
        message: "boolean schema is false",
    };
    function topBoolOrEmptySchema(it) {
        const { gen, schema, validateName } = it;
        if (schema === false) {
            falseSchemaError(it, false);
        }
        else if (typeof schema == "object" && schema.$async === true) {
            gen.return(names_1.default.data);
        }
        else {
            gen.assign(codegen._ `${validateName}.errors`, null);
            gen.return(true);
        }
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
        const { gen, schema } = it;
        if (schema === false) {
            gen.var(valid, false); // TODO var
            falseSchemaError(it);
        }
        else {
            gen.var(valid, true); // TODO var
        }
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
        const { gen, data } = it;
        // TODO maybe some other interface should be used for non-keyword validation errors...
        const cxt = {
            gen,
            keyword: "false schema",
            data,
            schema: false,
            schemaCode: false,
            schemaValue: false,
            params: {},
            it,
        };
        errors.reportError(cxt, boolError, undefined, overrideAllErrors);
    }

    });

    var rules = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRules = exports.isJSONType = void 0;
    const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    const jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
        return typeof x == "string" && jsonTypes.has(x);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
        const groups = {
            number: { type: "number", rules: [] },
            string: { type: "string", rules: [] },
            array: { type: "array", rules: [] },
            object: { type: "object", rules: [] },
        };
        return {
            types: { ...groups, integer: true, boolean: true, null: true },
            rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
            post: { rules: [] },
            all: {},
            keywords: {},
        };
    }
    exports.getRules = getRules;

    });

    var applicability = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
        const group = self.RULES.types[type];
        return group && group !== true && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
        return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
        var _a;
        return (schema[rule.keyword] !== undefined ||
            ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));
    }
    exports.shouldUseRule = shouldUseRule;

    });

    var dataType = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;





    var DataType;
    (function (DataType) {
        DataType[DataType["Correct"] = 0] = "Correct";
        DataType[DataType["Wrong"] = 1] = "Wrong";
    })(DataType = exports.DataType || (exports.DataType = {}));
    function getSchemaTypes(schema) {
        const types = getJSONTypes(schema.type);
        const hasNull = types.includes("null");
        if (hasNull) {
            if (schema.nullable === false)
                throw new Error("type: null contradicts nullable: false");
        }
        else {
            if (!types.length && schema.nullable !== undefined) {
                throw new Error('"nullable" cannot be used without "type"');
            }
            if (schema.nullable === true)
                types.push("null");
        }
        return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
        const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
        if (types.every(rules.isJSONType))
            return types;
        throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
        const { gen, data, opts } = it;
        const coerceTo = coerceToTypes(types, opts.coerceTypes);
        const checkTypes = types.length > 0 &&
            !(coerceTo.length === 0 && types.length === 1 && applicability.schemaHasRulesForType(it, types[0]));
        if (checkTypes) {
            const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
            gen.if(wrongType, () => {
                if (coerceTo.length)
                    coerceData(it, types, coerceTo);
                else
                    reportTypeError(it);
            });
        }
        return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
        return coerceTypes
            ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
            : [];
    }
    function coerceData(it, types, coerceTo) {
        const { gen, data, opts } = it;
        const dataType = gen.let("dataType", codegen._ `typeof ${data}`);
        const coerced = gen.let("coerced", codegen._ `undefined`);
        if (opts.coerceTypes === "array") {
            gen.if(codegen._ `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen
                .assign(data, codegen._ `${data}[0]`)
                .assign(dataType, codegen._ `typeof ${data}`)
                .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
        }
        gen.if(codegen._ `${coerced} !== undefined`);
        for (const t of coerceTo) {
            if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
                coerceSpecificType(t);
            }
        }
        gen.else();
        reportTypeError(it);
        gen.endIf();
        gen.if(codegen._ `${coerced} !== undefined`, () => {
            gen.assign(data, coerced);
            assignParentData(it, coerced);
        });
        function coerceSpecificType(t) {
            switch (t) {
                case "string":
                    gen
                        .elseIf(codegen._ `${dataType} == "number" || ${dataType} == "boolean"`)
                        .assign(coerced, codegen._ `"" + ${data}`)
                        .elseIf(codegen._ `${data} === null`)
                        .assign(coerced, codegen._ `""`);
                    return;
                case "number":
                    gen
                        .elseIf(codegen._ `${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`)
                        .assign(coerced, codegen._ `+${data}`);
                    return;
                case "integer":
                    gen
                        .elseIf(codegen._ `${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`)
                        .assign(coerced, codegen._ `+${data}`);
                    return;
                case "boolean":
                    gen
                        .elseIf(codegen._ `${data} === "false" || ${data} === 0 || ${data} === null`)
                        .assign(coerced, false)
                        .elseIf(codegen._ `${data} === "true" || ${data} === 1`)
                        .assign(coerced, true);
                    return;
                case "null":
                    gen.elseIf(codegen._ `${data} === "" || ${data} === 0 || ${data} === false`);
                    gen.assign(coerced, null);
                    return;
                case "array":
                    gen
                        .elseIf(codegen._ `${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`)
                        .assign(coerced, codegen._ `[${data}]`);
            }
        }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
        // TODO use gen.property
        gen.if(codegen._ `${parentData} !== undefined`, () => gen.assign(codegen._ `${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
        const EQ = correct === DataType.Correct ? codegen.operators.EQ : codegen.operators.NEQ;
        let cond;
        switch (dataType) {
            case "null":
                return codegen._ `${data} ${EQ} null`;
            case "array":
                cond = codegen._ `Array.isArray(${data})`;
                break;
            case "object":
                cond = codegen._ `${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
                break;
            case "integer":
                cond = numCond(codegen._ `!(${data} % 1) && !isNaN(${data})`);
                break;
            case "number":
                cond = numCond();
                break;
            default:
                return codegen._ `typeof ${data} ${EQ} ${dataType}`;
        }
        return correct === DataType.Correct ? cond : codegen.not(cond);
        function numCond(_cond = codegen.nil) {
            return codegen.and(codegen._ `typeof ${data} == "number"`, _cond, strictNums ? codegen._ `isFinite(${data})` : codegen.nil);
        }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
        if (dataTypes.length === 1) {
            return checkDataType(dataTypes[0], data, strictNums, correct);
        }
        let cond;
        const types = util.toHash(dataTypes);
        if (types.array && types.object) {
            const notObj = codegen._ `typeof ${data} != "object"`;
            cond = types.null ? notObj : codegen._ `!${data} || ${notObj}`;
            delete types.null;
            delete types.array;
            delete types.object;
        }
        else {
            cond = codegen.nil;
        }
        if (types.number)
            delete types.integer;
        for (const t in types)
            cond = codegen.and(cond, checkDataType(t, data, strictNums, correct));
        return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    const typeError = {
        message: ({ schema }) => `must be ${schema}`,
        params: ({ schema, schemaValue }) => typeof schema == "string" ? codegen._ `{type: ${schema}}` : codegen._ `{type: ${schemaValue}}`,
    };
    function reportTypeError(it) {
        const cxt = getTypeErrorContext(it);
        errors.reportError(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
        const { gen, data, schema } = it;
        const schemaCode = util.schemaRefOrVal(it, schema, "type");
        return {
            gen,
            keyword: "type",
            data,
            schema: schema.type,
            schemaCode,
            schemaValue: schemaCode,
            parentSchema: schema,
            params: {},
            it,
        };
    }

    });

    var defaults = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignDefaults = void 0;


    function assignDefaults(it, ty) {
        const { properties, items } = it.schema;
        if (ty === "object" && properties) {
            for (const key in properties) {
                assignDefault(it, key, properties[key].default);
            }
        }
        else if (ty === "array" && Array.isArray(items)) {
            items.forEach((sch, i) => assignDefault(it, i, sch.default));
        }
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
        const { gen, compositeRule, data, opts } = it;
        if (defaultValue === undefined)
            return;
        const childData = codegen._ `${data}${codegen.getProperty(prop)}`;
        if (compositeRule) {
            util.checkStrictMode(it, `default is ignored for: ${childData}`);
            return;
        }
        let condition = codegen._ `${childData} === undefined`;
        if (opts.useDefaults === "empty") {
            condition = codegen._ `${condition} || ${childData} === null || ${childData} === ""`;
        }
        // `${childData} === undefined` +
        // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
        gen.if(condition, codegen._ `${childData} = ${codegen.stringify(defaultValue)}`);
    }

    });

    var code = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;



    function checkReportMissingProp(cxt, prop) {
        const { gen, data, it } = cxt;
        gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
            cxt.setParams({ missingProperty: codegen._ `${prop}` }, true);
            cxt.error();
        });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
        return codegen.or(...properties.map((prop) => codegen.and(noPropertyInData(gen, data, prop, opts.ownProperties), codegen._ `${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
        cxt.setParams({ missingProperty: missing }, true);
        cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
        return gen.scopeValue("func", {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            ref: Object.prototype.hasOwnProperty,
            code: codegen._ `Object.prototype.hasOwnProperty`,
        });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
        return codegen._ `${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
        const cond = codegen._ `${data}${codegen.getProperty(property)} !== undefined`;
        return ownProperties ? codegen._ `${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
        const cond = codegen._ `${data}${codegen.getProperty(property)} === undefined`;
        return ownProperties ? codegen.or(cond, codegen.not(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
        return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
        return allSchemaProperties(schemaMap).filter((p) => !util.alwaysValidSchema(it, schemaMap[p]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
        const dataAndSchema = passSchema ? codegen._ `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
        const valCxt = [
            [names_1.default.instancePath, codegen.strConcat(names_1.default.instancePath, errorPath)],
            [names_1.default.parentData, it.parentData],
            [names_1.default.parentDataProperty, it.parentDataProperty],
            [names_1.default.rootData, names_1.default.rootData],
        ];
        if (it.opts.dynamicRef)
            valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
        const args = codegen._ `${dataAndSchema}, ${gen.object(...valCxt)}`;
        return context !== codegen.nil ? codegen._ `${func}.call(${context}, ${args})` : codegen._ `${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    function usePattern({ gen, it: { opts } }, pattern) {
        const u = opts.unicodeRegExp ? "u" : "";
        return gen.scopeValue("pattern", {
            key: pattern,
            ref: new RegExp(pattern, u),
            code: codegen._ `new RegExp(${pattern}, ${u})`,
        });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
        const { gen, data, keyword, it } = cxt;
        const valid = gen.name("valid");
        if (it.allErrors) {
            const validArr = gen.let("valid", true);
            validateItems(() => gen.assign(validArr, false));
            return validArr;
        }
        gen.var(valid, true);
        validateItems(() => gen.break());
        return valid;
        function validateItems(notValid) {
            const len = gen.const("len", codegen._ `${data}.length`);
            gen.forRange("i", 0, len, (i) => {
                cxt.subschema({
                    keyword,
                    dataProp: i,
                    dataPropType: util.Type.Num,
                }, valid);
                gen.if(codegen.not(valid), notValid);
            });
        }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
        const { gen, schema, keyword, it } = cxt;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        const alwaysValid = schema.some((sch) => util.alwaysValidSchema(it, sch));
        if (alwaysValid && !it.opts.unevaluated)
            return;
        const valid = gen.let("valid", false);
        const schValid = gen.name("_valid");
        gen.block(() => schema.forEach((_sch, i) => {
            const schCxt = cxt.subschema({
                keyword,
                schemaProp: i,
                compositeRule: true,
            }, schValid);
            gen.assign(valid, codegen._ `${valid} || ${schValid}`);
            const merged = cxt.mergeValidEvaluated(schCxt, schValid);
            // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
            // or if all properties and items were evaluated (it.props === true && it.items === true)
            if (!merged)
                gen.if(codegen.not(valid));
        }));
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports.validateUnion = validateUnion;

    });

    var keyword = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;




    function macroKeywordCode(cxt, def) {
        const { gen, keyword, schema, parentSchema, it } = cxt;
        const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
        const schemaRef = useKeyword(gen, keyword, macroSchema);
        if (it.opts.validateSchema !== false)
            it.self.validateSchema(macroSchema, true);
        const valid = gen.name("valid");
        cxt.subschema({
            schema: macroSchema,
            schemaPath: codegen.nil,
            errSchemaPath: `${it.errSchemaPath}/${keyword}`,
            topSchemaRef: schemaRef,
            compositeRule: true,
        }, valid);
        cxt.pass(valid, () => cxt.error(true));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
        var _a;
        const { gen, keyword, schema, parentSchema, $data, it } = cxt;
        checkAsyncKeyword(it, def);
        const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
        const validateRef = useKeyword(gen, keyword, validate);
        const valid = gen.let("valid");
        cxt.block$data(valid, validateKeyword);
        cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
        function validateKeyword() {
            if (def.errors === false) {
                assignValid();
                if (def.modifying)
                    modifyData(cxt);
                reportErrs(() => cxt.error());
            }
            else {
                const ruleErrs = def.async ? validateAsync() : validateSync();
                if (def.modifying)
                    modifyData(cxt);
                reportErrs(() => addErrs(cxt, ruleErrs));
            }
        }
        function validateAsync() {
            const ruleErrs = gen.let("ruleErrs", null);
            gen.try(() => assignValid(codegen._ `await `), (e) => gen.assign(valid, false).if(codegen._ `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, codegen._ `${e}.errors`), () => gen.throw(e)));
            return ruleErrs;
        }
        function validateSync() {
            const validateErrs = codegen._ `${validateRef}.errors`;
            gen.assign(validateErrs, null);
            assignValid(codegen.nil);
            return validateErrs;
        }
        function assignValid(_await = def.async ? codegen._ `await ` : codegen.nil) {
            const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
            const passSchema = !(("compile" in def && !$data) || def.schema === false);
            gen.assign(valid, codegen._ `${_await}${code.callValidateCode(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
        }
        function reportErrs(errors) {
            var _a;
            gen.if(codegen.not((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
        }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
        const { gen, data, it } = cxt;
        gen.if(it.parentData, () => gen.assign(data, codegen._ `${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
        const { gen } = cxt;
        gen.if(codegen._ `Array.isArray(${errs})`, () => {
            gen
                .assign(names_1.default.vErrors, codegen._ `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)
                .assign(names_1.default.errors, codegen._ `${names_1.default.vErrors}.length`);
            errors.extendErrors(cxt);
        }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
        if (def.async && !schemaEnv.$async)
            throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
        if (result === undefined)
            throw new Error(`keyword "${keyword}" failed to compile`);
        return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: codegen.stringify(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
        // TODO add tests
        return (!schemaType.length ||
            schemaType.some((st) => st === "array"
                ? Array.isArray(schema)
                : st === "object"
                    ? schema && typeof schema == "object" && !Array.isArray(schema)
                    : typeof schema == st || (allowUndefined && typeof schema == "undefined")));
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
        /* istanbul ignore if */
        if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
            throw new Error("ajv implementation error");
        }
        const deps = def.dependencies;
        if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
            throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
        }
        if (def.validateSchema) {
            const valid = def.validateSchema(schema[keyword]);
            if (!valid) {
                const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
                    self.errorsText(def.validateSchema.errors);
                if (opts.validateSchema === "log")
                    self.logger.error(msg);
                else
                    throw new Error(msg);
            }
        }
    }
    exports.validateKeywordUsage = validateKeywordUsage;

    });

    var subschema = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;


    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
        if (keyword !== undefined && schema !== undefined) {
            throw new Error('both "keyword" and "schema" passed, only one allowed');
        }
        if (keyword !== undefined) {
            const sch = it.schema[keyword];
            return schemaProp === undefined
                ? {
                    schema: sch,
                    schemaPath: codegen._ `${it.schemaPath}${codegen.getProperty(keyword)}`,
                    errSchemaPath: `${it.errSchemaPath}/${keyword}`,
                }
                : {
                    schema: sch[schemaProp],
                    schemaPath: codegen._ `${it.schemaPath}${codegen.getProperty(keyword)}${codegen.getProperty(schemaProp)}`,
                    errSchemaPath: `${it.errSchemaPath}/${keyword}/${util.escapeFragment(schemaProp)}`,
                };
        }
        if (schema !== undefined) {
            if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
                throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
            }
            return {
                schema,
                schemaPath,
                topSchemaRef,
                errSchemaPath,
            };
        }
        throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
        if (data !== undefined && dataProp !== undefined) {
            throw new Error('both "data" and "dataProp" passed, only one allowed');
        }
        const { gen } = it;
        if (dataProp !== undefined) {
            const { errorPath, dataPathArr, opts } = it;
            const nextData = gen.let("data", codegen._ `${it.data}${codegen.getProperty(dataProp)}`, true);
            dataContextProps(nextData);
            subschema.errorPath = codegen.str `${errorPath}${util.getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`;
            subschema.parentDataProperty = codegen._ `${dataProp}`;
            subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
        }
        if (data !== undefined) {
            const nextData = data instanceof codegen.Name ? data : gen.let("data", data, true); // replaceable if used once?
            dataContextProps(nextData);
            if (propertyName !== undefined)
                subschema.propertyName = propertyName;
            // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
        }
        if (dataTypes)
            subschema.dataTypes = dataTypes;
        function dataContextProps(_nextData) {
            subschema.data = _nextData;
            subschema.dataLevel = it.dataLevel + 1;
            subschema.dataTypes = [];
            it.definedProperties = new Set();
            subschema.parentData = it.data;
            subschema.dataNames = [...it.dataNames, _nextData];
        }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
        if (compositeRule !== undefined)
            subschema.compositeRule = compositeRule;
        if (createErrors !== undefined)
            subschema.createErrors = createErrors;
        if (allErrors !== undefined)
            subschema.allErrors = allErrors;
        subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
        subschema.jtdMetadata = jtdMetadata; // not inherited
    }
    exports.extendSubschemaMode = extendSubschemaMode;

    });

    // do not edit .js files directly - edit src/index.jst



    var fastDeepEqual = function equal(a, b) {
      if (a === b) return true;

      if (a && b && typeof a == 'object' && typeof b == 'object') {
        if (a.constructor !== b.constructor) return false;

        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0;)
            if (!equal(a[i], b[i])) return false;
          return true;
        }



        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;

        for (i = length; i-- !== 0;)
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

        for (i = length; i-- !== 0;) {
          var key = keys[i];

          if (!equal(a[key], b[key])) return false;
        }

        return true;
      }

      // true if both NaN, false otherwise
      return a!==a && b!==b;
    };

    var jsonSchemaTraverse = createCommonjsModule(function (module) {

    var traverse = module.exports = function (schema, opts, cb) {
      // Legacy support for v0.3.1 and earlier.
      if (typeof opts == 'function') {
        cb = opts;
        opts = {};
      }

      cb = opts.cb || cb;
      var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
      var post = cb.post || function() {};

      _traverse(opts, pre, post, schema, '', schema);
    };


    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };

    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };

    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };

    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };


    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i=0; i<sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == 'object') {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
            _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }


    function escapeJsonPtr(str) {
      return str.replace(/~/g, '~0').replace(/\//g, '~1');
    }
    });

    /** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */

    var uri_all = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
    	factory(exports) ;
    }(commonjsGlobal, (function (exports) {
    function merge() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
            sets[_key] = arguments[_key];
        }

        if (sets.length > 1) {
            sets[0] = sets[0].slice(0, -1);
            var xl = sets.length - 1;
            for (var x = 1; x < xl; ++x) {
                sets[x] = sets[x].slice(1, -1);
            }
            sets[xl] = sets[xl].slice(1);
            return sets.join('');
        } else {
            return sets[0];
        }
    }
    function subexp(str) {
        return "(?:" + str + ")";
    }
    function typeOf(o) {
        return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str) {
        return str.toUpperCase();
    }
    function toArray(obj) {
        return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
    }
    function assign(target, source) {
        var obj = target;
        if (source) {
            for (var key in source) {
                obj[key] = source[key];
            }
        }
        return obj;
    }

    function buildExps(isIRI) {
        var ALPHA$$ = "[A-Za-z]",
            DIGIT$$ = "[0-9]",
            HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
            PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
            //expanded
        GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
            SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
            RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
            UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
            //subset, excludes bidi control characters
        IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
            //subset
        UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
            subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
            subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*");
            var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
            //relaxed parsing rules
        IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
            H16$ = subexp(HEXDIG$$ + "{1,4}"),
            LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
            IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
            //                           6( h16 ":" ) ls32
        IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
            //                      "::" 5( h16 ":" ) ls32
        IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
            //[               h16 ] "::" 4( h16 ":" ) ls32
        IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
            //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
        IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
            //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
        IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
            //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
        IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
            //[ *4( h16 ":" ) h16 ] "::"              ls32
        IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
            //[ *5( h16 ":" ) h16 ] "::"              h16
        IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
            //[ *6( h16 ":" ) h16 ] "::"
        IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
            ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+");
            //RFC 6874, with relaxed parsing rules
        subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+");
            //RFC 6874
        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*");
            var PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]"));
            subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+");
            subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
        return {
            NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
            NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
            NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
            ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            UNRESERVED: new RegExp(UNRESERVED$$, "g"),
            OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
            PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
            IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
            IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
        };
    }
    var URI_PROTOCOL = buildExps(false);

    var IRI_PROTOCOL = buildExps(true);

    var slicedToArray = function () {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = undefined;

        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);

            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"]) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }

        return _arr;
      }

      return function (arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();













    var toConsumableArray = function (arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

        return arr2;
      } else {
        return Array.from(arr);
      }
    };

    /** Highest positive signed 32-bit float value */

    var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

    /** Bootstring parameters */
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128; // 0x80
    var delimiter = '-'; // '\x2D'

    /** Regular expressions */
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

    /** Error messages */
    var errors = {
    	'overflow': 'Overflow: input needs wider integers to process',
    	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    	'invalid-input': 'Invalid input'
    };

    /** Convenience shortcuts */
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;

    /*--------------------------------------------------------------------------*/

    /**
     * A generic error utility function.
     * @private
     * @param {String} type The error type.
     * @returns {Error} Throws a `RangeError` with the applicable error message.
     */
    function error$1(type) {
    	throw new RangeError(errors[type]);
    }

    /**
     * A generic `Array#map` utility function.
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} callback The function that gets called for every array
     * item.
     * @returns {Array} A new array of values returned by the callback function.
     */
    function map(array, fn) {
    	var result = [];
    	var length = array.length;
    	while (length--) {
    		result[length] = fn(array[length]);
    	}
    	return result;
    }

    /**
     * A simple `Array#map`-like wrapper to work with domain name strings or email
     * addresses.
     * @private
     * @param {String} domain The domain name or email address.
     * @param {Function} callback The function that gets called for every
     * character.
     * @returns {Array} A new string of characters returned by the callback
     * function.
     */
    function mapDomain(string, fn) {
    	var parts = string.split('@');
    	var result = '';
    	if (parts.length > 1) {
    		// In email addresses, only the domain name should be punycoded. Leave
    		// the local part (i.e. everything up to `@`) intact.
    		result = parts[0] + '@';
    		string = parts[1];
    	}
    	// Avoid `split(regex)` for IE8 compatibility. See #17.
    	string = string.replace(regexSeparators, '\x2E');
    	var labels = string.split('.');
    	var encoded = map(labels, fn).join('.');
    	return result + encoded;
    }

    /**
     * Creates an array containing the numeric code points of each Unicode
     * character in the string. While JavaScript uses UCS-2 internally,
     * this function will convert a pair of surrogate halves (each of which
     * UCS-2 exposes as separate characters) into a single code point,
     * matching UTF-16.
     * @see `punycode.ucs2.encode`
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode.ucs2
     * @name decode
     * @param {String} string The Unicode input string (UCS-2).
     * @returns {Array} The new array of code points.
     */
    function ucs2decode(string) {
    	var output = [];
    	var counter = 0;
    	var length = string.length;
    	while (counter < length) {
    		var value = string.charCodeAt(counter++);
    		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
    			// It's a high surrogate, and there is a next character.
    			var extra = string.charCodeAt(counter++);
    			if ((extra & 0xFC00) == 0xDC00) {
    				// Low surrogate.
    				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
    			} else {
    				// It's an unmatched surrogate; only append this code unit, in case the
    				// next code unit is the high surrogate of a surrogate pair.
    				output.push(value);
    				counter--;
    			}
    		} else {
    			output.push(value);
    		}
    	}
    	return output;
    }

    /**
     * Creates a string based on an array of numeric code points.
     * @see `punycode.ucs2.decode`
     * @memberOf punycode.ucs2
     * @name encode
     * @param {Array} codePoints The array of numeric code points.
     * @returns {String} The new Unicode string (UCS-2).
     */
    var ucs2encode = function ucs2encode(array) {
    	return String.fromCodePoint.apply(String, toConsumableArray(array));
    };

    /**
     * Converts a basic code point into a digit/integer.
     * @see `digitToBasic()`
     * @private
     * @param {Number} codePoint The basic numeric code point value.
     * @returns {Number} The numeric value of a basic code point (for use in
     * representing integers) in the range `0` to `base - 1`, or `base` if
     * the code point does not represent a value.
     */
    var basicToDigit = function basicToDigit(codePoint) {
    	if (codePoint - 0x30 < 0x0A) {
    		return codePoint - 0x16;
    	}
    	if (codePoint - 0x41 < 0x1A) {
    		return codePoint - 0x41;
    	}
    	if (codePoint - 0x61 < 0x1A) {
    		return codePoint - 0x61;
    	}
    	return base;
    };

    /**
     * Converts a digit/integer into a basic code point.
     * @see `basicToDigit()`
     * @private
     * @param {Number} digit The numeric value of a basic code point.
     * @returns {Number} The basic code point whose value (when used for
     * representing integers) is `digit`, which needs to be in the range
     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
     * used; else, the lowercase form is used. The behavior is undefined
     * if `flag` is non-zero and `digit` has no uppercase form.
     */
    var digitToBasic = function digitToBasic(digit, flag) {
    	//  0..25 map to ASCII a..z or A..Z
    	// 26..35 map to ASCII 0..9
    	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };

    /**
     * Bias adaptation function as per section 3.4 of RFC 3492.
     * https://tools.ietf.org/html/rfc3492#section-3.4
     * @private
     */
    var adapt = function adapt(delta, numPoints, firstTime) {
    	var k = 0;
    	delta = firstTime ? floor(delta / damp) : delta >> 1;
    	delta += floor(delta / numPoints);
    	for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
    		delta = floor(delta / baseMinusTMin);
    	}
    	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };

    /**
     * Converts a Punycode string of ASCII-only symbols to a string of Unicode
     * symbols.
     * @memberOf punycode
     * @param {String} input The Punycode string of ASCII-only symbols.
     * @returns {String} The resulting string of Unicode symbols.
     */
    var decode = function decode(input) {
    	// Don't use UCS-2.
    	var output = [];
    	var inputLength = input.length;
    	var i = 0;
    	var n = initialN;
    	var bias = initialBias;

    	// Handle the basic code points: let `basic` be the number of input code
    	// points before the last delimiter, or `0` if there is none, then copy
    	// the first basic code points to the output.

    	var basic = input.lastIndexOf(delimiter);
    	if (basic < 0) {
    		basic = 0;
    	}

    	for (var j = 0; j < basic; ++j) {
    		// if it's not a basic code point
    		if (input.charCodeAt(j) >= 0x80) {
    			error$1('not-basic');
    		}
    		output.push(input.charCodeAt(j));
    	}

    	// Main decoding loop: start just after the last delimiter if any basic code
    	// points were copied; start at the beginning otherwise.

    	for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

    		// `index` is the index of the next character to be consumed.
    		// Decode a generalized variable-length integer into `delta`,
    		// which gets added to `i`. The overflow checking is easier
    		// if we increase `i` as we go, then subtract off its starting
    		// value at the end to obtain `delta`.
    		var oldi = i;
    		for (var w = 1, k = base;; /* no condition */k += base) {

    			if (index >= inputLength) {
    				error$1('invalid-input');
    			}

    			var digit = basicToDigit(input.charCodeAt(index++));

    			if (digit >= base || digit > floor((maxInt - i) / w)) {
    				error$1('overflow');
    			}

    			i += digit * w;
    			var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

    			if (digit < t) {
    				break;
    			}

    			var baseMinusT = base - t;
    			if (w > floor(maxInt / baseMinusT)) {
    				error$1('overflow');
    			}

    			w *= baseMinusT;
    		}

    		var out = output.length + 1;
    		bias = adapt(i - oldi, out, oldi == 0);

    		// `i` was supposed to wrap around from `out` to `0`,
    		// incrementing `n` each time, so we'll fix that now:
    		if (floor(i / out) > maxInt - n) {
    			error$1('overflow');
    		}

    		n += floor(i / out);
    		i %= out;

    		// Insert `n` at position `i` of the output.
    		output.splice(i++, 0, n);
    	}

    	return String.fromCodePoint.apply(String, output);
    };

    /**
     * Converts a string of Unicode symbols (e.g. a domain name label) to a
     * Punycode string of ASCII-only symbols.
     * @memberOf punycode
     * @param {String} input The string of Unicode symbols.
     * @returns {String} The resulting Punycode string of ASCII-only symbols.
     */
    var encode = function encode(input) {
    	var output = [];

    	// Convert the input in UCS-2 to an array of Unicode code points.
    	input = ucs2decode(input);

    	// Cache the length.
    	var inputLength = input.length;

    	// Initialize the state.
    	var n = initialN;
    	var delta = 0;
    	var bias = initialBias;

    	// Handle the basic code points.
    	var _iteratorNormalCompletion = true;
    	var _didIteratorError = false;
    	var _iteratorError = undefined;

    	try {
    		for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    			var _currentValue2 = _step.value;

    			if (_currentValue2 < 0x80) {
    				output.push(stringFromCharCode(_currentValue2));
    			}
    		}
    	} catch (err) {
    		_didIteratorError = true;
    		_iteratorError = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion && _iterator.return) {
    				_iterator.return();
    			}
    		} finally {
    			if (_didIteratorError) {
    				throw _iteratorError;
    			}
    		}
    	}

    	var basicLength = output.length;
    	var handledCPCount = basicLength;

    	// `handledCPCount` is the number of code points that have been handled;
    	// `basicLength` is the number of basic code points.

    	// Finish the basic string with a delimiter unless it's empty.
    	if (basicLength) {
    		output.push(delimiter);
    	}

    	// Main encoding loop:
    	while (handledCPCount < inputLength) {

    		// All non-basic code points < n have been handled already. Find the next
    		// larger one:
    		var m = maxInt;
    		var _iteratorNormalCompletion2 = true;
    		var _didIteratorError2 = false;
    		var _iteratorError2 = undefined;

    		try {
    			for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    				var currentValue = _step2.value;

    				if (currentValue >= n && currentValue < m) {
    					m = currentValue;
    				}
    			}

    			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
    			// but guard against overflow.
    		} catch (err) {
    			_didIteratorError2 = true;
    			_iteratorError2 = err;
    		} finally {
    			try {
    				if (!_iteratorNormalCompletion2 && _iterator2.return) {
    					_iterator2.return();
    				}
    			} finally {
    				if (_didIteratorError2) {
    					throw _iteratorError2;
    				}
    			}
    		}

    		var handledCPCountPlusOne = handledCPCount + 1;
    		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
    			error$1('overflow');
    		}

    		delta += (m - n) * handledCPCountPlusOne;
    		n = m;

    		var _iteratorNormalCompletion3 = true;
    		var _didIteratorError3 = false;
    		var _iteratorError3 = undefined;

    		try {
    			for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    				var _currentValue = _step3.value;

    				if (_currentValue < n && ++delta > maxInt) {
    					error$1('overflow');
    				}
    				if (_currentValue == n) {
    					// Represent delta as a generalized variable-length integer.
    					var q = delta;
    					for (var k = base;; /* no condition */k += base) {
    						var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
    						if (q < t) {
    							break;
    						}
    						var qMinusT = q - t;
    						var baseMinusT = base - t;
    						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
    						q = floor(qMinusT / baseMinusT);
    					}

    					output.push(stringFromCharCode(digitToBasic(q, 0)));
    					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
    					delta = 0;
    					++handledCPCount;
    				}
    			}
    		} catch (err) {
    			_didIteratorError3 = true;
    			_iteratorError3 = err;
    		} finally {
    			try {
    				if (!_iteratorNormalCompletion3 && _iterator3.return) {
    					_iterator3.return();
    				}
    			} finally {
    				if (_didIteratorError3) {
    					throw _iteratorError3;
    				}
    			}
    		}

    		++delta;
    		++n;
    	}
    	return output.join('');
    };

    /**
     * Converts a Punycode string representing a domain name or an email address
     * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
     * it doesn't matter if you call it on a string that has already been
     * converted to Unicode.
     * @memberOf punycode
     * @param {String} input The Punycoded domain name or email address to
     * convert to Unicode.
     * @returns {String} The Unicode representation of the given Punycode
     * string.
     */
    var toUnicode = function toUnicode(input) {
    	return mapDomain(input, function (string) {
    		return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    	});
    };

    /**
     * Converts a Unicode string representing a domain name or an email address to
     * Punycode. Only the non-ASCII parts of the domain name will be converted,
     * i.e. it doesn't matter if you call it with a domain that's already in
     * ASCII.
     * @memberOf punycode
     * @param {String} input The domain name or email address to convert, as a
     * Unicode string.
     * @returns {String} The Punycode representation of the given domain name or
     * email address.
     */
    var toASCII = function toASCII(input) {
    	return mapDomain(input, function (string) {
    		return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    	});
    };

    /*--------------------------------------------------------------------------*/

    /** Define the public API */
    var punycode = {
    	/**
      * A string representing the current Punycode.js version number.
      * @memberOf punycode
      * @type String
      */
    	'version': '2.1.0',
    	/**
      * An object of methods to convert from JavaScript's internal character
      * representation (UCS-2) to Unicode code points, and back.
      * @see <https://mathiasbynens.be/notes/javascript-encoding>
      * @memberOf punycode
      * @type Object
      */
    	'ucs2': {
    		'decode': ucs2decode,
    		'encode': ucs2encode
    	},
    	'decode': decode,
    	'encode': encode,
    	'toASCII': toASCII,
    	'toUnicode': toUnicode
    };

    /**
     * URI.js
     *
     * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
     * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
     * @see http://github.com/garycourt/uri-js
     */
    /**
     * Copyright 2011 Gary Court. All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without modification, are
     * permitted provided that the following conditions are met:
     *
     *    1. Redistributions of source code must retain the above copyright notice, this list of
     *       conditions and the following disclaimer.
     *
     *    2. Redistributions in binary form must reproduce the above copyright notice, this list
     *       of conditions and the following disclaimer in the documentation and/or other materials
     *       provided with the distribution.
     *
     * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
     * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     *
     * The views and conclusions contained in the software and documentation are those of the
     * authors and should not be interpreted as representing official policies, either expressed
     * or implied, of Gary Court.
     */
    var SCHEMES = {};
    function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
    }
    function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while (i < il) {
            var c = parseInt(str.substr(i + 1, 2), 16);
            if (c < 128) {
                newStr += String.fromCharCode(c);
                i += 3;
            } else if (c >= 194 && c < 224) {
                if (il - i >= 6) {
                    var c2 = parseInt(str.substr(i + 4, 2), 16);
                    newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
                } else {
                    newStr += str.substr(i, 6);
                }
                i += 6;
            } else if (c >= 224) {
                if (il - i >= 9) {
                    var _c = parseInt(str.substr(i + 4, 2), 16);
                    var c3 = parseInt(str.substr(i + 7, 2), 16);
                    newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
                } else {
                    newStr += str.substr(i, 9);
                }
                i += 9;
            } else {
                newStr += str.substr(i, 3);
                i += 3;
            }
        }
        return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved(str) {
            var decStr = pctDecChars(str);
            return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
    }

    function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];

        var _matches = slicedToArray(matches, 2),
            address = _matches[1];

        if (address) {
            return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
            return host;
        }
    }
    function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];

        var _matches2 = slicedToArray(matches, 3),
            address = _matches2[1],
            zone = _matches2[2];

        if (address) {
            var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
                _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
                last = _address$toLowerCase$2[0],
                first = _address$toLowerCase$2[1];

            var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
            var lastFields = last.split(":").map(_stripLeadingZeros);
            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
            var fieldCount = isLastFieldIPv4Address ? 7 : 8;
            var lastFieldsStart = lastFields.length - fieldCount;
            var fields = Array(fieldCount);
            for (var x = 0; x < fieldCount; ++x) {
                fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
            }
            if (isLastFieldIPv4Address) {
                fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
            }
            var allZeroFields = fields.reduce(function (acc, field, index) {
                if (!field || field === "0") {
                    var lastLongest = acc[acc.length - 1];
                    if (lastLongest && lastLongest.index + lastLongest.length === index) {
                        lastLongest.length++;
                    } else {
                        acc.push({ index: index, length: 1 });
                    }
                }
                return acc;
            }, []);
            var longestZeroFields = allZeroFields.sort(function (a, b) {
                return b.length - a.length;
            })[0];
            var newHost = void 0;
            if (longestZeroFields && longestZeroFields.length > 1) {
                var newFirst = fields.slice(0, longestZeroFields.index);
                var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
                newHost = newFirst.join(":") + "::" + newLast.join(":");
            } else {
                newHost = fields.join(":");
            }
            if (zone) {
                newHost += "%" + zone;
            }
            return newHost;
        } else {
            return host;
        }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
    function parse(uriString) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
            if (NO_MATCH_IS_UNDEFINED) {
                //store each component
                components.scheme = matches[1];
                components.userinfo = matches[3];
                components.host = matches[4];
                components.port = parseInt(matches[5], 10);
                components.path = matches[6] || "";
                components.query = matches[7];
                components.fragment = matches[8];
                //fix port number
                if (isNaN(components.port)) {
                    components.port = matches[5];
                }
            } else {
                //IE FIX for improper RegExp matching
                //store each component
                components.scheme = matches[1] || undefined;
                components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
                components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
                components.port = parseInt(matches[5], 10);
                components.path = matches[6] || "";
                components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
                components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
                //fix port number
                if (isNaN(components.port)) {
                    components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
                }
            }
            if (components.host) {
                //normalize IP hosts
                components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
            }
            //determine reference type
            if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
                components.reference = "same-document";
            } else if (components.scheme === undefined) {
                components.reference = "relative";
            } else if (components.fragment === undefined) {
                components.reference = "absolute";
            } else {
                components.reference = "uri";
            }
            //check for reference errors
            if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
                components.error = components.error || "URI is not a " + options.reference + " reference.";
            }
            //find scheme handler
            var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
            //check if scheme can't handle IRIs
            if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
                //if host component is a domain name
                if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                    //convert Unicode IDN -> ASCII IDN
                    try {
                        components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                    } catch (e) {
                        components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                    }
                }
                //convert IRI -> URI
                _normalizeComponentEncoding(components, URI_PROTOCOL);
            } else {
                //normalize encodings
                _normalizeComponentEncoding(components, protocol);
            }
            //perform scheme specific parsing
            if (schemeHandler && schemeHandler.parse) {
                schemeHandler.parse(components, options);
            }
        } else {
            components.error = components.error || "URI can not be parsed.";
        }
        return components;
    }

    function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== undefined) {
            uriTokens.push(components.userinfo);
            uriTokens.push("@");
        }
        if (components.host !== undefined) {
            //normalize IP hosts, add brackets and escape zone separator for IPv6
            uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
                return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
            }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
            uriTokens.push(":");
            uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : undefined;
    }

    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
        var output = [];
        while (input.length) {
            if (input.match(RDS1)) {
                input = input.replace(RDS1, "");
            } else if (input.match(RDS2)) {
                input = input.replace(RDS2, "/");
            } else if (input.match(RDS3)) {
                input = input.replace(RDS3, "/");
                output.pop();
            } else if (input === "." || input === "..") {
                input = "";
            } else {
                var im = input.match(RDS5);
                if (im) {
                    var s = im[0];
                    input = input.slice(s.length);
                    output.push(s);
                } else {
                    throw new Error("Unexpected dot segment condition");
                }
            }
        }
        return output.join("");
    }

    function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //perform scheme specific serialization
        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
        if (components.host) {
            //if host component is an IPv6 address
            if (protocol.IPV6ADDRESS.test(components.host)) ;
            //TODO: normalize IPv6 address as per RFC 5952

            //if host component is a domain name
            else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                    //convert IDN via punycode
                    try {
                        components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                    } catch (e) {
                        components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                    }
                }
        }
        //normalize encoding
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
            uriTokens.push(components.scheme);
            uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== undefined) {
            if (options.reference !== "suffix") {
                uriTokens.push("//");
            }
            uriTokens.push(authority);
            if (components.path && components.path.charAt(0) !== "/") {
                uriTokens.push("/");
            }
        }
        if (components.path !== undefined) {
            var s = components.path;
            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
                s = removeDotSegments(s);
            }
            if (authority === undefined) {
                s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
            }
            uriTokens.push(s);
        }
        if (components.query !== undefined) {
            uriTokens.push("?");
            uriTokens.push(components.query);
        }
        if (components.fragment !== undefined) {
            uriTokens.push("#");
            uriTokens.push(components.fragment);
        }
        return uriTokens.join(""); //merge tokens into a string
    }

    function resolveComponents(base, relative) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var skipNormalization = arguments[3];

        var target = {};
        if (!skipNormalization) {
            base = parse(serialize(base, options), options); //normalize base components
            relative = parse(serialize(relative, options), options); //normalize relative components
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
            target.scheme = relative.scheme;
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
                //target.authority = relative.authority;
                target.userinfo = relative.userinfo;
                target.host = relative.host;
                target.port = relative.port;
                target.path = removeDotSegments(relative.path || "");
                target.query = relative.query;
            } else {
                if (!relative.path) {
                    target.path = base.path;
                    if (relative.query !== undefined) {
                        target.query = relative.query;
                    } else {
                        target.query = base.query;
                    }
                } else {
                    if (relative.path.charAt(0) === "/") {
                        target.path = removeDotSegments(relative.path);
                    } else {
                        if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                            target.path = "/" + relative.path;
                        } else if (!base.path) {
                            target.path = relative.path;
                        } else {
                            target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                        }
                        target.path = removeDotSegments(target.path);
                    }
                    target.query = relative.query;
                }
                //target.authority = base.authority;
                target.userinfo = base.userinfo;
                target.host = base.host;
                target.port = base.port;
            }
            target.scheme = base.scheme;
        }
        target.fragment = relative.fragment;
        return target;
    }

    function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: 'null' }, options);
        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }

    function normalize(uri, options) {
        if (typeof uri === "string") {
            uri = serialize(parse(uri, options), options);
        } else if (typeOf(uri) === "object") {
            uri = parse(serialize(uri, options), options);
        }
        return uri;
    }

    function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
            uriA = serialize(parse(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
            uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
            uriB = serialize(parse(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
            uriB = serialize(uriB, options);
        }
        return uriA === uriB;
    }

    function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }

    function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }

    var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse(components, options) {
            //report missing host
            if (!components.host) {
                components.error = components.error || "HTTP URIs must have a host.";
            }
            return components;
        },
        serialize: function serialize(components, options) {
            var secure = String(components.scheme).toLowerCase() === "https";
            //normalize the default port
            if (components.port === (secure ? 443 : 80) || components.port === "") {
                components.port = undefined;
            }
            //normalize the empty path
            if (!components.path) {
                components.path = "/";
            }
            //NOTE: We do not parse query strings for HTTP URIs
            //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
            //and not the HTTP spec.
            return components;
        }
    };

    var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
    };

    function isSecure(wsComponents) {
        return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    //RFC 6455
    var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse(components, options) {
            var wsComponents = components;
            //indicate if the secure flag is set
            wsComponents.secure = isSecure(wsComponents);
            //construct resouce name
            wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
            wsComponents.path = undefined;
            wsComponents.query = undefined;
            return wsComponents;
        },
        serialize: function serialize(wsComponents, options) {
            //normalize the default port
            if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
                wsComponents.port = undefined;
            }
            //ensure scheme matches secure flag
            if (typeof wsComponents.secure === 'boolean') {
                wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
                wsComponents.secure = undefined;
            }
            //reconstruct path from resource name
            if (wsComponents.resourceName) {
                var _wsComponents$resourc = wsComponents.resourceName.split('?'),
                    _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
                    path = _wsComponents$resourc2[0],
                    query = _wsComponents$resourc2[1];

                wsComponents.path = path && path !== '/' ? path : undefined;
                wsComponents.query = query;
                wsComponents.resourceName = undefined;
            }
            //forbid fragment component
            wsComponents.fragment = undefined;
            return wsComponents;
        }
    };

    var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
    };

    var O = {};
    //RFC 3986
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + ("\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" ) + "]";
    var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
    //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
    //const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
    //const WSP$$ = "[\\x20\\x09]";
    //const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
    //const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
    //const VCHAR$$ = "[\\x21-\\x7E]";
    //const WSP$$ = "[\\x20\\x09]";
    //const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
    //const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
    //const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
    //const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
    }
    var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
            var mailtoComponents = components;
            var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
            mailtoComponents.path = undefined;
            if (mailtoComponents.query) {
                var unknownHeaders = false;
                var headers = {};
                var hfields = mailtoComponents.query.split("&");
                for (var x = 0, xl = hfields.length; x < xl; ++x) {
                    var hfield = hfields[x].split("=");
                    switch (hfield[0]) {
                        case "to":
                            var toAddrs = hfield[1].split(",");
                            for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                                to.push(toAddrs[_x]);
                            }
                            break;
                        case "subject":
                            mailtoComponents.subject = unescapeComponent(hfield[1], options);
                            break;
                        case "body":
                            mailtoComponents.body = unescapeComponent(hfield[1], options);
                            break;
                        default:
                            unknownHeaders = true;
                            headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                            break;
                    }
                }
                if (unknownHeaders) mailtoComponents.headers = headers;
            }
            mailtoComponents.query = undefined;
            for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
                var addr = to[_x2].split("@");
                addr[0] = unescapeComponent(addr[0]);
                if (!options.unicodeSupport) {
                    //convert Unicode IDN -> ASCII IDN
                    try {
                        addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                    } catch (e) {
                        mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                    }
                } else {
                    addr[1] = unescapeComponent(addr[1], options).toLowerCase();
                }
                to[_x2] = addr.join("@");
            }
            return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
            var components = mailtoComponents;
            var to = toArray(mailtoComponents.to);
            if (to) {
                for (var x = 0, xl = to.length; x < xl; ++x) {
                    var toAddr = String(to[x]);
                    var atIdx = toAddr.lastIndexOf("@");
                    var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                    var domain = toAddr.slice(atIdx + 1);
                    //convert IDN via punycode
                    try {
                        domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                    } catch (e) {
                        components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                    }
                    to[x] = localPart + "@" + domain;
                }
                components.path = to.join(",");
            }
            var headers = mailtoComponents.headers = mailtoComponents.headers || {};
            if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
            if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
            var fields = [];
            for (var name in headers) {
                if (headers[name] !== O[name]) {
                    fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
                }
            }
            if (fields.length) {
                components.query = fields.join("&");
            }
            return components;
        }
    };

    var URN_PARSE = /^([^\:]+)\:(.*)/;
    //RFC 2141
    var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
            var matches = components.path && components.path.match(URN_PARSE);
            var urnComponents = components;
            if (matches) {
                var scheme = options.scheme || urnComponents.scheme || "urn";
                var nid = matches[1].toLowerCase();
                var nss = matches[2];
                var urnScheme = scheme + ":" + (options.nid || nid);
                var schemeHandler = SCHEMES[urnScheme];
                urnComponents.nid = nid;
                urnComponents.nss = nss;
                urnComponents.path = undefined;
                if (schemeHandler) {
                    urnComponents = schemeHandler.parse(urnComponents, options);
                }
            } else {
                urnComponents.error = urnComponents.error || "URN can not be parsed.";
            }
            return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = urnComponents.nid;
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            if (schemeHandler) {
                urnComponents = schemeHandler.serialize(urnComponents, options);
            }
            var uriComponents = urnComponents;
            var nss = urnComponents.nss;
            uriComponents.path = (nid || options.nid) + ":" + nss;
            return uriComponents;
        }
    };

    var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    //RFC 4122
    var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse(urnComponents, options) {
            var uuidComponents = urnComponents;
            uuidComponents.uuid = uuidComponents.nss;
            uuidComponents.nss = undefined;
            if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
                uuidComponents.error = uuidComponents.error || "UUID is not valid.";
            }
            return uuidComponents;
        },
        serialize: function serialize(uuidComponents, options) {
            var urnComponents = uuidComponents;
            //normalize UUID
            urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
            return urnComponents;
        }
    };

    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;

    exports.SCHEMES = SCHEMES;
    exports.pctEncChar = pctEncChar;
    exports.pctDecChars = pctDecChars;
    exports.parse = parse;
    exports.removeDotSegments = removeDotSegments;
    exports.serialize = serialize;
    exports.resolveComponents = resolveComponents;
    exports.resolve = resolve;
    exports.normalize = normalize;
    exports.equal = equal;
    exports.escapeComponent = escapeComponent;
    exports.unescapeComponent = unescapeComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

    })));

    });

    var resolve = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;




    // TODO refactor to use keyword definitions
    const SIMPLE_INLINED = new Set([
        "type",
        "format",
        "pattern",
        "maxLength",
        "minLength",
        "maxProperties",
        "minProperties",
        "maxItems",
        "minItems",
        "maximum",
        "minimum",
        "uniqueItems",
        "multipleOf",
        "required",
        "enum",
        "const",
    ]);
    function inlineRef(schema, limit = true) {
        if (typeof schema == "boolean")
            return true;
        if (limit === true)
            return !hasRef(schema);
        if (!limit)
            return false;
        return countKeys(schema) <= limit;
    }
    exports.inlineRef = inlineRef;
    const REF_KEYWORDS = new Set([
        "$ref",
        "$recursiveRef",
        "$recursiveAnchor",
        "$dynamicRef",
        "$dynamicAnchor",
    ]);
    function hasRef(schema) {
        for (const key in schema) {
            if (REF_KEYWORDS.has(key))
                return true;
            const sch = schema[key];
            if (Array.isArray(sch) && sch.some(hasRef))
                return true;
            if (typeof sch == "object" && hasRef(sch))
                return true;
        }
        return false;
    }
    function countKeys(schema) {
        let count = 0;
        for (const key in schema) {
            if (key === "$ref")
                return Infinity;
            count++;
            if (SIMPLE_INLINED.has(key))
                continue;
            if (typeof schema[key] == "object") {
                util.eachItem(schema[key], (sch) => (count += countKeys(sch)));
            }
            if (count === Infinity)
                return Infinity;
        }
        return count;
    }
    function getFullPath(id = "", normalize) {
        if (normalize !== false)
            id = normalizeId(id);
        const p = uri_all.parse(id);
        return _getFullPath(p);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(p) {
        return uri_all.serialize(p).split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    const TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
        return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(baseId, id) {
        id = normalizeId(id);
        return uri_all.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema) {
        if (typeof schema == "boolean")
            return {};
        const { schemaId } = this.opts;
        const schId = normalizeId(schema[schemaId]);
        const baseIds = { "": schId };
        const pathPrefix = getFullPath(schId, false);
        const localRefs = {};
        const schemaRefs = new Set();
        jsonSchemaTraverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
            if (parentJsonPtr === undefined)
                return;
            const fullPath = pathPrefix + jsonPtr;
            let baseId = baseIds[parentJsonPtr];
            if (typeof sch[schemaId] == "string")
                baseId = addRef.call(this, sch[schemaId]);
            addAnchor.call(this, sch.$anchor);
            addAnchor.call(this, sch.$dynamicAnchor);
            baseIds[jsonPtr] = baseId;
            function addRef(ref) {
                ref = normalizeId(baseId ? uri_all.resolve(baseId, ref) : ref);
                if (schemaRefs.has(ref))
                    throw ambiguos(ref);
                schemaRefs.add(ref);
                let schOrRef = this.refs[ref];
                if (typeof schOrRef == "string")
                    schOrRef = this.refs[schOrRef];
                if (typeof schOrRef == "object") {
                    checkAmbiguosRef(sch, schOrRef.schema, ref);
                }
                else if (ref !== normalizeId(fullPath)) {
                    if (ref[0] === "#") {
                        checkAmbiguosRef(sch, localRefs[ref], ref);
                        localRefs[ref] = sch;
                    }
                    else {
                        this.refs[ref] = fullPath;
                    }
                }
                return ref;
            }
            function addAnchor(anchor) {
                if (typeof anchor == "string") {
                    if (!ANCHOR.test(anchor))
                        throw new Error(`invalid anchor "${anchor}"`);
                    addRef.call(this, `#${anchor}`);
                }
            }
        });
        return localRefs;
        function checkAmbiguosRef(sch1, sch2, ref) {
            if (sch2 !== undefined && !fastDeepEqual(sch1, sch2))
                throw ambiguos(ref);
        }
        function ambiguos(ref) {
            return new Error(`reference "${ref}" resolves to more than one schema`);
        }
    }
    exports.getSchemaRefs = getSchemaRefs;

    });

    var validate = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;



    const dataType_2 = dataType;








    // schema compilation - generates validation function, subschemaCode (below) is used for subschemas
    function validateFunctionCode(it) {
        if (isSchemaObj(it)) {
            checkKeywords(it);
            if (schemaCxtHasRules(it)) {
                topSchemaObjCode(it);
                return;
            }
        }
        validateFunction(it, () => boolSchema.topBoolOrEmptySchema(it));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
        if (opts.code.es5) {
            gen.func(validateName, codegen._ `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
                gen.code(codegen._ `"use strict"; ${funcSourceUrl(schema, opts)}`);
                destructureValCxtES5(gen, opts);
                gen.code(body);
            });
        }
        else {
            gen.func(validateName, codegen._ `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
        }
    }
    function destructureValCxt(opts) {
        return codegen._ `{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? codegen._ `, ${names_1.default.dynamicAnchors}={}` : codegen.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
        gen.if(names_1.default.valCxt, () => {
            gen.var(names_1.default.instancePath, codegen._ `${names_1.default.valCxt}.${names_1.default.instancePath}`);
            gen.var(names_1.default.parentData, codegen._ `${names_1.default.valCxt}.${names_1.default.parentData}`);
            gen.var(names_1.default.parentDataProperty, codegen._ `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
            gen.var(names_1.default.rootData, codegen._ `${names_1.default.valCxt}.${names_1.default.rootData}`);
            if (opts.dynamicRef)
                gen.var(names_1.default.dynamicAnchors, codegen._ `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
        }, () => {
            gen.var(names_1.default.instancePath, codegen._ `""`);
            gen.var(names_1.default.parentData, codegen._ `undefined`);
            gen.var(names_1.default.parentDataProperty, codegen._ `undefined`);
            gen.var(names_1.default.rootData, names_1.default.data);
            if (opts.dynamicRef)
                gen.var(names_1.default.dynamicAnchors, codegen._ `{}`);
        });
    }
    function topSchemaObjCode(it) {
        const { schema, opts, gen } = it;
        validateFunction(it, () => {
            if (opts.$comment && schema.$comment)
                commentKeyword(it);
            checkNoDefault(it);
            gen.let(names_1.default.vErrors, null);
            gen.let(names_1.default.errors, 0);
            if (opts.unevaluated)
                resetEvaluated(it);
            typeAndKeywords(it);
            returnResults(it);
        });
        return;
    }
    function resetEvaluated(it) {
        // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
        const { gen, validateName } = it;
        it.evaluated = gen.const("evaluated", codegen._ `${validateName}.evaluated`);
        gen.if(codegen._ `${it.evaluated}.dynamicProps`, () => gen.assign(codegen._ `${it.evaluated}.props`, codegen._ `undefined`));
        gen.if(codegen._ `${it.evaluated}.dynamicItems`, () => gen.assign(codegen._ `${it.evaluated}.items`, codegen._ `undefined`));
    }
    function funcSourceUrl(schema, opts) {
        const schId = typeof schema == "object" && schema[opts.schemaId];
        return schId && (opts.code.source || opts.code.process) ? codegen._ `/*# sourceURL=${schId} */` : codegen.nil;
    }
    // schema compilation - this function is used recursively to generate code for sub-schemas
    function subschemaCode(it, valid) {
        if (isSchemaObj(it)) {
            checkKeywords(it);
            if (schemaCxtHasRules(it)) {
                subSchemaObjCode(it, valid);
                return;
            }
        }
        boolSchema.boolOrEmptySchema(it, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
        if (typeof schema == "boolean")
            return !schema;
        for (const key in schema)
            if (self.RULES.all[key])
                return true;
        return false;
    }
    function isSchemaObj(it) {
        return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
        const { schema, gen, opts } = it;
        if (opts.$comment && schema.$comment)
            commentKeyword(it);
        updateContext(it);
        checkAsyncSchema(it);
        const errsCount = gen.const("_errs", names_1.default.errors);
        typeAndKeywords(it, errsCount);
        // TODO var
        gen.var(valid, codegen._ `${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
        util.checkUnknownRules(it);
        checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
        if (it.opts.jtd)
            return schemaKeywords(it, [], false, errsCount);
        const types = dataType.getSchemaTypes(it.schema);
        const checkedTypes = dataType.coerceAndCheckDataType(it, types);
        schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
        const { schema, errSchemaPath, opts, self } = it;
        if (schema.$ref && opts.ignoreKeywordsWithRef && util.schemaHasRulesButRef(schema, self.RULES)) {
            self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
        }
    }
    function checkNoDefault(it) {
        const { schema, opts } = it;
        if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
            util.checkStrictMode(it, "default is ignored in the schema root");
        }
    }
    function updateContext(it) {
        const schId = it.schema[it.opts.schemaId];
        if (schId)
            it.baseId = resolve.resolveUrl(it.baseId, schId);
    }
    function checkAsyncSchema(it) {
        if (it.schema.$async && !it.schemaEnv.$async)
            throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
        const msg = schema.$comment;
        if (opts.$comment === true) {
            gen.code(codegen._ `${names_1.default.self}.logger.log(${msg})`);
        }
        else if (typeof opts.$comment == "function") {
            const schemaPath = codegen.str `${errSchemaPath}/$comment`;
            const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
            gen.code(codegen._ `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
        }
    }
    function returnResults(it) {
        const { gen, schemaEnv, validateName, ValidationError, opts } = it;
        if (schemaEnv.$async) {
            // TODO assign unevaluated
            gen.if(codegen._ `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw(codegen._ `new ${ValidationError}(${names_1.default.vErrors})`));
        }
        else {
            gen.assign(codegen._ `${validateName}.errors`, names_1.default.vErrors);
            if (opts.unevaluated)
                assignEvaluated(it);
            gen.return(codegen._ `${names_1.default.errors} === 0`);
        }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
        if (props instanceof codegen.Name)
            gen.assign(codegen._ `${evaluated}.props`, props);
        if (items instanceof codegen.Name)
            gen.assign(codegen._ `${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
        const { gen, schema, data, allErrors, opts, self } = it;
        const { RULES } = self;
        if (schema.$ref && (opts.ignoreKeywordsWithRef || !util.schemaHasRulesButRef(schema, RULES))) {
            gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
            return;
        }
        if (!opts.jtd)
            checkStrictTypes(it, types);
        gen.block(() => {
            for (const group of RULES.rules)
                groupKeywords(group);
            groupKeywords(RULES.post);
        });
        function groupKeywords(group) {
            if (!applicability.shouldUseGroup(schema, group))
                return;
            if (group.type) {
                gen.if(dataType_2.checkDataType(group.type, data, opts.strictNumbers));
                iterateKeywords(it, group);
                if (types.length === 1 && types[0] === group.type && typeErrors) {
                    gen.else();
                    dataType_2.reportTypeError(it);
                }
                gen.endIf();
            }
            else {
                iterateKeywords(it, group);
            }
            // TODO make it "ok" call?
            if (!allErrors)
                gen.if(codegen._ `${names_1.default.errors} === ${errsCount || 0}`);
        }
    }
    function iterateKeywords(it, group) {
        const { gen, schema, opts: { useDefaults }, } = it;
        if (useDefaults)
            defaults.assignDefaults(it, group.type);
        gen.block(() => {
            for (const rule of group.rules) {
                if (applicability.shouldUseRule(schema, rule)) {
                    keywordCode(it, rule.keyword, rule.definition, group.type);
                }
            }
        });
    }
    function checkStrictTypes(it, types) {
        if (it.schemaEnv.meta || !it.opts.strictTypes)
            return;
        checkContextTypes(it, types);
        if (!it.opts.allowUnionTypes)
            checkMultipleTypes(it, types);
        checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
        if (!types.length)
            return;
        if (!it.dataTypes.length) {
            it.dataTypes = types;
            return;
        }
        types.forEach((t) => {
            if (!includesType(it.dataTypes, t)) {
                strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
            }
        });
        it.dataTypes = it.dataTypes.filter((t) => includesType(types, t));
    }
    function checkMultipleTypes(it, ts) {
        if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
            strictTypesError(it, "use allowUnionTypes to allow union type keyword");
        }
    }
    function checkKeywordTypes(it, ts) {
        const rules = it.self.RULES.all;
        for (const keyword in rules) {
            const rule = rules[keyword];
            if (typeof rule == "object" && applicability.shouldUseRule(it.schema, rule)) {
                const { type } = rule.definition;
                if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
                    strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
                }
            }
        }
    }
    function hasApplicableType(schTs, kwdT) {
        return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
    }
    function includesType(ts, t) {
        return ts.includes(t) || (t === "integer" && ts.includes("number"));
    }
    function strictTypesError(it, msg) {
        const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
        msg += ` at "${schemaPath}" (strictTypes)`;
        util.checkStrictMode(it, msg, it.opts.strictTypes);
    }
    class KeywordCxt {
        constructor(it, def, keyword$1) {
            keyword.validateKeywordUsage(it, def, keyword$1);
            this.gen = it.gen;
            this.allErrors = it.allErrors;
            this.keyword = keyword$1;
            this.data = it.data;
            this.schema = it.schema[keyword$1];
            this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
            this.schemaValue = util.schemaRefOrVal(it, this.schema, keyword$1, this.$data);
            this.schemaType = def.schemaType;
            this.parentSchema = it.schema;
            this.params = {};
            this.it = it;
            this.def = def;
            if (this.$data) {
                this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
            }
            else {
                this.schemaCode = this.schemaValue;
                if (!keyword.validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {
                    throw new Error(`${keyword$1} value must be ${JSON.stringify(def.schemaType)}`);
                }
            }
            if ("code" in def ? def.trackErrors : def.errors !== false) {
                this.errsCount = it.gen.const("_errs", names_1.default.errors);
            }
        }
        result(condition, successAction, failAction) {
            this.gen.if(codegen.not(condition));
            if (failAction)
                failAction();
            else
                this.error();
            if (successAction) {
                this.gen.else();
                successAction();
                if (this.allErrors)
                    this.gen.endIf();
            }
            else {
                if (this.allErrors)
                    this.gen.endIf();
                else
                    this.gen.else();
            }
        }
        pass(condition, failAction) {
            this.result(condition, undefined, failAction);
        }
        fail(condition) {
            if (condition === undefined) {
                this.error();
                if (!this.allErrors)
                    this.gen.if(false); // this branch will be removed by gen.optimize
                return;
            }
            this.gen.if(condition);
            this.error();
            if (this.allErrors)
                this.gen.endIf();
            else
                this.gen.else();
        }
        fail$data(condition) {
            if (!this.$data)
                return this.fail(condition);
            const { schemaCode } = this;
            this.fail(codegen._ `${schemaCode} !== undefined && (${codegen.or(this.invalid$data(), condition)})`);
        }
        error(append, errorParams, errorPaths) {
            if (errorParams) {
                this.setParams(errorParams);
                this._error(append, errorPaths);
                this.setParams({});
                return;
            }
            this._error(append, errorPaths);
        }
        _error(append, errorPaths) {
            (append ? errors.reportExtraError : errors.reportError)(this, this.def.error, errorPaths);
        }
        $dataError() {
            errors.reportError(this, this.def.$dataError || errors.keyword$DataError);
        }
        reset() {
            if (this.errsCount === undefined)
                throw new Error('add "trackErrors" to keyword definition');
            errors.resetErrorsCount(this.gen, this.errsCount);
        }
        ok(cond) {
            if (!this.allErrors)
                this.gen.if(cond);
        }
        setParams(obj, assign) {
            if (assign)
                Object.assign(this.params, obj);
            else
                this.params = obj;
        }
        block$data(valid, codeBlock, $dataValid = codegen.nil) {
            this.gen.block(() => {
                this.check$data(valid, $dataValid);
                codeBlock();
            });
        }
        check$data(valid = codegen.nil, $dataValid = codegen.nil) {
            if (!this.$data)
                return;
            const { gen, schemaCode, schemaType, def } = this;
            gen.if(codegen.or(codegen._ `${schemaCode} === undefined`, $dataValid));
            if (valid !== codegen.nil)
                gen.assign(valid, true);
            if (schemaType.length || def.validateSchema) {
                gen.elseIf(this.invalid$data());
                this.$dataError();
                if (valid !== codegen.nil)
                    gen.assign(valid, false);
            }
            gen.else();
        }
        invalid$data() {
            const { gen, schemaCode, schemaType, def, it } = this;
            return codegen.or(wrong$DataType(), invalid$DataSchema());
            function wrong$DataType() {
                if (schemaType.length) {
                    /* istanbul ignore if */
                    if (!(schemaCode instanceof codegen.Name))
                        throw new Error("ajv implementation error");
                    const st = Array.isArray(schemaType) ? schemaType : [schemaType];
                    return codegen._ `${dataType_2.checkDataTypes(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
                }
                return codegen.nil;
            }
            function invalid$DataSchema() {
                if (def.validateSchema) {
                    const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
                    return codegen._ `!${validateSchemaRef}(${schemaCode})`;
                }
                return codegen.nil;
            }
        }
        subschema(appl, valid) {
            const subschema$1 = subschema.getSubschema(this.it, appl);
            subschema.extendSubschemaData(subschema$1, this.it, appl);
            subschema.extendSubschemaMode(subschema$1, appl);
            const nextContext = { ...this.it, ...subschema$1, items: undefined, props: undefined };
            subschemaCode(nextContext, valid);
            return nextContext;
        }
        mergeEvaluated(schemaCxt, toName) {
            const { it, gen } = this;
            if (!it.opts.unevaluated)
                return;
            if (it.props !== true && schemaCxt.props !== undefined) {
                it.props = util.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
            }
            if (it.items !== true && schemaCxt.items !== undefined) {
                it.items = util.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
            }
        }
        mergeValidEvaluated(schemaCxt, valid) {
            const { it, gen } = this;
            if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
                gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen.Name));
                return true;
            }
        }
    }
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword$1, def, ruleType) {
        const cxt = new KeywordCxt(it, def, keyword$1);
        if ("code" in def) {
            def.code(cxt, ruleType);
        }
        else if (cxt.$data && def.validate) {
            keyword.funcKeywordCode(cxt, def);
        }
        else if ("macro" in def) {
            keyword.macroKeywordCode(cxt, def);
        }
        else if (def.compile || def.validate) {
            keyword.funcKeywordCode(cxt, def);
        }
    }
    const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
        let jsonPointer;
        let data;
        if ($data === "")
            return names_1.default.rootData;
        if ($data[0] === "/") {
            if (!JSON_POINTER.test($data))
                throw new Error(`Invalid JSON-pointer: ${$data}`);
            jsonPointer = $data;
            data = names_1.default.rootData;
        }
        else {
            const matches = RELATIVE_JSON_POINTER.exec($data);
            if (!matches)
                throw new Error(`Invalid JSON-pointer: ${$data}`);
            const up = +matches[1];
            jsonPointer = matches[2];
            if (jsonPointer === "#") {
                if (up >= dataLevel)
                    throw new Error(errorMsg("property/index", up));
                return dataPathArr[dataLevel - up];
            }
            if (up > dataLevel)
                throw new Error(errorMsg("data", up));
            data = dataNames[dataLevel - up];
            if (!jsonPointer)
                return data;
        }
        let expr = data;
        const segments = jsonPointer.split("/");
        for (const segment of segments) {
            if (segment) {
                data = codegen._ `${data}${codegen.getProperty(util.unescapeJsonPointer(segment))}`;
                expr = codegen._ `${expr} && ${data}`;
            }
        }
        return expr;
        function errorMsg(pointerType, up) {
            return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
        }
    }
    exports.getData = getData;

    });

    class ValidationError extends Error {
        constructor(errors) {
            super("validation failed");
            this.errors = errors;
            this.ajv = this.validation = true;
        }
    }
    var _default$y = ValidationError;


    var validation_error = /*#__PURE__*/Object.defineProperty({
    	default: _default$y
    }, '__esModule', {value: true});

    class MissingRefError extends Error {
        constructor(baseId, ref, msg) {
            super(msg || `can't resolve reference ${ref} from id ${baseId}`);
            this.missingRef = resolve.resolveUrl(baseId, ref);
            this.missingSchema = resolve.normalizeId(resolve.getFullPath(this.missingRef));
        }
    }
    var _default$x = MissingRefError;


    var ref_error = /*#__PURE__*/Object.defineProperty({
    	default: _default$x
    }, '__esModule', {value: true});

    var compile = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;







    class SchemaEnv {
        constructor(env) {
            var _a;
            this.refs = {};
            this.dynamicAnchors = {};
            let schema;
            if (typeof env.schema == "object")
                schema = env.schema;
            this.schema = env.schema;
            this.schemaId = env.schemaId;
            this.root = env.root || this;
            this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : resolve.normalizeId(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
            this.schemaPath = env.schemaPath;
            this.localRefs = env.localRefs;
            this.meta = env.meta;
            this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
            this.refs = {};
        }
    }
    exports.SchemaEnv = SchemaEnv;
    // let codeSize = 0
    // let nodeCount = 0
    // Compiles schema in SchemaEnv
    function compileSchema(sch) {
        // TODO refactor - remove compilations
        const _sch = getCompilingSchema.call(this, sch);
        if (_sch)
            return _sch;
        const rootId = resolve.getFullPath(sch.root.baseId); // TODO if getFullPath removed 1 tests fails
        const { es5, lines } = this.opts.code;
        const { ownProperties } = this.opts;
        const gen = new codegen.CodeGen(this.scope, { es5, lines, ownProperties });
        let _ValidationError;
        if (sch.$async) {
            _ValidationError = gen.scopeValue("Error", {
                ref: validation_error.default,
                code: codegen._ `require("ajv/dist/runtime/validation_error").default`,
            });
        }
        const validateName = gen.scopeName("validate");
        sch.validateName = validateName;
        const schemaCxt = {
            gen,
            allErrors: this.opts.allErrors,
            data: names_1.default.data,
            parentData: names_1.default.parentData,
            parentDataProperty: names_1.default.parentDataProperty,
            dataNames: [names_1.default.data],
            dataPathArr: [codegen.nil],
            dataLevel: 0,
            dataTypes: [],
            definedProperties: new Set(),
            topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
                ? { ref: sch.schema, code: codegen.stringify(sch.schema) }
                : { ref: sch.schema }),
            validateName,
            ValidationError: _ValidationError,
            schema: sch.schema,
            schemaEnv: sch,
            rootId,
            baseId: sch.baseId || rootId,
            schemaPath: codegen.nil,
            errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
            errorPath: codegen._ `""`,
            opts: this.opts,
            self: this,
        };
        let sourceCode;
        try {
            this._compilations.add(sch);
            validate.validateFunctionCode(schemaCxt);
            gen.optimize(this.opts.code.optimize);
            // gen.optimize(1)
            const validateCode = gen.toString();
            sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
            // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
            if (this.opts.code.process)
                sourceCode = this.opts.code.process(sourceCode, sch);
            // console.log("\n\n\n *** \n", sourceCode)
            const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
            const validate$1 = makeValidate(this, this.scope.get());
            this.scope.value(validateName, { ref: validate$1 });
            validate$1.errors = null;
            validate$1.schema = sch.schema;
            validate$1.schemaEnv = sch;
            if (sch.$async)
                validate$1.$async = true;
            if (this.opts.code.source === true) {
                validate$1.source = { validateName, validateCode, scopeValues: gen._values };
            }
            if (this.opts.unevaluated) {
                const { props, items } = schemaCxt;
                validate$1.evaluated = {
                    props: props instanceof codegen.Name ? undefined : props,
                    items: items instanceof codegen.Name ? undefined : items,
                    dynamicProps: props instanceof codegen.Name,
                    dynamicItems: items instanceof codegen.Name,
                };
                if (validate$1.source)
                    validate$1.source.evaluated = codegen.stringify(validate$1.evaluated);
            }
            sch.validate = validate$1;
            return sch;
        }
        catch (e) {
            delete sch.validate;
            delete sch.validateName;
            if (sourceCode)
                this.logger.error("Error compiling schema, function code:", sourceCode);
            // console.log("\n\n\n *** \n", sourceCode, this.opts)
            throw e;
        }
        finally {
            this._compilations.delete(sch);
        }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
        var _a;
        ref = resolve.resolveUrl(baseId, ref);
        const schOrFunc = root.refs[ref];
        if (schOrFunc)
            return schOrFunc;
        let _sch = resolve$1.call(this, root, ref);
        if (_sch === undefined) {
            const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
            const { schemaId } = this.opts;
            if (schema)
                _sch = new SchemaEnv({ schema, schemaId, root, baseId });
        }
        if (_sch === undefined)
            return;
        return (root.refs[ref] = inlineOrCompile.call(this, _sch));
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
        if (resolve.inlineRef(sch.schema, this.opts.inlineRefs))
            return sch.schema;
        return sch.validate ? sch : compileSchema.call(this, sch);
    }
    // Index of schema compilation in the currently compiled list
    function getCompilingSchema(schEnv) {
        for (const sch of this._compilations) {
            if (sameSchemaEnv(sch, schEnv))
                return sch;
        }
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
        return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    // resolve and compile the references ($ref)
    // TODO returns AnySchemaObject (if the schema can be inlined) or validation function
    function resolve$1(root, // information about the root schema for the current schema
    ref // reference to resolve
    ) {
        let sch;
        while (typeof (sch = this.refs[ref]) == "string")
            ref = sch;
        return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    // Resolve schema, its root and baseId
    function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
    ref // reference to resolve
    ) {
        const p = uri_all.parse(ref);
        const refPath = resolve._getFullPath(p);
        let baseId = resolve.getFullPath(root.baseId);
        // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
        if (Object.keys(root.schema).length > 0 && refPath === baseId) {
            return getJsonPointer.call(this, p, root);
        }
        const id = resolve.normalizeId(refPath);
        const schOrRef = this.refs[id] || this.schemas[id];
        if (typeof schOrRef == "string") {
            const sch = resolveSchema.call(this, root, schOrRef);
            if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
                return;
            return getJsonPointer.call(this, p, sch);
        }
        if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
            return;
        if (!schOrRef.validate)
            compileSchema.call(this, schOrRef);
        if (id === resolve.normalizeId(ref)) {
            const { schema } = schOrRef;
            const { schemaId } = this.opts;
            const schId = schema[schemaId];
            if (schId)
                baseId = resolve.resolveUrl(baseId, schId);
            return new SchemaEnv({ schema, schemaId, root, baseId });
        }
        return getJsonPointer.call(this, p, schOrRef);
    }
    exports.resolveSchema = resolveSchema;
    const PREVENT_SCOPE_CHANGE = new Set([
        "properties",
        "patternProperties",
        "enum",
        "dependencies",
        "definitions",
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
        var _a;
        if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
            return;
        for (const part of parsedRef.fragment.slice(1).split("/")) {
            if (typeof schema == "boolean")
                return;
            schema = schema[util.unescapeFragment(part)];
            if (schema === undefined)
                return;
            // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
            const schId = typeof schema == "object" && schema[this.opts.schemaId];
            if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
                baseId = resolve.resolveUrl(baseId, schId);
            }
        }
        let env;
        if (typeof schema != "boolean" && schema.$ref && !util.schemaHasRulesButRef(schema, this.RULES)) {
            const $ref = resolve.resolveUrl(baseId, schema.$ref);
            env = resolveSchema.call(this, root, $ref);
        }
        // even though resolution failed we need to return SchemaEnv to throw exception
        // so that compileAsync loads missing schema.
        const { schemaId } = this.opts;
        env = env || new SchemaEnv({ schema, schemaId, root, baseId });
        if (env.schema !== env.root.schema)
            return env;
        return undefined;
    }

    });

    var $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
    var description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
    var type$1 = "object";
    var required$1 = [
    	"$data"
    ];
    var properties$2 = {
    	$data: {
    		type: "string",
    		anyOf: [
    			{
    				format: "relative-json-pointer"
    			},
    			{
    				format: "json-pointer"
    			}
    		]
    	}
    };
    var additionalProperties$1 = false;
    var $dataRefSchema = {
    	$id: $id$1,
    	description: description,
    	type: type$1,
    	required: required$1,
    	properties: properties$2,
    	additionalProperties: additionalProperties$1
    };

    var core$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;

    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate.KeywordCxt; } });

    Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen._; } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen.str; } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen.stringify; } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen.nil; } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen.Name; } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen.CodeGen; } });




    const codegen_2 = codegen;




    const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    const EXT_SCOPE_NAMES = new Set([
        "validate",
        "serialize",
        "parse",
        "wrapper",
        "root",
        "schema",
        "keyword",
        "pattern",
        "formats",
        "validate$data",
        "func",
        "obj",
        "Error",
    ]);
    const removedOptions = {
        errorDataPath: "",
        format: "`validateFormats: false` can be used instead.",
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
        extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
        missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
        processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
        sourceCode: "Use option `code: {source: true}`",
        strictDefaults: "It is default now, see option `strict`.",
        strictKeywords: "It is default now, see option `strict`.",
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
        cache: "Map is used as cache, schema object as key.",
        serialize: "Map is used as cache, schema object as key.",
        ajvErrors: "It is default now.",
    };
    const deprecatedOptions = {
        ignoreKeywordsWithRef: "",
        jsPropertySyntax: "",
        unicode: '"minLength"/"maxLength" account for unicode characters by default.',
    };
    const MAX_EXPRESSION = 200;
    // eslint-disable-next-line complexity
    function requiredOptions(o) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
        const s = o.strict;
        const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
        const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
        return {
            strictSchema: (_c = (_b = o.strictSchema) !== null && _b !== void 0 ? _b : s) !== null && _c !== void 0 ? _c : true,
            strictNumbers: (_e = (_d = o.strictNumbers) !== null && _d !== void 0 ? _d : s) !== null && _e !== void 0 ? _e : true,
            strictTypes: (_g = (_f = o.strictTypes) !== null && _f !== void 0 ? _f : s) !== null && _g !== void 0 ? _g : "log",
            strictTuples: (_j = (_h = o.strictTuples) !== null && _h !== void 0 ? _h : s) !== null && _j !== void 0 ? _j : "log",
            strictRequired: (_l = (_k = o.strictRequired) !== null && _k !== void 0 ? _k : s) !== null && _l !== void 0 ? _l : false,
            code: o.code ? { ...o.code, optimize } : { optimize },
            loopRequired: (_m = o.loopRequired) !== null && _m !== void 0 ? _m : MAX_EXPRESSION,
            loopEnum: (_o = o.loopEnum) !== null && _o !== void 0 ? _o : MAX_EXPRESSION,
            meta: (_p = o.meta) !== null && _p !== void 0 ? _p : true,
            messages: (_q = o.messages) !== null && _q !== void 0 ? _q : true,
            inlineRefs: (_r = o.inlineRefs) !== null && _r !== void 0 ? _r : true,
            schemaId: (_s = o.schemaId) !== null && _s !== void 0 ? _s : "$id",
            addUsedSchema: (_t = o.addUsedSchema) !== null && _t !== void 0 ? _t : true,
            validateSchema: (_u = o.validateSchema) !== null && _u !== void 0 ? _u : true,
            validateFormats: (_v = o.validateFormats) !== null && _v !== void 0 ? _v : true,
            unicodeRegExp: (_w = o.unicodeRegExp) !== null && _w !== void 0 ? _w : true,
        };
    }
    class Ajv {
        constructor(opts = {}) {
            this.schemas = {};
            this.refs = {};
            this.formats = {};
            this._compilations = new Set();
            this._loading = {};
            this._cache = new Map();
            opts = this.opts = { ...opts, ...requiredOptions(opts) };
            const { es5, lines } = this.opts.code;
            this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
            this.logger = getLogger(opts.logger);
            const formatOpt = opts.validateFormats;
            opts.validateFormats = false;
            this.RULES = rules.getRules();
            checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
            checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
            this._metaOpts = getMetaSchemaOptions.call(this);
            if (opts.formats)
                addInitialFormats.call(this);
            this._addVocabularies();
            this._addDefaultMetaSchema();
            if (opts.keywords)
                addInitialKeywords.call(this, opts.keywords);
            if (typeof opts.meta == "object")
                this.addMetaSchema(opts.meta);
            addInitialSchemas.call(this);
            opts.validateFormats = formatOpt;
        }
        _addVocabularies() {
            this.addKeyword("$async");
        }
        _addDefaultMetaSchema() {
            const { $data, meta, schemaId } = this.opts;
            let _dataRefSchema = $dataRefSchema;
            if (schemaId === "id") {
                _dataRefSchema = { ...$dataRefSchema };
                _dataRefSchema.id = _dataRefSchema.$id;
                delete _dataRefSchema.$id;
            }
            if (meta && $data)
                this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
        }
        defaultMeta() {
            const { meta, schemaId } = this.opts;
            return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);
        }
        validate(schemaKeyRef, // key, ref or schema object
        data // to be validated
        ) {
            let v;
            if (typeof schemaKeyRef == "string") {
                v = this.getSchema(schemaKeyRef);
                if (!v)
                    throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
            }
            else {
                v = this.compile(schemaKeyRef);
            }
            const valid = v(data);
            if (!("$async" in v))
                this.errors = v.errors;
            return valid;
        }
        compile(schema, _meta) {
            const sch = this._addSchema(schema, _meta);
            return (sch.validate || this._compileSchemaEnv(sch));
        }
        compileAsync(schema, meta) {
            if (typeof this.opts.loadSchema != "function") {
                throw new Error("options.loadSchema should be a function");
            }
            const { loadSchema } = this.opts;
            return runCompileAsync.call(this, schema, meta);
            async function runCompileAsync(_schema, _meta) {
                await loadMetaSchema.call(this, _schema.$schema);
                const sch = this._addSchema(_schema, _meta);
                return sch.validate || _compileAsync.call(this, sch);
            }
            async function loadMetaSchema($ref) {
                if ($ref && !this.getSchema($ref)) {
                    await runCompileAsync.call(this, { $ref }, true);
                }
            }
            async function _compileAsync(sch) {
                try {
                    return this._compileSchemaEnv(sch);
                }
                catch (e) {
                    if (!(e instanceof ref_error.default))
                        throw e;
                    checkLoaded.call(this, e);
                    await loadMissingSchema.call(this, e.missingSchema);
                    return _compileAsync.call(this, sch);
                }
            }
            function checkLoaded({ missingSchema: ref, missingRef }) {
                if (this.refs[ref]) {
                    throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
                }
            }
            async function loadMissingSchema(ref) {
                const _schema = await _loadSchema.call(this, ref);
                if (!this.refs[ref])
                    await loadMetaSchema.call(this, _schema.$schema);
                if (!this.refs[ref])
                    this.addSchema(_schema, ref, meta);
            }
            async function _loadSchema(ref) {
                const p = this._loading[ref];
                if (p)
                    return p;
                try {
                    return await (this._loading[ref] = loadSchema(ref));
                }
                finally {
                    delete this._loading[ref];
                }
            }
        }
        // Adds schema to the instance
        addSchema(schema, // If array is passed, `key` will be ignored
        key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
        _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
        _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
        ) {
            if (Array.isArray(schema)) {
                for (const sch of schema)
                    this.addSchema(sch, undefined, _meta, _validateSchema);
                return this;
            }
            let id;
            if (typeof schema === "object") {
                const { schemaId } = this.opts;
                id = schema[schemaId];
                if (id !== undefined && typeof id != "string") {
                    throw new Error(`schema ${schemaId} must be string`);
                }
            }
            key = resolve.normalizeId(key || id);
            this._checkUnique(key);
            this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
            return this;
        }
        // Add schema that will be used to validate other schemas
        // options in META_IGNORE_OPTIONS are alway set to false
        addMetaSchema(schema, key, // schema key
        _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
        ) {
            this.addSchema(schema, key, true, _validateSchema);
            return this;
        }
        //  Validate schema against its meta-schema
        validateSchema(schema, throwOrLogError) {
            if (typeof schema == "boolean")
                return true;
            let $schema;
            $schema = schema.$schema;
            if ($schema !== undefined && typeof $schema != "string") {
                throw new Error("$schema must be a string");
            }
            $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
            if (!$schema) {
                this.logger.warn("meta-schema not available");
                this.errors = null;
                return true;
            }
            const valid = this.validate($schema, schema);
            if (!valid && throwOrLogError) {
                const message = "schema is invalid: " + this.errorsText();
                if (this.opts.validateSchema === "log")
                    this.logger.error(message);
                else
                    throw new Error(message);
            }
            return valid;
        }
        // Get compiled schema by `key` or `ref`.
        // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
        getSchema(keyRef) {
            let sch;
            while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
                keyRef = sch;
            if (sch === undefined) {
                const { schemaId } = this.opts;
                const root = new compile.SchemaEnv({ schema: {}, schemaId });
                sch = compile.resolveSchema.call(this, root, keyRef);
                if (!sch)
                    return;
                this.refs[keyRef] = sch;
            }
            return (sch.validate || this._compileSchemaEnv(sch));
        }
        // Remove cached schema(s).
        // If no parameter is passed all schemas but meta-schemas are removed.
        // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
        // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
        removeSchema(schemaKeyRef) {
            if (schemaKeyRef instanceof RegExp) {
                this._removeAllSchemas(this.schemas, schemaKeyRef);
                this._removeAllSchemas(this.refs, schemaKeyRef);
                return this;
            }
            switch (typeof schemaKeyRef) {
                case "undefined":
                    this._removeAllSchemas(this.schemas);
                    this._removeAllSchemas(this.refs);
                    this._cache.clear();
                    return this;
                case "string": {
                    const sch = getSchEnv.call(this, schemaKeyRef);
                    if (typeof sch == "object")
                        this._cache.delete(sch.schema);
                    delete this.schemas[schemaKeyRef];
                    delete this.refs[schemaKeyRef];
                    return this;
                }
                case "object": {
                    const cacheKey = schemaKeyRef;
                    this._cache.delete(cacheKey);
                    let id = schemaKeyRef[this.opts.schemaId];
                    if (id) {
                        id = resolve.normalizeId(id);
                        delete this.schemas[id];
                        delete this.refs[id];
                    }
                    return this;
                }
                default:
                    throw new Error("ajv.removeSchema: invalid parameter");
            }
        }
        // add "vocabulary" - a collection of keywords
        addVocabulary(definitions) {
            for (const def of definitions)
                this.addKeyword(def);
            return this;
        }
        addKeyword(kwdOrDef, def // deprecated
        ) {
            let keyword;
            if (typeof kwdOrDef == "string") {
                keyword = kwdOrDef;
                if (typeof def == "object") {
                    this.logger.warn("these parameters are deprecated, see docs for addKeyword");
                    def.keyword = keyword;
                }
            }
            else if (typeof kwdOrDef == "object" && def === undefined) {
                def = kwdOrDef;
                keyword = def.keyword;
                if (Array.isArray(keyword) && !keyword.length) {
                    throw new Error("addKeywords: keyword must be string or non-empty array");
                }
            }
            else {
                throw new Error("invalid addKeywords parameters");
            }
            checkKeyword.call(this, keyword, def);
            if (!def) {
                util.eachItem(keyword, (kwd) => addRule.call(this, kwd));
                return this;
            }
            keywordMetaschema.call(this, def);
            const definition = {
                ...def,
                type: dataType.getJSONTypes(def.type),
                schemaType: dataType.getJSONTypes(def.schemaType),
            };
            util.eachItem(keyword, definition.type.length === 0
                ? (k) => addRule.call(this, k, definition)
                : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
            return this;
        }
        getKeyword(keyword) {
            const rule = this.RULES.all[keyword];
            return typeof rule == "object" ? rule.definition : !!rule;
        }
        // Remove keyword
        removeKeyword(keyword) {
            // TODO return type should be Ajv
            const { RULES } = this;
            delete RULES.keywords[keyword];
            delete RULES.all[keyword];
            for (const group of RULES.rules) {
                const i = group.rules.findIndex((rule) => rule.keyword === keyword);
                if (i >= 0)
                    group.rules.splice(i, 1);
            }
            return this;
        }
        // Add format
        addFormat(name, format) {
            if (typeof format == "string")
                format = new RegExp(format);
            this.formats[name] = format;
            return this;
        }
        errorsText(errors = this.errors, // optional array of validation errors
        { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`
        ) {
            if (!errors || errors.length === 0)
                return "No errors";
            return errors
                .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
                .reduce((text, msg) => text + separator + msg);
        }
        $dataMetaSchema(metaSchema, keywordsJsonPointers) {
            const rules = this.RULES.all;
            metaSchema = JSON.parse(JSON.stringify(metaSchema));
            for (const jsonPointer of keywordsJsonPointers) {
                const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
                let keywords = metaSchema;
                for (const seg of segments)
                    keywords = keywords[seg];
                for (const key in rules) {
                    const rule = rules[key];
                    if (typeof rule != "object")
                        continue;
                    const { $data } = rule.definition;
                    const schema = keywords[key];
                    if ($data && schema)
                        keywords[key] = schemaOrData(schema);
                }
            }
            return metaSchema;
        }
        _removeAllSchemas(schemas, regex) {
            for (const keyRef in schemas) {
                const sch = schemas[keyRef];
                if (!regex || regex.test(keyRef)) {
                    if (typeof sch == "string") {
                        delete schemas[keyRef];
                    }
                    else if (sch && !sch.meta) {
                        this._cache.delete(sch.schema);
                        delete schemas[keyRef];
                    }
                }
            }
        }
        _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
            let id;
            const { schemaId } = this.opts;
            if (typeof schema == "object") {
                id = schema[schemaId];
            }
            else {
                if (this.opts.jtd)
                    throw new Error("schema must be object");
                else if (typeof schema != "boolean")
                    throw new Error("schema must be object or boolean");
            }
            let sch = this._cache.get(schema);
            if (sch !== undefined)
                return sch;
            const localRefs = resolve.getSchemaRefs.call(this, schema);
            baseId = resolve.normalizeId(id || baseId);
            sch = new compile.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
            this._cache.set(sch.schema, sch);
            if (addSchema && !baseId.startsWith("#")) {
                // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
                if (baseId)
                    this._checkUnique(baseId);
                this.refs[baseId] = sch;
            }
            if (validateSchema)
                this.validateSchema(schema, true);
            return sch;
        }
        _checkUnique(id) {
            if (this.schemas[id] || this.refs[id]) {
                throw new Error(`schema with key or id "${id}" already exists`);
            }
        }
        _compileSchemaEnv(sch) {
            if (sch.meta)
                this._compileMetaSchema(sch);
            else
                compile.compileSchema.call(this, sch);
            /* istanbul ignore if */
            if (!sch.validate)
                throw new Error("ajv implementation error");
            return sch.validate;
        }
        _compileMetaSchema(sch) {
            const currentOpts = this.opts;
            this.opts = this._metaOpts;
            try {
                compile.compileSchema.call(this, sch);
            }
            finally {
                this.opts = currentOpts;
            }
        }
    }
    exports.default = Ajv;
    Ajv.ValidationError = validation_error.default;
    Ajv.MissingRefError = ref_error.default;
    function checkOptions(checkOpts, options, msg, log = "error") {
        for (const key in checkOpts) {
            const opt = key;
            if (opt in options)
                this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
        }
    }
    function getSchEnv(keyRef) {
        keyRef = resolve.normalizeId(keyRef); // TODO tests fail without this line
        return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
        const optsSchemas = this.opts.schemas;
        if (!optsSchemas)
            return;
        if (Array.isArray(optsSchemas))
            this.addSchema(optsSchemas);
        else
            for (const key in optsSchemas)
                this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
        for (const name in this.opts.formats) {
            const format = this.opts.formats[name];
            if (format)
                this.addFormat(name, format);
        }
    }
    function addInitialKeywords(defs) {
        if (Array.isArray(defs)) {
            this.addVocabulary(defs);
            return;
        }
        this.logger.warn("keywords option as map is deprecated, pass array");
        for (const keyword in defs) {
            const def = defs[keyword];
            if (!def.keyword)
                def.keyword = keyword;
            this.addKeyword(def);
        }
    }
    function getMetaSchemaOptions() {
        const metaOpts = { ...this.opts };
        for (const opt of META_IGNORE_OPTIONS)
            delete metaOpts[opt];
        return metaOpts;
    }
    const noLogs = { log() { }, warn() { }, error() { } };
    function getLogger(logger) {
        if (logger === false)
            return noLogs;
        if (logger === undefined)
            return console;
        if (logger.log && logger.warn && logger.error)
            return logger;
        throw new Error("logger must implement log, warn and error methods");
    }
    const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
        const { RULES } = this;
        util.eachItem(keyword, (kwd) => {
            if (RULES.keywords[kwd])
                throw new Error(`Keyword ${kwd} is already defined`);
            if (!KEYWORD_NAME.test(kwd))
                throw new Error(`Keyword ${kwd} has invalid name`);
        });
        if (!def)
            return;
        if (def.$data && !("code" in def || "validate" in def)) {
            throw new Error('$data keyword must have "code" or "validate" function');
        }
    }
    function addRule(keyword, definition, dataType$1) {
        var _a;
        const post = definition === null || definition === void 0 ? void 0 : definition.post;
        if (dataType$1 && post)
            throw new Error('keyword with "post" flag cannot have "type"');
        const { RULES } = this;
        let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType$1);
        if (!ruleGroup) {
            ruleGroup = { type: dataType$1, rules: [] };
            RULES.rules.push(ruleGroup);
        }
        RULES.keywords[keyword] = true;
        if (!definition)
            return;
        const rule = {
            keyword,
            definition: {
                ...definition,
                type: dataType.getJSONTypes(definition.type),
                schemaType: dataType.getJSONTypes(definition.schemaType),
            },
        };
        if (definition.before)
            addBeforeRule.call(this, ruleGroup, rule, definition.before);
        else
            ruleGroup.rules.push(rule);
        RULES.all[keyword] = rule;
        (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
        const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
        if (i >= 0) {
            ruleGroup.rules.splice(i, 0, rule);
        }
        else {
            ruleGroup.rules.push(rule);
            this.logger.warn(`rule ${before} is not defined`);
        }
    }
    function keywordMetaschema(def) {
        let { metaSchema } = def;
        if (metaSchema === undefined)
            return;
        if (def.$data && this.opts.$data)
            metaSchema = schemaOrData(metaSchema);
        def.validateSchema = this.compile(metaSchema, true);
    }
    const $dataRef = {
        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    };
    function schemaOrData(schema) {
        return { anyOf: [schema, $dataRef] };
    }

    });

    const def$p = {
        keyword: "id",
        code() {
            throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
        },
    };
    var _default$w = def$p;


    var id = /*#__PURE__*/Object.defineProperty({
    	default: _default$w
    }, '__esModule', {value: true});

    var ref = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callRef = exports.getValidate = void 0;






    const def = {
        keyword: "$ref",
        schemaType: "string",
        code(cxt) {
            const { gen, schema: $ref, it } = cxt;
            const { baseId, schemaEnv: env, validateName, opts, self } = it;
            const { root } = env;
            if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
                return callRootRef();
            const schOrEnv = compile.resolveRef.call(self, root, baseId, $ref);
            if (schOrEnv === undefined)
                throw new ref_error.default(baseId, $ref);
            if (schOrEnv instanceof compile.SchemaEnv)
                return callValidate(schOrEnv);
            return inlineRefSchema(schOrEnv);
            function callRootRef() {
                if (env === root)
                    return callRef(cxt, validateName, env, env.$async);
                const rootName = gen.scopeValue("root", { ref: root });
                return callRef(cxt, codegen._ `${rootName}.validate`, root, root.$async);
            }
            function callValidate(sch) {
                const v = getValidate(cxt, sch);
                callRef(cxt, v, sch, sch.$async);
            }
            function inlineRefSchema(sch) {
                const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: codegen.stringify(sch) } : { ref: sch });
                const valid = gen.name("valid");
                const schCxt = cxt.subschema({
                    schema: sch,
                    dataTypes: [],
                    schemaPath: codegen.nil,
                    topSchemaRef: schName,
                    errSchemaPath: $ref,
                }, valid);
                cxt.mergeEvaluated(schCxt);
                cxt.ok(valid);
            }
        },
    };
    function getValidate(cxt, sch) {
        const { gen } = cxt;
        return sch.validate
            ? gen.scopeValue("validate", { ref: sch.validate })
            : codegen._ `${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
        const { gen, it } = cxt;
        const { allErrors, schemaEnv: env, opts } = it;
        const passCxt = opts.passContext ? names_1.default.this : codegen.nil;
        if ($async)
            callAsyncRef();
        else
            callSyncRef();
        function callAsyncRef() {
            if (!env.$async)
                throw new Error("async schema referenced by sync schema");
            const valid = gen.let("valid");
            gen.try(() => {
                gen.code(codegen._ `await ${code.callValidateCode(cxt, v, passCxt)}`);
                addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
                if (!allErrors)
                    gen.assign(valid, true);
            }, (e) => {
                gen.if(codegen._ `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
                addErrorsFrom(e);
                if (!allErrors)
                    gen.assign(valid, false);
            });
            cxt.ok(valid);
        }
        function callSyncRef() {
            cxt.result(code.callValidateCode(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
        }
        function addErrorsFrom(source) {
            const errs = codegen._ `${source}.errors`;
            gen.assign(names_1.default.vErrors, codegen._ `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged
            gen.assign(names_1.default.errors, codegen._ `${names_1.default.vErrors}.length`);
        }
        function addEvaluatedFrom(source) {
            var _a;
            if (!it.opts.unevaluated)
                return;
            const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
            // TODO refactor
            if (it.props !== true) {
                if (schEvaluated && !schEvaluated.dynamicProps) {
                    if (schEvaluated.props !== undefined) {
                        it.props = util.mergeEvaluated.props(gen, schEvaluated.props, it.props);
                    }
                }
                else {
                    const props = gen.var("props", codegen._ `${source}.evaluated.props`);
                    it.props = util.mergeEvaluated.props(gen, props, it.props, codegen.Name);
                }
            }
            if (it.items !== true) {
                if (schEvaluated && !schEvaluated.dynamicItems) {
                    if (schEvaluated.items !== undefined) {
                        it.items = util.mergeEvaluated.items(gen, schEvaluated.items, it.items);
                    }
                }
                else {
                    const items = gen.var("items", codegen._ `${source}.evaluated.items`);
                    it.items = util.mergeEvaluated.items(gen, items, it.items, codegen.Name);
                }
            }
        }
    }
    exports.callRef = callRef;
    exports.default = def;

    });

    const core = [
        "$schema",
        "$id",
        "$defs",
        "$vocabulary",
        { keyword: "$comment" },
        "definitions",
        id.default,
        ref.default,
    ];
    var _default$v = core;


    var core_1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$v
    }, '__esModule', {value: true});

    const ops = codegen.operators;
    const KWDs = {
        maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
        minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
        exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
        exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
    };
    const error$h = {
        message: ({ keyword, schemaCode }) => codegen.str `must be ${KWDs[keyword].okStr} ${schemaCode}`,
        params: ({ keyword, schemaCode }) => codegen._ `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
    };
    const def$o = {
        keyword: Object.keys(KWDs),
        type: "number",
        schemaType: "number",
        $data: true,
        error: error$h,
        code(cxt) {
            const { keyword, data, schemaCode } = cxt;
            cxt.fail$data(codegen._ `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
        },
    };
    var _default$u = def$o;


    var limitNumber = /*#__PURE__*/Object.defineProperty({
    	default: _default$u
    }, '__esModule', {value: true});

    const error$g = {
        message: ({ schemaCode }) => codegen.str `must be multiple of ${schemaCode}`,
        params: ({ schemaCode }) => codegen._ `{multipleOf: ${schemaCode}}`,
    };
    const def$n = {
        keyword: "multipleOf",
        type: "number",
        schemaType: "number",
        $data: true,
        error: error$g,
        code(cxt) {
            const { gen, data, schemaCode, it } = cxt;
            // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
            const prec = it.opts.multipleOfPrecision;
            const res = gen.let("res");
            const invalid = prec
                ? codegen._ `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
                : codegen._ `${res} !== parseInt(${res})`;
            cxt.fail$data(codegen._ `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
        },
    };
    var _default$t = def$n;


    var multipleOf = /*#__PURE__*/Object.defineProperty({
    	default: _default$t
    }, '__esModule', {value: true});

    // https://mathiasbynens.be/notes/javascript-encoding
    // https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
    function ucs2length(str) {
        const len = str.length;
        let length = 0;
        let pos = 0;
        let value;
        while (pos < len) {
            length++;
            value = str.charCodeAt(pos++);
            if (value >= 0xd800 && value <= 0xdbff && pos < len) {
                // high surrogate, and there is a next character
                value = str.charCodeAt(pos);
                if ((value & 0xfc00) === 0xdc00)
                    pos++; // low surrogate
            }
        }
        return length;
    }
    var _default$s = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';


    var ucs2length_1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$s
    }, '__esModule', {value: true});

    const error$f = {
        message({ keyword, schemaCode }) {
            const comp = keyword === "maxLength" ? "more" : "fewer";
            return codegen.str `must NOT have ${comp} than ${schemaCode} characters`;
        },
        params: ({ schemaCode }) => codegen._ `{limit: ${schemaCode}}`,
    };
    const def$m = {
        keyword: ["maxLength", "minLength"],
        type: "string",
        schemaType: "number",
        $data: true,
        error: error$f,
        code(cxt) {
            const { keyword, data, schemaCode, it } = cxt;
            const op = keyword === "maxLength" ? codegen.operators.GT : codegen.operators.LT;
            const len = it.opts.unicode === false ? codegen._ `${data}.length` : codegen._ `${util.useFunc(cxt.gen, ucs2length_1.default)}(${data})`;
            cxt.fail$data(codegen._ `${len} ${op} ${schemaCode}`);
        },
    };
    var _default$r = def$m;


    var limitLength = /*#__PURE__*/Object.defineProperty({
    	default: _default$r
    }, '__esModule', {value: true});

    const error$e = {
        message: ({ schemaCode }) => codegen.str `must match pattern "${schemaCode}"`,
        params: ({ schemaCode }) => codegen._ `{pattern: ${schemaCode}}`,
    };
    const def$l = {
        keyword: "pattern",
        type: "string",
        schemaType: "string",
        $data: true,
        error: error$e,
        code(cxt) {
            const { data, $data, schema, schemaCode, it } = cxt;
            // TODO regexp should be wrapped in try/catchs
            const u = it.opts.unicodeRegExp ? "u" : "";
            const regExp = $data ? codegen._ `(new RegExp(${schemaCode}, ${u}))` : code.usePattern(cxt, schema);
            cxt.fail$data(codegen._ `!${regExp}.test(${data})`);
        },
    };
    var _default$q = def$l;


    var pattern = /*#__PURE__*/Object.defineProperty({
    	default: _default$q
    }, '__esModule', {value: true});

    const error$d = {
        message({ keyword, schemaCode }) {
            const comp = keyword === "maxProperties" ? "more" : "fewer";
            return codegen.str `must NOT have ${comp} than ${schemaCode} items`;
        },
        params: ({ schemaCode }) => codegen._ `{limit: ${schemaCode}}`,
    };
    const def$k = {
        keyword: ["maxProperties", "minProperties"],
        type: "object",
        schemaType: "number",
        $data: true,
        error: error$d,
        code(cxt) {
            const { keyword, data, schemaCode } = cxt;
            const op = keyword === "maxProperties" ? codegen.operators.GT : codegen.operators.LT;
            cxt.fail$data(codegen._ `Object.keys(${data}).length ${op} ${schemaCode}`);
        },
    };
    var _default$p = def$k;


    var limitProperties = /*#__PURE__*/Object.defineProperty({
    	default: _default$p
    }, '__esModule', {value: true});

    const error$c = {
        message: ({ params: { missingProperty } }) => codegen.str `must have required property '${missingProperty}'`,
        params: ({ params: { missingProperty } }) => codegen._ `{missingProperty: ${missingProperty}}`,
    };
    const def$j = {
        keyword: "required",
        type: "object",
        schemaType: "array",
        $data: true,
        error: error$c,
        code(cxt) {
            const { gen, schema, schemaCode, data, $data, it } = cxt;
            const { opts } = it;
            if (!$data && schema.length === 0)
                return;
            const useLoop = schema.length >= opts.loopRequired;
            if (it.allErrors)
                allErrorsMode();
            else
                exitOnErrorMode();
            if (opts.strictRequired) {
                const props = cxt.parentSchema.properties;
                const { definedProperties } = cxt.it;
                for (const requiredKey of schema) {
                    if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
                        const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                        const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
                        util.checkStrictMode(it, msg, it.opts.strictRequired);
                    }
                }
            }
            function allErrorsMode() {
                if (useLoop || $data) {
                    cxt.block$data(codegen.nil, loopAllRequired);
                }
                else {
                    for (const prop of schema) {
                        code.checkReportMissingProp(cxt, prop);
                    }
                }
            }
            function exitOnErrorMode() {
                const missing = gen.let("missing");
                if (useLoop || $data) {
                    const valid = gen.let("valid", true);
                    cxt.block$data(valid, () => loopUntilMissing(missing, valid));
                    cxt.ok(valid);
                }
                else {
                    gen.if(code.checkMissingProp(cxt, schema, missing));
                    code.reportMissingProp(cxt, missing);
                    gen.else();
                }
            }
            function loopAllRequired() {
                gen.forOf("prop", schemaCode, (prop) => {
                    cxt.setParams({ missingProperty: prop });
                    gen.if(code.noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error());
                });
            }
            function loopUntilMissing(missing, valid) {
                cxt.setParams({ missingProperty: missing });
                gen.forOf(missing, schemaCode, () => {
                    gen.assign(valid, code.propertyInData(gen, data, missing, opts.ownProperties));
                    gen.if(codegen.not(valid), () => {
                        cxt.error();
                        gen.break();
                    });
                }, codegen.nil);
            }
        },
    };
    var _default$o = def$j;


    var required = /*#__PURE__*/Object.defineProperty({
    	default: _default$o
    }, '__esModule', {value: true});

    const error$b = {
        message({ keyword, schemaCode }) {
            const comp = keyword === "maxItems" ? "more" : "fewer";
            return codegen.str `must NOT have ${comp} than ${schemaCode} items`;
        },
        params: ({ schemaCode }) => codegen._ `{limit: ${schemaCode}}`,
    };
    const def$i = {
        keyword: ["maxItems", "minItems"],
        type: "array",
        schemaType: "number",
        $data: true,
        error: error$b,
        code(cxt) {
            const { keyword, data, schemaCode } = cxt;
            const op = keyword === "maxItems" ? codegen.operators.GT : codegen.operators.LT;
            cxt.fail$data(codegen._ `${data}.length ${op} ${schemaCode}`);
        },
    };
    var _default$n = def$i;


    var limitItems = /*#__PURE__*/Object.defineProperty({
    	default: _default$n
    }, '__esModule', {value: true});

    // https://github.com/ajv-validator/ajv/issues/889

    fastDeepEqual.code = 'require("ajv/dist/runtime/equal").default';
    var _default$m = fastDeepEqual;


    var equal_1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$m
    }, '__esModule', {value: true});

    const error$a = {
        message: ({ params: { i, j } }) => codegen.str `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
        params: ({ params: { i, j } }) => codegen._ `{i: ${i}, j: ${j}}`,
    };
    const def$h = {
        keyword: "uniqueItems",
        type: "array",
        schemaType: "boolean",
        $data: true,
        error: error$a,
        code(cxt) {
            const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
            if (!$data && !schema)
                return;
            const valid = gen.let("valid");
            const itemTypes = parentSchema.items ? dataType.getSchemaTypes(parentSchema.items) : [];
            cxt.block$data(valid, validateUniqueItems, codegen._ `${schemaCode} === false`);
            cxt.ok(valid);
            function validateUniqueItems() {
                const i = gen.let("i", codegen._ `${data}.length`);
                const j = gen.let("j");
                cxt.setParams({ i, j });
                gen.assign(valid, true);
                gen.if(codegen._ `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
            }
            function canOptimize() {
                return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
            }
            function loopN(i, j) {
                const item = gen.name("item");
                const wrongType = dataType.checkDataTypes(itemTypes, item, it.opts.strictNumbers, dataType.DataType.Wrong);
                const indices = gen.const("indices", codegen._ `{}`);
                gen.for(codegen._ `;${i}--;`, () => {
                    gen.let(item, codegen._ `${data}[${i}]`);
                    gen.if(wrongType, codegen._ `continue`);
                    if (itemTypes.length > 1)
                        gen.if(codegen._ `typeof ${item} == "string"`, codegen._ `${item} += "_"`);
                    gen
                        .if(codegen._ `typeof ${indices}[${item}] == "number"`, () => {
                        gen.assign(j, codegen._ `${indices}[${item}]`);
                        cxt.error();
                        gen.assign(valid, false).break();
                    })
                        .code(codegen._ `${indices}[${item}] = ${i}`);
                });
            }
            function loopN2(i, j) {
                const eql = util.useFunc(gen, equal_1.default);
                const outer = gen.name("outer");
                gen.label(outer).for(codegen._ `;${i}--;`, () => gen.for(codegen._ `${j} = ${i}; ${j}--;`, () => gen.if(codegen._ `${eql}(${data}[${i}], ${data}[${j}])`, () => {
                    cxt.error();
                    gen.assign(valid, false).break(outer);
                })));
            }
        },
    };
    var _default$l = def$h;


    var uniqueItems = /*#__PURE__*/Object.defineProperty({
    	default: _default$l
    }, '__esModule', {value: true});

    const error$9 = {
        message: "must be equal to constant",
        params: ({ schemaCode }) => codegen._ `{allowedValue: ${schemaCode}}`,
    };
    const def$g = {
        keyword: "const",
        $data: true,
        error: error$9,
        code(cxt) {
            const { gen, data, $data, schemaCode, schema } = cxt;
            if ($data || (schema && typeof schema == "object")) {
                cxt.fail$data(codegen._ `!${util.useFunc(gen, equal_1.default)}(${data}, ${schemaCode})`);
            }
            else {
                cxt.fail(codegen._ `${schema} !== ${data}`);
            }
        },
    };
    var _default$k = def$g;


    var _const = /*#__PURE__*/Object.defineProperty({
    	default: _default$k
    }, '__esModule', {value: true});

    const error$8 = {
        message: "must be equal to one of the allowed values",
        params: ({ schemaCode }) => codegen._ `{allowedValues: ${schemaCode}}`,
    };
    const def$f = {
        keyword: "enum",
        schemaType: "array",
        $data: true,
        error: error$8,
        code(cxt) {
            const { gen, data, $data, schema, schemaCode, it } = cxt;
            if (!$data && schema.length === 0)
                throw new Error("enum must have non-empty array");
            const useLoop = schema.length >= it.opts.loopEnum;
            const eql = util.useFunc(gen, equal_1.default);
            let valid;
            if (useLoop || $data) {
                valid = gen.let("valid");
                cxt.block$data(valid, loopEnum);
            }
            else {
                /* istanbul ignore if */
                if (!Array.isArray(schema))
                    throw new Error("ajv implementation error");
                const vSchema = gen.const("vSchema", schemaCode);
                valid = codegen.or(...schema.map((_x, i) => equalCode(vSchema, i)));
            }
            cxt.pass(valid);
            function loopEnum() {
                gen.assign(valid, false);
                gen.forOf("v", schemaCode, (v) => gen.if(codegen._ `${eql}(${data}, ${v})`, () => gen.assign(valid, true).break()));
            }
            function equalCode(vSchema, i) {
                const sch = schema[i];
                return typeof sch === "object" && sch !== null
                    ? codegen._ `${eql}(${data}, ${vSchema}[${i}])`
                    : codegen._ `${data} === ${sch}`;
            }
        },
    };
    var _default$j = def$f;


    var _enum = /*#__PURE__*/Object.defineProperty({
    	default: _default$j
    }, '__esModule', {value: true});

    const validation = [
        // number
        limitNumber.default,
        multipleOf.default,
        // string
        limitLength.default,
        pattern.default,
        // object
        limitProperties.default,
        required.default,
        // array
        limitItems.default,
        uniqueItems.default,
        // any
        { keyword: "type", schemaType: ["string", "array"] },
        { keyword: "nullable", schemaType: "boolean" },
        _const.default,
        _enum.default,
    ];
    var _default$i = validation;


    var validation_1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$i
    }, '__esModule', {value: true});

    var additionalItems = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAdditionalItems = void 0;


    const error = {
        message: ({ params: { len } }) => codegen.str `must NOT have more than ${len} items`,
        params: ({ params: { len } }) => codegen._ `{limit: ${len}}`,
    };
    const def = {
        keyword: "additionalItems",
        type: "array",
        schemaType: ["boolean", "object"],
        before: "uniqueItems",
        error,
        code(cxt) {
            const { parentSchema, it } = cxt;
            const { items } = parentSchema;
            if (!Array.isArray(items)) {
                util.checkStrictMode(it, '"additionalItems" is ignored when "items" is not an array of schemas');
                return;
            }
            validateAdditionalItems(cxt, items);
        },
    };
    function validateAdditionalItems(cxt, items) {
        const { gen, schema, data, keyword, it } = cxt;
        it.items = true;
        const len = gen.const("len", codegen._ `${data}.length`);
        if (schema === false) {
            cxt.setParams({ len: items.length });
            cxt.pass(codegen._ `${len} <= ${items.length}`);
        }
        else if (typeof schema == "object" && !util.alwaysValidSchema(it, schema)) {
            const valid = gen.var("valid", codegen._ `${len} <= ${items.length}`); // TODO var
            gen.if(codegen.not(valid), () => validateItems(valid));
            cxt.ok(valid);
        }
        function validateItems(valid) {
            gen.forRange("i", items.length, len, (i) => {
                cxt.subschema({ keyword, dataProp: i, dataPropType: util.Type.Num }, valid);
                if (!it.allErrors)
                    gen.if(codegen.not(valid), () => gen.break());
            });
        }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;

    });

    var items = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTuple = void 0;



    const def = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "array", "boolean"],
        before: "uniqueItems",
        code(cxt) {
            const { schema, it } = cxt;
            if (Array.isArray(schema))
                return validateTuple(cxt, "additionalItems", schema);
            it.items = true;
            if (util.alwaysValidSchema(it, schema))
                return;
            cxt.ok(code.validateArray(cxt));
        },
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
        const { gen, parentSchema, data, keyword, it } = cxt;
        checkStrictTuple(parentSchema);
        if (it.opts.unevaluated && schArr.length && it.items !== true) {
            it.items = util.mergeEvaluated.items(gen, schArr.length, it.items);
        }
        const valid = gen.name("valid");
        const len = gen.const("len", codegen._ `${data}.length`);
        schArr.forEach((sch, i) => {
            if (util.alwaysValidSchema(it, sch))
                return;
            gen.if(codegen._ `${len} > ${i}`, () => cxt.subschema({
                keyword,
                schemaProp: i,
                dataProp: i,
            }, valid));
            cxt.ok(valid);
        });
        function checkStrictTuple(sch) {
            const { opts, errSchemaPath } = it;
            const l = schArr.length;
            const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
            if (opts.strictTuples && !fullTuple) {
                const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
                util.checkStrictMode(it, msg, opts.strictTuples);
            }
        }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;

    });

    const def$e = {
        keyword: "prefixItems",
        type: "array",
        schemaType: ["array"],
        before: "uniqueItems",
        code: (cxt) => items.validateTuple(cxt, "items"),
    };
    var _default$h = def$e;


    var prefixItems = /*#__PURE__*/Object.defineProperty({
    	default: _default$h
    }, '__esModule', {value: true});

    const error$7 = {
        message: ({ params: { len } }) => codegen.str `must NOT have more than ${len} items`,
        params: ({ params: { len } }) => codegen._ `{limit: ${len}}`,
    };
    const def$d = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        error: error$7,
        code(cxt) {
            const { schema, parentSchema, it } = cxt;
            const { prefixItems } = parentSchema;
            it.items = true;
            if (util.alwaysValidSchema(it, schema))
                return;
            if (prefixItems)
                additionalItems.validateAdditionalItems(cxt, prefixItems);
            else
                cxt.ok(code.validateArray(cxt));
        },
    };
    var _default$g = def$d;


    var items2020 = /*#__PURE__*/Object.defineProperty({
    	default: _default$g
    }, '__esModule', {value: true});

    const error$6 = {
        message: ({ params: { min, max } }) => max === undefined
            ? codegen.str `must contain at least ${min} valid item(s)`
            : codegen.str `must contain at least ${min} and no more than ${max} valid item(s)`,
        params: ({ params: { min, max } }) => max === undefined ? codegen._ `{minContains: ${min}}` : codegen._ `{minContains: ${min}, maxContains: ${max}}`,
    };
    const def$c = {
        keyword: "contains",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        trackErrors: true,
        error: error$6,
        code(cxt) {
            const { gen, schema, parentSchema, data, it } = cxt;
            let min;
            let max;
            const { minContains, maxContains } = parentSchema;
            if (it.opts.next) {
                min = minContains === undefined ? 1 : minContains;
                max = maxContains;
            }
            else {
                min = 1;
            }
            const len = gen.const("len", codegen._ `${data}.length`);
            cxt.setParams({ min, max });
            if (max === undefined && min === 0) {
                util.checkStrictMode(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
                return;
            }
            if (max !== undefined && min > max) {
                util.checkStrictMode(it, `"minContains" > "maxContains" is always invalid`);
                cxt.fail();
                return;
            }
            if (util.alwaysValidSchema(it, schema)) {
                let cond = codegen._ `${len} >= ${min}`;
                if (max !== undefined)
                    cond = codegen._ `${cond} && ${len} <= ${max}`;
                cxt.pass(cond);
                return;
            }
            it.items = true;
            const valid = gen.name("valid");
            if (max === undefined && min === 1) {
                validateItems(valid, () => gen.if(valid, () => gen.break()));
            }
            else {
                gen.let(valid, false);
                const schValid = gen.name("_valid");
                const count = gen.let("count", 0);
                validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
            }
            cxt.result(valid, () => cxt.reset());
            function validateItems(_valid, block) {
                gen.forRange("i", 0, len, (i) => {
                    cxt.subschema({
                        keyword: "contains",
                        dataProp: i,
                        dataPropType: util.Type.Num,
                        compositeRule: true,
                    }, _valid);
                    block();
                });
            }
            function checkLimits(count) {
                gen.code(codegen._ `${count}++`);
                if (max === undefined) {
                    gen.if(codegen._ `${count} >= ${min}`, () => gen.assign(valid, true).break());
                }
                else {
                    gen.if(codegen._ `${count} > ${max}`, () => gen.assign(valid, false).break());
                    if (min === 1)
                        gen.assign(valid, true);
                    else
                        gen.if(codegen._ `${count} >= ${min}`, () => gen.assign(valid, true));
                }
            }
        },
    };
    var _default$f = def$c;


    var contains = /*#__PURE__*/Object.defineProperty({
    	default: _default$f
    }, '__esModule', {value: true});

    var dependencies = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;



    exports.error = {
        message: ({ params: { property, depsCount, deps } }) => {
            const property_ies = depsCount === 1 ? "property" : "properties";
            return codegen.str `must have ${property_ies} ${deps} when property ${property} is present`;
        },
        params: ({ params: { property, depsCount, deps, missingProperty } }) => codegen._ `{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`, // TODO change to reference
    };
    const def = {
        keyword: "dependencies",
        type: "object",
        schemaType: "object",
        error: exports.error,
        code(cxt) {
            const [propDeps, schDeps] = splitDependencies(cxt);
            validatePropertyDeps(cxt, propDeps);
            validateSchemaDeps(cxt, schDeps);
        },
    };
    function splitDependencies({ schema }) {
        const propertyDeps = {};
        const schemaDeps = {};
        for (const key in schema) {
            if (key === "__proto__")
                continue;
            const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
            deps[key] = schema[key];
        }
        return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
        const { gen, data, it } = cxt;
        if (Object.keys(propertyDeps).length === 0)
            return;
        const missing = gen.let("missing");
        for (const prop in propertyDeps) {
            const deps = propertyDeps[prop];
            if (deps.length === 0)
                continue;
            const hasProperty = code.propertyInData(gen, data, prop, it.opts.ownProperties);
            cxt.setParams({
                property: prop,
                depsCount: deps.length,
                deps: deps.join(", "),
            });
            if (it.allErrors) {
                gen.if(hasProperty, () => {
                    for (const depProp of deps) {
                        code.checkReportMissingProp(cxt, depProp);
                    }
                });
            }
            else {
                gen.if(codegen._ `${hasProperty} && (${code.checkMissingProp(cxt, deps, missing)})`);
                code.reportMissingProp(cxt, missing);
                gen.else();
            }
        }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
        const { gen, data, keyword, it } = cxt;
        const valid = gen.name("valid");
        for (const prop in schemaDeps) {
            if (util.alwaysValidSchema(it, schemaDeps[prop]))
                continue;
            gen.if(code.propertyInData(gen, data, prop, it.opts.ownProperties), () => {
                const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
                cxt.mergeValidEvaluated(schCxt, valid);
            }, () => gen.var(valid, true) // TODO var
            );
            cxt.ok(valid);
        }
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;

    });

    const error$5 = {
        message: "property name must be valid",
        params: ({ params }) => codegen._ `{propertyName: ${params.propertyName}}`,
    };
    const def$b = {
        keyword: "propertyNames",
        type: "object",
        schemaType: ["object", "boolean"],
        error: error$5,
        code(cxt) {
            const { gen, schema, data, it } = cxt;
            if (util.alwaysValidSchema(it, schema))
                return;
            const valid = gen.name("valid");
            gen.forIn("key", data, (key) => {
                cxt.setParams({ propertyName: key });
                cxt.subschema({
                    keyword: "propertyNames",
                    data: key,
                    dataTypes: ["string"],
                    propertyName: key,
                    compositeRule: true,
                }, valid);
                gen.if(codegen.not(valid), () => {
                    cxt.error(true);
                    if (!it.allErrors)
                        gen.break();
                });
            });
            cxt.ok(valid);
        },
    };
    var _default$e = def$b;


    var propertyNames = /*#__PURE__*/Object.defineProperty({
    	default: _default$e
    }, '__esModule', {value: true});

    const error$4 = {
        message: "must NOT have additional properties",
        params: ({ params }) => codegen._ `{additionalProperty: ${params.additionalProperty}}`,
    };
    const def$a = {
        keyword: "additionalProperties",
        type: ["object"],
        schemaType: ["boolean", "object"],
        allowUndefined: true,
        trackErrors: true,
        error: error$4,
        code(cxt) {
            const { gen, schema, parentSchema, data, errsCount, it } = cxt;
            /* istanbul ignore if */
            if (!errsCount)
                throw new Error("ajv implementation error");
            const { allErrors, opts } = it;
            it.props = true;
            if (opts.removeAdditional !== "all" && util.alwaysValidSchema(it, schema))
                return;
            const props = code.allSchemaProperties(parentSchema.properties);
            const patProps = code.allSchemaProperties(parentSchema.patternProperties);
            checkAdditionalProperties();
            cxt.ok(codegen._ `${errsCount} === ${names_1.default.errors}`);
            function checkAdditionalProperties() {
                gen.forIn("key", data, (key) => {
                    if (!props.length && !patProps.length)
                        additionalPropertyCode(key);
                    else
                        gen.if(isAdditional(key), () => additionalPropertyCode(key));
                });
            }
            function isAdditional(key) {
                let definedProp;
                if (props.length > 8) {
                    // TODO maybe an option instead of hard-coded 8?
                    const propsSchema = util.schemaRefOrVal(it, parentSchema.properties, "properties");
                    definedProp = code.isOwnProperty(gen, propsSchema, key);
                }
                else if (props.length) {
                    definedProp = codegen.or(...props.map((p) => codegen._ `${key} === ${p}`));
                }
                else {
                    definedProp = codegen.nil;
                }
                if (patProps.length) {
                    definedProp = codegen.or(definedProp, ...patProps.map((p) => codegen._ `${code.usePattern(cxt, p)}.test(${key})`));
                }
                return codegen.not(definedProp);
            }
            function deleteAdditional(key) {
                gen.code(codegen._ `delete ${data}[${key}]`);
            }
            function additionalPropertyCode(key) {
                if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
                    deleteAdditional(key);
                    return;
                }
                if (schema === false) {
                    cxt.setParams({ additionalProperty: key });
                    cxt.error();
                    if (!allErrors)
                        gen.break();
                    return;
                }
                if (typeof schema == "object" && !util.alwaysValidSchema(it, schema)) {
                    const valid = gen.name("valid");
                    if (opts.removeAdditional === "failing") {
                        applyAdditionalSchema(key, valid, false);
                        gen.if(codegen.not(valid), () => {
                            cxt.reset();
                            deleteAdditional(key);
                        });
                    }
                    else {
                        applyAdditionalSchema(key, valid);
                        if (!allErrors)
                            gen.if(codegen.not(valid), () => gen.break());
                    }
                }
            }
            function applyAdditionalSchema(key, valid, errors) {
                const subschema = {
                    keyword: "additionalProperties",
                    dataProp: key,
                    dataPropType: util.Type.Str,
                };
                if (errors === false) {
                    Object.assign(subschema, {
                        compositeRule: true,
                        createErrors: false,
                        allErrors: false,
                    });
                }
                cxt.subschema(subschema, valid);
            }
        },
    };
    var _default$d = def$a;


    var additionalProperties = /*#__PURE__*/Object.defineProperty({
    	default: _default$d
    }, '__esModule', {value: true});

    const def$9 = {
        keyword: "properties",
        type: "object",
        schemaType: "object",
        code(cxt) {
            const { gen, schema, parentSchema, data, it } = cxt;
            if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
                additionalProperties.default.code(new validate.KeywordCxt(it, additionalProperties.default, "additionalProperties"));
            }
            const allProps = code.allSchemaProperties(schema);
            for (const prop of allProps) {
                it.definedProperties.add(prop);
            }
            if (it.opts.unevaluated && allProps.length && it.props !== true) {
                it.props = util.mergeEvaluated.props(gen, util.toHash(allProps), it.props);
            }
            const properties = allProps.filter((p) => !util.alwaysValidSchema(it, schema[p]));
            if (properties.length === 0)
                return;
            const valid = gen.name("valid");
            for (const prop of properties) {
                if (hasDefault(prop)) {
                    applyPropertySchema(prop);
                }
                else {
                    gen.if(code.propertyInData(gen, data, prop, it.opts.ownProperties));
                    applyPropertySchema(prop);
                    if (!it.allErrors)
                        gen.else().var(valid, true);
                    gen.endIf();
                }
                cxt.it.definedProperties.add(prop);
                cxt.ok(valid);
            }
            function hasDefault(prop) {
                return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
            }
            function applyPropertySchema(prop) {
                cxt.subschema({
                    keyword: "properties",
                    schemaProp: prop,
                    dataProp: prop,
                }, valid);
            }
        },
    };
    var _default$c = def$9;


    var properties$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$c
    }, '__esModule', {value: true});

    const util_2 = util;
    const def$8 = {
        keyword: "patternProperties",
        type: "object",
        schemaType: "object",
        code(cxt) {
            const { gen, schema, data, parentSchema, it } = cxt;
            const { opts } = it;
            const patterns = code.schemaProperties(it, schema);
            // TODO mark properties matching patterns with always valid schemas as evaluated
            if (patterns.length === 0)
                return;
            const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
            const valid = gen.name("valid");
            if (it.props !== true && !(it.props instanceof codegen.Name)) {
                it.props = util_2.evaluatedPropsToName(gen, it.props);
            }
            const { props } = it;
            validatePatternProperties();
            function validatePatternProperties() {
                for (const pat of patterns) {
                    if (checkProperties)
                        checkMatchingProperties(pat);
                    if (it.allErrors) {
                        validateProperties(pat);
                    }
                    else {
                        gen.var(valid, true); // TODO var
                        validateProperties(pat);
                        gen.if(valid);
                    }
                }
            }
            function checkMatchingProperties(pat) {
                for (const prop in checkProperties) {
                    if (new RegExp(pat).test(prop)) {
                        util.checkStrictMode(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
                    }
                }
            }
            function validateProperties(pat) {
                gen.forIn("key", data, (key) => {
                    gen.if(codegen._ `${code.usePattern(cxt, pat)}.test(${key})`, () => {
                        cxt.subschema({
                            keyword: "patternProperties",
                            schemaProp: pat,
                            dataProp: key,
                            dataPropType: util_2.Type.Str,
                        }, valid);
                        if (it.opts.unevaluated && props !== true) {
                            gen.assign(codegen._ `${props}[${key}]`, true);
                        }
                        else if (!it.allErrors) {
                            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
                            // or if all properties were evaluated (props === true)
                            gen.if(codegen.not(valid), () => gen.break());
                        }
                    });
                });
            }
        },
    };
    var _default$b = def$8;


    var patternProperties = /*#__PURE__*/Object.defineProperty({
    	default: _default$b
    }, '__esModule', {value: true});

    const def$7 = {
        keyword: "not",
        schemaType: ["object", "boolean"],
        trackErrors: true,
        code(cxt) {
            const { gen, schema, it } = cxt;
            if (util.alwaysValidSchema(it, schema)) {
                cxt.fail();
                return;
            }
            const valid = gen.name("valid");
            cxt.subschema({
                keyword: "not",
                compositeRule: true,
                createErrors: false,
                allErrors: false,
            }, valid);
            cxt.result(valid, () => cxt.error(), () => cxt.reset());
        },
        error: { message: "must NOT be valid" },
    };
    var _default$a = def$7;


    var not = /*#__PURE__*/Object.defineProperty({
    	default: _default$a
    }, '__esModule', {value: true});

    const def$6 = {
        keyword: "anyOf",
        schemaType: "array",
        trackErrors: true,
        code: code.validateUnion,
        error: { message: "must match a schema in anyOf" },
    };
    var _default$9 = def$6;


    var anyOf = /*#__PURE__*/Object.defineProperty({
    	default: _default$9
    }, '__esModule', {value: true});

    const error$3 = {
        message: "must match exactly one schema in oneOf",
        params: ({ params }) => codegen._ `{passingSchemas: ${params.passing}}`,
    };
    const def$5 = {
        keyword: "oneOf",
        schemaType: "array",
        trackErrors: true,
        error: error$3,
        code(cxt) {
            const { gen, schema, parentSchema, it } = cxt;
            /* istanbul ignore if */
            if (!Array.isArray(schema))
                throw new Error("ajv implementation error");
            if (it.opts.discriminator && parentSchema.discriminator)
                return;
            const schArr = schema;
            const valid = gen.let("valid", false);
            const passing = gen.let("passing", null);
            const schValid = gen.name("_valid");
            cxt.setParams({ passing });
            // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
            gen.block(validateOneOf);
            cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
            function validateOneOf() {
                schArr.forEach((sch, i) => {
                    let schCxt;
                    if (util.alwaysValidSchema(it, sch)) {
                        gen.var(schValid, true);
                    }
                    else {
                        schCxt = cxt.subschema({
                            keyword: "oneOf",
                            schemaProp: i,
                            compositeRule: true,
                        }, schValid);
                    }
                    if (i > 0) {
                        gen
                            .if(codegen._ `${schValid} && ${valid}`)
                            .assign(valid, false)
                            .assign(passing, codegen._ `[${passing}, ${i}]`)
                            .else();
                    }
                    gen.if(schValid, () => {
                        gen.assign(valid, true);
                        gen.assign(passing, i);
                        if (schCxt)
                            cxt.mergeEvaluated(schCxt, codegen.Name);
                    });
                });
            }
        },
    };
    var _default$8 = def$5;


    var oneOf = /*#__PURE__*/Object.defineProperty({
    	default: _default$8
    }, '__esModule', {value: true});

    const def$4 = {
        keyword: "allOf",
        schemaType: "array",
        code(cxt) {
            const { gen, schema, it } = cxt;
            /* istanbul ignore if */
            if (!Array.isArray(schema))
                throw new Error("ajv implementation error");
            const valid = gen.name("valid");
            schema.forEach((sch, i) => {
                if (util.alwaysValidSchema(it, sch))
                    return;
                const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
                cxt.ok(valid);
                cxt.mergeEvaluated(schCxt);
            });
        },
    };
    var _default$7 = def$4;


    var allOf = /*#__PURE__*/Object.defineProperty({
    	default: _default$7
    }, '__esModule', {value: true});

    const error$2 = {
        message: ({ params }) => codegen.str `must match "${params.ifClause}" schema`,
        params: ({ params }) => codegen._ `{failingKeyword: ${params.ifClause}}`,
    };
    const def$3 = {
        keyword: "if",
        schemaType: ["object", "boolean"],
        trackErrors: true,
        error: error$2,
        code(cxt) {
            const { gen, parentSchema, it } = cxt;
            if (parentSchema.then === undefined && parentSchema.else === undefined) {
                util.checkStrictMode(it, '"if" without "then" and "else" is ignored');
            }
            const hasThen = hasSchema(it, "then");
            const hasElse = hasSchema(it, "else");
            if (!hasThen && !hasElse)
                return;
            const valid = gen.let("valid", true);
            const schValid = gen.name("_valid");
            validateIf();
            cxt.reset();
            if (hasThen && hasElse) {
                const ifClause = gen.let("ifClause");
                cxt.setParams({ ifClause });
                gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
            }
            else if (hasThen) {
                gen.if(schValid, validateClause("then"));
            }
            else {
                gen.if(codegen.not(schValid), validateClause("else"));
            }
            cxt.pass(valid, () => cxt.error(true));
            function validateIf() {
                const schCxt = cxt.subschema({
                    keyword: "if",
                    compositeRule: true,
                    createErrors: false,
                    allErrors: false,
                }, schValid);
                cxt.mergeEvaluated(schCxt);
            }
            function validateClause(keyword, ifClause) {
                return () => {
                    const schCxt = cxt.subschema({ keyword }, schValid);
                    gen.assign(valid, schValid);
                    cxt.mergeValidEvaluated(schCxt, valid);
                    if (ifClause)
                        gen.assign(ifClause, codegen._ `${keyword}`);
                    else
                        cxt.setParams({ ifClause: keyword });
                };
            }
        },
    };
    function hasSchema(it, keyword) {
        const schema = it.schema[keyword];
        return schema !== undefined && !util.alwaysValidSchema(it, schema);
    }
    var _default$6 = def$3;


    var _if = /*#__PURE__*/Object.defineProperty({
    	default: _default$6
    }, '__esModule', {value: true});

    const def$2 = {
        keyword: ["then", "else"],
        schemaType: ["object", "boolean"],
        code({ keyword, parentSchema, it }) {
            if (parentSchema.if === undefined)
                util.checkStrictMode(it, `"${keyword}" without "if" is ignored`);
        },
    };
    var _default$5 = def$2;


    var thenElse = /*#__PURE__*/Object.defineProperty({
    	default: _default$5
    }, '__esModule', {value: true});

    function getApplicator(draft2020 = false) {
        const applicator = [
            // any
            not.default,
            anyOf.default,
            oneOf.default,
            allOf.default,
            _if.default,
            thenElse.default,
            // object
            propertyNames.default,
            additionalProperties.default,
            dependencies.default,
            properties$1.default,
            patternProperties.default,
        ];
        // array
        if (draft2020)
            applicator.push(prefixItems.default, items2020.default);
        else
            applicator.push(additionalItems.default, items.default);
        applicator.push(contains.default);
        return applicator;
    }
    var _default$4 = getApplicator;


    var applicator = /*#__PURE__*/Object.defineProperty({
    	default: _default$4
    }, '__esModule', {value: true});

    const error$1 = {
        message: ({ schemaCode }) => codegen.str `must match format "${schemaCode}"`,
        params: ({ schemaCode }) => codegen._ `{format: ${schemaCode}}`,
    };
    const def$1 = {
        keyword: "format",
        type: ["number", "string"],
        schemaType: "string",
        $data: true,
        error: error$1,
        code(cxt, ruleType) {
            const { gen, data, $data, schema, schemaCode, it } = cxt;
            const { opts, errSchemaPath, schemaEnv, self } = it;
            if (!opts.validateFormats)
                return;
            if ($data)
                validate$DataFormat();
            else
                validateFormat();
            function validate$DataFormat() {
                const fmts = gen.scopeValue("formats", {
                    ref: self.formats,
                    code: opts.code.formats,
                });
                const fDef = gen.const("fDef", codegen._ `${fmts}[${schemaCode}]`);
                const fType = gen.let("fType");
                const format = gen.let("format");
                // TODO simplify
                gen.if(codegen._ `typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, codegen._ `${fDef}.type || "string"`).assign(format, codegen._ `${fDef}.validate`), () => gen.assign(fType, codegen._ `"string"`).assign(format, fDef));
                cxt.fail$data(codegen.or(unknownFmt(), invalidFmt()));
                function unknownFmt() {
                    if (opts.strictSchema === false)
                        return codegen.nil;
                    return codegen._ `${schemaCode} && !${format}`;
                }
                function invalidFmt() {
                    const callFormat = schemaEnv.$async
                        ? codegen._ `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
                        : codegen._ `${format}(${data})`;
                    const validData = codegen._ `(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
                    return codegen._ `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
                }
            }
            function validateFormat() {
                const formatDef = self.formats[schema];
                if (!formatDef) {
                    unknownFormat();
                    return;
                }
                if (formatDef === true)
                    return;
                const [fmtType, format, fmtRef] = getFormat(formatDef);
                if (fmtType === ruleType)
                    cxt.pass(validCondition());
                function unknownFormat() {
                    if (opts.strictSchema === false) {
                        self.logger.warn(unknownMsg());
                        return;
                    }
                    throw new Error(unknownMsg());
                    function unknownMsg() {
                        return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
                    }
                }
                function getFormat(fmtDef) {
                    const code = fmtDef instanceof RegExp
                        ? codegen.regexpCode(fmtDef)
                        : opts.code.formats
                            ? codegen._ `${opts.code.formats}${codegen.getProperty(schema)}`
                            : undefined;
                    const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
                    if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                        return [fmtDef.type || "string", fmtDef.validate, codegen._ `${fmt}.validate`];
                    }
                    return ["string", fmtDef, fmt];
                }
                function validCondition() {
                    if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                        if (!schemaEnv.$async)
                            throw new Error("async format in sync schema");
                        return codegen._ `await ${fmtRef}(${data})`;
                    }
                    return typeof format == "function" ? codegen._ `${fmtRef}(${data})` : codegen._ `${fmtRef}.test(${data})`;
                }
            }
        },
    };
    var _default$3 = def$1;


    var format$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$3
    }, '__esModule', {value: true});

    const format = [format$1.default];
    var _default$2 = format;


    var format_2 = /*#__PURE__*/Object.defineProperty({
    	default: _default$2
    }, '__esModule', {value: true});

    var metadata = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
        "title",
        "description",
        "default",
        "deprecated",
        "readOnly",
        "writeOnly",
        "examples",
    ];
    exports.contentVocabulary = [
        "contentMediaType",
        "contentEncoding",
        "contentSchema",
    ];

    });

    const draft7Vocabularies = [
        core_1.default,
        validation_1.default,
        applicator.default(),
        format_2.default,
        metadata.metadataVocabulary,
        metadata.contentVocabulary,
    ];
    var _default$1 = draft7Vocabularies;


    var draft7 = /*#__PURE__*/Object.defineProperty({
    	default: _default$1
    }, '__esModule', {value: true});

    var types = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    (function (DiscrError) {
        DiscrError["Tag"] = "tag";
        DiscrError["Mapping"] = "mapping";
    })(exports.DiscrError || (exports.DiscrError = {}));

    });

    const error = {
        message: ({ params: { discrError, tagName } }) => discrError === types.DiscrError.Tag
            ? `tag "${tagName}" must be string`
            : `value of tag "${tagName}" must be in oneOf`,
        params: ({ params: { discrError, tag, tagName } }) => codegen._ `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
    };
    const def = {
        keyword: "discriminator",
        type: "object",
        schemaType: "object",
        error,
        code(cxt) {
            const { gen, data, schema, parentSchema, it } = cxt;
            const { oneOf } = parentSchema;
            if (!it.opts.discriminator) {
                throw new Error("discriminator: requires discriminator option");
            }
            const tagName = schema.propertyName;
            if (typeof tagName != "string")
                throw new Error("discriminator: requires propertyName");
            if (schema.mapping)
                throw new Error("discriminator: mapping is not supported");
            if (!oneOf)
                throw new Error("discriminator: requires oneOf keyword");
            const valid = gen.let("valid", false);
            const tag = gen.const("tag", codegen._ `${data}${codegen.getProperty(tagName)}`);
            gen.if(codegen._ `typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types.DiscrError.Tag, tag, tagName }));
            cxt.ok(valid);
            function validateMapping() {
                const mapping = getMapping();
                gen.if(false);
                for (const tagValue in mapping) {
                    gen.elseIf(codegen._ `${tag} === ${tagValue}`);
                    gen.assign(valid, applyTagSchema(mapping[tagValue]));
                }
                gen.else();
                cxt.error(false, { discrError: types.DiscrError.Mapping, tag, tagName });
                gen.endIf();
            }
            function applyTagSchema(schemaProp) {
                const _valid = gen.name("valid");
                const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
                cxt.mergeEvaluated(schCxt, codegen.Name);
                return _valid;
            }
            function getMapping() {
                var _a;
                const oneOfMapping = {};
                const topRequired = hasRequired(parentSchema);
                let tagRequired = true;
                for (let i = 0; i < oneOf.length; i++) {
                    const sch = oneOf[i];
                    const propSch = (_a = sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
                    if (typeof propSch != "object") {
                        throw new Error(`discriminator: oneOf schemas must have "properties/${tagName}"`);
                    }
                    tagRequired = tagRequired && (topRequired || hasRequired(sch));
                    addMappings(propSch, i);
                }
                if (!tagRequired)
                    throw new Error(`discriminator: "${tagName}" must be required`);
                return oneOfMapping;
                function hasRequired({ required }) {
                    return Array.isArray(required) && required.includes(tagName);
                }
                function addMappings(sch, i) {
                    if (sch.const) {
                        addMapping(sch.const, i);
                    }
                    else if (sch.enum) {
                        for (const tagValue of sch.enum) {
                            addMapping(tagValue, i);
                        }
                    }
                    else {
                        throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
                    }
                }
                function addMapping(tagValue, i) {
                    if (typeof tagValue != "string" || tagValue in oneOfMapping) {
                        throw new Error(`discriminator: "${tagName}" values must be unique strings`);
                    }
                    oneOfMapping[tagValue] = i;
                }
            }
        },
    };
    var _default = def;


    var discriminator = /*#__PURE__*/Object.defineProperty({
    	default: _default
    }, '__esModule', {value: true});

    var $schema = "http://json-schema.org/draft-07/schema#";
    var $id = "http://json-schema.org/draft-07/schema#";
    var title = "Core schema meta-schema";
    var definitions = {
    	schemaArray: {
    		type: "array",
    		minItems: 1,
    		items: {
    			$ref: "#"
    		}
    	},
    	nonNegativeInteger: {
    		type: "integer",
    		minimum: 0
    	},
    	nonNegativeIntegerDefault0: {
    		allOf: [
    			{
    				$ref: "#/definitions/nonNegativeInteger"
    			},
    			{
    				"default": 0
    			}
    		]
    	},
    	simpleTypes: {
    		"enum": [
    			"array",
    			"boolean",
    			"integer",
    			"null",
    			"number",
    			"object",
    			"string"
    		]
    	},
    	stringArray: {
    		type: "array",
    		items: {
    			type: "string"
    		},
    		uniqueItems: true,
    		"default": [
    		]
    	}
    };
    var type = [
    	"object",
    	"boolean"
    ];
    var properties = {
    	$id: {
    		type: "string",
    		format: "uri-reference"
    	},
    	$schema: {
    		type: "string",
    		format: "uri"
    	},
    	$ref: {
    		type: "string",
    		format: "uri-reference"
    	},
    	$comment: {
    		type: "string"
    	},
    	title: {
    		type: "string"
    	},
    	description: {
    		type: "string"
    	},
    	"default": true,
    	readOnly: {
    		type: "boolean",
    		"default": false
    	},
    	examples: {
    		type: "array",
    		items: true
    	},
    	multipleOf: {
    		type: "number",
    		exclusiveMinimum: 0
    	},
    	maximum: {
    		type: "number"
    	},
    	exclusiveMaximum: {
    		type: "number"
    	},
    	minimum: {
    		type: "number"
    	},
    	exclusiveMinimum: {
    		type: "number"
    	},
    	maxLength: {
    		$ref: "#/definitions/nonNegativeInteger"
    	},
    	minLength: {
    		$ref: "#/definitions/nonNegativeIntegerDefault0"
    	},
    	pattern: {
    		type: "string",
    		format: "regex"
    	},
    	additionalItems: {
    		$ref: "#"
    	},
    	items: {
    		anyOf: [
    			{
    				$ref: "#"
    			},
    			{
    				$ref: "#/definitions/schemaArray"
    			}
    		],
    		"default": true
    	},
    	maxItems: {
    		$ref: "#/definitions/nonNegativeInteger"
    	},
    	minItems: {
    		$ref: "#/definitions/nonNegativeIntegerDefault0"
    	},
    	uniqueItems: {
    		type: "boolean",
    		"default": false
    	},
    	contains: {
    		$ref: "#"
    	},
    	maxProperties: {
    		$ref: "#/definitions/nonNegativeInteger"
    	},
    	minProperties: {
    		$ref: "#/definitions/nonNegativeIntegerDefault0"
    	},
    	required: {
    		$ref: "#/definitions/stringArray"
    	},
    	additionalProperties: {
    		$ref: "#"
    	},
    	definitions: {
    		type: "object",
    		additionalProperties: {
    			$ref: "#"
    		},
    		"default": {
    		}
    	},
    	properties: {
    		type: "object",
    		additionalProperties: {
    			$ref: "#"
    		},
    		"default": {
    		}
    	},
    	patternProperties: {
    		type: "object",
    		additionalProperties: {
    			$ref: "#"
    		},
    		propertyNames: {
    			format: "regex"
    		},
    		"default": {
    		}
    	},
    	dependencies: {
    		type: "object",
    		additionalProperties: {
    			anyOf: [
    				{
    					$ref: "#"
    				},
    				{
    					$ref: "#/definitions/stringArray"
    				}
    			]
    		}
    	},
    	propertyNames: {
    		$ref: "#"
    	},
    	"const": true,
    	"enum": {
    		type: "array",
    		items: true,
    		minItems: 1,
    		uniqueItems: true
    	},
    	type: {
    		anyOf: [
    			{
    				$ref: "#/definitions/simpleTypes"
    			},
    			{
    				type: "array",
    				items: {
    					$ref: "#/definitions/simpleTypes"
    				},
    				minItems: 1,
    				uniqueItems: true
    			}
    		]
    	},
    	format: {
    		type: "string"
    	},
    	contentMediaType: {
    		type: "string"
    	},
    	contentEncoding: {
    		type: "string"
    	},
    	"if": {
    		$ref: "#"
    	},
    	then: {
    		$ref: "#"
    	},
    	"else": {
    		$ref: "#"
    	},
    	allOf: {
    		$ref: "#/definitions/schemaArray"
    	},
    	anyOf: {
    		$ref: "#/definitions/schemaArray"
    	},
    	oneOf: {
    		$ref: "#/definitions/schemaArray"
    	},
    	not: {
    		$ref: "#"
    	}
    };
    var draft7MetaSchema = {
    	$schema: $schema,
    	$id: $id,
    	title: title,
    	definitions: definitions,
    	type: type,
    	properties: properties,
    	"default": true
    };

    createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;




    const META_SUPPORT_DATA = ["/properties"];
    const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    class Ajv extends core$1.default {
        _addVocabularies() {
            super._addVocabularies();
            draft7.default.forEach((v) => this.addVocabulary(v));
            if (this.opts.discriminator)
                this.addKeyword(discriminator.default);
        }
        _addDefaultMetaSchema() {
            super._addDefaultMetaSchema();
            if (!this.opts.meta)
                return;
            const metaSchema = this.opts.$data
                ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
                : draft7MetaSchema;
            this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
            this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
        }
        defaultMeta() {
            return (this.opts.defaultMeta =
                super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
        }
    }
    module.exports = exports = Ajv;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv;

    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate.KeywordCxt; } });

    Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen._; } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen.str; } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen.stringify; } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen.nil; } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen.Name; } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen.CodeGen; } });

    });

    const JSONEditor = JSONEditor$1;

    /* src\components\JsonReader.svelte generated by Svelte v3.38.2 */
    const file$1 = "src\\components\\JsonReader.svelte";

    function create_fragment$2(ctx) {
    	let div;
    	let t0;
    	let t1_value = /*message*/ ctx[0].number + "";
    	let t1;
    	let t2;
    	let t3_value = /*message*/ ctx[0].event + "";
    	let t3;
    	let t4;
    	let jsoneditor;
    	let updating_json;
    	let current;

    	function jsoneditor_json_binding(value) {
    		/*jsoneditor_json_binding*/ ctx[3](value);
    	}

    	let jsoneditor_props = { mainMenuBar: /*mainMenuBar*/ ctx[1] };

    	if (/*json*/ ctx[2] !== void 0) {
    		jsoneditor_props.json = /*json*/ ctx[2];
    	}

    	jsoneditor = new JSONEditor({ props: jsoneditor_props, $$inline: true });
    	binding_callbacks.push(() => bind$2(jsoneditor, "json", jsoneditor_json_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("#");
    			t1 = text(t1_value);
    			t2 = text(" - ");
    			t3 = text(t3_value);
    			t4 = space();
    			create_component(jsoneditor.$$.fragment);
    			add_location(div, file$1, 7, 0, 168);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			append_dev(div, t3);
    			insert_dev(target, t4, anchor);
    			mount_component(jsoneditor, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*message*/ 1) && t1_value !== (t1_value = /*message*/ ctx[0].number + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty & /*message*/ 1) && t3_value !== (t3_value = /*message*/ ctx[0].event + "")) set_data_dev(t3, t3_value);
    			const jsoneditor_changes = {};
    			if (dirty & /*mainMenuBar*/ 2) jsoneditor_changes.mainMenuBar = /*mainMenuBar*/ ctx[1];

    			if (!updating_json && dirty & /*json*/ 4) {
    				updating_json = true;
    				jsoneditor_changes.json = /*json*/ ctx[2];
    				add_flush_callback(() => updating_json = false);
    			}

    			jsoneditor.$set(jsoneditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(jsoneditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(jsoneditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t4);
    			destroy_component(jsoneditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("JsonReader", slots, []);
    	let { message } = $$props;
    	let { mainMenuBar = false } = $$props;
    	let json = message.data;
    	const writable_props = ["message", "mainMenuBar"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<JsonReader> was created with unknown prop '${key}'`);
    	});

    	function jsoneditor_json_binding(value) {
    		json = value;
    		$$invalidate(2, json);
    	}

    	$$self.$$set = $$props => {
    		if ("message" in $$props) $$invalidate(0, message = $$props.message);
    		if ("mainMenuBar" in $$props) $$invalidate(1, mainMenuBar = $$props.mainMenuBar);
    	};

    	$$self.$capture_state = () => ({ JSONEditor, message, mainMenuBar, json });

    	$$self.$inject_state = $$props => {
    		if ("message" in $$props) $$invalidate(0, message = $$props.message);
    		if ("mainMenuBar" in $$props) $$invalidate(1, mainMenuBar = $$props.mainMenuBar);
    		if ("json" in $$props) $$invalidate(2, json = $$props.json);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [message, mainMenuBar, json, jsoneditor_json_binding];
    }

    class JsonReader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { message: 0, mainMenuBar: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "JsonReader",
    			options,
    			id: create_fragment$2.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*message*/ ctx[0] === undefined && !("message" in props)) {
    			console.warn("<JsonReader> was created without expected prop 'message'");
    		}
    	}

    	get message() {
    		throw new Error("<JsonReader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set message(value) {
    		throw new Error("<JsonReader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mainMenuBar() {
    		throw new Error("<JsonReader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mainMenuBar(value) {
    		throw new Error("<JsonReader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\SingleReader.svelte generated by Svelte v3.38.2 */

    function create_fragment$1(ctx) {
    	let jsoneditor;
    	let updating_json;
    	let current;

    	function jsoneditor_json_binding(value) {
    		/*jsoneditor_json_binding*/ ctx[1](value);
    	}

    	let jsoneditor_props = { mainMenuBar: mainMenuBar$1 };

    	if (/*json*/ ctx[0] !== void 0) {
    		jsoneditor_props.json = /*json*/ ctx[0];
    	}

    	jsoneditor = new JSONEditor({ props: jsoneditor_props, $$inline: true });
    	binding_callbacks.push(() => bind$2(jsoneditor, "json", jsoneditor_json_binding));

    	const block = {
    		c: function create() {
    			create_component(jsoneditor.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(jsoneditor, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const jsoneditor_changes = {};

    			if (!updating_json && dirty & /*json*/ 1) {
    				updating_json = true;
    				jsoneditor_changes.json = /*json*/ ctx[0];
    				add_flush_callback(() => updating_json = false);
    			}

    			jsoneditor.$set(jsoneditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(jsoneditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(jsoneditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(jsoneditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const mainMenuBar$1 = false;

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SingleReader", slots, []);
    	let { json } = $$props;
    	const writable_props = ["json"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SingleReader> was created with unknown prop '${key}'`);
    	});

    	function jsoneditor_json_binding(value) {
    		json = value;
    		$$invalidate(0, json);
    	}

    	$$self.$$set = $$props => {
    		if ("json" in $$props) $$invalidate(0, json = $$props.json);
    	};

    	$$self.$capture_state = () => ({ JSONEditor, mainMenuBar: mainMenuBar$1, json });

    	$$self.$inject_state = $$props => {
    		if ("json" in $$props) $$invalidate(0, json = $$props.json);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [json, jsoneditor_json_binding];
    }

    class SingleReader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { json: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SingleReader",
    			options,
    			id: create_fragment$1.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*json*/ ctx[0] === undefined && !("json" in props)) {
    			console.warn("<SingleReader> was created without expected prop 'json'");
    		}
    	}

    	get json() {
    		throw new Error("<SingleReader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set json(value) {
    		throw new Error("<SingleReader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\App.svelte generated by Svelte v3.38.2 */

    const { console: console_1 } = globals;
    const file = "src\\App.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[26] = list[i];
    	return child_ctx;
    }

    // (183:1) {:else}
    function create_else_block_2(ctx) {
    	let div;
    	let h2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h2 = element("h2");
    			h2.textContent = "You are not connected to anything yet.";
    			add_location(h2, file, 184, 3, 4387);
    			attr_dev(div, "class", "tile");
    			add_location(div, file, 183, 2, 4364);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h2);
    		},
    		p: noop$2,
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(183:1) {:else}",
    		ctx
    	});

    	return block;
    }

    // (137:1) {#if $connected}
    function create_if_block(ctx) {
    	let jsoneditor;
    	let updating_json;
    	let t0;
    	let div6;
    	let h3;
    	let t2;
    	let div5;
    	let div0;
    	let label0;
    	let input;
    	let t3;
    	let t4;
    	let div1;
    	let button;
    	let t6;
    	let div2;
    	let label1;
    	let t8;
    	let select;
    	let option;
    	let t10;
    	let div3;
    	let t11;
    	let div4;
    	let t12;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;

    	function jsoneditor_json_binding(value) {
    		/*jsoneditor_json_binding*/ ctx[13](value);
    	}

    	let jsoneditor_props = { onChange: /*jsonSave*/ ctx[11] };

    	if (/*jsonEditorValue*/ ctx[3] !== void 0) {
    		jsoneditor_props.json = /*jsonEditorValue*/ ctx[3];
    	}

    	jsoneditor = new JSONEditor({ props: jsoneditor_props, $$inline: true });
    	binding_callbacks.push(() => bind$2(jsoneditor, "json", jsoneditor_json_binding));
    	let each_value_1 = /*$history*/ ctx[4];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const if_block_creators = [create_if_block_1, create_else_block];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*SingleBox*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			create_component(jsoneditor.$$.fragment);
    			t0 = space();
    			div6 = element("div");
    			h3 = element("h3");
    			h3.textContent = "Received";
    			t2 = space();
    			div5 = element("div");
    			div0 = element("div");
    			label0 = element("label");
    			input = element("input");
    			t3 = text(" Single box");
    			t4 = space();
    			div1 = element("div");
    			button = element("button");
    			button.textContent = "delete";
    			t6 = space();
    			div2 = element("div");
    			label1 = element("label");
    			label1.textContent = "filter event:";
    			t8 = space();
    			select = element("select");
    			option = element("option");
    			option.textContent = "NONE";

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t10 = space();
    			div3 = element("div");
    			t11 = space();
    			div4 = element("div");
    			t12 = space();
    			if_block.c();
    			attr_dev(h3, "class", "subtitle is-3");
    			add_location(h3, file, 139, 3, 3233);
    			attr_dev(input, "type", "checkbox");
    			add_location(input, file, 143, 6, 3370);
    			add_location(label0, file, 142, 5, 3355);
    			attr_dev(div0, "class", "column");
    			add_location(div0, file, 141, 4, 3328);
    			attr_dev(button, "class", "is-info");
    			add_location(button, file, 151, 5, 3547);
    			attr_dev(div1, "class", "column");
    			add_location(div1, file, 150, 4, 3520);
    			attr_dev(label1, "for", "eventName");
    			add_location(label1, file, 160, 5, 3734);
    			option.__value = "";
    			option.value = option.__value;
    			add_location(option, file, 163, 6, 3884);
    			attr_dev(select, "id", "events");
    			if (/*eventFilter*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[16].call(select));
    			add_location(select, file, 162, 5, 3831);
    			attr_dev(div2, "class", "column");
    			add_location(div2, file, 159, 4, 3707);
    			attr_dev(div3, "class", "column");
    			add_location(div3, file, 169, 4, 4040);
    			attr_dev(div4, "class", "column");
    			add_location(div4, file, 170, 4, 4068);
    			attr_dev(div5, "name", "receivedControls");
    			attr_dev(div5, "class", "columns");
    			add_location(div5, file, 140, 3, 3277);
    			attr_dev(div6, "id", "receivedData");
    			add_location(div6, file, 138, 2, 3205);
    		},
    		m: function mount(target, anchor) {
    			mount_component(jsoneditor, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div6, anchor);
    			append_dev(div6, h3);
    			append_dev(div6, t2);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			append_dev(div0, label0);
    			append_dev(label0, input);
    			input.checked = /*SingleBox*/ ctx[2];
    			append_dev(label0, t3);
    			append_dev(div5, t4);
    			append_dev(div5, div1);
    			append_dev(div1, button);
    			append_dev(div5, t6);
    			append_dev(div5, div2);
    			append_dev(div2, label1);
    			append_dev(div2, t8);
    			append_dev(div2, select);
    			append_dev(select, option);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*eventFilter*/ ctx[0]);
    			append_dev(div5, t10);
    			append_dev(div5, div3);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div6, t12);
    			if_blocks[current_block_type_index].m(div6, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*input_change_handler*/ ctx[14]),
    					listen_dev(input, "click", /*saveSingleBox*/ ctx[12], false, false, false),
    					listen_dev(button, "click", /*click_handler*/ ctx[15], false, false, false),
    					listen_dev(select, "change", /*select_change_handler*/ ctx[16])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const jsoneditor_changes = {};

    			if (!updating_json && dirty & /*jsonEditorValue*/ 8) {
    				updating_json = true;
    				jsoneditor_changes.json = /*jsonEditorValue*/ ctx[3];
    				add_flush_callback(() => updating_json = false);
    			}

    			jsoneditor.$set(jsoneditor_changes);

    			if (dirty & /*SingleBox*/ 4) {
    				input.checked = /*SingleBox*/ ctx[2];
    			}

    			if (dirty & /*$history*/ 16) {
    				each_value_1 = /*$history*/ ctx[4];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (dirty & /*eventFilter, $history*/ 17) {
    				select_option(select, /*eventFilter*/ ctx[0]);
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div6, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(jsoneditor.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(jsoneditor.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(jsoneditor, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div6);
    			destroy_each(each_blocks, detaching);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(137:1) {#if $connected}",
    		ctx
    	});

    	return block;
    }

    // (165:6) {#each $history as item}
    function create_each_block_1(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[26] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[26];
    			option.value = option.__value;
    			add_location(option, file, 165, 7, 3955);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$history*/ 16 && t_value !== (t_value = /*item*/ ctx[26] + "")) set_data_dev(t, t_value);

    			if (dirty & /*$history*/ 16 && option_value_value !== (option_value_value = /*item*/ ctx[26])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(165:6) {#each $history as item}",
    		ctx
    	});

    	return block;
    }

    // (175:3) {:else}
    function create_else_block(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*filteredMessages*/ ctx[7];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let each_1_else = null;

    	if (!each_value.length) {
    		each_1_else = create_else_block_1(ctx);
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();

    			if (each_1_else) {
    				each_1_else.c();
    			}
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);

    			if (each_1_else) {
    				each_1_else.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*filteredMessages, mainMenuBar*/ 128) {
    				each_value = /*filteredMessages*/ ctx[7];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();

    				if (each_value.length) {
    					if (each_1_else) {
    						each_1_else.d(1);
    						each_1_else = null;
    					}
    				} else if (!each_1_else) {
    					each_1_else = create_else_block_1(ctx);
    					each_1_else.c();
    					each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    			if (each_1_else) each_1_else.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(175:3) {:else}",
    		ctx
    	});

    	return block;
    }

    // (173:3) {#if SingleBox}
    function create_if_block_1(ctx) {
    	let singlereader;
    	let updating_json;
    	let current;

    	function singlereader_json_binding(value) {
    		/*singlereader_json_binding*/ ctx[17](value);
    	}

    	let singlereader_props = {};

    	if (/*filteredMessages*/ ctx[7] !== void 0) {
    		singlereader_props.json = /*filteredMessages*/ ctx[7];
    	}

    	singlereader = new SingleReader({
    			props: singlereader_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind$2(singlereader, "json", singlereader_json_binding));

    	const block = {
    		c: function create() {
    			create_component(singlereader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(singlereader, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const singlereader_changes = {};

    			if (!updating_json && dirty & /*filteredMessages*/ 128) {
    				updating_json = true;
    				singlereader_changes.json = /*filteredMessages*/ ctx[7];
    				add_flush_callback(() => updating_json = false);
    			}

    			singlereader.$set(singlereader_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(singlereader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(singlereader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(singlereader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(173:3) {#if SingleBox}",
    		ctx
    	});

    	return block;
    }

    // (178:4) {:else}
    function create_else_block_1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Nothing received yet";
    			add_location(p, file, 178, 5, 4290);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(178:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (176:4) {#each filteredMessages as message}
    function create_each_block(ctx) {
    	let jsonreader;
    	let current;

    	jsonreader = new JsonReader({
    			props: {
    				message: /*message*/ ctx[23],
    				mainMenuBar
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(jsonreader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(jsonreader, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const jsonreader_changes = {};
    			if (dirty & /*filteredMessages*/ 128) jsonreader_changes.message = /*message*/ ctx[23];
    			jsonreader.$set(jsonreader_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(jsonreader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(jsonreader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(jsonreader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(176:4) {#each filteredMessages as message}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let main;
    	let nav;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	nav = new Nav({ $$inline: true });
    	nav.$on("connect", /*onConnect*/ ctx[8]);
    	nav.$on("disconnect", /*onDisconnect*/ ctx[9]);
    	nav.$on("send", /*sendMsg*/ ctx[10]);
    	const if_block_creators = [create_if_block, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$connected*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(nav.$$.fragment);
    			t = space();
    			if_block.c();
    			add_location(main, file, 130, 0, 3019);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(nav, main, null);
    			append_dev(main, t);
    			if_blocks[current_block_type_index].m(main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(main, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nav.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nav.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(nav);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const mainMenuBar = false;

    function instance($$self, $$props, $$invalidate) {
    	let filteredMessages;
    	let $data;
    	let $isVolatile;
    	let $history;
    	let $connecting;
    	let $connected;
    	let $receivedCounter;
    	let $messages;
    	validate_store(data, "data");
    	component_subscribe($$self, data, $$value => $$invalidate(18, $data = $$value));
    	validate_store(isVolatile, "isVolatile");
    	component_subscribe($$self, isVolatile, $$value => $$invalidate(19, $isVolatile = $$value));
    	validate_store(history, "history");
    	component_subscribe($$self, history, $$value => $$invalidate(4, $history = $$value));
    	validate_store(connecting, "connecting");
    	component_subscribe($$self, connecting, $$value => $$invalidate(20, $connecting = $$value));
    	validate_store(connected, "connected");
    	component_subscribe($$self, connected, $$value => $$invalidate(5, $connected = $$value));
    	validate_store(receivedCounter, "receivedCounter");
    	component_subscribe($$self, receivedCounter, $$value => $$invalidate(6, $receivedCounter = $$value));
    	validate_store(messages, "messages");
    	component_subscribe($$self, messages, $$value => $$invalidate(1, $messages = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);

    	const db = new NeuDB({
    			selectedEvent: "message",
    			singleBox: true,
    			eventHistory: [],
    			connectionHistory: [],
    			currentConnection: "",
    			isVolatile: false,
    			messageObject: { test: { value: "test" } }
    		});

    	const dispatch = createEventDispatcher();
    	set_store_value(data, $data = db.get(), $data);
    	set_store_value(isVolatile, $isVolatile = db.get("isVolatile"), $isVolatile);
    	set_store_value(history, $history = db.get("eventHistory"), $history);
    	let SingleBox = $data.singleBox;
    	let jsonEditorValue = db.get("messageObject") || { test: { value1: 1, values: "test" } };
    	let eventFilter = "";

    	const onConnect = evt => {
    		if ($connecting) {
    			onDisconnect(evt);
    			set_store_value(connecting, $connecting = false, $connecting);
    			set_store_value(connected, $connected = false, $connected);
    		} else {
    			set_store_value(connecting, $connecting = true, $connecting);
    			const { uri } = evt.detail;
    			console.log("Connect", uri);
    			setSocket(io(uri));

    			SocketErrors(evt => {
    				console.log(evt);

    				if ($connecting) {
    					alert("Disconnected");
    				}

    				socket.disconnect();
    				set_store_value(connecting, $connecting = false, $connecting);
    				set_store_value(connected, $connected = false, $connected);
    				setSocket(undefined);
    			});

    			socket.on("connect", () => {
    				set_store_value(connecting, $connecting = false, $connecting);

    				socket.onAny((event, data) => {
    					ChangeCounter(1);

    					messages.update(old => {
    						return [{ number: $receivedCounter, event, data }, ...old];
    					});
    				});

    				db.push("connectionHistory", uri);
    				db.set("currentConnection", uri);
    				set_store_value(connected, $connected = true, $connected);
    			});

    			socket.on("disconnect", () => {
    				set_store_value(connected, $connected = false, $connected);
    			});
    		}
    	};

    	const onDisconnect = evt => {
    		const { uri } = evt.detail;
    		console.log("Disconnect", uri);
    		socket.disconnect();
    		set_store_value(connected, $connected = false, $connected);
    		setSocket(undefined);
    	};

    	const sendMsg = evt => {
    		const { event } = evt.detail;
    		db.set("messageObject", jsonEditorValue);
    		console.log(db.get());
    		console.log("Send: ", event, $isVolatile);

    		if ($isVolatile) {
    			socket.volatile.emit(event, jsonEditorValue);
    		} else {
    			socket.emit(event, jsonEditorValue);
    		}

    		db.push("eventHistory", event);
    	};

    	isVolatile.subscribe(v => {
    		db.set("isVolatile", v);
    	});

    	const jsonSave = () => {
    		db.set("messageObject", jsonEditorValue);
    	};

    	const saveSingleBox = () => {
    		db.set("singleBox", !SingleBox);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	function jsoneditor_json_binding(value) {
    		jsonEditorValue = value;
    		$$invalidate(3, jsonEditorValue);
    	}

    	function input_change_handler() {
    		SingleBox = this.checked;
    		$$invalidate(2, SingleBox);
    	}

    	const click_handler = () => {
    		set_store_value(messages, $messages = [], $messages);
    		set_store_value(receivedCounter, $receivedCounter = 0, $receivedCounter);
    	};

    	function select_change_handler() {
    		eventFilter = select_value(this);
    		$$invalidate(0, eventFilter);
    	}

    	function singlereader_json_binding(value) {
    		filteredMessages = value;
    		(($$invalidate(7, filteredMessages), $$invalidate(1, $messages)), $$invalidate(0, eventFilter));
    	}

    	$$self.$capture_state = () => ({
    		io,
    		createEventDispatcher,
    		NeuDB,
    		db,
    		dispatch,
    		mainMenuBar,
    		messages,
    		connected,
    		changeConnected,
    		ChangeCounter,
    		setSocket,
    		receivedCounter,
    		history,
    		SocketErrors,
    		socket,
    		isVolatile,
    		connecting,
    		data,
    		SingleBox,
    		Nav,
    		JSONEditor,
    		JsonReader,
    		SingleReader,
    		jsonEditorValue,
    		eventFilter,
    		onConnect,
    		onDisconnect,
    		sendMsg,
    		jsonSave,
    		saveSingleBox,
    		$data,
    		$isVolatile,
    		$history,
    		$connecting,
    		$connected,
    		$receivedCounter,
    		filteredMessages,
    		$messages
    	});

    	$$self.$inject_state = $$props => {
    		if ("SingleBox" in $$props) $$invalidate(2, SingleBox = $$props.SingleBox);
    		if ("jsonEditorValue" in $$props) $$invalidate(3, jsonEditorValue = $$props.jsonEditorValue);
    		if ("eventFilter" in $$props) $$invalidate(0, eventFilter = $$props.eventFilter);
    		if ("filteredMessages" in $$props) $$invalidate(7, filteredMessages = $$props.filteredMessages);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$messages, eventFilter*/ 3) {
    			$$invalidate(7, filteredMessages = $messages.filter(m => {
    				if (eventFilter != "") {
    					return m.event === eventFilter.trim();
    				} else return true;
    			}) || []); //make sure it's an array
    		}
    	};

    	return [
    		eventFilter,
    		$messages,
    		SingleBox,
    		jsonEditorValue,
    		$history,
    		$connected,
    		$receivedCounter,
    		filteredMessages,
    		onConnect,
    		onDisconnect,
    		sendMsg,
    		jsonSave,
    		saveSingleBox,
    		jsoneditor_json_binding,
    		input_change_handler,
    		click_handler,
    		select_change_handler,
    		singlereader_json_binding
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
    	target: document.body,
    	props: {
    		name: 'world'
    	}
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
